<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[回溯算法]]></title>
    <url>%2F2022%2F03%2F07%2F%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[我们先理解几个问题： 具体思想 1，回溯算法是什么？解决回溯算法相关的问题有什么技巧？如何学习回溯算法？回溯算法代码有什么规律？ 回溯算法其实就是DFS算法，本质上就是一种暴力穷举算法。 解决一个回溯问题，实际就是一个决策树的遍历过程。我们只需要考虑3个问题： （1）路径： 也就是已经做出的选择。 （2）选择列表： 也就是你当前可以做的选择。 （3）结束条件： 也就是达到决策树底层，无法再做选择的条件。 回溯算法框架： 123456789result = []def backtrack(路径，选择列表): if 满足结束条件: result.add(路径) return for 选择 in 选择列表: 做选择 backtrack(路径，选择列表) 撤销选择 其核心就是for循环里面的递归，在递归调用之前”做选择“，在递归调用之后”撤销选择“。 46. 全排列给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。 示例： 输入：nums = [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 思路： 我们把这棵树称为回溯算法的「决策树」。因为我们在每个节点上都是在做决策。 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; res; vector&lt;vector&lt;int&gt; &gt; permute(vector&lt;int&gt;&amp; nums) &#123; //记录路径 vector&lt;int&gt; track; //标记数组，避免重复使用 vector&lt;bool&gt; used(nums.size()); backtrack(nums, track, used); return res; &#125; void backtrack(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; track, vector&lt;bool&gt;&amp; used)&#123; //结束条件：nums 中的元素全部在 track 中 if(track.size() == nums.size())&#123; res.push_back(track); return; &#125; for(int i = 0; i &lt; nums.size(); i++)&#123; //排除不合法的选择 if(used[i])&#123; //num[i] 已经在 track 中，跳过 continue; &#125; //做选择 track.push_back(nums[i]); used[i] = true; //进入下一层决策树 backtrack(nums, track, used); //取消选择 track.pop_back(); used[i] = false; &#125; &#125;&#125;; 51. N 皇后n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。 每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。 每一行每一列每一条直线只有一个皇后 示例： 输入：n = 4输出：[[“.Q..”,”…Q”,”Q…”,”..Q.”],[“..Q.”,”Q…”,”…Q”,”.Q..”]]解释：如上图所示，4 皇后问题存在两个不同的解法。 思路：路径：board 中小于 row 的那些行都已经成功放置了皇后 选择列表：第 row 行的所有列都是放置皇后的选择 结束条件：row 超过 board 的最后一行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123;public: vector&lt;vector&lt;string&gt; &gt;res; vector&lt;vector&lt;string&gt; &gt; solveNQueens(int n) &#123; //初识化棋盘：'.'表示空，'Q'表示皇后。 vector&lt;string&gt; board(n, string(n,'.')); backstrack(board, 0); return res; &#125; //路径：board 中小于 row 的那些行都已经成功放置了皇后 //选择列表：第 row 行的所有列都是放置皇后的选择 //结束条件：row 超过 board 的最后一行 void backstrack(vector&lt;string&gt;&amp; board, int row)&#123; //终止条件 if(row == board.size())&#123; res.push_back(board); return; &#125; int n = board[row].size(); for(int col = 0; col &lt; n; col++)&#123; //排除不合法的选择 if(!isValid(board, row, col))&#123; continue; &#125; //做选择 board[row][col] = 'Q'; //进入下一行决策 backstrack(board, row + 1); //撤销选择 board[row][col] = '.'; &#125; &#125; //是否可以在 board[row][col]放置皇后 bool isValid(vector&lt;string&gt;&amp; board, int row, int col)&#123; int n = board.size(); //检查列是否有皇后互相冲突 for(int i = 0; i &lt; n; i++)&#123; if(board[i][col] == 'Q') return false; &#125; //检查右上方是否有皇后互相冲突 for(int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; i--,j++)&#123; if(board[i][j] == 'Q') return false; &#125; //检查左上方是否有皇后互相冲突 for(int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--,j--)&#123; if(board[i][j] == 'Q') return false; &#125; return true; &#125;&#125;;]]></content>
      <categories>
        <category>回溯算法</category>
        <category>DFS</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>回溯算法</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树]]></title>
    <url>%2F2022%2F03%2F07%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[226. 翻转二叉树给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。 示例： root = [4,2,7,1,3,6,9]输出：[4,7,2,9,6,3,1] 思路：我们可以发现只需要翻转每个节点的左右子节点。就可以得到翻转后的二叉树了。 1234567891011121314151617class Solution &#123;public: TreeNode* invertTree(TreeNode* root) &#123; if(root == nullptr) return nullptr; //交换root节点的左右子节点 TreeNode* tmp = root-&gt;left; root-&gt;left = root-&gt;right; root-&gt;right = tmp; //让左右子节点继续翻转他们的子节点 invertTree(root-&gt;left); invertTree(root-&gt;right); return root; &#125;&#125;; 116.填充每个节点的下一个右侧节点指针给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下： 1234567&gt; struct Node &#123;&gt; int val;&gt; Node *left;&gt; Node *right;&gt; Node *next;&gt; &#125;&gt; 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 初始状态下，所有 next 指针都被设置为 NULL。 示例： 输入：root = [1,2,3,4,5,6,7]输出：[1,#,2,3,#,4,5,6,7,#]解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，’#’ 标志着每一层的结束。 思路：我们可以很轻松的用递归实现左子节点指向右子节点，可是面临一个难题，那就是不同子树的节点， 我们应该如何连接呢？ 二叉树的问题难点在于，如何把题目要求细化成每个节点需要做的事。 如果只依赖一个节点的话，我们肯定没有办法连接跨父节点的两个相邻节点，那么我们的做法就是增加函数参数， 使用两个节点。 例如：题中的5和6如何相连，我们只需要递归实现connectTowNode(2-&gt;right,3-&gt;left)即可。 12345678910111213141516171819202122class Solution &#123;public: Node* connect(Node* root) &#123; if(root == nullptr) return nullptr; connectTwoNode(root-&gt;left, root-&gt;right); return root; &#125; void connectTwoNode(Node* node1, Node* node2)&#123; if(node1 == nullptr || node2 == nullptr) return; //前序位置 //将传入的节点连接 node1-&gt;next = node2; //连接相同父节点的两个节点 connectTwoNode(node1-&gt;left, node1-&gt;right); connectTwoNode(node2-&gt;left, node2-&gt;right); //连接跨父节点的两个节点 connectTwoNode(node1-&gt;right, node2-&gt;left); &#125;&#125;; 114. 二叉树展开为链表给你二叉树的根结点 root ，请你将它展开为一个单链表： 展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。 展开后的单链表应该与二叉树 先序遍历 顺序相同。 示例： 输入：root = [1,2,5,3,4,null,6]输出：[1,null,2,null,3,null,4,null,5,null,6] 思路： 1，将root的左右子树拉平。 2，将root的左子树作为右子树 3，将右子树接到左子树下方 123456789101112131415161718192021222324252627class Solution &#123;public: void flatten(TreeNode* root) &#123; if(root == nullptr) return; flatten(root-&gt;left); flatten(root-&gt;right); //后续遍历位置，因为我们需要拉平才能操作 //1，左右子树已经拉平成一条链表 TreeNode* left = root-&gt;left; TreeNode* right = root-&gt;right; //2，将左子树作为右子树 root-&gt;right = left; root-&gt;left = nullptr; //3，将右子树接到左子树下方 TreeNode* p = root; //让p指针指向最末端 while(p-&gt;right != nullptr)&#123; p = p-&gt;right; &#125; //指向原来的右子树 p-&gt;right = right; &#125;&#125;; 654. 最大二叉树给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建: ​ 1，创建一个根节点，其值为 nums 中的最大值。​ 2，递归地在最大值 左边 的 子数组前缀上 构建左子树。​ 3，递归地在最大值 右边 的 子数组后缀上 构建右子树。返回 nums 构建的 最大二叉树 。 示例： 输入：nums = [3,2,1,6,0,5]输出：[6,3,5,null,2,0,null,null,1]解释：递归调用如下所示： [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。 [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。 空数组，无子节点。 [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。 空数组，无子节点。 只有一个元素，所以子节点是一个值为 1 的节点。 [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。 只有一个元素，所以子节点是一个值为 0 的节点。 空数组，无子节点。 思路： 我们首先要明确每个节点应该做什么？很显然每个节点要做的就是把自己构造出来 1，递归终止条件lo &gt; hi ​ 2，遍历找出最大值maxVal 3，递归左右两边作为左右子树。 12345678910111213141516171819202122232425262728class Solution &#123;public: TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return nullptr; return build(nums, 0, nums.size() - 1); &#125; TreeNode* build(vector&lt;int&gt;&amp; nums, int lo, int hi)&#123; //递归终止条件 if(lo &gt; hi) return nullptr; //找到数组中最大值和对应的索引 int index = -1, maxVal = INT_MIN; for(int i = lo; i &lt;= hi; i++)&#123; if(maxVal &lt; nums[i])&#123; index = i; maxVal = nums[i]; &#125; &#125; //构建自己的节点 TreeNode* root = new TreeNode(maxVal); //递归构建自己节点的左右子树 root-&gt;left = build(nums, lo, index-1); root-&gt;right = build(nums, index + 1, hi); return root; &#125;&#125;; 105. 从前序与中序遍历序列构造二叉树给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。 示例： 输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]输出: [3,9,20,null,null,15,7] 12345678struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;&#125;; 思路：我们主要的就是把根节点做出来，然后递归构造左右子树即可。 前序遍历可以把数组分成[根，左， 右]三部分，而中序遍历可以把数组分为[左，根， 右]三部分 我们知道前序遍历的第一个值就是根节点的值，关键在于如何通过根节点的值。将preorder和inorder分为两半，构建根节点的左右子树 这样就可以分为： 123int leftSize = index - inStart;root-&gt;left = build(preorder, preStart + 1, preStart + leftSize, inorder, inStart, index - 1);root-&gt;right = build(preorder, preStart + leftSize + 1, preEnd, inorder, index + 1, inEnd); 综上： 123456789101112131415161718192021222324252627282930class Solution &#123;public: TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123; //前序，前序起点，前序终点，中序，中序起点，中序终点 return build(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1); &#125; TreeNode* build(vector&lt;int&gt;&amp; preorder, int preStart, int preEnd, vector&lt;int&gt;&amp; inorder, int inStart, int inEnd)&#123; //递归终止条件 if(preStart &gt; preEnd) return nullptr; //root 节点就是前序遍历的第一个节点 int rootVal = preorder[preStart]; //rootVal 在中序遍历中的索引 int index = 0; for(int i = inStart; i &lt;= inEnd; i++)&#123; if(inorder[i] == rootVal)&#123; index = i; break; &#125; &#125; //左子树长度 int leftSize = index - inStart; //构建根节点 TreeNode* root = new TreeNode(rootVal); //递归构建左右子树 root-&gt;left = build(preorder, preStart + 1, preStart + leftSize, inorder, inStart, index - 1); root-&gt;right = build(preorder, preStart + leftSize + 1, preEnd, inorder, index + 1, inEnd); return root; &#125;&#125;; 106. 从中序与后序遍历序列构造二叉树给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。 示例： 输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]输出：[3,9,20,null,null,15,7] 思路：和上题一样，我们只需要知道后序遍历为[左 右 根]根节点为最后一个元素。 1234567891011121314151617181920212223242526272829303132333435363738struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;&#125;;class Solution &#123;public: TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123; return build(inorder, 0, inorder.size() - 1, postorder, 0, postorder.size() - 1); &#125; TreeNode* build(vector&lt;int&gt;&amp; inorder, int inStart, int inEnd, vector&lt;int&gt;&amp; postorder, int postStart, int postEnd)&#123; //递归终止条件 if(inStart &gt; inEnd) return nullptr; //root 为后序遍历postorder的最后一个节点 int rootVal = postorder[postEnd]; //rootVal 在中序遍历中的索引 int index = 0; for(int i = inStart; i &lt;= inEnd; i++)&#123; if(inorder[i] == rootVal)&#123; index = i; break; &#125; &#125; //计算左子树长度 int leftSize = index - inStart; //构建根节点 TreeNode* root = new TreeNode(rootVal); //递归构建左右子树 root-&gt;left = build(inorder, inStart, index - 1, postorder, postStart, postStart + leftSize - 1); root-&gt;right = build(inorder, index + 1, inEnd, postorder, postStart + leftSize, postEnd - 1); return root; &#125;&#125;; 889. 根据前序和后序遍历构造二叉树给定两个整数数组，preorder 和 postorder ，其中 preorder 是一个具有 无重复 值的二叉树的前序遍历，postorder 是同一棵树的后序遍历，重构并返回二叉树。 如果存在多个答案，您可以返回其中 任何 一个。 示例： 输入：preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]输出：[1,2,3,4,5,6,7] 12345678struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;&#125;; 思路：通过前序中序，或者后序中序遍历可以确定一棵原始二叉树，但是通过前序后序结果无法确定原始二叉树。 1，首先把前序遍历的第一个节点或者后序遍历的最后一个元素作为根节点的值 2，然后把前序遍历结果的第二个元素作为左子树的根节点的值 3，在后序遍历结果中寻找左子树根节点的值，从而确定了左子树的索引边界，进而确定右子树的索引边界，递归构造左右子树即可 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: TreeNode* constructFromPrePost(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; postorder) &#123; return build(preorder, 0, preorder.size() - 1, postorder, 0, postorder.size() - 1); &#125; TreeNode* build(vector&lt;int&gt;&amp; preorder, int preStart, int preEnd, vector&lt;int&gt;&amp; postorder, int postStart, int postEnd)&#123; //递归终止条件 if(preStart &gt; preEnd) return nullptr; //只剩一个节点了，直接构建为新节点即可 if(preStart == preEnd) return new TreeNode(preorder[preStart]); //root 为前序遍历的第一个元素 int rootVal = preorder[preStart]; //leftRoot 为前序遍历的第二个元素 //通过前序和后序遍历构造二叉树的关键在于通过左子树 //确定preorder 和 postorder 中左右子树的元素区间 int leftRootVal = preorder[preStart + 1]; //leftRootVal 在后序遍历数组中的索引 int index = 0; //这里不能等于，因为相等时,就没有leftRootVal了 for(int i = postStart; i &lt; postEnd; i++)&#123; if(postorder[i] == leftRootVal)&#123; index = i; break; &#125; &#125; // 左子树长度，记得加一，因为 index 也属于左子树 int leftSize = index - postStart + 1; //先构建出当前根节点 TreeNode* root = new TreeNode(rootVal); //递归构建左右子树 root-&gt;left = build(preorder, preStart + 1, preStart + leftSize, postorder, postStart, index); root-&gt;right = build(preorder, preStart + leftSize + 1, preEnd, postorder, index + 1, postEnd - 1); return root; &#125;&#125;; 652. 寻找重复的子树给定一棵二叉树 root，返回所有重复的子树。 对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。 如果两棵树具有相同的结构和相同的结点值，则它们是重复的。 示例： 输入：root = [1,2,3,4,null,2,4,null,null,4]输出：[[2,4],[4]] 思路：具体请点击 对于某一点，它应该做什么？ 1，以我为根的这颗二叉树长什么样？ 2，以其他节点为根的子树都长什么样？ 可以看出我们可以选择「后序遍历」框架来解决： 12345void traverse(TreeNode* root)&#123; traverse(root-&gt;left); traverse(root-&gt;right); /*解法代码位置*/&#125; 因为我要知道以自己为根的子树长什么样，是不是得先知道我的左右子树长什么样，再加上自己，就构成了整颗子树的样子。 那么接下来我们应该怎么描述一棵二叉树的模样呢？ 通过二叉树序列化：通过拼接字符串的方式。 1234567891011string traverse(TreeNode* root)&#123; //对于空节点，可以用一个特殊字符表示 if(root == null) return '#'; //将左右子树序列化成字符串 string left = traverse(root-&gt;left); string right = traverse(root-&gt;right); /*后序遍历位置*/ //左右子树加上自己，就是以自己为根的二叉树序列化结果 string subTree = left + "," + right + "," + to_string(root-&gt;val); return subTree;&#125; 这样我们解决了第一个问题，知道了自己长什么样，现在解决第二个问题，怎么知道别人长什么样？这样我才能知道有没有其他子树根我重复。 我们只需要借助unordered_map，让每个节点把自己子树的序列化结果存进去，这样，对于每个节点，不就知道有没有其他节点的子树和自己重复了。 完整代码： 123456789101112131415161718192021222324252627class Solution &#123;public: // 记录所有子树以及出现的次数 unordered_map&lt;string, int&gt; mp; vector&lt;TreeNode*&gt; res; vector&lt;TreeNode*&gt; findDuplicateSubtrees(TreeNode* root) &#123; traverse(root); return res; &#125; string traverse(TreeNode* root)&#123; //递归终止条件 if(root == nullptr)&#123; return "#"; &#125; //二叉树序列化 string left = traverse(root-&gt;left); string right = traverse(root-&gt;right); string subTree = left + "," + right + "," + to_string(root-&gt;val); if(mp[subTree] == 1)&#123; res.push_back(root); &#125; //给子树对应的出现次数加一 mp[subTree]++; return subTree; &#125;&#125;; 297. 二叉树的序列化与反序列化序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。 请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。 提示: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。 示例: 输入：root = [1,2,3,null,null,4,5]输出：[1,2,3,null,null,4,5] 思路：先序实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Codec &#123;public: // 将二叉树转化为字符串 string serialize(TreeNode* root) &#123; string res; mySerialize(root,res); return res; &#125; // 辅助函数，将二叉树存入 str void mySerialize(TreeNode* root, string&amp; str)&#123; if(root == nullptr)&#123; str += "#,"; &#125;else&#123; //前序遍历 str += to_string(root-&gt;val) + ","; mySerialize(root-&gt;left, str); mySerialize(root-&gt;right, str); &#125; &#125; // 将字符串反序列化为二叉树结构 TreeNode* deserialize(string data) &#123; string str; //将字符串反序列化为列表 list&lt;string&gt; datalist; for(auto&amp; ch : data)&#123; if( ch == ',')&#123; datalist.push_back(str); //删除容器存储的所有元素 str.clear(); &#125;else&#123; str.push_back(ch); &#125; &#125; if(!str.empty())&#123; datalist.push_back(str); str.clear(); &#125; return myDeserialize(datalist); &#125; //辅助函数，通过 nodes 列表构造二叉树 TreeNode* myDeserialize(list&lt;string&gt;&amp; datalist)&#123; if(datalist.front() == "#")&#123; datalist.erase(datalist.begin()); return nullptr; &#125; // 列表最左侧就是根节点 TreeNode* root = new TreeNode(stoi(datalist.front())); datalist.erase(datalist.begin()); root-&gt;left = myDeserialize(datalist); root-&gt;right = myDeserialize(datalist); return root; &#125;&#125;; 1373. 二叉搜索子树的最大键值和给你一棵以 root 为根的 二叉树 ，请你返回 任意 二叉搜索子树的最大键值和。 二叉搜索树的定义如下： 任意节点的左子树中的键值都 小于 此节点的键值。 任意节点的右子树中的键值都 大于 此节点的键值。 任意节点的左子树和右子树都是二叉搜索树。 示例： 输入：root = [1,4,3,2,4,2,5,null,null,null,null,null,null,4,6]输出：20解释：键值为 3 的子树是和最大的二叉搜索树。 思路：1，左右子树是不是BST 2，左子树的最大值和右子树的最小值 3，左右子树的节点值之和 traverse(root)返回一个大小为4的int数组res res[0] 记录以 root 为根的二叉树是否是BST，若为1则说明是BST，否则不是 res[1] 记录以 root 为根的二叉树所有节点中的最小值； res[2] 记录以 root 为根的二叉树所有节点中的最大值； res[3] 记录以 root 为根的二叉树所有节点值之和； 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: int maxSum = 0; int maxSumBST(TreeNode* root) &#123; traverse(root); return maxSum; &#125; vector&lt;int&gt; traverse(TreeNode* root)&#123; //递归终止条件 vector&lt;int&gt; tmp = &#123;1,INT_MAX,INT_MIN,0&#125;; if(root == nullptr)&#123; return tmp; &#125; // 递归计算左右子树 vector&lt;int&gt; left(4); vector&lt;int&gt; right(4); left = traverse(root-&gt;left); right = traverse(root-&gt;right); //后序遍历位置 vector&lt;int&gt; res(4); // if 判断以 root 为根的二叉树是不是BST if(left[0] == 1 &amp;&amp; right[0] == 1 &amp;&amp; root-&gt;val &gt; left[2] &amp;&amp; root-&gt;val &lt; right[1])&#123; res[0] = 1; //计算以 root 为根的这颗 BST 的最小值 res[1] = min(left[1],root-&gt;val); //计算以 root 为根的这颗 BST 的最大值 res[2] = max(right[2],root-&gt;val); //计算以 root 为根的这颗 BST 所有节点之和 res[3] = left[3] + right[3] + root-&gt;val; //更新全局变量 maxSum = max(maxSum, res[3]); &#125;else&#123; //以 root 为根的二叉树不是 BST res[0] = 0; //其他值就不需要计算了 &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>二叉树</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找]]></title>
    <url>%2F2022%2F03%2F06%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[对于寻找左右边界的二分搜索，常见的手法是使用左闭右开的搜索区间，但是为了方便记忆，全部统一为两端都闭。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657int binary_search(int[] nums, int target) &#123; int left = 0, right = nums.length - 1; while(left &lt;= right) &#123; int mid = left + (right - left) / 2; if (nums[mid] &lt; target) &#123; left = mid + 1; &#125; else if (nums[mid] &gt; target) &#123; right = mid - 1; &#125; else if(nums[mid] == target) &#123; // 直接返回 return mid; &#125; &#125; // 直接返回 return -1;&#125;//左边界int left_bound(int[] nums, int target) &#123; int left = 0, right = nums.length - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (nums[mid] &lt; target) &#123; left = mid + 1; &#125; else if (nums[mid] &gt; target) &#123; right = mid - 1; &#125; else if (nums[mid] == target) &#123; // 别返回，锁定左侧边界 right = mid - 1; &#125; &#125; // 最后要检查 left 越界的情况 if (left &gt;= nums.length || nums[left] != target) &#123; return -1; &#125; return left;&#125;//右边界int right_bound(int[] nums, int target) &#123; int left = 0, right = nums.length - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (nums[mid] &lt; target) &#123; left = mid + 1; &#125; else if (nums[mid] &gt; target) &#123; right = mid - 1; &#125; else if (nums[mid] == target) &#123; // 别返回，锁定右侧边界 left = mid + 1; &#125; &#125; // 最后要检查 right 越界的情况 if (right &lt; 0 || nums[right] != target) &#123; return -1; &#125; return right;&#125;]]></content>
      <categories>
        <category>二分查找</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Hot 100]]></title>
    <url>%2F2022%2F03%2F03%2FLeetCode-Hot-100%2F</url>
    <content type="text"><![CDATA[1. 两数之和给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例： 输入： nums = [2,7,11,15], target = 9 输出： [0,1] 解释：因为nums[0] + nuts[1] == 9 思路：方法一：暴力 方法二：用哈希表 1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int,int&gt;mp; vector&lt;int&gt;res(2,-1); for(int i=0;i&lt;nums.size();i++)&#123; //判断是否有相加等于target的数 if(mp.count(target-nums[i])&gt;0)&#123; res[0]=mp[target-nums[i]]; res[1]=i; break; &#125; mp[nums[i]]=i; &#125; return res; &#125;&#125;; 2. 两数相加给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 输入：l1 = [2,4,3], l2 = [5,6,4] 输出：[7,0,8] 解释：342 + 465 = 807 思路：模拟即可，需要注意进位 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;struct ListNode &#123; int val; ListNode *next; ListNode() : val(0), next(nullptr) &#123;&#125; ListNode(int x) : val(x), next(nullptr) &#123;&#125; ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; &#125;;class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; //定义新链表 ListNode* res = new ListNode(); //进位 int carry = 0; //定义一个可移动指针 ListNode* cur = res; //当l1或者l2不为空时 while(l1 != nullptr || l2 != nullptr)&#123; //如果l1不等于null,就取它的值，等于就赋值0，保持两个链表具有相同的位数 int x = l1 != nullptr ? l1-&gt;val : 0; //如果l2不等于null,就取它的值，等于就赋值0，保持两个链表具有相同的位数 int y = l2 != nullptr ? l2-&gt;val : 0; //计算两个数的和，注意进位 int sum = x + y + carry; //计算进位 carry = sum/10; sum = sum % 10; //将结果添加到新节点中 cur-&gt;next = new ListNode(sum); cur = cur-&gt;next; //后移l1,l2 if(l1!=nullptr)&#123; l1 = l1-&gt;next; &#125; if(l2!=nullptr)&#123; l2 = l2-&gt;next; &#125; &#125; //如果最后两个数相加有进位，赋予链表新节点 if(carry)&#123; cur-&gt;next = new ListNode(carry); &#125; //返回头节点 return res-&gt;next; &#125;&#125;; 3. 无重复字符的最长子串给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。 示例： 输入：s=”abcabcbb” 输出：3 输入：s = “bbbbb” 输出：1 输入：s = “pwwkew” 输出：3 思路：标签：滑动窗口 暴力解法时间复杂度较高，会达到O(n^2)，故而采取滑动窗口的方法降低时间复杂度 定义一个 map 数据结构存储 (k, v)，其中 key 值为字符，value 值为字符位置 +1，加 1 表示从字符位置后一个才开始不重复 我们定义不重复子串的开始位置为 start，结束位置为 end 随着 end 不断遍历向后，会遇到与 [start, end] 区间内字符相同的情况，此时将字符作为 key 值，获取其 value 值，并更新 start，此时 [start, end] 区间内不存在重复字符 无论是否更新 start，都会更新其 map 数据结构和结果 ans = end - start + 1。 时间复杂度：O(n) 12345678910111213141516171819class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int n = s.size(),ans=0; //mp用于记录下一个数字从哪开始 map&lt;char,int&gt; mp; for(int start=0,end=0;end&lt;n;end++)&#123; char tmp = s[end]; //已经出现过 if(mp.count(tmp)&gt;0)&#123; //移动start到新的窗口 start = max(mp[tmp],start); &#125; ans = max(ans,end-start+1); mp[tmp] = end+1; &#125; return ans; &#125;&#125;; 两数之和 II - 输入有序数组给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列 ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 &lt;= index1 &lt; index2 &lt;= numbers.length 。 以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。 你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。 你所设计的解决方案必须只使用常量级的额外空间。 示例： 输入：numbers = [2,7,11,15], target = 9输出：[1,2]解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。 思路：采用双指针，l=0,r=numners.size()-1,sum = numbers[l]+numbers[r] 我们可以得出如果sum &gt; target,那么我们可以排除这一列，因为往后和越大，我们只需要r-- 如果sum&lt;target，我们可以排除这一行，l++ 123456789101112131415class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; int l=0,r=numbers.size()-1; while(l&lt;r)&#123; int sum = numbers[l]+numbers[r]; //排除这一行 if(sum &lt; target) l++; //排除这一列 else if(sum &gt; target) r--; else return &#123;l+1,r+1&#125;; &#125; return &#123;-1,-1&#125;; &#125;&#125;; 20. 有效的括号给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。 示例： 输入：s = “()”输出：true 思路：方法一：使用哈希表 12345678910111213141516171819202122232425262728class Solution &#123;public: bool isValid(string s) &#123; int n = s.size(); if (n % 2 == 1) &#123; return false; &#125; unordered_map&lt;char, char&gt; pairs = &#123; &#123;')', '('&#125;, &#123;']', '['&#125;, &#123;'&#125;', '&#123;'&#125; &#125;; stack&lt;char&gt; stk; for (char ch: s) &#123; if (pairs.count(ch)) &#123; if (stk.empty() || stk.top() != pairs[ch]) &#123; return false; &#125; stk.pop(); &#125; else &#123; stk.push(ch); &#125; &#125; return stk.empty(); &#125;&#125;; 方法二：不使用哈希表 1234567891011121314151617181920212223242526class Solution &#123;public: bool isValid(string s) &#123; if(s.size() == 0) return true; //奇数 if(s.size()&amp;1) return false; stack&lt;char&gt; st; for(char c:s)&#123; if(c == '(' || c=='[' || c=='&#123;') st.push(c); if(c == ')')&#123; if(!st.empty() &amp;&amp; st.top()=='(') st.pop(); else return false; &#125; if(c==']')&#123; if(!st.empty() &amp;&amp; st.top()=='[') st.pop(); else return false; &#125; if(c=='&#125;')&#123; if(!st.empty() &amp;&amp; st.top()=='&#123;') st.pop(); else return false; &#125; &#125; if(st.empty()) return true; return false; &#125;&#125;; 48. 旋转图像给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。 你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。 示例： 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]输出：[[7,4,1],[8,5,2],[9,6,3]] 思路：顺时针旋转90度 算法流程： 1，先对角线反转 2，再中间对称反转 1234567891011121314151617181920212223class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt; &gt;&amp; matrix) &#123; int n = matrix.size(); //先沿对角线镜像对称二维矩阵 for(int i = 0; i &lt; n; i++)&#123; for(int j = i; j &lt; n; j++)&#123; swap(matrix[i][j],matrix[j][i]); &#125; &#125; //然后中间对称反转 for(int i = 0; i &lt; n; i++)&#123; reverse(matrix[i]); &#125; &#125; void reverse(vector&lt;int&gt;&amp; row)&#123; int i = 0, j = row.size() - 1; while(j &gt; i)&#123; swap(row[i++],row[j--]); &#125; &#125;&#125;; 54. 螺旋矩阵给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。 示例： 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]输出：[1,2,3,6,9,8,7,4,5] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt; &gt;&amp; matrix) &#123; //初始化 vector&lt;int&gt; res; int m = matrix.size(),n = matrix[0].size(); if(m == 0 || n == 0) return &#123;&#125;; //定义边界 int upper_bound = 0; int lower_bound = m - 1; int left_bound = 0; int right_bound = n - 1; while(res.size() &lt;= m*n )&#123; //从左往右，行不变，列增大 for(int i = left_bound; i &lt;= right_bound; i++)&#123; res.push_back(matrix[upper_bound][i]); &#125; //上边界下移 upper_bound++; if(upper_bound &gt; lower_bound) break; //从上往下，列不变，行增大 for(int j = upper_bound; j &lt;= lower_bound; j++)&#123; res.push_back(matrix[j][right_bound]); &#125; //右边界左移 right_bound--; if(right_bound &lt; left_bound) break; //从右往左，行不变，列减小 for(int i = right_bound; i &gt;= left_bound; i--)&#123; res.push_back(matrix[lower_bound][i]); &#125; //下边界上移 lower_bound--; if(lower_bound &lt; upper_bound) break; //从上往下，列不变，行减小 for(int j = lower_bound; j &gt;= upper_bound; j--)&#123; res.push_back(matrix[j][left_bound]); &#125; //左边界右移 left_bound++; if(left_bound &gt; right_bound) break; &#125; return res; &#125;&#125;; 59. 螺旋矩阵 II给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。 示例: 输入：n = 3输出：[[1,2,3],[8,9,4],[7,6,5]] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; generateMatrix(int n) &#123; //初始化 vector&lt;vector&lt;int&gt; &gt; res(n,vector&lt;int&gt;(n)); int upper_bound = 0; int lower_bound = n - 1; int left_bound = 0; int right_bound = n - 1; int num = 1; while(num &lt;= n * n )&#123; //从左往右，行不变，列增大 for(int i = left_bound; i &lt;= right_bound; i++)&#123; res[upper_bound][i] = num++; &#125; //上边界下移 upper_bound++; if(upper_bound &gt; lower_bound) break; //从上往下，列不变，行增大 for(int j = upper_bound; j &lt;= lower_bound; j++)&#123; res[j][right_bound] = num++; &#125; //右边界左移 right_bound--; if(right_bound &lt; left_bound) break; //从右往左，行不变，列减小 for(int i = right_bound; i &gt;= left_bound; i--)&#123; res[lower_bound][i] = num++; &#125; //下边界上移 lower_bound--; if(lower_bound &lt; upper_bound) break; //从上往下，列不变，行减小 for(int j = lower_bound; j &gt;= upper_bound; j--)&#123; res[j][left_bound] = num++; &#125; //左边界右移 left_bound++; if(left_bound &gt; right_bound) break; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode Hot 100</category>
      </categories>
      <tags>
        <tag>LeetCode Hot 100</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[背包问题]]></title>
    <url>%2F2022%2F03%2F03%2F%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[0-1背包给你一个可装载重量为 W 的背包和 N 个物品，每个物品有重量和价值两个属性。其中第 i 个物品的重量为 wt[i]，价值为 val[i]，现在让你用这个背包装物品，最多能装的价值是多少？ 例如： N = 3, W = 4 wt = [2,1,3] val = [4,2,3] 算法返回 6，选择前两件物品装进背包，总重量 3 小于 W，可以获得最大价值 6。 题目就是这么简单，一个典型的动态规划问题。这个题目中的物品不可以分割，要么装进包里，要么不装，不能说切成两块装一半。这就是 0-1 背包这个名词的来历。 解决这个问题没有什么排序之类巧妙的方法，只能穷举所有可能，根据我们 动态规划详解 中的套路，直接走流程就行了。 第一步要明确两点，「状态」和「选择」对于0-1背包状态有两个，就是「背包容量」和「可选择的物品」； 再说选择，对于每件物品，选择就是「装进背包」或者「不装进背包」 1234for 状态1 in 状态1的所有取值： for 状态2 in 状态2的所有取值: for ... dp[状态1][状态2][...] = 择优(选择1，选择2...) 第二步要明确dp数组的定义首先看看刚才找到的「状态」，有两个，也就是说我们需要一个二维 dp 数组。 dp[i][w] 的定义如下：对于前 i 个物品，当前背包的容量为 w，这种情况下可以装的最大价值是 dp[i][w]。 比如说，如果 dp[3][5] = 6，其含义为：对于给定的一系列物品中，若只对前 3 个物品进行选择，当背包容量为 5 时，最多可以装下的价值为 6。 1234567891011int[][] dp[N+1][W+1]dp[0][..] = 0dp[..][0] = 0for i in [1..N]: for w in [1..W]: dp[i][w] = max( 把物品 i 装进背包, 不把物品 i 装进背包 )return dp[N][W] 第三步，根据「选择」，思考状态转移的逻辑先重申下dp数组的定义： 对于前 i 个物品，当前背包的容量为 w，这种情况下可以装的最大价值是 dp[i][w]。 如果你没有把这第i个物品装入背包， 那么最大价值dp[i][w]应该等于dp[i-1][w]，继承之前的结果。 如果你把第i个物品装入了背包， 那么dp[i][w]应该等于dp[i-1][w-wt[i-1]]+val[i-1] 首先，由于i是从1开始的，所以val和wt的索引是i-1时表示第i个物品的价值和重量。 而 dp[i-1][w - wt[i-1]] 也很好理解：你如果装了第 i 个物品，就要寻求剩余重量 w - wt[i-1] 限制下的最大价值，加上第 i 个物品的价值 val[i-1]。 1234567for i in [1..N]: for w in [1..W]: dp[i][w] = max( dp[i-1][w], dp[i-1][w - wt[i-1]] + val[i-1] )return dp[N][W] 最后一步，处理边界1234567891011121314151617181920int knapsack(int W, int N, int[] wt, int[] val) &#123; // base case 已初始化 int[][] dp = new int[N + 1][W + 1]; for (int i = 1; i &lt;= N; i++) &#123; for (int w = 1; w &lt;= W; w++) &#123; if (w - wt[i - 1] &lt; 0) &#123; // 这种情况下只能选择不装入背包 dp[i][w] = dp[i - 1][w]; &#125; else &#123; // 装入或者不装入背包，择优 dp[i][w] = Math.max( dp[i - 1][w - wt[i-1]] + val[i-1], dp[i - 1][w] ); &#125; &#125; &#125; return dp[N][W];&#125; 416. 分割等和子集给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 示例： 输入：nums = [1,5,11,5]输出：true解释：数组可以分割成 [1, 5, 5] 和 [11] 。 思路：那么对于这个问题，我们可以先对集合求和，得出 sum，把问题转化为背包问题： 给一个可装载重量为 sum / 2 的背包和 N 个物品，每个物品的重量为 nums[i]。现在让你装物品，是否存在一种装法，能够恰好将背包装满？ 第一步要明确两点，「状态」和「选择」状态就是「背包的容量」和「可选择的物品」，选择就是「装进背包」或者「不装进背包」。 第二步要明确dp数组的定义dp[i][j] = x表示，对于前i个物品，当前背包容量为j时，若x为true，则说明可以恰好将背包装满，若为false，则说明不能恰好将背包装满。 对于本题，我们相求的最终答案为dp[N][sum/2]，结束条件为dp[..][0] = true和dp[0][..] = false，因为背包没有空间的时候，就相当于装满了，而当没有物品可选择的时候，肯定没办法装满背包。 第三步，根据「选择」，思考状态转移的逻辑如果不把 nums[i] 算入子集，或者说你不把这第 i 个物品装入背包，那么是否能够恰好装满背包，取决于上一个状态 dp[i-1][j]，继承之前的结果。 如果把 nums[i] 算入子集，或者说你把这第 i 个物品装入了背包，那么是否能够恰好装满背包，取决于状态 dp[i-1][j-nums[i-1]]。 首先，由于 i 是从 1 开始的，而数组索引是从 0 开始的，所以第 i 个物品的重量应该是 nums[i-1]，这一点不要搞混。 dp[i - 1][j-nums[i-1]] 也很好理解：你如果装了第 i 个物品，就要看背包的剩余重量 j - nums[i-1] 限制下是否能够被恰好装满。 换句话说，如果 j - nums[i-1] 的重量可以被恰好装满，那么只要把第 i 个物品装进去，也可恰好装满 j的重量；否则的话，重量 j 肯定是装不满的。 最后一步，处理一些边界问题123456789101112131415161718192021222324252627282930class Solution &#123;public: bool canPartition(vector&lt;int&gt;&amp; nums) &#123; int sum = 0; int n = nums.size(); // 计算和 for(int num : nums) sum += num; //和为奇数，不可能划分 if(sum % 2 != 0) return false; sum = sum / 2; //初始化 base case vector&lt;vector&lt;bool&gt; &gt;dp(n+1,vector&lt;bool&gt;(sum+1,false)); for(int i = 0; i &lt;= n; i++)&#123; dp[i][0] = true; &#125; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= sum; j++)&#123; if(j - nums[i-1] &lt; 0)&#123; //容量不足，不能装入第 i 个物品 dp[i][j] = dp[i-1][j]; &#125;else&#123; //装入或者不装入 dp[i][j] = dp[i-1][j] || dp[i-1][j - nums[i - 1]]; &#125; &#125; &#125; return dp[n][sum]; &#125;&#125;; 进一步优化再进一步，是否可以优化这个代码呢？注意到 dp[i][j] 都是通过上一行 dp[i-1][..] 转移过来的，之前的数据都不会再使用了。 将二维dp数组压缩为一维 123456789101112131415161718192021222324class Solution &#123;public: bool canPartition(vector&lt;int&gt;&amp; nums) &#123; int sum = 0; int n = nums.size(); // 计算和 for(int num : nums) sum += num; //和为奇数，不可能划分 if(sum % 2 != 0) return false; sum = sum / 2; //base case vector&lt;bool&gt; dp(sum + 1,false); dp[0] = true; for(int i = 0; i &lt; n; i++)&#123; for(int j = sum; j &gt;= 0; j--)&#123; if(j - nums[i] &gt;= 0)&#123; dp[j] = dp[j] || dp[j - nums[i]]; &#125; &#125; &#125; return dp[sum]; &#125;&#125;; 其实这段代码和之前的解法思路完全相同，只在一行 dp 数组上操作，i 每进行一轮迭代，dp[j] 其实就相当于 dp[i-1][j]，所以只需要一维数组就够用了。 唯一需要注意的是 j 应该从后往前反向遍历，因为每个物品（或者说数字）只能用一次，以免之前的结果影响其他的结果。 完全背包问题518. 零钱兑换 II给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。 请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。 假设每一种面额的硬币有无限个。 题目数据保证结果符合 32 位带符号整数。 示例： 输入：amount = 5, coins = [1, 2, 5]输出：4解释：有四种方式可以凑成总金额：5=55=2+2+15=2+1+1+15=1+1+1+1+1 思路：我们可以把这个问题转化为背包问题的描述形式： 有一个背包，最大容量为 amount，有一系列物品 coins，每个物品的重量为 coins[i]，每个物品的数量无限。请问有多少种方法，能够把背包恰好装满？ 这个问题和我们前面讲过的两个背包问题，有一个最大的区别就是，每个物品的数量是无限的，这也就是传说中的「完全背包问题」，没啥高大上的，无非就是状态转移方程有一点变化而已。 第一步要明确两点，「状态」和「选择」状态有两个，就是「背包的容量」和「可选择的物品」，选择就是「装进背包」或者「不装进背包」嘛，背包问题的套路都是这样。 1234for 状态1 in 状态1的所有取值： for 状态2 in 状态2的所有取值： for ... dp[状态1][状态2][...] = 计算(选择1，选择2...) 第二步要明确 dp 数组的定义dp[i][j] 的定义如下： 若只使用前 i 个物品（可以重复使用），当背包容量为 j 时，有 dp[i][j] 种方法可以装满背包。 换句话说，翻译回我们题目的意思就是： 若只使用 coins 中的前 i 个硬币的面值，若想凑出金额 j，有 dp[i][j] 种凑法。 经过以上的定义，可以得到： base case 为 dp[0][..] = 0， dp[..][0] = 1。因为如果不使用任何硬币面值，就无法凑出任何金额；如果凑出的目标金额为 0，那么“无为而治”就是唯一的一种凑法。 我们最终想得到的答案就是 dp[N][amount]，其中 N 为 coins 数组的大小。 123456789int dp[N+1][amount+1]dp[0][..] = 0dp[..][0] = 1for i in [1..N]: for j in [1..amount]: 把物品 i 装进背包, 不把物品 i 装进背包return dp[N][amount] 第三步，根据「选择」，思考状态转移的逻辑如果你不把这第 i 个物品装入背包，也就是说你不使用 coins[i] 这个面值的硬币，那么凑出面额 j 的方法数 dp[i][j] 应该等于 dp[i-1][j]，继承之前的结果。 如果你把这第 i 个物品装入了背包，也就是说你使用 coins[i] 这个面值的硬币，那么 dp[i][j] 应该等于 dp[i][j-coins[i-1]]。 首先由于 i 是从 1 开始的，所以 coins 的索引是 i-1 时表示第 i 个硬币的面值。 dp[i][j-coins[i-1]] 也不难理解，如果你决定使用这个面值的硬币，那么就应该关注如何凑出金额 j - coins[i-1]。 比如说，你想用面值为 2 的硬币凑出金额 5，那么如果你知道了凑出金额 3 的方法，再加上一枚面额为 2 的硬币，不就可以凑出 5 了嘛。 综上就是两种选择，而我们想求的 dp[i][j] 是「共有多少种凑法」，所以 dp[i][j] 的值应该是以上两种选择的结果之和： 123456for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= amount; j++) &#123; if (j - coins[i-1] &gt;= 0) dp[i][j] = dp[i - 1][j] + dp[i][j-coins[i-1]];return dp[N][W] 最后一步，把伪码翻译成代码，处理一些边界情况12345678910111213141516171819202122class Solution &#123;public: int change(int amount, vector&lt;int&gt;&amp; coins) &#123; int n = coins.size(); //base case vector&lt;vector&lt;int&gt; &gt;dp(n+1,vector&lt;int&gt;(amount+1,0)); for(int i = 0; i &lt;= n; i++)&#123; dp[i][0] = 1; &#125; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= amount; j++)&#123; if(j-coins[i - 1] &gt;= 0)&#123; dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i - 1]]; &#125;else&#123; dp[i][j] = dp[i - 1][j]; &#125; &#125; &#125; return dp[n][amount]; &#125;&#125;; 而且，我们通过观察可以发现，dp 数组的转移只和 dp[i][..] 和 dp[i-1][..] 有关，所以可以压缩状态，进一步降低算法的空间复杂度： 1234567891011121314151617class Solution &#123;public: int change(int amount, vector&lt;int&gt;&amp; coins) &#123; int n = coins.size(); //base case vector&lt;int&gt; dp(amount + 1,0); dp[0] = 1; for(int i = 0; i &lt; n; i++)&#123; for(int j = 1; j &lt;= amount; j++)&#123; if(j - coins[i] &gt;= 0) dp[j] = dp[j] + dp[j-coins[i]]; &#125; &#125; return dp[amount]; &#125;&#125;;]]></content>
      <categories>
        <category>算法</category>
        <category>背包问题</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>背包问题</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[华为机试]]></title>
    <url>%2F2022%2F02%2F24%2F%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95%2F</url>
    <content type="text"><![CDATA[HJ1 字符串最后一个单词的长度计算字符串最后一个单词的长度，单词以空格隔开，字符串长度小于5000。（注：字符串末尾不以空格为结尾） 示例： 输入 hello world 输出 8 思路： 从后往前开始计算，碰到第一个空格时，长度为字符串长度-当前所在的位置-1； 代码： 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string s1=""; getline(cin,s1); int ans = 0; for(int i = s1.size()-1; i &gt;= 0; --i)&#123; if(s1[i] == ' ')&#123; ans = s1.size() - i - 1; break; &#125; else if(i==0)&#123; ans = s1.size(); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; HJ2 计算某字符出现次数写出一个程序，接受一个由字母、数字和空格组成的字符串，和一个字符，然后输出输入字符串中该字符的出现次数。（不区分大小写字母） ABCabc A 输出：2 思路： 由于不区分大小写，所以将大写转化为小写，统计输出次数。 tolower函数把小写字母转换为小写，非字母字符不做出处理 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string s1; int res = 0; while(getline(cin,s1))&#123; char input; cin &gt;&gt; input; cin.ignore(); input= tolower(input);//转化为小写 for(int i=0;i&lt;s1.size();++i)&#123; if(s1[i]==input|| s1[i]==input-32)&#123; res++; &#125; &#125; &#125; cout&lt;&lt;res&lt;&lt;endl; return 0;&#125; HJ3 明明的随机数明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了 N 个 1 到 1000 之间的随机整数（ N≤1000 ），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。现在明明把他已经用计算机生成好的 N 个随机数按照下面的输入描述的格式交给你，请你协助明明完成“去重”与“排序”的工作(同一个测试用例里可能会有多组数据(用于不同的调查)，希望大家能正确处理)。 注：测试用例保证输入参数的正确性，答题者无需验证。测试用例不止一组。 当没有新的输入时，说明输入结束。 数据范围： 1≤n≤1000 1≤n≤1000 ，输入的数字大小满足 1≤val≤500 1≤val≤500 322111102040326740208930040015 输出： 1210152032406789300400 说明： 示例1包含了两个小样例！！输入解释：第一个数字是3，也即这个小样例的N=3，说明用计算机生成了3个1到1000之间的随机整数，接下来每行一个随机数字，共3行，也即这3个随机数字为：221所以第一个小样例的输出为：12第二个小样例的第一个数字为11，也即…(类似上面的解释)…所以第二个小样例的输出为：10152032406789300400 思路： 类似于map,统计，最后遍历一遍输出即可 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int number,n; while(cin&gt;&gt;number)&#123; int a[1001] = &#123;0&#125;; while(number--)&#123; cin&gt;&gt;n; a[n]++; &#125; for(int i = 0;i&lt;1001;++i)&#123; if(a[i])&#123; cout&lt;&lt;i&lt;&lt;endl; &#125; &#125; &#125; return 0;&#125; HJ4 字符串分隔•连续输入字符串，请按长度为8拆分每个输入字符串并进行输出； •长度不是8整数倍的字符串请在后面补数字0，空字符串不处理。 （注：本题有多组输入） 示例： 输入： abc123456789 输出： abc000001234567890000000 思路： 我们在读取的字符串后面增加7个零，这样我们就可以保证后面的0；在通过substr函数进行提取，这里需要简单介绍下substr函数。 s.substr(pos,len)，返回值是string,包含s中从pos开始的len个字符的拷贝。 1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string s1; while(cin&gt;&gt;s1)&#123; s1 = s1 + "0000000"; //增加7个0，然后substr函数截取前8个 while(s1.size()&gt;=8)&#123; cout&lt;&lt;s1.substr(0,8)&lt;&lt;endl; s1 = s1.substr(8); &#125; &#125; return 0;&#125; HJ5 进制转换写出一个程序，接受一个十六进制的数，输出该数值的十进制表示。 数据范围：保证结果在 1≤n≤231−1 1≤n≤231−1 注意本题有多组输入 示例： 输入： 0xA0xAA 输出： 10170 思路： 方法一： 直接用流类格式化输入输出 12345678#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int a; while(cin&gt;&gt;hex&gt;&gt;a) cout&lt;&lt;dec&lt;&lt;a&lt;&lt;endl;&#125; 方法二： 主要就是十进制和十六进制的转换关系。 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string s; while(cin&gt;&gt;s)&#123; int bit=0; int ans=0; for(int i =s.size()-1;i&gt;1;--i)&#123; if(s[i]&gt;='0'&amp;&amp;s[i]&lt;='9')&#123; ans+=(s[i]-'0')*pow(16,bit++); &#125; else if(s[i]&gt;='A'&amp;&amp;s[i]&lt;='F')&#123; ans+=(s[i]-'A'+10)*pow(16,bit++); &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; HJ6 质数因子功能:输入一个正整数，按照从小到大的顺序输出它的所有质因子（重复的也要列举）（如180的质因子为2 2 3 3 5 ） 数据范围： 1≤n≤2×109+14 1≤n≤2×109+14 输入描述： 输入一个整数 输出描述： 按照从小到大的顺序输出它的所有质数的因子，以空格隔开。最后一个数后面也要有空格。 示例： 输入：180 输出：2 2 3 3 5 思路： 输出所有质数的因子，那么这个因子最大也就是这个数值开根号，比如25，质数因子就是 5、5；除数从2开始，进行除法计算，除不尽就用3，以此类推，直到除数增加到该数的开根号。 有除数能除的最后数值一定是1，如果不是1，那就是这个数本身就是质因子，只有1和本身可以整数，直接输出即可。 123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; long res; long i = 2; cin &gt;&gt; res; for(i;i&lt;=sqrt(res);i++)&#123; while(res%i==0)&#123; cout&lt;&lt;i&lt;&lt;" "; res /= i; &#125; &#125; if(res&gt;1)&#123; cout&lt;&lt;res&lt;&lt;" "; &#125; return 0;&#125; HJ7 取近似值写出一个程序，接受一个正浮点数值，输出该数值的近似整数值。如果小数点后数值大于等于 0.5 ,向上取整；小于 0.5 ，则向下取整。 数据范围：保证输入的数字在 32 位浮点数范围内 示例： 输入：5.5 输出：6 输入：2.499 输出：2 思路： 直接在输入的数上+0.5，然后通过int取整就可以了 123456789#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; float input; cin&gt;&gt;input; cout&lt;&lt;int(input+0.5)&lt;&lt;endl; return 0;&#125; HJ8 合并表记录数据表记录包含表索引和数值（int范围的正整数），请对表索引相同的记录进行合并，即将相同索引的数值进行求和运算，输出按照key值升序进行输出。 提示: 0 &lt;= index &lt;= 11111111 1 &lt;= value &lt;= 100000 输入描述: 先输入键值对的个数n（1 &lt;= n &lt;= 500）然后输入成对的index和value值，以空格隔开 输出描述： 输出合并后的键值对（多行） 示例： 输入： 40 10 21 23 4 输出： 0 31 23 4 解题思路： 方法一： 我们用一个数组来存储，对相同索引的数值求和，最后遍历输出数值大与0的即可。（不能完全AC） 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int num; cin&gt;&gt;num; int sum[1000]=&#123;0&#125;; int index,value; for(int i=0;i&lt;num;i++)&#123; cin&gt;&gt;index&gt;&gt;value; sum[index]+=value; &#125; for(int i=0;i&lt;1000;i++)&#123; if(sum[i]!=0)&#123; cout&lt;&lt;i&lt;&lt;" "&lt;&lt;sum[i]&lt;&lt;endl; &#125; &#125; return 0;&#125; 方法二： 利用C++的map实现 1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; map&lt;int,int&gt;sum; int n; cin&gt;&gt;n; int index,value; while(n--)&#123; cin&gt;&gt;index&gt;&gt;value; sum[index]+=value; &#125; for(auto c:sum)&#123; cout&lt;&lt;c.first&lt;&lt;" "&lt;&lt;c.second&lt;&lt;endl; &#125; return 0;&#125; HJ9 提取不重复的整数输入一个 int 型整数，按照从右向左的阅读顺序，返回一个不含重复数字的新的整数。 保证输入的整数最后一位不是 0 。 数据范围： 1≤n≤108 1≤n≤108 示例： 输入：9876673 输出：37689 解题思路： 转化为字符串的方法来解决，这里了解一下string::npos find函数在找不到指定值得情况下会返回string::npos。 1234567891011121314#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string str; string str1=""; cin&gt;&gt;str; for(int i=str.size()-1;i&gt;=0;i--)&#123; if(str1.find(str[i])==string::npos) str1+=str[i]; &#125; cout&lt;&lt;str1&lt;&lt;endl; return 0;&#125; 方法二： 使用数组a[10]来更新，每次把a[n%10]来判断是否出现过 123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n; int a[10]=&#123;0&#125;; int num=0; cin&gt;&gt;n; while(n)&#123; if(a[n%10]==0)&#123; a[n%10]++;//这一步更新，遇到相同的数会跳过 num = num*10+n%10; &#125; n/=10; &#125; cout&lt;&lt;num&lt;&lt;endl; return 0;&#125; HJ10 字符个数统计编写一个函数，计算字符串中含有的不同字符的个数。字符在 ASCII 码范围内( 0~127 ，包括 0 和 127 )，换行表示结束符，不算在字符里。不在范围内的不作统计。多个相同的字符只计算一次 例如，对于字符串 abaca 而言，有 a、b、c 三种不同的字符，因此输出 3 。 数据范围： 1≤n≤500 1≤n≤500 示例： 输入：abc 输出：3 思路：set就是关键字的简单集合。当只是想知道一个值是否存在时，set是最有用的。 1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string str; set&lt;char&gt;s; while(getline(cin,str))&#123; for(int i=0;i&lt;str.size();i++)&#123; s.insert(str[i]); &#125; &#125; cout&lt;&lt;s.size()&lt;&lt;endl; return 0;&#125; HJ11 数字颠倒输入一个整数，将这个整数以字符串的形式逆序输出 程序不考虑负数的情况，若数字含有0，则逆序形式也含有0，如输入为100，则输出为001 数据范围： 0≤n≤230−1 0≤n≤230−1 示例： 输入：1516000 输出：0006151 思路：转化为string,然后翻转 1234567891011#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int input; cin&gt;&gt;input; string res = to_string(input); reverse(res.begin(), res.end()); cout&lt;&lt;res; return 0;&#125; HJ12 字符串反转接受一个只包含小写字母的字符串，然后输出该字符串反转后的字符串。（字符串长度不超过1000） 示例： 输入：abcd 输出：dcba 思路：直接reverse() 12345678910#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string str; cin&gt;&gt;str; reverse(str.begin(),str.end()); cout&lt;&lt;str; return 0;&#125; HJ13 句子逆序将一个英文语句以单词为单位逆序排放。例如“I am a boy”，逆序排放后为“boy a am I” 所有单词之间用一个空格隔开，语句中除了英文字母外，不再包含其他字符 数据范围：输入的字符串长度满足 1≤n≤1000 1≤n≤1000 注意本题有多组输入 示例： 输入：I am a boy 输出：boy a am I 思路：我们定义一个string数组，顺序输入，倒序输出即可 123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string str; vector&lt;string&gt; tmp; while(cin&gt;&gt;str)&#123; tmp.push_back(str); &#125; for(int i=tmp.size()-1;i&gt;0;i--)&#123; cout&lt;&lt;tmp[i]&lt;&lt;" "; &#125; cout&lt;&lt;tmp[0]&lt;&lt;endl; return 0;&#125; HJ14 字符串排序描述给定 n 个字符串，请对 n 个字符串按照字典序排列。 数据范围： 1≤n≤1000 1≤n≤1000 ，字符串长度满足 1≤len≤100 1≤len≤100 输入描述：输入第一行为一个正整数n(1≤n≤1000),下面n行为n个字符串(字符串长度≤100),字符串中只含有大小写字母。 输出描述：数据输出n行，输出结果为按照字典序排列的字符串。 示例： 输入： 9captocatcardtwotooupboatboot 输出： boatbootcapcardcattotootwoup 思路：直接排序 123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; vector&lt;string&gt; res; while(n--)&#123; string tmp; cin&gt;&gt;tmp; res.push_back(tmp); &#125; sort(res.begin(),res.end()); for(int i=0;i&lt;res.size();i++)&#123; cout&lt;&lt;res[i]&lt;&lt;endl; &#125; return 0;&#125; HJ15 求int型正整数在内存中存储时1的个数描述输入一个 int 型的正整数，计算出该 int 型数据在内存中存储时 1 的个数。 数据范围：保证在 32 位整型数字范围内 输入描述： 输入一个整数（int类型） 输出描述： 这个数转换成2进制后，输出1的个数 示例： 输入：5 输出：2 思路：n&amp;(n-1) 即（0111）&amp;（0110）== 0110 就是 n去除了最后一个1 ； 12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n; while(cin&gt;&gt;n)&#123; int count = 0; while(n)&#123; //判断二进制有多少个1 n &amp;= n-1; count++; &#125; cout&lt;&lt;count&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>字节跳动</category>
      </categories>
      <tags>
        <tag>字节跳动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer]]></title>
    <url>%2F2022%2F02%2F24%2F%E5%89%91%E6%8C%87offer%2F</url>
    <content type="text"><![CDATA[06.从尾到头打印链表输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 示例： 输入：head= 【1，3，2】 输出：[2,3,1] 方法一：遍历翻转 借助栈的后进先出特性来实现 123456789101112class Solution &#123;public: vector&lt;int&gt; reversePrint(ListNode* head) &#123; vector&lt;int&gt;res; while(head)&#123; res.push_back(head-&gt;val); head = head-&gt;next; &#125; reverse(res.rbegin(),res.rend()); return res; &#125;&#125;; 方法二：递归法 先走到链表末端，回溯时依次将节点值加入列表，这样就可以实现链表的倒叙输出 12345678910111213class Solution &#123;public: vector&lt;int&gt;res; vector&lt;int&gt; reversePrint(ListNode* head) &#123; if(head!=NULL)&#123; if(head-&gt;next!=NULL)&#123; reversePrint(head-&gt;next); &#125; res.push_back(head-&gt;val); &#125; return res; &#125;&#125;; 07. 重建二叉树输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。 假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 示例： 输入：preorder = [3,9,20,15,7], inorder = [9,3,15,20,7] 输出：[3,9,20,null,null,15,7] 解题思路： 前序遍历性质： 节点按照 [ 根节点 | 左子树 | 右子树 ] 排序。中序遍历性质： 节点按照 [ 左子树 | 根节点 | 右子树 ] 排序。 以题目示例为例： 前序遍历划分 [ 3 | 9 | 20 15 7 ]中序遍历划分 [ 9 | 3 | 15 20 7 ]根据以上性质，可得出以下推论： 前序遍历的首元素 为 树的根节点 node 的值。在中序遍历中搜索根节点 node 的索引 ，可将 中序遍历 划分为 [ 左子树 | 根节点 | 右子树 ] 。根据中序遍历中的左（右）子树的节点数量，可将 前序遍历 划分为 [ 根节点 | 左子树 | 右子树 ] 。 通过以上三步，可确定 三个节点 ：1.树的根节点、2.左子树根节点、3.右子树根节点。 根据「分治算法」思想，对于树的左、右子树，仍可复用以上方法划分子树的左右子树。 分治算法解析： 递推参数： 根节点在前序遍历的索引 root 、子树在中序遍历的左边界 left 、子树在中序遍历的右边界 right ； 终止条件： 当 left &gt; right ，代表已经越过叶节点，此时返回 null ； 递推工作：1，建立根节点 node ： 节点值为 preorder[root] ；2，划分左右子树： 查找根节点在中序遍历 inorder 中的索引 i ； 为了提升效率，本文使用哈希表 dic 存储中序遍历的值与索引的映射，查找操作的时间复杂度为O(1) ； 构建左右子树： 开启左右子树递归； 根节点索引 中序遍历左边界 中序遍历右边界 左子树 root + 1 left i - 1右子树 i - left + root + 1 i + 1 right TIPS： i - left + root + 1含义为 根节点索引 + 左子树长度 + 1 返回值： 回溯返回 node ，作为上一层递归中根节点的左 / 右子节点； 1234567891011121314151617181920212223242526class Solution &#123;public: unordered_map&lt;int,int&gt;mp; TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123; //将中序序列用哈希表存储，便于查找根节点 for(int i=0;i&lt;inorder.size();i++)&#123; mp[inorder[i]] = i; &#125; //传入参数：前序、中序、前序序列根节点、中序序列左边界、中序序列右边界 return recur(preorder,inorder,0,0,inorder.size()-1); &#125; TreeNode* recur(vector&lt;int&gt;&amp; preorder,vector&lt;int&gt;&amp; inorder,int pre_root,int in_left,int in_right)&#123; if(in_left &gt; in_right) return NULL; //建立新节点 TreeNode* root = new TreeNode(preorder[pre_root]); //根节点在中序序列中的位置，用于划分左右子树的边界 int in_root = mp[preorder[pre_root]]; //左子树在前序中的根节点位于：pre_root+1,左子树在中序中的边界：[int_left,in_root-1] root-&gt;left = recur(preorder,inorder,pre_root+1,in_left,in_root-1); // 右子树在前序中的根节点位于：根节点+左子树长度+1 = pre_root+in_root-in_left+1 // 右子树在中序中的边界：[in_root+1,in_right] root-&gt;right = recur(preorder,inorder,pre_root+in_root-in_left+1,in_root+1,in_right); return root; &#125;&#125;; 09. 用两个栈实现队列用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) 示例1: 输入： [“CQueue”,”appendTail”,”deleteHead”,”deleteHead”] [[],[3],[],[]] 输出： [null,null,3,-1] 题目理解： [“CQueue”,”appendTail”,”deleteHead”,”deleteHead”] 这里是要执行的方法，从左到右执行 [[],[3],[],[]]对应上面的方法，是上面方法的参数。CQueue和deleteHead方法不需要指定数字，只有添加才需要指定数字 1.创建队列，返回值为null 2.将3压入栈，返回值为null 3.将栈底的元素删除，也就是消息队列中先进来的元素，所以是deleteHead，返回该元素的数值，所以为3 4.继续删除栈底的元素，但是没有元素了，所以返回-1 所以就有了下面的输出 输出：[null,null,3,-1] 解题思路： 双栈可以实现列表倒序 1，加入队尾appenTail()函数：将数字val加入栈A 2，删除队首deleteHead()函数：有以下三种情况 ​ 1）当栈B不为空时：B中仍有已完成倒序的元素，因此直接返回B的栈顶元素 ​ 2）否则，当A为空时：即两个栈都为空，无元素，因此返回-1 ​ 3）否则，将栈A元素全部转移至栈B中，实现元素倒序，并返回栈B的栈顶元素 时间复杂度：appenTail()为O(1);deleteHead()在N次队首元素删除操作中总共需完成N个元素的倒序。 空间复杂度：最差情况下，栈A和栈B共保存N个元素 1234567891011121314151617181920212223242526272829303132class CQueue &#123;public: stack&lt;int&gt; A,B; CQueue() &#123; &#125; void appendTail(int value) &#123; A.push(value); &#125; int deleteHead() &#123; //栈B不空 if(!B.empty())&#123; int res = B.top(); B.pop(); return res; &#125; //B空A空 if(A.empty())&#123; return -1; &#125; //B空A不空，将A中元素倒序到B中 while(!A.empty())&#123; B.push(A.top()); A.pop(); &#125; int ans = B.top(); B.pop(); return ans; &#125;&#125;; 10- I. 斐波那契数列写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下： F(0) = 0, F(1) = 1F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1. 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例： 输入：n=2 输出：1 思路： 方法一：递归法 ​ 原理：把f(n)问题拆分为f(n-1)和f(n-2)两个子问题的计算，以f(0),f(1)为终止条件。 ​ 缺点：大量重复的递归计算 12345678class Solution &#123;public: int fib(int n) &#123; if(n==0) return 0; if(n==1 || n==2) return 1; return (fib(n-1)+fib(n-2))%1000000007; &#125;&#125;; 方法二：记忆化递归 ​ 原理：在递归法的基础上，新建一个长度为n的数组，用于递归时存储f(0)至f(n)的数字值，重复遇到某数字时则直接从数组取用，避免重复的递归计算。 ​ 缺点：需要使用O(N)的额外空间。 方法三：动态规划 ​ 原理：以斐波那契数列性质f(n+1)=f(n)+f(n-1)为转移方程。 动态规划解析： 状态定义：设dp为一维数组，其中dp[i]的值代表斐波那契数列第几个数字。 转移方程：dp[i+1] = dp[i] + dp[i-1] 初始状态：dp[0]=0,dp[1]=1 返回值：dp[n],即斐波那契数列的第n个数字 空间复杂度分析： 若新建长度为 n 的 dp 列表，则空间复杂度为 O(N) 。 由于dp列表第i项只与第i-1和第i-2有关，因此只需要初始化三个整形变量sum、a、b，利用辅助sum使a,b两数字交替前进即可。 节省了dp列表空间，因此空间复杂度降至O(1)。 12345678910111213class Solution &#123;public: int fib(int n) &#123; if(n==0 || n==1) return n; int a = 0,b=1,sum=a+b; for(int i=2;i&lt;n;i++)&#123; a = b; b =sum; sum = (a+b)%1000000007; &#125; return sum; &#125;&#125;; 10- II. 青蛙跳台阶问题一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例： 输入：n=2 输出：2 输入：n=7 输出：21 输入：n=0 输出：0 思路： 也是斐波那契数列的变形，到达第n阶，则前面一定是n-1或者n-2,也就是f(n)=f(n-1)+f(n-2) 方法一：时间复杂度为O(n)，空间复杂度为O(n) 12345678910111213class Solution &#123;public: int numWays(int n) &#123; if(n==0 || n==1) return 1; int dp[n+1]; dp[1]=1; dp[2]=2; for(int i=3;i&lt;=n;i++)&#123; dp[i] = (dp[i-1]+dp[i-2])%1000000007; &#125; return dp[n]; &#125;&#125;; 复杂度为O(1) 12345678910111213class Solution &#123;public: int numWays(int n) &#123; if(n==0 || n==1) return 1; int a=1,b=2,sum; for(int i=3;i&lt;=n;i++)&#123; sum = (a+b)%1000000007; a=b; b=sum; &#125; return b; &#125;&#125;; 11. 旋转数组的最小数字把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为1。 示例： 输入：[3,4,5,1,2] 输出：1 思路： 方法一：排序直接输出 12345678class Solution &#123;public: int minArray(vector&lt;int&gt;&amp; numbers) &#123; if(numbers.size()&lt;=0) return 0; sort(numbers.begin(),numbers.end()); return numbers[0]; &#125;&#125;; 方法二：二分查找 算法流程： 1，初始化：声明i,j双指针分别指向nums数组左右两端 2，循环二分：设m=(i+j)/2为每次二分的中点，可分为以下三种情况： 当nums[m]&gt;nums[j]时：m一定在左排序数组中，即旋转点x一定在[m+1,j]，因此执行i=m+1; 当nums[m]&lt;nums[j]时：m一定在右排序数组中，即旋转点x一定在[i,m]，因此执行j=m; 当nums[m]=nums[j]时：无法判断m在哪个排序数组中，即无法判断旋转点x在[i,m]还是[m+1,j]中。 解决方案：直接遍历 3，返回值：当j=j时跳出循环，并返回旋转点的值nums[i]即可。 12345678910111213141516171819class Solution &#123;public: int minArray(vector&lt;int&gt;&amp; numbers) &#123; int i=0,j=numbers.size()-1; while(i&lt;j)&#123; int m=(i+j)/2; if(numbers[m]&gt;numbers[j]) i=m+1; else if(numbers[m]&lt;numbers[j]) j=m; else&#123; int x =i; for(int k=i+1;k&lt;j;k++)&#123; if(numbers[k]&lt;numbers[x]) x=k; &#125; return numbers[x]; &#125; &#125; return numbers[i]; &#125;&#125;; 12. 矩阵中的路径给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 例如，在下面的 3×4 的矩阵中包含单词 “ABCCED”（单词中的字母已标出） 示例： 输入：board = [[“A”,”B”,”C”,”E”],[“S”,”F”,”C”,”S”],[“A”,”D”,”E”,”E”]], word = “ABCCED” 输出：true 思路：dfs1，递归参数：当前元素在矩阵中的行列索引i和j,当前目标字符在word中的索引k。 2,递归终止条件： ​ 当行列索引越界或当前元素与目标字符不同 3，递推工作： ​ 1，标记当前单元格，将board[i][j]修改为空字符，代表已经访问过，防止之后重复访问 ​ 2，搜索下一单元格，计算当前元素的上下左右，看是否是word的相连字符，不是就放回false ​ 3，还原当前矩阵元素 4，返回值：返回布尔量res,代表是否搜索到目标字符串 12345678910111213141516171819202122232425class Solution &#123;public: bool exist(vector&lt;vector&lt;char&gt; &gt;&amp; board, string word) &#123; int rows = board.size(),cols = board[0].size(); for(int i=0;i&lt;rows;i++)&#123; for(int j=0;j&lt;cols;j++)&#123; if(dfs(board,word,i,j,0)) return true; &#125; &#125; return false; &#125;private: int dfs(vector&lt;vector&lt;char&gt; &gt;&amp;board,string word,int i,int j,int k)&#123; //递归终止条件 if(i&gt;=board.size() || i &lt; 0 || j&gt;=board[0].size() || j&lt;0 || board[i][j] != word[k]) return false; //递归 if(k==word.size()-1) return true; //保证不走回头路 board[i][j] ='/0'; bool res = dfs(board,word,i+1,j,k+1) || dfs(board,word,i-1,j,k+1) || dfs(board,word,i,j+1,k+1) || dfs(board,word,i,j-1,k+1); //还原，只代表本次搜索已经访问过 board[i][j] = word[k]; return res; &#125;&#125;; 13. 机器人的运动范围地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？ 示例： 输入：m=2,n=3,k=1 输出：3 输入：m=3,n=1,k=0 输出：0 思路：方法一：深度优先遍历DFSDFS通过递归，先朝一个方向搜到底，再回溯至上一个节点，沿另一个方向搜索。 剪枝： 在搜索中，遇到数位和超出目标值、此元素已访问，则应立即返回，称之为 可行性剪枝 。 算法解析： 递归参数： 当前元素在矩阵中的行列索引i和j,两者的数位和si,sj; 终止条件： 当行列索引越界或数位和超出目标值K或当前元素已经访问过，返回0，代表计入不可达; 递推工作： ​ 1，标记当前单元格：将索引(i,j)存入set visited中，代表此单元格已经访问过。 ​ 2，搜索下一单元格：计算当前元素的下，右两个方向元素的数位和，并开启下层递归。 回溯返回值： 返回 1 + 右边搜索可达解总数 + 下边可达解总数，代表从本单元格递归搜索的可达解总数; 代码1： 12345678910111213141516171819202122232425262728class Solution &#123;public: int movingCount(int m, int n, int k) &#123; //标记数组 vector&lt;vector&lt;bool&gt; &gt; visited(m,vector&lt;bool&gt;(n,0)); //递归访问 return dfs(visited,m,n,k,0,0); &#125;private: int dfs(vector&lt;vector&lt;bool&gt; &gt;&amp; visited,int m,int n,int k,int i, int j)&#123; //递归终止条件 if(i&gt;=m || j&gt;=n || visited[i][j] || bitSum(i)+bitSum(j) &gt; k) return 0; //访问 visited[i][j]=1; //递归访问下边和右边 return 1 + dfs(visited,m,n,k,i+1,j) + dfs(visited,m,n,k,i,j+1); &#125; //计算数位和 int bitSum(int n)&#123; int sum = 0; while(n&gt;0)&#123; sum += n % 10; n /= 10; &#125; return sum; &#125;&#125;; 方法二：广度优先遍历BFSBFS通常利用队列实现 算法解析： 初始化: 将机器人初始点(0,0)加入队列queue 递归终止条件： queue为空。代表已遍历完所有可达解； 迭代工作：* ​ 1，单元格出队：将队首单元格的索引，数位和弹出，作为当前搜索单元格； ​ 2，判断是否跳过：当行列索引越界或数位和超出目标值K或当前元素已经访问过，返回0，代表计入不可达，执行continue; ​ 3，标记当前单元格：将单元格索引(i,j)存入visited中，代表此单元格已被访问过； ​ 4，单元格入队：将当前元素的下边、右边单元格的索引、数位和加入queue中； 返回值： visited的长度即为可达解数量; 代码2: 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: int movingCount(int m, int n, int k) &#123; //标记数组 vector&lt;vector&lt;bool&gt; &gt; visited(m,vector&lt;bool&gt;(n,0)); int res = 0; //辅助队列 queue&lt;vector&lt;int&gt; &gt; que; que.push(&#123;0,0,0,0&#125;); while(que.size()&gt;0)&#123; //弹出队首元素 vector&lt;int&gt; x = que.front(); que.pop(); int i=x[0],j=x[1],si=x[2],sj=x[3]; if(i&gt;=m || j&gt;=n || visited[i][j] || si + sj &gt; k) continue; //访问 visited[i][j] = true; res++; //将下边和右边入队 que.push(&#123;i+1,j,bitSum(i+1),sj&#125;); que.push(&#123;i,j+1,si,bitSum(j+1)&#125;); &#125; return res; &#125;private:int bitSum(int n)&#123; int sum = 0; while(n&gt;0)&#123; sum += n % 10; n /= 10; &#125; return sum; &#125;&#125;; 14- I. 剪绳子给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]k[1]…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 示例： 输入：2 输出：1 思路：关于为什么切分为3的优先级最高 可以利用均值不等式求出乘积最大值 L(m)=(n/m)^m 对此式求导（可利用对数法）， 可以证明当 m=n/e 时，乘积取最大，此时每段绳子的长度为 n/(n/e)=e，自然对数e的值为2.718，显然接近3，所以总体来讲3最好 均值不等式 \frac{n_1+n_2+...n_a}n \quad \geq \sqrt[n]{n_1n_2...n_a}由数学推导可得： 1，当所有绳段长度相等时，乘积最大。 2，最优的绳段长度为3 切分规则： 1，最优：3.把绳子尽可能切为多个长度为3的片段，留下的最后一段绳子的长度可能为9，1，2三种情况 2，次优：2.若最后一段绳子长度为2；则保留，不再拆分为1+1 3，最差：1，若最后一段绳子长度为1；则应把一份3+1替换成2+2。 算法流程： 1，当n&lt;=3时，按照规则应不切分，但由于题目要求必须切成m&gt;1段，因此必须剪出一段长度为1的绳子，即返回n-1 2，当n&gt;3时，求n除以3的整数部分a和余数部分b(即n=3a+b)，并分为以下三种情况： ​ 当b=0时，直接返回3^n ​ 当b=1时，要将一个1+3转换为2+2,因此返回3^(a-1)*4 ​ 当b=2时，返回3^a*2 时间复杂度：O(1) 空间复杂度：O(1) 12345678910class Solution &#123;public: int cuttingRope(int n) &#123; if(n&lt;=3) return n-1; int a = n/3,b = n%3; if(b==0) return pow(3,a); if(b==1) return pow(3,a-1)*4; else return pow(3,a)*2; &#125;&#125;; 方法二：动态规划: 12345678910111213141516171819class Solution &#123;public: int cuttingRope(int n) &#123; if(n&lt;=3) return n-1; //里的3可以不需要再分了，因为3分段最大才2，不分就是3。记录最大的。 int dp[n+1]; dp[1] = 1; dp[2] = 2; dp[3] = 3; for(int i=4;i&lt;=n;i++)&#123; int maxValue = 0; for(int j=1;j&lt;=i/2;j++)&#123; maxValue = max(maxValue,dp[j]*dp[i-j]); &#125; dp[i] = maxValue; &#125; return dp[n]; &#125;&#125;; 14- II. 剪绳子 II给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m - 1] 。请问 k[0]k[1]…*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 在上一题的基础上取模,最佳方法就是快速幂 12345678910111213141516171819202122232425class Solution &#123;public: int cuttingRope(int n) &#123; if(n&lt;=3) return n-1; int a = n/3,b=n%3,k= 1000000007; if(b==0) return quick_mod(3,a,k)%k; if(b==1) return quick_mod(3,a-1,k)*4%k; else return quick_mod(3,a,k)*2%k; &#125;private: //快速幂 long long quick_mod(long x,long y,long k)&#123; long long ans = 1; //对刚进来的x进行取模运算，避免后面第一次求平方溢出 x %= k; while(y)&#123; if(y&amp;1)&#123; ans = ans*x%k; &#125; y&gt;&gt;=1; x = x * x %k; &#125; return ans%k; &#125;&#125;; 方法二：循环求余 123456789101112131415class Solution &#123; public int cuttingRope(int n) &#123; if(n &lt;= 3) return n - 1; int b = n % 3, p = 1000000007; long rem = 1, x = 3 ,a = n / 3; //直接套循环求余公式 for(int i = 0; i &lt; ((b == 1)?a-1:a); i++) &#123; //b == 1代表余数为1的时候，需要单独取出一个3出来凑成2*2达到最大值效果 rem = (rem * x) % p; &#125; if(b == 0) return (int)(rem % p); if(b == 1) return (int)(rem * 4 % p); return (int)(rem * 2 % p); &#125;&#125;; 15. 二进制中1的个数编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 汉明重量).）。 提示： 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。在 Java 中，编译器使用 二进制补码 记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。 示例： 输入：n = 11 (控制台输入 00000000000000000000000000001011)输出：3解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 ‘1’。 思路：方法一: &amp;1,并且右移1位 12345678910111213class Solution &#123;public: int hammingWeight(uint32_t n) &#123; int count = 0; while(n)&#123; if(n&amp;1)&#123; count++; &#125; n&gt;&gt;=1; &#125; return count; &#125;&#125;; 方法二： 直接n&amp;(n-1)即可得到1的数量 1234567891011class Solution &#123;public: int hammingWeight(uint32_t n) &#123; int count = 0; while(n)&#123; n &amp;= n-1; count++; &#125; return count; &#125;&#125;; 16. 数值的整数次方实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题 示例： 输入：x = 2.00000, n = 10输出：1024.00000 输入：x = 2.10000, n = 3输出：9.26100 输入：x = 2.00000, n = -2输出：0.25000解释：2-2 = 1/22 = 1/4 = 0.25 思路：快速幂，但是需要注意当n = (-1)*n时会出现错误，我们需要把n放到long中 12345678910111213141516171819202122232425262728class Solution &#123;public: double myPow(double x, int n) &#123; double sum; long m = n; if(n==0 || x==1) return 1; if(n&gt;0)&#123; sum = quick_mod(x,m); &#125; else&#123; m = (-1)*m; sum = 1/quick_mod(x,m); &#125; return sum; &#125;private: double quick_mod(double x,long y)&#123; double ans = 1; while(y)&#123; if(y&amp;1)&#123; ans = ans*x; &#125; y&gt;&gt;=1; x = x*x; &#125; return ans; &#125;&#125;; 17. 打印从1到最大的n位数输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。 示例： 输入: n = 1输出: [1,2,3,4,5,6,7,8,9] 思路：不考虑大数的话 1234567891011class Solution &#123;public: vector&lt;int&gt; printNumbers(int n) &#123; int high = pow(10,n)-1; vector&lt;int&gt; res(high); for(int i=0;i&lt;high;i++)&#123; res[i]=i+1; &#125; return res; &#125;&#125;; 考虑大数 我们要转化为string来处理 递归生成全排列: 基于分治算法的思想，先固定高位，向低位递归，当个位已被固定时，添加数字的字符串。例如当n=2时，(数字范围1-99)，固定十位为0-9，按顺序依次开启递归，固定个位0-9，终止递归并添加数字字符串。 但是也有两个问题 1，删除高位多余的0 2，列表从1开始 12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;string&gt; res; string cur; char num[10] = &#123;'0','1','2','3','4','5','6','7','8','9'&#125;; vector&lt;string&gt; printNumbers(int n) &#123; //数字长度 for(int i=1;i&lt;=n;i++) dfs(0,i); return res; &#125; void dfs(int x,int len)&#123; //添加到结果中 if(x==len)&#123; res.push_back(cur); return; &#125; //x=0表示左边第一位数字，不能为0 int start = x==0 ? 1 : 0; for(int i=start;i&lt;10;i++)&#123; //确定本位数字 cur.push_back(num[i]); //确定下一位数字 dfs(x+1,len); //删除本位数字 cur.pop_back(); &#125; &#125;&#125;; 转化为int 12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;string&gt; res; string cur; char num[10] = &#123;'0','1','2','3','4','5','6','7','8','9'&#125;; vector&lt;int&gt; printNumbers(int n) &#123; //数字长度 for(int i=1;i&lt;=n;i++) dfs(0,i); vector&lt;int&gt; res_int; for(int i=0;i&lt;res.size();i++)&#123; res_int.push_back(stoi(res[i])); &#125; return res_int; &#125; void dfs(int x,int len)&#123; if(x==len)&#123; res.push_back(cur); return; &#125; //x=0表示左边第一位数字，不能为0 int start = x==0 ? 1 : 0; for(int i=start;i&lt;10;i++)&#123; //确定本位数字 cur.push_back(num[i]); //确定下一位数字 dfs(x+1,len); //删除本位数字 cur.pop_back(); &#125; &#125;&#125;; 18. 删除链表的节点给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。 返回删除后的链表的头节点。 注意：此题对比原题有改动 示例： 输入: head = [4,5,1,9], val = 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9. 思路：双指针法： 算法流程： 1，定义*pre = head*· `cur=head-&gt;next 2，判断当cur不为空和cur-&gt;val != val 时，指针向前运动 3，返回值：如果cur不为空，代表找到了，我们只需要删除即可，最后返回头节点 1234567891011121314class Solution &#123;public: ListNode* deleteNode(ListNode* head, int val) &#123; if(head==nullptr) return head; if(head-&gt;val==val) return head-&gt;next; ListNode* cur = head-&gt;next,*pre=head; while(cur!=nullptr &amp;&amp; cur-&gt;val != val)&#123; pre = cur; cur = cur-&gt;next; &#125; if(cur != nullptr) pre-&gt;next = cur-&gt;next; return head; &#125;&#125;; 21. 调整数组顺序使奇数位于偶数前面输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。 示例： 输入： nums=[1,2,3,4] 输出： [1,3,2,4]或[3,1,2,4] 思路： 排序 方法一：采用双指针法 定义双指针在数组两端，循环执行（i=j时跳出）： ​ 1，指针i从左往右寻找偶数 ​ 2，指针j从右往左寻找奇数 ​ 3，交换 123456789101112class Solution &#123;public: vector&lt;int&gt; exchange(vector&lt;int&gt;&amp; nums) &#123; int i = 0,j = nums.size()-1; while(i&lt;j)&#123; while(i&lt;j &amp;&amp; (nums[i] &amp; 1) == 1) i++; while(i&lt;j &amp;&amp; (nums[j] &amp; 1) == 0) j--; swap(nums[i],nums[j]); &#125; return nums; &#125;&#125;; 方法二：快慢指针 1234567891011121314class Solution &#123;public: vector&lt;int&gt; exchange(vector&lt;int&gt;&amp; nums) &#123; int slow =0,fast=0; while(fast&lt;nums.size())&#123; if(nums[fast]&amp;1)&#123; swap(nums[slow],nums[fast]); slow++; &#125; fast++; &#125; return nums; &#125;&#125;; 22. 链表中倒数第k个节点输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。 例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。 示例： 给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2. 返回链表 4-&gt;5. 思路：方法一： 1，先遍历求链表长度n 2，再回到头节点走n-k步 123456789101112131415161718192021class Solution &#123;public: ListNode* getKthFromEnd(ListNode* head, int k) &#123; int n = 0; ListNode *cur = head; //确定链表长度 while(cur!=nullptr)&#123; n++; cur = cur-&gt;next; &#125; //判断溢出 if(k&gt;n) return nullptr; //回到头节点 cur = head; //移动到第n-k个位置 for(int i=0;i&lt;n-k;i++)&#123; cur = cur-&gt;next; &#125; return cur; &#125;&#125;; 方法二：双指针 1，定义一个指针cur向前走k步，pre指向头节点 2，判断溢出 3，两个指针同时运动，直到cur指向null,返回pre 12345678910111213141516class Solution &#123;public: ListNode* getKthFromEnd(ListNode* head, int k) &#123; ListNode *pre = head,*cur=head; for(int i=0;i&lt;k;i++)&#123; //判断溢出 if(cur==nullptr) return nullptr; cur = cur-&gt;next; &#125; while(cur!=nullptr)&#123; cur = cur-&gt;next; pre = pre -&gt;next; &#125; return pre; &#125;&#125;; 24. 反转链表定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。 示例： 输入：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出：5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 思路：方法一：双指针 12345678910111213class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; ListNode* cur = head,*pre=nullptr; while(cur!=nullptr)&#123; ListNode* tmp = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = tmp; &#125; return pre; &#125;&#125;; 方法二：递归 算法流程： recur(cur,pre): 1，终止条件：当cur为空，则返回尾节点pre(即反转链表的头节点) 2，递归后继节点，记录返回值为res 3，修改当前节点cur指向前驱节点pre 4，返回res 12345678910111213141516class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; return recur(head,nullptr); &#125;private: ListNode* recur(ListNode* cur,ListNode* pre)&#123; //终止条件 if(cur==nullptr) return pre; //递归后继节点 ListNode* res = recur(cur-&gt;next,cur); //修改节点引用指向 cur-&gt;next = pre; return res; &#125;&#125;; 25. 合并两个排序的链表输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。 示例： 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 思路：方法一：双指针 双指针l1、l2遍历两链表。 算法流程： 1，初始化：创建伪节点dum,节点cur指向dum 2，循环合并：当l1或l2为空时跳出： 当l1.val &lt; l2.val时：cur的后继节点指定为l1,l1向前走一步 当l1.val &gt;= l2.val时：cur的后继节点指定为l2,l2向前走一步 节点cur向前走一步，即cur=cur-&gt;next 3，合并剩余尾部 l1不空，将l1添加至节点cur后 否则，将l2添加至节点cur之后 4，返回值：合并链表在伪节点dum之后，因此返回dum-&gt;next 1234567891011121314151617181920212223242526class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; //判断 if(l1==nullptr) return l2; if(l2==nullptr) return l1; if(l1==nullptr &amp;&amp; l2==nullptr) return nullptr; //创建伪节点 ListNode* dum = new ListNode(0),*cur = dum; //循环合并 while(l1 != nullptr &amp;&amp; l2 != nullptr)&#123; //l1-&gt;val&lt;l2.val，指向l1 if(l1-&gt;val &lt; l2-&gt;val)&#123; cur-&gt;next = l1; l1 = l1-&gt;next; &#125;else&#123; cur-&gt;next = l2; l2 = l2-&gt;next; &#125; cur = cur-&gt;next; &#125; //合并剩余尾部 cur-&gt;next = l1 != nullptr ? l1 : l2; return dum-&gt;next; &#125;&#125;; 方法二：递归 1234567891011121314151617class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; //判断 if(l1==nullptr) return l2; if(l2==nullptr) return l1; if(l1==nullptr &amp;&amp; l2==nullptr) return nullptr; if(l1-&gt;val &lt;= l2-&gt;val)&#123; l1-&gt;next = mergeTwoLists(l1-&gt;next,l2); return l1; &#125;else&#123; l2-&gt;next = mergeTwoLists(l1,l2-&gt;next); return l2; &#125; &#125;&#125;; 27. 二叉树的镜像请完成一个函数，输入一个二叉树，该函数输出它的镜像。 例如输入： 4 / \ 2 7 / \ / \1 3 6 9 镜像输出： 4 / \ 7 2 / \ / \9 6 3 1 示例： 输入：root = [4,2,7,1,3,6,9]输出：[4,7,2,9,6,3,1] 思路：方法一：递归 根据二叉树镜像的定义，考虑递归(dfs)二叉树，交换每个节点的左/右子节点，即可生成二叉树的镜像 算法流程： 1，终止条件：当root为空时，返回null 2，递推工作： 初始化节点tmp,用于暂存root的左子节点； 开启递归右子节点mirrorTree(root-&gt;right)，并将返回值作为root的左子节点； 开启递归右子节点mirrorTree(tmp)，并将返回值作为root的右子节点； 3，返回值：返回当前节点root 12345678910class Solution &#123;public: TreeNode* mirrorTree(TreeNode* root) &#123; if(root==nullptr) return nullptr; TreeNode* tmp = root-&gt;left; root-&gt;left = mirrorTree(root-&gt;right); root-&gt;right = mirrorTree(tmp); return root; &#125;&#125;; 方法二：辅助栈 算法流程： 1，初始化：设置一个链表栈，root入栈 2，设置node指针指向栈顶，然后出栈，左右子树入栈 3，交换左右子树 4，返回root 123456789101112131415161718192021class Solution &#123;public: TreeNode* mirrorTree(TreeNode* root) &#123; if(root==nullptr) return nullptr; stack&lt;TreeNode*&gt; st; st.push(root); while(!st.empty())&#123; TreeNode* node = st.top(); //出栈 st.pop(); //左右子树入栈 if(node-&gt;left != nullptr) st.push(node-&gt;left); if(node-&gt;right != nullptr) st.push(node-&gt;right); //交换左右子树 TreeNode* tmp = node-&gt;left; node-&gt;left = node-&gt;right; node-&gt;right = tmp; &#125; return root; &#125;&#125;; 28. 对称的二叉树请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 / \ 2 2 / \ / \3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 1 / \ 2 2 \ \ 3 3 示例： 输入：root = [1,2,2,3,4,4,3]输出：true 思路：对称二叉树定义：对于树中任意两个对称节点L和R，一定有： ​ 1，L.val = R.val ​ 2，L.left.val = R.right.val ​ 3，L.right.val = R.left.val 算法流程： 1，终止条件： 当L和R同时越过叶节点；此树丛顶至顶都对称，返回true 当L或R中有一个越过叶节点：此树不对称，返回false 当节点L值 != R值：不对称，返回false 2，递推工作： 判断两节点L.left和R.right是否对称,即recur(L.left,R.right); 判断两节点L.right和R.left是否对称,即recur(L.right,R.left); 12345678910111213141516class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; if(root == nullptr) return true; //递归 return recur(root-&gt;left,root-&gt;right); &#125; bool recur(TreeNode* L,TreeNode* R)&#123; //左右同时结束 if(L==nullptr &amp;&amp; R==nullptr) return true; //左子树或者右子树一边没有元素或者两边不等 if(L == nullptr || R==nullptr || L-&gt;val != R-&gt;val) return false; //递归 return recur(L-&gt;left,R-&gt;right) &amp;&amp; recur(L-&gt;right,R-&gt;left); &#125;&#125;; 30. 包含min函数的栈定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。 示例： MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.min(); —&gt; 返回 -3.minStack.pop();minStack.top(); —&gt; 返回 0.minStack.min(); —&gt; 返回 -2. 思路：普通栈push()和pop()复杂度为O(1),而获取栈最小值min()需要遍历整个栈，复杂度为O(N); 我们可以通过建立辅助栈实现： 数据栈A：栈A用于存储所有元素，保证push()、pop()、top()函数的正常逻辑 数据栈B：栈B中存储栈A中所有非严格降序的元素，则栈A中的最小元素始终对应栈B的栈顶元素，即min()只需返回栈B的栈顶元素即可； 算法流程：push(x): 重点保持栈B的元素是非严格降序的 ​ 1，将x压入栈A； ​ 2，若栈B为空或x小于等于栈B的栈顶元素，则将x压入栈B pop():重点保持栈A，B的元素一致性 ​ 1，执行栈A出栈，将出栈元素记为y; ​ 2，若y等于栈B的栈顶元素，则执行栈B出栈； top():直接返回栈A的栈顶元素 min():直接返回栈B的栈顶元素 123456789101112131415161718192021222324252627282930313233class MinStack &#123;public: /** initialize your data structure here. */ stack&lt;int&gt;A,B; MinStack() &#123; &#125; void push(int x) &#123; A.push(x); //B空或者栈B的栈顶元素小于x，入栈B if(B.empty() || x&lt;=B.top())&#123; B.push(x); &#125; &#125; void pop() &#123; int y=A.top(); A.pop(); //保持一致性 if(B.top()==y)&#123; B.pop(); &#125; &#125; int top() &#123; return A.top(); &#125; int min() &#123; return B.top(); &#125;&#125;; 35. 复杂链表的复制请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。 示例1: 输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]] 输出：[[7,null],[13,0],[11,4],[10,2],[1,0]] 思路：方法一：哈希表利用哈希表的查询特点，考虑构建 原链表节点 和 新链表对应节点 的键值对映射关系， 再遍历构建新链表各节点的 next 和 random 引用指向即可。 算法流程： 1，若头节点head为空节点，直接返回null; 2，初始化：哈希表dic，节点cur指向头节点; 3，复制链表： 建立新节点，并向dic添加键值对(原cur节点，新cur节点) cur遍历至原链表下一节点； 4，构建新链表的引用指向： 1，构建新节点的next和random引用指向； 2，cur遍历至原链表下一节点； 5，返回值：新链表的头节点dic[cur]； 时间复杂度O(N): 两轮遍历链表，使用O(N)时间。 空间复杂度O(N)：哈希表dic使用线性大小的额外空间； 1234567891011121314151617181920212223class Solution &#123;public: Node* copyRandomList(Node* head) &#123; if(head==nullptr) return nullptr; Node* cur = head; unordered_map&lt;Node*,Node*&gt;map; //复制链表，并建立“原节点-&gt;新节点“的map映射 while(cur != nullptr)&#123; map[cur] = new Node(cur-&gt;val); cur = cur-&gt;next; &#125; //指向头节点,重新遍历 cur = head; //构建新链表的next和random指向 while(cur != nullptr)&#123; map[cur]-&gt;next = map[cur-&gt;next]; map[cur]-&gt;random = map[cur-&gt;random]; cur = cur-&gt;next; &#125; //返回新链表的头节点 return map[head]; &#125;&#125;; 方法二：拼接+拆分考虑构建: 原节点1-&gt;新节点1-&gt;原节点2-&gt;新节点2-&gt;….的拼接链表，如此便可在访问原节点的random指向节点 的同时找到新对应新节点的random指向节点; 算法流程： 1，复制各节点，构建拼接链表： 设原节点为node1-&gt;node2…,构建成node1-&gt;node1-&gt;node2-&gt;node2-&gt;…. 2，构建新链表各节点的random指向： 当访问原节点cur的随机指向节点cur.random时，对应新节点的cur.next的随机指向节点为cur.random-&gt;next 3，拆分原/新链表： 设置pre/cur分别指向原/新链表头节点，遍历执行pre.next = pre.next.next和cur.next = cur.next.next将两链表拆分开 4，返回新链表的头节点res即可 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: Node* copyRandomList(Node* head) &#123; if(head == nullptr) return nullptr; //设置cur指向头节点 Node* cur = head; //1，复制各节点，并构建拼接新链表 while(cur != nullptr)&#123; //构建新节点 Node* tmp = new Node(cur-&gt;val); tmp-&gt;next = cur-&gt;next; cur-&gt;next = tmp; cur = tmp-&gt;next; &#125; //构建各新节点的random指向 //返回头节点，重新遍历 cur = head; while(cur != nullptr)&#123; if(cur-&gt;random != nullptr)&#123; cur-&gt;next-&gt;random = cur-&gt;random-&gt;next; &#125; cur = cur-&gt;next-&gt;next; &#125; //3,拆分两链表 cur=head-&gt;next; Node* pre = head,*res = head-&gt;next; while(cur-&gt;next != nullptr)&#123; pre-&gt;next = pre-&gt;next-&gt;next; cur-&gt;next = cur-&gt;next-&gt;next; pre = pre-&gt;next; cur = cur-&gt;next; &#125; //单独处理原链表尾节点 pre-&gt;next = nullptr; return res; &#125;&#125;; 39. 数组中出现次数超过一半的数字数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 示例： 输入： [1,2,3,2,2,2,5,4,2] 输出： 2 思路： 方法一：哈希表统计法 时间空间复杂度为O(N) 12345678910111213class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; map&lt;int,int&gt;mp; for(auto num:nums)&#123; mp[num]++; if(mp[num] &gt; (nums.size()/2))&#123; return num; &#125; &#125; return 0; &#125;&#125;; 方法二：数组排序法 将数组排序，数组中点的元素一定为众数 1234567class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(),nums.end()); return nums[nums.size()/2]; &#125;&#125;; 方法三：摩尔投票法 投票法简单来说就是不同则抵消，占半数以上的数字必然留到最后。这句话是摩尔投票法的精髓 时间和空间复杂度为O(N)和O(1) 1234567891011121314class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; int x=0,votes=0,count=0; for(int num:nums)&#123; if(votes==0) x=num; votes += num == x ? 1:-1; &#125; //验收 for(int num:nums) if(num == x) count++; return count&gt;nums.size()/2 ? x:0; &#125;&#125;; 40. 最小的k个数输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。 示例： 输入：arr = [3,2,1], k = 2 输出：[1,2] 或者 [2,1] 输入：arr = [0,1,2,1],k = 1 输出：[0] ToK问题： 方法一：快排1234567891011class Solution &#123;public: vector&lt;int&gt; getLeastNumbers(vector&lt;int&gt;&amp; arr, int k) &#123; vector&lt;int&gt; vec(k,0); sort(arr.begin(),arr.end()); for(int i=0;i&lt;k;i++)&#123; vec[i]=arr[i]; &#125; return vec; &#125;&#125;; 不用api 快速排序原理： 快速排序算法有两个核心点，分别为 “哨兵划分” 和 “递归” 。 哨兵划分操作： 以数组某个元素（一般选取首元素）为 基准数 ，将所有小于基准数的元素移动至其左边，大于基准数的元素移动至其右边。 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;int&gt; getLeastNumbers(vector&lt;int&gt;&amp; arr, int k) &#123; quickSort(arr,0,arr.size()-1); vector&lt;int&gt;res; //assign()函数主要是将一个容器中元素全部复制到另一个容器中 res.assign(arr.begin(),arr.begin()+k); return res; &#125;private: void quickSort(vector&lt;int&gt;&amp; arr, int l, int r)&#123; //子数组长度为1时递归终止 if(l&gt;=r) return; //哨兵划分操作（以arr[1]作为基准） int i=l,j=r; while(i&lt;j)&#123; while(i&lt;j &amp;&amp; arr[j]&gt;=arr[l]) j--; while(i&lt;j &amp;&amp; arr[i]&lt;=arr[l]) i++; swap(arr[i],arr[j]); &#125; //使左边小于等于基准，右边大于等于基准 swap(arr[i],arr[l]); //递归左右子数组执行哨兵划分 quickSort(arr,l,i-1); quickSort(arr,i+1,r); &#125;&#125;; 方法二：基于快速排序的数组划分题目只要求返回最小的 k 个数，对这 k 个数的顺序并没有要求。因此，只需要将数组划分为 最小的 k 个数 和 其他数字 两部分即可，而快速排序的哨兵划分可完成此目标。 根据快速排序原理，如果某次哨兵划分后 基准数正好是第 k+1 小的数字 ，那么此时基准数左边的所有数字便是题目所求的 最小的 k 个数 。 根据此思路，考虑在每次哨兵划分后，判断基准数在数组中的索引是否等于k ，若 true 则直接返回此时数组的前k 个数字即可。 算法流程： getLeastNumbers() ​ 1，若k大于数组长度，则直接返回整个数组； ​ 2，执行并返回quick_sort() quick_sort() ​ 功能不是排序整个数组，而是搜索并返回最小的k个数 哨兵划分： ​ 划分完毕后，基准数为arr[i],左/右子数组区间分别为[l,i-1],[i+1,r]; 递归或返回： 若K&lt;i，代表第 k+1 小的数字在左子数组中，则递归左子数组； 若K&gt;i，代表第 k+1 小的数字在右子数组中，则递归右子数组； 若K=i，代表此时arr[k]即为第k+1小的数字，则直接返回数组前k个数字即可； 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; getLeastNumbers(vector&lt;int&gt;&amp; arr, int k) &#123; if(k&gt;=arr.size()) return arr; return quick_sort(arr,k,0,arr.size()-1); &#125;private: vector&lt;int&gt; quick_sort(vector&lt;int&gt;&amp; arr,int k,int l,int r)&#123; int i=l,j=r; while(i&lt;j)&#123; while(i&lt;j &amp;&amp; arr[j] &gt;= arr[l]) j--; while(i&lt;j &amp;&amp; arr[i] &lt;= arr[l]) i++; swap(arr[i],arr[j]); &#125; swap(arr[i],arr[l]); //递归左数组 if(i&gt;k) return quick_sort(arr,k,l,i-1); //递归右数组 if(i&lt;k) return quick_sort(arr,k,i+1,r); vector&lt;int&gt;res; res.assign(arr.begin(),arr.begin()+k); return res; &#125;&#125;; 方法三：堆我们用一个大根堆实时维护数组的前 k 小值。首先将前k个数插入大根堆中， 随后从第k+1 个数开始遍历，如果当前遍历到的数比大根堆的堆顶的数要小，就把堆顶的数弹出，再插入当前遍历到的数。 最后将大根堆里的数存入数组返回即可。在下面的代码中，由于 C++ 语言中的堆（即优先队列）为大根堆，我们可以这么做。 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;int&gt; getLeastNumbers(vector&lt;int&gt;&amp; arr, int k) &#123; vector&lt;int&gt; vec(k,0); if(k==0) return vec; priority_queue&lt;int&gt; Q; //把前k个数入堆 for(int i=0;i&lt;k;i++)&#123; Q.push(arr[i]); &#125; for(int i=k;i&lt;arr.size();i++)&#123; //把堆中大的元素出堆 if(Q.top()&gt;arr[i])&#123; Q.pop(); Q.push(arr[i]); &#125; &#125; //输出堆中的元素即最小k位 for(int i=0;i&lt;k;i++)&#123; vec[i]=Q.top(); Q.pop(); &#125; return vec; &#125;&#125;; 41. 数据流中的中位数如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。 例如， [2,3,4] 的中位数是 3 [2,3] 的中位数是 (2 + 3) / 2 = 2.5 设计一个支持以下两种操作的数据结构： void addNum(int num) - 从数据流中添加一个整数到数据结构中。double findMedian() - 返回目前所有元素的中位数。 示例： 输入： [“MedianFinder”,”addNum”,”addNum”,”findMedian”,”addNum”,”findMedian”] [[],[1],[2],[],[3],[]] 输出： [null,null,null,1.50000,null,2.00000] 方法：用大小堆小顶堆A保存较大的数 大顶堆B保存较小的数 A和B尽量保存一样的数量，中位数可以根据栈顶元素计算得出 算法流程： 设元素总数为N=m+n,m和n分别为A和B中的元素 addNum(num)函数 1，当m=n(即N为偶数时)：需向A添加一个元素。实现方法：将新元素num插入至B，再将B堆顶元素插入至A； 2，当m≠n(即N为奇数时)：需向B添加一个元素。实现方法：将新元素num插入至A，再将A堆顶元素插入至B； 这样始终保持A保存较大一半、B保存较小一半。 findMedian()函数 1，当m=n：中位数为(A的堆顶元素+B的堆顶元素)/2； 2，当m≠n(即N为奇数时)：则中位数为A的堆顶元素 1234567891011121314151617181920212223242526272829303132333435class MedianFinder &#123;public: // 最大堆，存储左边一半的数据，堆顶为最大值 priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt;&gt; maxHeap_B; // 最小堆， 存储右边一半的数据，堆顶为最小值 priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; minHeap_A; /** initialize your data structure here. */ MedianFinder() &#123; &#125; // 维持堆数据平衡，并保证左边堆的最大值小于或等于右边堆的最小值 void addNum(int num) &#123; //当m=n(即N为偶数时)：需向A添加一个元素。实现方法：将新元素num插入至B，再将B堆顶元素插入至A； if(maxHeap_B.size()==minHeap_A.size())&#123; maxHeap_B.push(num); int top=maxHeap_B.top(); maxHeap_B.pop(); minHeap_A.push(top); &#125;else&#123; minHeap_A.push(num); int top=minHeap_A.top(); minHeap_A.pop(); maxHeap_B.push(top); &#125; &#125; double findMedian() &#123; if(minHeap_A.size()==maxHeap_B.size())&#123; return (maxHeap_B.top()+minHeap_A.top())*1.0/2; &#125;else&#123; return minHeap_A.top()*1.0; &#125; &#125;&#125;; 44. 数字序列中某一位的数字数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。 请写一个函数，求任意第n位对应的数字。 示例： 输入：n = 3 输出：3 输入：n = 11 输出：0 思路： 数字范围 位数 数字数量 数位数量 1-9 1 9 9 10-99 2 90 180 100-999 3 900 2700 … … … … start - end digit 9*start 9start\digit 1，确定n所在数字的位数，记为digit; 2，确定n所在的数字，记为num; 3，确定n是num中的哪一数位，并返回结果; 123456789101112131415161718192021222324252627282930class Solution &#123;public: int findNthDigit(int n) &#123; //数位 int digit = 1; //当前数字范围的左区间 long start = 1; //数位数量 long count = 9; //定位目标数字所在的数字范围 while(n&gt;count)&#123; n -= count; digit += 1; start *= 10; count = 9*start*digit; &#125; //确定n所在的数字 long num = start + (n-1) / digit; //index最大取digit-1，即此时num坐标从左往右为0,1...digit-1,共digit位 int index = (n-1)%digit; while(index&lt;(digit-1))&#123; //最后的结果是num中的第index个数字 num/=10; digit--; &#125; //结果为num右侧末尾数字 return num%10; &#125;&#125;; 51. 数组中的逆序对在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。 示例： 输入：[7,5,6,4] 输出：5 思路：归并排序与逆序对是息息相关的归并排序体现了“分治思想” 算法流程： merge_sort()归并排序与逆序对统计： 1，终止条件： 当l&gt;=r时，代表子数组长度为1，此时终止划分； 2，递归划分： 计算数组中点m，递归划分左子数组merge_sort(1,m)和右子数组merge_sort(m+1,r); 3，合并与逆序对统计： ​ （1），暂存数组nums[i,r]内的元素至辅助数组tmp； ​ （2），循环合并：设置双指针i,j分别指向左/右子数组的首元素： 当i=m+1时：代表左子数组已合并完，因此添加右子数组当前元素tmp[j],并执行j=j+1; 否则，当j=r+1时：代表右子数组已合并完，因此添加左子数组当前元素 tmp[i],并执行i=i+1; 否则，当tmp[i]&lt;=tmp[j]时：添加左子数组当前元素tmp[i],并执行i=i+1; 否则(即tmp[i]&gt;tmp[j])时：添加右子数组当前元素tmp[j],并执行j=j+1;此时构成m-i+1个逆序对，统计添加至res; 4，返回值：res reversePairs()函数： 1，初始化：辅助数组tmp,用于合并阶段暂存元素； 2，返回值：执行归并排序，并返回逆序对总数； 时间复杂度：O(Nlog N) 空间复杂度：O(N) 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: int reversePairs(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt;tmp(nums.size()); return merge_sort(0,nums.size()-1,nums,tmp); &#125;private: int merge_sort(int l,int r,vector&lt;int&gt;&amp; nums,vector&lt;int&gt;&amp; tmp)&#123; //终止条件 if(l&gt;=r) return 0; //递归划分 int m = (l+r)/2; //分成两份后结果分别相加 int res = merge_sort(l,m,nums,tmp) + merge_sort(m+1,r,nums,tmp); //合并阶段 int i = l,j=m+1; //用一个数组保存合并之前的模样 for(int k=l;k&lt;=r;k++)&#123; tmp[k] = nums[k]; &#125; for(int k=l;k&lt;=r;k++)&#123; //m及其左边元素合并完，把右边剩下的放在合并后的数组 if(i==m+1) nums[k]=tmp[j++]; //m+1及其右边元素合并完毕，把左边剩下的放入合并后的数组 或者 左边数组的元素小于等于右边， //将左边数组的元素放入结果数组中，并让索引i+1 else if(j==r+1 || tmp[i]&lt;=tmp[j]) nums[k]=tmp[i++]; //右边数组的元素小于左边,将右边数组的元素其放入结果数组中,并让索引j加1 //并且此时左边数组中的从i到m的所有数都是大于tmp[j]的(因为m左右的数组都是已经排好序的，第15行代码的功劳) //即此时有m-i+1个逆序对，加到res上即可 else&#123; nums[k]=tmp[j++]; res += m-i+1; //统计逆序对 &#125; &#125; return res; &#125;&#125;; 53 - I. 在排序数组中查找数字 I统计一个数字在排序数组中出现的次数。 示例： 输入: nums = [5,7,7,8,8,10], target = 8输出: 2 思路：方法一：哈希表 12345678910class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; map&lt;int,int&gt; mp; for(int i=0;i&lt;nums.size();i++)&#123; mp[nums[i]]++; &#125; return mp[target]; &#125;&#125;; 方法二：二次二分 寻找左边界left和右边界right,数量为right-left-1 算法流程： 1，初始化：左边界i=0,右边界j=len-1 2，循环二分：当闭区间[i,j]无元素时跳出 计算m=(i+j)/2 若nums[m] &lt; target，则target在闭区间[m+1,j]中，执行i=m+1 若nums[m] &gt; target，则target在闭区间[i,m-1]中，执行j=m-1 若nums[m] = target，则右边界right在[m+1,j]中，左边界left在[i,m-1]中，因此分两种情况： 若查找right，则执行i=m+!;(跳出时i指向右边界) 若查找left，则执行j=m-1;(跳出时j指向左边界) 3，返回值：right-left-1 ==以上可以优化为都查找右边界== 查找target的右边界 查找target-1的右边界 时间复杂度O(logN) 空间复杂度O(1) 12345678910111213141516171819class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; return helper(nums,target) - helper(nums,target-1); &#125; int helper(vector&lt;int&gt;&amp; nums,int tar)&#123; int i=0,j=nums.size()-1; //这边是“小于等于”，因此当循环结束后，ij不重合，且如果存在target值的话， //i的位置就是右边界（target值序列右边第一个大于target值的位置），因为最后一次循环一定是i=mid+1； //且此时j指向target while(i&lt;=j)&#123; int m=(i+j)/1; //这里是“小于等于”，目的是为了确定右边界，就是说当mid等于target时，因为不确定后面还有没有target，所以同样需要左边收缩范围 if(nums[m] &lt;= tar) i = m + 1; else j = m - 1; &#125; return i; &#125;&#125;; 53 - II. 0～n-1中缺失的数字一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。 示例： 输入: [0,1,3]输出: 2 思路：方法一：数学或者直接判断 nums[i] 是否等于i 方法二：二分查找 方法三：二分查找 排序数组中的搜索问题，首先想到二分法 左子数组：nums[i]=i 右子数组：nums[i]!=i 算法流程： 1，初始化：左边界i=0,右边界j=len-1;代表区间[i,j] 2，循环二分：当i&lt;=j时循环 计算中点m=(i+j)/2 若nums[m]=m，则右子数组的首位元素一定在[m+1,j]中，执行i=m+1; 若nums[m]!=m，则左子数组的末位元素一定在[i,m-1]中，执行j=m-1 3，返回值：跳出时，i和j分别指向右子数组的首位元素和左子数组的末位元素，因此返回i即可 123456789101112class Solution &#123;public: int missingNumber(vector&lt;int&gt;&amp; nums) &#123; int i = 0, j = nums.size() - 1; while(i&lt;=j)&#123; int m = (i + j) / 2; if(nums[m] == m) i = m + 1; else j = m - 1; &#125; return i; &#125;&#125;; 57. 和为s的两个数字输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。 示例： 输入：nums = [2,7,11,15], target = 9输出：[2,7] 或者 [7,2] 思路：方法一：哈希表 复杂度为O(N) 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_set&lt;int,int&gt;mp; vector&lt;int&gt; res(2,-1); for(int i = 0; i &lt; nums.size(); i++)&#123; if(mp.count(target-nums[i]) &gt; 0)&#123; res[0] = target - nums[i]; res[1] = nums[i]; return res; &#125; mp.insert(nums[i]); &#125; return res; &#125;&#125;; 方法二：双指针 123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; int i = 0, j = nums.size() - 1; vector&lt;int&gt; res; while(i &lt; j)&#123; int sum = nums[i] + nums[j]; if(sum &lt; target) i++; else if(sum &gt; target) j--; else&#123; res.push_back(nums[i]); res.push_back(nums[j]); return res; &#125; &#125; return res; &#125;&#125;; 58 - II. 左旋转字符串字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。 示例: 输入: s = “abcdefg”, k = 2输出: “cdefgab” 思路：方法一：借用一个string 时间复杂度O(N) 空间复杂度O(N) 123456789101112131415class Solution &#123;public: string reverseLeftWords(string s, int n) &#123; int len = s.size(); string res; //res = s.substr(n,len-1)+s.substr(0,n); for(int i=n;i&lt;len;i++)&#123; res.push_back(s[i]); &#125; for(int i=0;i&lt;n;i++)&#123; res.push_back(s[i]); &#125; return res; &#125;&#125;; 方法二：三次翻转 时间复杂度O(N) 空间复杂度O(1) 三次翻转 例如： s = “abcdefg” k=2 第一次翻转：整体翻转 gfedcba reverse(s.begin(),s.end()); 第二次翻转：翻转len-n个 cdefgba reverse(s.begin(),s.end()-n); 第三次翻转：翻转最后n个 cdefgab reverse(s.end()-n,s.end()); 123456789101112class Solution &#123;public: string reverseLeftWords(string s, int n) &#123; //整体翻转 reverse(s.begin(),s.end()); //翻转len-n个 reverse(s.begin(),s.end()-n); //翻转最后n个 reverse(s.end()-n,s.end()); return s; &#125;&#125;;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C和C++面试秘籍]]></title>
    <url>%2F2022%2F02%2F23%2FC%E5%92%8CC%2B%2B%E9%9D%A2%E8%AF%95%E7%A7%98%E7%B1%8D%2F</url>
    <content type="text"><![CDATA[1. C和C++的区别是什么？1，C是面向过程的语言，C++是面向对象的编程语言。面向对象是一种对现实世界理解和抽象的方法。 2，C中函数不能进行重载，C++中函数可以重载。 3，C++在C的基础上增添类。 4，C中struct和C++的类(class)，除了默认访问权限外(struct的成员默认访问修饰符是public,而class默认的是private;)，别的功能几乎相同。 5，C和C++动态管理管理内存的方法不同，C是使用malloc/free函数，而C++除此之外还有new/delete关键字。 6，C++中有引用而C没有。 2. 关键字static、const、extern作用static关键字的作用： 1）隐藏，当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。 ​ 2）保持变量内容的持久。 ​ 3）默认初始化为0 ​ 4）C++中的类成员声明static const关键字的作用：（1）阻止一个变量被改变（2）声明常量指针和指针常量（3）const修饰形参，表明该输入参数在函数内部不能改变其值（4）对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量(const成员一般在成员初始化列表处初始化)（5）对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为”左值”。extern关键字的作用：（1）extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。（2）extern “C”的作用是让 C++ 编译器将extern “C”声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接。 3. 内存有哪几种类型及分配方式类型： ​ 1，栈区(stack)：如局部变量，函数参数 ​ 2，堆区(heap)：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统回收。 ​ 3，全局/静态区：如全局变量、static变量 ​ 4，常量存储区：存放常量字符串 ​ 5，程序代码区：存放函数体的二进制代码 ​ 6，c++中还有所谓的自由存储区(new) 分配方式： ​ 1，从静态存储区域分配 ​ 2，在栈上分配 ​ 3，在堆上分配，也被称为动态内存分配 4. 堆和栈的区别？1)堆存放动态分配的对象——即那些在程序运行时动态分配的对象，比如 new 出来的对象，其生存期由程序控制； 2)栈用来保存定义在函数内的非static对象，如局部变量，仅在其定义的程序块运行时才存在； 3)静态内存用来保存static对象，类static数据成员以及定义在任何函数外部的变量，static对象在使用之前分配，程序结束时销毁； 4)栈和静态内存的对象由编译器自动创建和销毁。 5. 什么是内存泄漏？面对内存泄漏和指针越界，你有哪些方法？你通常采用哪些方法来避免和减少这类错误？用动态存储分配函数动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元即为内存泄露。 方法： 1). 使用的时候要记得指针的长度. 2). malloc的时候得确定在那里free. 3). 对指针赋值的时候应该注意被赋值指针需要不需要释放. 4). 动态分配内存的指针最好不要再次赋值. 5). 在C++中应该优先考虑使用智能指针. 6. 引用和指针的区别？1) 指针是一个实体，需要分配内存空间。引用只是变量的别名，不需要分配内存空间。 2) 引用在定义时必须初始化，并且不能够改变。（引用的值不能为NULL）指针在定义时不一定需要初始化，并且指向的空间可变。 3) 有多级指针，但是没有多级引用，只能有一级引用。 4) 指针和引用的自增运算结果不同。（指针是指向下一个空间，引用是引用的变量加1） 5) sizeof引用得到的是所指向的变量的大小，sizeof指针得到的是指针的大小。 6) 引用访问一个变量是直接访问，而指针访问是间接访问。 7) 作为参数时也不一样，传指针本质上是传值，传递的值是指针的地址；传引用本质是传地址，传递的是变量的地址。 7. 面向对象的三大特性1) 抽象 2) 继承 3) 多态 8. 形参和实参的区别？1）形参变量只有在被调用时才分配内存单元，在调用结束时， 即刻释放所分配的内存单元。 2）实参可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值， 以便把这些值传送给形参。 3）函数调用中发生的数据传送是单向的。只能把实参的值传送给形参，而不能把形参的值反向地传送给实参。]]></content>
      <categories>
        <category>C++</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组和字符串]]></title>
    <url>%2F2022%2F02%2F22%2F%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[堆和栈的区别1.1 知识要点1.1.1数组在栈上创建： 1int array[M][N]; 在堆上创建： 1int **array = new int*[M]; \\或者(int**) malloc (M * sizeof(int*)) 数组可以通过下标随机访问元素，所以在修改、读取某个元素的时候效率很高，具有O(1)的时间复杂度。在插入、删除的时候为O(n)。 1.1.2 哈希表哈希表(Hash Table)主要基于“键(key)“的查找，存储的基本元素是键-值对。 哈希表的本质是当使用者提供一个键，根据哈希表自身定义的哈 希函数（Hash Function），映射出一个下标，根据这个下标决定需要 把当前的元素存储在什么位置。在一些合理的假设情况下，查找一个 元素的平均时间复杂度是 O(1)，插入一个元素的平摊（amortized） 时间复杂度是 O(1)。 当对于不同的键，哈希函数提供相同的存储地址时，哈希表就遇 到了所谓的冲突（collision）。解决冲突的方式有链接法（chaining） 和开放地址法（Open Addressing）两种。简单来说，链接法相当于 利用辅助数据结构（比如链表），将哈希函数映射出相同地址的那些 元素链接起来。而开放地址法是指以某种持续的哈希方式继续哈希， 直到产生的下标对应尚未被使用的存储地址，然后把当前元素存储在 这个地址里。 链接法实现相对简便，但是可能需要附加空间，并且利用 当前空间的效率不如开放地址法高。开放地址法更需要合理设计的连 续哈希函数，但是可以获得更好的空间使用效率。 C++标准库中提供 map 容器，可以插入、删除、查找键-值对，底 层以平衡二叉搜索树的方式实现，根据键进行了排序。严格来说，map 并不是一个哈希表，原因是查找时间从 O(1)变为了 O(log n)，但是 好处在于能够根据键值，顺序地输出元素，对于某些应用场景可能更 为合适。在 C++11 中，标准库添加了 unordered_map，更符合哈希表 的传统定义，平均查找时间 O(1)。 1.1.3 String在 C 语言中，字符串指的是一个以‘\0’结尾的 char 数组。关 于字符串的函数通常需要传入一个字符型指针。然而，在 C++ 中， String 是一个类，并且可以通过调用类函数实现判断字符串长度等 等操作。 2.1 模式识别2.1.1 使用哈希表当遇到某些题目需要统计元素集中一个元素出现的次数，应该直觉反应使用哈希表，即使用 std::unordered_map 或 std::map：键是 元素，值是出现的次数。特别地，有一些题目仅仅需要判断元素出现 与否（相当于判断值是 0 还是 1），可以用 bitvector，即 bitset，利 用一个 bit 来表示当前的下标是否有值。 ​ 例题1： 判断一个字符串所有的字符是否都是唯一的 如果运用哈希表，我们可 以直接用字符作为键，出现的次数作为值。 如果运用 bitset，我们需要建立字符到整数下标的映射关系。 复杂度分析：哈希表和 bitset 做法都需要扫描整个字符串，每次插入操作时间复杂度 O(1)，假设字符串长度为 n，则平均时间复杂 度都是 O(n)。空间上，每个合法字符都有可能出现，假设字符集大小 为 m，则平均空间是 O(m)。哈希表的数据结构需要占用更多空间，所以 bitset 是更合理的数据结构。 参考答案： 法一: 用hashmap 1234567891011121314151617class Solution &#123;public: bool isUnique(string astr) &#123; //判断位数 if(astr.size() &lt;= 1)&#123; return true; &#125; unordered_map&lt;char,int&gt;mp; for(const char c:astr)&#123; if(mp.count(c))&#123; return false; &#125; mp[c] = 1; &#125; return true; &#125;&#125;; 法二：先排序，看看是否存在相邻的两个字符相同的情况 12345678910111213141516171819class Solution &#123;public: bool isUnique(string astr) &#123; //判断位数 if(astr.size() &lt;= 1)&#123; return true; &#125; sort(astr.begin(),astr.end()); int i = 0, j = 1; while(j != astr.size())&#123; if(astr[i] == astr[j])&#123; return false; &#125; ++i; ++j; &#125; return true; &#125;&#125;; 法三：位运算： 1、假如字符串不在[‘a’-‘z’]之间 2、设置一个26位的二进制数，将其中某一位置为1表示对应的char字符，0000…0001（26位）表示a，用dist表示当前字符在二进制数中的位置。 3、用now_post记录26个位置中有多少个位置已经出现1 123456789101112131415class Solution &#123;public: bool isUnique(string astr) &#123; int dist = 0; int now_pos = 0; for(const char c:astr)&#123; dist = c -'a'; //得到所在的位置 if(now_pos &amp; 1 &lt;&lt; dist) &#123; //如果这个位置已经出现过1，即表示该字符已经出现过 return false; &#125; now_pos |= (1&lt;&lt;dist); //更新存在1的位置 &#125; return true; &#125;&#125;; 例题2: 给定两个字符串，判断它们是否互为字符重排 解题分析： ​ 我们需要找到两个字符串之间的共同点，即通过某种映射，使得所有置换得到相同的结果。考虑到置换的特性：无论如何变化，每个字符出现的次数一定相同。一旦需要统计 一个元素集中元素出现的次数，我们就应该想到哈希表。 复杂度分析： ​ 哈希表需要扫描整个字符串，每次插入操作时间复 杂度 O(1)，假设字符串的长度为 n，则平均时间复杂度都是 O(n)。最 后比较两个 hash 是否相同，每个合法字符都有可能出现，假设字符 集大小为 m，则需要的时间复杂度是 O(m)，故总的时间复杂度 O(m+n)。 空间上，平均空间是 O(m)。 参考答案： 1234567891011121314151617181920212223242526class Solution &#123;public: bool CheckPermutation(string s1, string s2) &#123; // 若 s1, s2 长度不同，则不互为重排 if (s1.length() != s2.length()) return false; // 初始化哈希表 dic unordered_map&lt;char, int&gt; dic; // 统计字符串 s1 各字符数量，遇到 +1 for (char c : s1) &#123; dic[c] += 1; &#125; // 统计字符串 s2 各字符数量，遇到 -1 for (char c : s2) &#123; dic[c] -= 1; &#125; // 遍历 s1, s2 中各字符的数量差 for (auto kv : dic) &#123; // 若 s1, s2 中某字符的数量不一致，则不互为重排 if (kv.second != 0) return false; &#125; // 所有字符数量都一致，因此互为重排 return true; &#125;&#125;; 2.1.2 利用哈希表实现动态规划的思想当处理当前节点需要依赖于之前的部分结果时，可以考虑使用哈希表记录之前的处理结果。 其本质类似于动态规划（ Dynamic Programming），利用哈希表以 O(1)的时间复杂度利用之前的结果。 例4: 输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可 解题分析：]]></content>
      <categories>
        <category>程序员面试白皮书</category>
        <category>数组</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NumPy入门]]></title>
    <url>%2F2022%2F01%2F20%2FNumPy%2F</url>
    <content type="text"><![CDATA[什么是NumPy?NumPy是python中科学计算的基础包。提供多维数组对象，各种派生对象（如掩码数组和矩阵），以及用于数组快速操作的各种API，有包括数学、逻辑、形状操作、排序、选择、输入输出、离散傅立叶变换、基本线性代数，基本统计运算和随机模拟等等。 NumPy数组 和 原生Python Array（数组）之间有几个重要的区别： NumPy 数组在创建时具有固定的大小，与Python的原生数组对象（可以动态增长）不同。更改ndarray的大小将创建一个新数组并删除原来的数组。 NumPy 数组中的元素都需要具有相同的数据类型，因此在内存中的大小相同。 例外情况：Python的原生数组里包含了NumPy的对象的时候，这种情况下就允许不同大小元素的数组。 NumPy 数组有助于对大量数据进行高级数学和其他类型的操作。通常，这些操作的执行效率更高，比使用Python原生数组的代码更少。 越来越多的基于Python的科学和数学软件包使用NumPy数组; 虽然这些工具通常都支持Python的原生数组作为参数，但它们在处理之前会还是会将输入的数组转换为NumPy的数组，而且也通常输出为NumPy数组。换句话说，为了高效地使用当今科学/数学基于Python的工具（大部分的科学计算工具），你只知道如何使用Python的原生数组类型是不够的 - 还需要知道如何使用 NumPy 数组。 快速入门教程NumPy官网 NumPy中文网站 # 导入包 import numpy as np 1.基础知识NumPy的数组类被调用为ndarray：一个同质多维数组（同质指所有元素类型相同） 12import numpy as npa = np.arange(15).reshape(3,5) #生成一个3*5的矩阵 ndarray.ndim数组的轴（维度）的个数 ndarray.shape数组的维度 ndarray.size数组元素的总数 ndarray.dtype一个描述数组中元素类型的对象 ndarray.itemsize数组中每个元素的字节大小 ndarray.data该缓冲区包含数组的实际元素。通常，我们不需要使用此元素，因为我们将使用索引访问数组中的元素。 1.1 数组创建方法一：通过Python的list或tuple创建ndarray123456#具体做法就是传入一个list或tuple作为参数a = np.array([1,2,3,4])#一种典型的错误情况：a = np.array(1,2,3,4)#如果传入又多个参数b = np.array([(1,5,2,3),(4,5,6)]) 方法二：用占位符创建已知尺寸的数组1234567891011d = np.zeros((3,4))e = np.ones((2,3,4),dtype=np.int16)f = np.empty((2,3)) #其初始内容是随机的，取决于内存的状态，默认情况下dtype是float64类型#arrange类似于python内置的rangeg = np.arange(10,30,5)h = np.arange(0,2,0.3) #可以使用浮点数,步长为0.3#arrange函数由于浮点数精度的原因，可能无法知道数组最后有多少个数#为了解决这一问题可以使用linspace函数i = np.linspace(0,2,9) #9个数组从0到2 1.2 打印数组如果数组太大而无法打印，NumPy会自动跳过数组的中心部分并打印角点，要禁用此行为并强制NumPy打印整个数组，可以使用打印选项set_printoptions 1np.set_printoptions(threshold=sys.maxsize) 1.3 基本数学操作加减这里就不需要演示了，乘积运算符*在NumPy数组中按元素进行运算。矩阵乘积可以使用@运算符或dot函数或方法执行: 12345678910A = np.array([[1,1],[0,1]])B = np.array([[2,0],[3,4]])A*B#结果为array([[2,0],[0,4]])A@B#结果为array([[5,4],[3,4]])A.dot(B)array([[5,4],[3,4]]) +=,*=等运算符进行原地运算（需要加同类型的，如果不强制转换就会报错） 默认情况下，这些操作适用于数组，就像它是一个数字列表一样，无论其形状如何。但是，通过指定axis 参数，您可以沿数组的指定轴应用操作： 12345678910111213141516&gt;&gt;&gt; b = np.arange(12).reshape(3,4)&gt;&gt;&gt; barray([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]])&gt;&gt;&gt;&gt;&gt;&gt; b.sum(axis=0) # sum of each columnarray([12, 15, 18, 21])&gt;&gt;&gt;&gt;&gt;&gt; b.min(axis=1) # min of each rowarray([0, 4, 8])&gt;&gt;&gt;&gt;&gt;&gt; b.cumsum(axis=1) # cumulative sum along each rowarray([[ 0, 1, 3, 6], [ 4, 9, 15, 22], [ 8, 17, 27, 38]]) 1.4 索引，切片和迭代12345678910111213141516171819202122232425&gt;&gt;&gt; a = np.arange(10)**3&gt;&gt;&gt; aarray([ 0, 1, 8, 27, 64, 125, 216, 343, 512, 729])&gt;&gt;&gt; a[2]8&gt;&gt;&gt; a[2:5]array([ 8, 27, 64])&gt;&gt;&gt; a[:6:2] = -1000 # equivalent to a[0:6:2] = -1000; from start to position 6, exclusive, set every 2nd element to -1000&gt;&gt;&gt; aarray([-1000, 1, -1000, 27, -1000, 125, 216, 343, 512, 729])&gt;&gt;&gt; a[ : :-1] # reversed aarray([ 729, 512, 343, 216, 125, -1000, 27, -1000, 1, -1000])&gt;&gt;&gt; for i in a:... print(i**(1/3.))...nan1.0nan3.0nan5.06.07.08.09.0 三个点（...）表示产生完整索引元组所需的冒号。例如x是rank为5的数组，则： x[1,2,...]相当于x[1,2,:,:,:] x[...,3]等效于x[:,:,:,:,3] x[4,...,5,:]等效于x[4,:,:,5,:] 对多维数组进行迭代（Iterating）是相对于第一个轴完成的： 12345678&gt;&gt;&gt; for row in b:... print(row)...[0 1 2 3][10 11 12 13][20 21 22 23][30 31 32 33][40 41 42 43] 但是，如果想要对数组中的每个元素执行操作，可以使用flat属性，该属性是数组的所有元素的迭代器： 1234567891011121314151617181920212223&gt;&gt;&gt; for element in b.flat:... print(element)...012310111213202122233031323340414243 2. 形状操纵2.1 改变数组的形状123456789101112131415161718&gt;&gt;&gt; a.ravel() # returns the array, flattenedarray([ 2., 8., 0., 6., 4., 5., 1., 1., 8., 9., 3., 6.])&gt;&gt;&gt; a.reshape(6,2) # returns the array with a modified shapearray([[ 2., 8.], [ 0., 6.], [ 4., 5.], [ 1., 1.], [ 8., 9.], [ 3., 6.]])&gt;&gt;&gt; a.T # returns the array, transposedarray([[ 2., 4., 8.], [ 8., 5., 9.], [ 0., 1., 3.], [ 6., 1., 6.]])&gt;&gt;&gt; a.T.shape(4, 3)&gt;&gt;&gt; a.shape(3, 4) reshape函数返回带有修改形状的参数，而该ndarray.resize方法会修改数组本身： 12345678&gt;&gt;&gt; aarray([[ 2., 8., 0., 6.], [ 4., 5., 1., 1.], [ 8., 9., 3., 6.]])&gt;&gt;&gt; a.resize((2,6))&gt;&gt;&gt; aarray([[ 2., 8., 0., 6., 4., 5.], [ 1., 1., 8., 9., 3., 6.]]) 如果在 reshape 操作中将 size 指定为-1，则会自动计算其他的 size 大小： 1234&gt;&gt;&gt; a.reshape(3,-1)array([[ 2., 8., 0., 6.], [ 4., 5., 1., 1.], [ 8., 9., 3., 6.]]) 2.2 将不同数组推叠在一起几个数组可以沿不同的轴堆叠在一起，例如： np.vstack相当于列拼接，np.hstack相当于行拼接 12345678910111213141516&gt;&gt;&gt; a = np.floor(10*np.random.random((2,2)))&gt;&gt;&gt; aarray([[ 8., 8.], [ 0., 0.]])&gt;&gt;&gt; b = np.floor(10*np.random.random((2,2)))&gt;&gt;&gt; barray([[ 1., 8.], [ 0., 4.]])&gt;&gt;&gt; np.vstack((a,b))array([[ 8., 8.], [ 0., 0.], [ 1., 8.], [ 0., 4.]])&gt;&gt;&gt; np.hstack((a,b))array([[ 8., 8., 1., 8.], [ 0., 0., 0., 4.]]) 2.3 将一个数组拆分成几个较小的数组使用hsplit，可以沿数组的水平轴拆分数组，方法是指定要返回的形状相等的数组的数量，或者指定应该在其之后进行分割的列： 1234567891011121314&gt;&gt;&gt; a = np.floor(10*np.random.random((2,12)))&gt;&gt;&gt; aarray([[ 9., 5., 6., 3., 6., 8., 0., 7., 9., 7., 2., 7.], [ 1., 4., 9., 2., 2., 1., 0., 6., 2., 2., 4., 0.]])&gt;&gt;&gt; np.hsplit(a,3) # Split a into 3[array([[ 9., 5., 6., 3.], [ 1., 4., 9., 2.]]), array([[ 6., 8., 0., 7.], [ 2., 1., 0., 6.]]), array([[ 9., 7., 2., 7.], [ 2., 2., 4., 0.]])]&gt;&gt;&gt; np.hsplit(a,(3,4)) # Split a after the third and the fourth column[array([[ 9., 5., 6.], [ 1., 4., 9.]]), array([[ 3.], [ 2.]]), array([[ 6., 8., 0., 7., 9., 7., 2., 7.], [ 2., 1., 0., 6., 2., 2., 4., 0.]])] vsplit沿垂直轴分割，并array_split允许指定要分割的轴。 3. 拷贝和视图3.1 完全不复制简单分配不会复制数组对象或其数据。 b=a 3.2 视图或浅拷贝不同的数组对象可以共享相同的数据。该view方法创建一个查看相同数据的新数组对象。 改变其数值，原来的数组数值也会发生改变。 12345678910111213141516&gt;&gt;&gt; c = a.view()&gt;&gt;&gt; c is aFalse&gt;&gt;&gt; c.base is a # c is a view of the data owned by aTrue&gt;&gt;&gt; c.flags.owndataFalse&gt;&gt;&gt;&gt;&gt;&gt; c.shape = 2,6 # a's shape doesn't change&gt;&gt;&gt; a.shape(3, 4)&gt;&gt;&gt; c[0,4] = 1234 # a's data changes&gt;&gt;&gt; aarray([[ 0, 1, 2, 3], [1234, 5, 6, 7], [ 8, 9, 10, 11]]) 切片数组会返回一个视图 3.3 深拷贝该copy方法生成数组及其数据的完整副本。 4. Less基础广播（Broadcasting）规则广播允许通用功能以有意义的方式处理不具有完全相同形状的输入。 广播的第一个规则是，如果所有输入数组不具有相同数量的维度，则将“1”重复地预先添加到较小数组的形状，直到所有数组具有相同数量的维度。 广播的第二个规则确保沿特定维度的大小为1的数组表现为具有沿该维度具有最大形状的数组的大小。假定数组元素的值沿着“广播”数组的那个维度是相同的。 应用广播规则后，所有数组的大小必须匹配。更多细节可以在广播中找到。 5. 花式索引和索引技巧使用索引数组进行索引12345678910&gt;&gt;&gt; a = np.arange(12)**2 # the first 12 square numbersarray([ 0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121])&gt;&gt;&gt; i = np.array( [ 1,1,3,8,5 ] ) # 显示a中的位置&gt;&gt;&gt; a[i] # the elements of a at the positions iarray([ 1, 1, 9, 64, 25])&gt;&gt;&gt;&gt;&gt;&gt; j = np.array( [ [ 3, 4], [ 9, 7 ] ] ) # a bidimensional array of indices&gt;&gt;&gt; a[j] # the same shape as jarray([[ 9, 16], [81, 49]]) 使用布尔数组进行索引我们可以明确地选择我们想要的数组中的哪些项目以及我们不需要的项目。 12345678&gt;&gt;&gt; a = np.arange(12).reshape(3,4)&gt;&gt;&gt; b = a &gt; 4&gt;&gt;&gt; b # b is a boolean with a's shapearray([[False, False, False, False], [False, True, True, True], [ True, True, True, True]])&gt;&gt;&gt; a[b] # 1d array with the selected elementsarray([ 5, 6, 7, 8, 9, 10, 11])]]></content>
      <categories>
        <category>机器学习</category>
        <category>NumPy</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>NumPy</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2021%2F01%2F06%2FLC%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[最长回文子串给定一个字符 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例1: 输入：“babad”输出：”bab”注意：”aba”也是一个有效答案。 示例2: 输入：”cbbd”：”bb” 方法一：暴力匹配（Brute Force） 根据回文子串的定义，枚举所有长度大于等于2的子串，依次判断它们是否是回文 在具体实现时，可以只针对大于“当前得到的最长回文子串长度”的子串进行“回文判断” 在记录最长回文子串时，只记录当前子串的起始位置和子串长度。 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;private: bool valid(string s,int left, int right)&#123; //验证子串s[left,right]是否为回文串 while(left &lt;= right)&#123; if(s[left] != s[right])&#123; return false; &#125; left++; right--; &#125; return true; &#125;public: string longestPalindrome(string s) &#123; //特判 int len = s.size(); if(len &lt; 2)&#123; return s; &#125; int maxLen = 1; string res = s.substr(0,1); //枚举所有长度大于等于2的子串 for(int i = 0; i &lt; len - 1; i++)&#123; for(int j = i + 1; j &lt; len; j++)&#123; if(j - i + 1 &gt; maxLen &amp;&amp; valid(s,i,j))&#123; maxLen = j - i + 1; res = s.substr(i,maxLen); &#125; &#125; &#125; return res; &#125;&#125;; 方法二：动态规划1，思考状态（重点） 状态的定义，先尝试（题目问什么，就把什么设置为状态）； 然后思考「状态如何转移」，如果「状态转移方程」不容易得到，尝试修改定义，目的依然是为了方便得到「状态转移方程」。 状态转移方程是原始问题的不同规模的子问题的联系。即大问题的最优解如何由小问题的最优解得到的。 2，思考状态转移方程（核心，难点） 常见的推到技巧是：分类讨论。即：对状态空间进行分类； 「动态规划」方法依然是「空间换时间」思想的体现，常见的解决问题的过程很像在「填表」。 3，思考初始化初始化是非常重要的，一步错，步步错。初始化状态一定要设置对，才可能得到正确的结果。 角度1: 直接从状态的语义出发。 角度2: 如果状态的语义不好思考，就考虑「状态转移方程」的边界需要什么样初始化的条件； 角度3: 从「状态转移方程」的下标看是否需要多设置一行，一列表示「哨兵」，这样可以避免一些特殊情况的讨论。 4，思考输出有些时候是最后一个状态，有些时候可能会综合之前所有计算过的状态。 5，思考优化空间（也可以叫表格复用） 经典的「优化空间」的典型问题是「0-1」背包问题和「完全背包」问题。 分析对于这道题来说，我们从回文串的定义展开讨论： 如果一个字符串的头尾两个字符不相等，那么这两个字符串一定不是回文串； 如果一个字符串的头尾两个字符相等，才有必要继续判断下去 ​ 1，如果里面的子串是回文，整体就是回文 ​ 2，如果里面的子串不是回文，整体就不是回文 综上： 在头尾字符相等的情况，里面的回文性质决定了整个子串的回文性质这就是状态转移。因此可以把「状态」定义为原字符串的一个子串是否是回文子串。 第1步：定义状态^dp[ i ][ j ]表示子串s[ i , j ]是否为回文子串，这里可以取到s[ i ]和s[ j ]。 第2步：思考状态转移方程根据我们前面的分析（头尾字符是否相等），可以得到： dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1] 这里需要注意： 「动态规划」事实上是在填一张二维表格，由于构成子串，因此 i 和 j 的关系 是i < = j ，因此，只需要填这张表格对角线以上的部分。 看到 dp[i + 1, j - 1\] 就得考虑边界情况。 边界条件是：表达式 [i + 1, j - 1\] 不构成区间，即长度严格小于 2，即 j - 1 - (i + 1) + 1 < 2 ，整理得 j - i < 3。 这个结论很显然：j - i &lt; 3 等价于 j - i + 1 &lt; 4，即当子串 s[i..j] 的长度等于 2 或者等于 3 的时候，其实只需要判断一下头尾两个字符是否相等就可以直接下结论了。 如果子串 s[i + 1..j - 1] 只有 1 个字符，即去掉两头，剩下中间部分只有 1个字符，显然是回文； 如果子串 s[i + 1..j - 1] 为空串，那么子串 s[i, j] 一定是回文子串。 因此，在 s[i] == s[j] 成立和 j - i &lt; 3 的前提下，直接可以下结论，dp[ i ][ j ] = true，否则才执行状态转移。 第3步：考虑初始化 初始化的时候，单个字符一定是回文串，因此把对角线先初始化为 true，即 dp[i][i] = true 。 事实上，初始化的部分都可以省去。因为只有一个字符的时候一定是回文，dp[ i ][ i ] 根本不会被其它状态值所参考。 第4步：考虑输出只要一得到 dp[ i ] [ j ] = true，就记录子串的长度和起始位置，没有必要截取，这是因为截取字符串也要消耗性能，记录此时的回文子串的「起始位置」和「回文长度」即可。 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: string longestPalindrome(string s) &#123; //特判 int len = s.size(); if(len &lt; 2)&#123; return s; &#125; int maxLen = 1; int begin = 0; //dp[i][j]表示s[i,j]是否是回文串 vector&lt;vector&lt;bool&gt;&gt; dp(len,vector&lt;bool&gt;(len)); for(int j = 1; j &lt; len; j++)&#123; for(int i = 0; i &lt; j; i++)&#123; if(s[i] != s[j])&#123; dp[i][j] = false; continue; &#125;else if(j - i &lt; 3)&#123; dp[i][j] = true; &#125;else&#123; dp[i][j] = dp[i + 1][j - 1]; &#125; if(dp[i][j] &amp;&amp; (j - i + 1 &gt; maxLen))&#123; maxLen = j - i + 1; begin = i; &#125; &#125; &#125; return s.substr(begin,maxLen); &#125;&#125;; 方法三：中心扩散法暴力法采用双指针，验证是否是回文串。 除了枚举字符串的左右边界以外，比较容易想到的是枚举可能出现的回文子串的“中心位置”，从中心位置尝试尽可能扩散出去，得到一个回文串。 思路：遍历每一个索引，以这个索引为中心，利用“回文串”中心对称的特点，往两边扩散，看最多能扩散多远。 枚举“中心位置”时间复杂度为O(N)，从“中心位置”扩散得到“回文子串”的时间复杂度为O(N)，因此时间复杂度可以降到O(N^2)。 注意：在这里注意一个细节：回文串在长度为奇数和偶数的时候，“回文中心”的形式是不一样的。 奇数回文串的“中心”是一个具体的字符，例如：回文串 aba 的中心是字符 b； 偶数回文串的”中心”是位于中间的两个字符的“空隙”，例如：回文串 abba的中心是两个 b中间的那个“空隙”。 我们可以设计一个方法，兼容以上两种情况： 1、如果传入重合的索引编码，进行中心扩散，此时得到的回文子串的长度是奇数； 2、如果传入相邻的索引编码，进行中心扩散，此时得到的回文子串的长度是偶数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;private: string centerSpread(string s, int left, int right) &#123; // left = right 的时候，此时回文中心是一个空隙，向两边扩散得到的回文子串的长度是奇数 // right = left + 1 的时候，此时回文中心是一个字符，向两边扩散得到的回文子串的长度是偶数 int size = s.size(); int i = left; int j = right; while (i &gt;= 0 &amp;&amp; j &lt; size) &#123; if (s[i] == s[j]) &#123; i--; j++; &#125; else &#123; break; &#125; &#125; // 这里要小心，跳出 while 循环时，恰好满足 s.charAt(i) != s.charAt(j)，因此不能取 i，不能取 j return s.substr(i + 1, j - i - 1); &#125;public: string longestPalindrome(string s) &#123; // 特判 int size = s.size(); if (size &lt; 2) &#123; return s; &#125; int maxLen = 1; string res = s.substr(0, 1); // 中心位置枚举到 len - 2 即可 for (int i = 0; i &lt; size - 1; i++) &#123; string oddStr = centerSpread(s, i, i); string evenStr = centerSpread(s, i, i + 1); string maxLenStr = oddStr.size() &gt; evenStr.size() ? oddStr : evenStr; if (maxLenStr.length() &gt; maxLen) &#123; maxLen = maxLenStr.size(); res = maxLenStr; &#125; &#125; return res; &#125;&#125;;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2021%2F01%2F06%2FJAVA%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[Mac JAVA连接数据库一，下载mysql1,直接百度下载即可 2，一路next 3，1.3. 启动MySQL:系统偏好设置 -&gt; MySQL-&gt;Start MySQL Server 4 ，点击Start MySQL Server就会变成running。 二，下载NavicatXclient下载链接 下载完成后，打开页面如下： 2.1点击左上角的connect，选择mysql2.2 输入密码即可，端口号一般为3306 三，下载MySQL驱动包官网链接 解压即可。 4，Eclipse访问MySQL数据库1，创建一个项目，并创建一个TestQuery.java类 2，右建hpuday08项目，找到Build Path，选择Add External Archives 3，选中我们下载好的MySQl驱动包即可. 4，在Eclipse中可以看到 就是导入成功了 测试结果： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package cn.edu.hpu.test1;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class TestQuery &#123; public static void main(String[] args) &#123; ResultSet rs = null; Statement st = null; Connection conn = null; try &#123; //1，加载驱动 Class.forName("com.mysql.cj.jdbc.Driver"); //2，获取连接对象 //连接URL为 jdbc:mysql//服务器地址/数据库名 ，后面的2个参数分别是登陆用户名和密码 conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/tkm", "root", "1261476297"); //3，使用连接对象生成一个报表对象用于执行sql语句 st = conn.createStatement(); //4，编写sql语句 //user 为你表的名称 String sql = "select * from user"; //5，使用Statement对象执行sql语句 rs = st.executeQuery(sql); //6，将结果从ResuluSet对象中取出来 while(rs.next()) &#123; System.out.println("用户编号" + rs.getInt("uid") + "\t用户名" + rs.getString("username") + "\t用户密码" + rs.getString("password") ); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; //关闭连接 try &#123; rs.close(); st.close(); conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2021%2F01%2F05%2FLC%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80%2F</url>
    <content type="text"><![CDATA[LC最长公共前缀编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &quot;&quot;。 示例1: 输入：[“flower”,”flow”,”flight”]输出：[fl] 示例2: 输入：[“dog”,”racecar”,”car”]输出：””解释：输入不存在公共前缀 说明：所有人输入只包含小写字母a-z。 思路1： 1，当字符串数组长度为0时，则公共前缀为空，直接返回2，令最长公共前缀ans的值为第一个字符串，进行初始化3，遍历后面的字符串，依次将其与res进行比较，两两找出公共前缀，最终结果即为 最长公共前缀4，如果查找过程中出现了res为空的情况，则公共前缀不存在，直接返回时间复杂度为O(s),s为所有字符串的长度之和 比如示例1； res = flower ​ flow res = flow ​ flight res = fl 1234567891011121314151617181920class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if(strs.size() == 0) return ""; string res = strs[0]; int minlen = res.size();//记录公共前缀 for(int i = 1; i &lt; strs.size(); i++)&#123; int j = 0; for(; j &lt; res.size() &amp;&amp; j &lt; strs[i].size(); j++)&#123; if(res[j] != strs[i][j]) break; &#125; if(j &lt;= minlen)&#123; res = string(res,0,j); minlen = j; &#125; if(res.empty()) return res; &#125; return res; &#125;&#125;; 思路2: 思路1:1，我们先对字符串排序比如abc ab abce排序完后为ab abc abce 2，比较头尾即可 复杂度为sort的复杂度 1234567891011class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if(strs.empty()) return string(); sort(strs.begin(), strs.end()); string st = strs.front(), end = strs.back(); int i, num = min(st.size(),end.size()); for(i = 0; i &lt; num &amp;&amp; st[i] == end[i]; i++); return string(st,0,i); &#125;&#125;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[LC寻找数组的中心索引]]></title>
    <url>%2F2020%2F12%2F30%2FLC%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[寻找数组的中心索引题目链接 给定一个整数类型的数组 nums，请编写一个能够返回数组 “中心索引” 的方法。 我们是这样定义数组 中心索引 的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。 如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。 示例1: 输入：nums = [1,7,3,6,5,6] 输出：3解释： 索引 3 (nums[3] = 6) 的左侧数之和 (1 + 7 + 3 = 11)，与右侧数之和 (5 + 6 = 11) 相等。同时, 3 也是第一个符合要求的中心索引。 示例2: 输入：nums = [1,2,3] 输出：-1解释： 数组中不存在满足此条件的中心索引 说明： nums 的长度范围为【0，10000】。 任何一个nums[i]将会是一个范围在[-1000，1000]的整数。 思路 第一种思路是我们定义leftsum 和 rightsum,分别从两头加，直到leftsum == rightsum且它们之间还有一个元素。 第二种思路就是我们可以知道totalSum = leftsum + rightsum + mums[i] leftsum == rightsum 所以 2*leftsum = totalSum - nums[i] 123456789101112131415class Solution &#123;public: int pivotIndex(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() == 0) return -1; int sum = 0, leftsum = 0; for(int i=0;i&lt;nums.size();i++)&#123; sum += nums[i]; &#125; for (int i=0;i&lt;nums.size();i++)&#123; if(leftsum * 2 == sum - nums[i]) return i; else leftsum += nums[i]; &#125; return -1; &#125;&#125;; 总的代码如下：123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;/*思路：leftsum + rightsum + nums[i] = sumleftsum*2 = sum -nums[i]*/class Solution &#123;public: int pivotIndex(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() == 0) return -1; int sum = 0, leftsum = 0; for(int i=0;i&lt;nums.size();i++)&#123; sum += nums[i]; &#125; for (int i=0;i&lt;nums.size();i++)&#123; if(leftsum * 2 == sum - nums[i]) return i; else leftsum += nums[i]; &#125; return -1; &#125;&#125;;int main()&#123; int arr[6]=&#123;1,7,3,6,5,6&#125;; vector&lt;int&gt; nums(arr,*(arr +1)); Solution a; int b; b = a.pivotIndex(nums); cout &lt;&lt; b &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>数组</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装pymysql库和tkinter库]]></title>
    <url>%2F2020%2F01%2F02%2F%E5%AE%89%E8%A3%85pymysql%E5%BA%93%E5%92%8Ctkinter%E5%BA%93%2F</url>
    <content type="text"><![CDATA[pymysql是python3中用于连接mysql服务器的一个库 在cmd中输入：(如果你是pip3就用pip3,否则就有pip) pip3 install pymysql 如果需要加上权限 mac sudo pip3 install pymysql window pip3 install —user pymysql 下载这个全靠运气，服务器在国外，下载速度慢，经常超时错误，多试几次,直接方向键上键就可以。 在python的ide中调用 import pymysql 看下有没有安装成功 tkinter是python的一个图形设置库 安装方法也如上,具体使用方法请百度。]]></content>
      <tags>
        <tag>python</tag>
        <tag>pymysql</tag>
        <tag>tkinter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[p1141 01迷宫]]></title>
    <url>%2F2019%2F06%2F11%2Fp1141-01%E8%BF%B7%E5%AE%AB%2F</url>
    <content type="text"><![CDATA[题目链接 题目描述有一个仅由数字0与1组成的n×n格迷宫。若你位于一格0上，那么你可以移动到相邻44格中的某一格1上，同样若你位于一格1上，那么你可以移动到相邻44格中的某一格0上。 你的任务是：对于给定的迷宫，询问从某一格开始能移动到多少个格子（包含自身）。 输入输出格式输入格式： 第1行为两个正整数n,m。 下面n行，每行n个字符，字符只可能是0或者1，字符之间没有空格。 接下来m行，每行2个用空格分隔的正整数i,j，对应了迷宫中第i行第j列的一个格子，询问从这一格开始能移动到多少格。 输出格式： mm行，对于每个询问输出相应答案。 输入输出样例输入样例#1: 2 2 01 10 1 1 2 2 输出样例#1: 4 4 解题思路一开始我直接就dfs直接搜了，但是TLE了3个数据。 代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=1010;char a[maxn][maxn];int dir[][2]=&#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125;&#125;;int vis[maxn][maxn];int n,m;int ans;int max_ans;void dfs(int x,int y,char temp)&#123; vis[x][y]=1; if(x&lt;1||x&gt;n||y&lt;1||y&gt;n) return; else &#123; for(int i=0;i&lt;4;i++)&#123; int dx=x+dir[i][0]; int dy=y+dir[i][1]; if(dx&gt;0&amp;&amp;dx&lt;=n&amp;&amp;dy&gt;0&amp;&amp;dy&lt;=n&amp;&amp;vis[dx][dy]==0&amp;&amp;a[dx][dy]!=temp)&#123; if(vis[dx][dy]==0) ans++; vis[dx][dy]++; temp=a[dx][dy]; if(ans&gt;max_ans) max_ans=ans; dfs(dx,dy,temp); temp=a[x][y]; &#125; &#125; &#125;&#125;int main()&#123; int start,end; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) cin&gt;&gt;a[i][j]; while(m--)&#123; cin&gt;&gt;start&gt;&gt;end; memset(vis,0,sizeof(vis)); ans=1;max_ans=1; dfs(start,end,a[start][end]); cout&lt;&lt;max_ans&lt;&lt;endl; &#125; return 0;&#125; 听大佬说可以用并查集可以直接写，但是不会（无奈） 想了许久，发现如果每次查询一个就重新查会TLE,那么是不是只要我们查过了的我们就标志下，下次就不用再查了. 12345678910111213141516171819202122232425262728293031323334#include &lt;bit/stdc++.h&gt;using namespace std;const int maxn=1000010;int x,y,f[1010][1010];int n,m,ans[maxn];char s[1010][1010];void dfs(int r,int c,int z,int l)&#123; if(r&lt;0||r&gt;=n||c&lt;0||c&gt;=n||f[r][c]!=-1||s[r][c]-'0'!=z) return; f[r][c]=l;ans[l]++;//记录个数 dfs(r-1,c,!z,l); dfs(r+1,c,!z,l); dfs(r,c-1,!z,l); dfs(r,c+1,!z,l);&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) cin&gt;&gt;s[i][j]; memset(f,-1,sizeof(f)); for(int i=0;i&lt;m;i++)&#123; cin&gt;&gt;x&gt;&gt;y; x--;y--; if(f[x][y]==-1) dfs(x,y,s[x][y]-'0',i); else ans[i]=ans[f[x][y]];//已经找过了 &#125; for(int i=0;i&lt;m;i++) cout&lt;&lt;ans[i]&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>dfs</category>
      </categories>
      <tags>
        <tag>dfs(优化)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进阶词云]]></title>
    <url>%2F2019%2F06%2F09%2F%E8%BF%9B%E9%98%B6%E8%AF%8D%E4%BA%91%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849登陆微信获取好友个性签名生成词云import itchatimport jiebaimport imageioimport wordcloudimport matplotlib.pyplot as plt# 登陆微信itchat.login()tList=[]# 获取好友列表friends=itchat.get_friends(update=True)#构建所有好友个性签名组成的大列表tListfor i in friends: signature=i["Signature"] if 'emoji' in signature: pass else: tList.append(signature)text=" ".join(tList)# 对个性签名进行中文分词wordlist_jieba=jieba.lcut(text,cut_all=True)wl_space_split=" ".join(wordlist_jieba)# 读取个性图片mk=imageio.imread("/Users/SJCHEN/Downloads/zihaowordcloud-master/code/chinamap.png")# 构建词云对象my_wordcloud=wordcloud.WordCloud(background_color='white', width=1000, height=700, font_path='Songti.ttc', max_words=2000, mask=mk, scale=20)my_wordcloud.generate(wl_space_split)nickname=friends[0]['NickName']filename="example12-&#123;&#125;的微信好友个性签名词云图.png".format(nickname)# 显示词云图plt.imshow(my_wordcloud)plt.axis("off")plt.show()print('程序结束')]]></content>
      <categories>
        <category>python</category>
        <category>词云</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>词云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级词云：绘制指定形状]]></title>
    <url>%2F2019%2F06%2F09%2F%E9%AB%98%E7%BA%A7%E8%AF%8D%E4%BA%91%EF%BC%9A%E7%BB%98%E5%88%B6%E6%8C%87%E5%AE%9A%E5%BD%A2%E7%8A%B6%2F</url>
    <content type="text"><![CDATA[1234first: 通过以下代码读入外部词云形状图片（需要先pip3 install imageio安装imageio）import imageiomk=imageio.imread(&quot;picture.png&quot;)w=wordcloud.WordCloud(mask=mk) 例子123456789101112131415161718192021import jiebaimport wordcloudimport imageiomk=imageio.imread("/Users/SJCHEN/Downloads/zihaowordcloud-master/code/wujiaoxing.png")w=wordcloud.WordCloud(mask=mk)# 构建并配置词云对象w，注意要加scale参数，提高清晰度w=wordcloud.WordCloud(width=1000, height=700, background_color='white', font_path='Songti.ttc', mask=mk, scale=15)f=open('/Users/SJCHEN/Downloads/zihaowordcloud-master/code/关于实施乡村振兴战略的意见.txt',encoding='utf-8')txt=f.read()textlist=jieba.lcut(txt)string=" ".join(textlist)w.generate(string)w.to_file('example7.png') 去除指定词（stopwords参数去除词）123456789101112131415161718192021import jiebaimport wordcloudimport imageiomk=imageio.imread("/Users/SJCHEN/Downloads/zihaowordcloud-master/code/chinamap.png")w=wordcloud.WordCloud(mask=mk)w=wordcloud.WordCloud(width=1000, height=700, background_color='white', font_path='Songti.ttc', mask=mk, scale=15, stopwords=&#123;'曹操','孔明'&#125;)f=open('/Users/SJCHEN/Downloads/zihaowordcloud-master/code/三国演义.txt',encoding='utf-8')txt=f.read()textlist=jieba.lcut(txt)string=" ".join(textlist)w.generate(string)w.to_file('example10.png') 利用原来的方法我们得到 去掉指定的词后 勾勒轮廓线1234567891011121314import wordcloudimport imageiomk=imageio.imread("/Users/SJCHEN/Downloads/zihaowordcloud-master/code/alice.png")# 构建词云对象w，注意增加参数contour_width和contour_color设置轮廓宽度和颜色w=wordcloud.WordCloud(background_color='white', mask=mk, contour_width=1, contour_color='steelblue')# 将外部文件包含的文本保存在string变量中string =open('/Users/SJCHEN/Downloads/zihaowordcloud-master/code/hamlet.txt').read()w.generate(string)w.to_file('example11.png') 按模版填色1234567891011121314151617181920212223242526272829303132333435import matplotlib.pyplot as pltfrom wordcloud import WordCloud,ImageColorGeneratorimport imageio# 将外部文件包含的文本保存在text变量中text = open('/Users/SJCHEN/Downloads/zihaowordcloud-master/code/alice.txt',encoding='utf-8').read()# 导入imageio库中的imread函数，并用这个函数读取本地图片queen2.jfif，作为词云形状图片mk = imageio.imread("/Users/SJCHEN/Downloads/zihaowordcloud-master/code/alice_color.png")# 构建词云对象wwc = WordCloud(background_color="white", mask=mk,)# 将text字符串变量传入w的generate()方法，给词云输入文字wc.generate(text)# 调用wordcloud库中的ImageColorGenerator()函数，提取模板图片各部分的颜色image_colors = ImageColorGenerator(mk)# 显示原生词云图、按模板图片颜色的词云图和模板图片，按左、中、右显示fig, axes = plt.subplots(1, 3)# 最左边的图片显示原生词云图axes[0].imshow(wc)# 中间的图片显示按模板图片颜色生成的词云图，采用双线性插值的方法显示颜色axes[1].imshow(wc.recolor(color_func=image_colors), interpolation="bilinear")# 右边的图片显示模板图片axes[2].imshow(mk, cmap=plt.cm.gray)for ax in axes: ax.set_axis_off()plt.show()# 给词云对象按模板图片的颜色重新上色wc_color = wc.recolor(color_func=image_colors)# 将词云图片导出到当前文件夹wc_color.to_file('example11.png') 如果只是简单的用的话 1234567891011from wordcloud import WordCloud,ImageColorGeneratorimport imageiotext = open('/Users/SJCHEN/Downloads/zihaowordcloud-master/code/alice.txt',encoding='utf-8').read()mk=imageio.imread("/Users/SJCHEN/Downloads/zihaowordcloud-master/code/alice_color.png")w=WordCloud(background_color='white', mask=mk,)w.generate(text)image_colors=ImageColorGenerator(mk)w_color=w.recolor(color_func=image_colors)w_color.to_file('exam.png')]]></content>
      <categories>
        <category>python</category>
        <category>词云</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>词云</tag>
        <tag>jieba</tag>
        <tag>imageio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“中文分词jieba”]]></title>
    <url>%2F2019%2F06%2F09%2F%E2%80%9C%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8Djieba%E2%80%9D%2F</url>
    <content type="text"><![CDATA[first：安装中文分词库, 在命令行中输入 pip3 install jieba 123456&gt;&gt;&gt; import jieba&gt;&gt;&gt; textlist=jieba.lcut('动力学和电磁学')['动力学','和','电磁学']&gt;&gt;&gt; string = " ".join(textlist)&gt;&gt;&gt; string‘动力学 和 电磁学’ 以上代码将一句完整的中文字符串转换成了以空格分隔的词组成的字符串，而后者是绘制词云时generate()方法要求传入的参数。 中文分词库jieba的常用方法精确模式（最常用，只会这个就行）：每个字只用一遍，不存在冗余词汇。jieba.lcut(‘动力学和电磁学’) 全模式：把每个字可能形成的词汇都提取出来，存在冗余。jieba.lcut(‘动力学和电磁学’,cut_all=True) 搜索引擎模式：将全模式分词的结果从短到长排列好。jieba.lcut_for_search(‘动力学和电磁学’) 以下命令演示了三种分词模式及结果，精确模式是最常用的。 12345678910&gt;&gt;&gt; import jieba&gt;&gt;&gt; textlist1 = jieba.lcut('动力学和电磁学')&gt;&gt;&gt; textlist1['动力学', '和', '电磁学']&gt;&gt;&gt; textlist2 = jieba.lcut('动力学和电磁学',cut_all=True)&gt;&gt;&gt; textlist2['动力', '动力学', '力学', '和', '电磁', '电磁学', '磁学']&gt;&gt;&gt; textlist3 = jieba.lcut_for_search('动力学和电磁学')&gt;&gt;&gt; textlist3['动力', '力学', '动力学', '和', '电磁', '磁学', '电磁学'] 学校介绍词云1234567891011121314151617import jiebaimport wordcloud#构建词云对象w=wordcloud.WordCloud(width=1000, height=700, background_color='white', font_path='Songti.ttc')#调用jieba的lcut()方法对原始文本进行中文分词，得到stringtxt='河南理工大学（Henan Polytechnic University）位于河南省焦作市，是中国第一所矿业高等学府、河南省建立最早的高等学校，为河南省与应急管理部共建高校、河南省属重点大学。'textlist=jieba.lcut(txt)string=" ".join(textlist)#将string变量传入到w的generate()方法，给词云输入文字w.generate(string)#将词云图片导出到当前文件夹w.to_file('example4.png') 读取文本1234567891011121314import jiebaimport wordcloudw=wordcloud.WordCloud(width=1000, height=700, background_color='white', font_path='Songti.ttc')f=open('/Users/SJCHEN/Downloads/zihaowordcloud-master/code/关于实施乡村振兴战略的意见.txt',encoding='utf-8')txt=f.read()textlist=jieba.lcut(txt)string=" ".join(textlist)w.generate(string)w.to_file('example5.png')]]></content>
      <categories>
        <category>python</category>
        <category>词云</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>词云</tag>
        <tag>jieba</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python实现词云]]></title>
    <url>%2F2019%2F06%2F08%2Fpython%E5%AE%9E%E7%8E%B0%E8%AF%8D%E4%BA%91%2F</url>
    <content type="text"><![CDATA[首先我们先配置下环境：打开命令行，输入以下命令，回车: pip3 install numpy matplotlib pillow wordcloud imageio jieba snownlp itchat -i https://pypi.tuna.tsinghua.edu.cn/simple 如果遇上权限问题的话:在前面加上sudo如果你遇到python pip更新问题:输入以下命令: sudo pip3 —upgrade pip 下面开始正式的词云学习: 1234567891011# 导入第三方库import wordcloud#创建词云对象w=wordcloud.WordCloud()#调用词云对象的generate方法，将文本传入w.generate('and that government of the people,by the people,for the people,shall not perish from the earth.')#将生成的词云保存到当前文件夹下w.to_file('example1.png') 效果如下： 这只是简单的制作，我们还可以美化它:我们可以在WordCloud()里面加入各种参数，控制词云的字体，字号，字色，背景颜色等等。wordcloud库会非常智能地按空格进行分词及词频统计，出现次数多的词就大。 美化词云注意字体 12345678910import wordcloud# 构建词云对象w，设置词云图片宽、高、字体、背景颜色等参数w = wordcloud.WordCloud(width=1000,height=700,background_color='white',font_path='Songti.ttc')# 调用词云对象的generate方法，将文本传入w.generate('从明天起，做一个幸福的人。喂马、劈柴，周游世界。从明天起，关心粮食和蔬菜。我有一所房子，面朝大海，春暖花开')# 将生成的词云保存为output2-poem.png图片文件，保存到当前文件夹中w.to_file('example2.png') 常用参数 width 词云图片宽度，默认400像素 height 词云图片高度 默认200像素 background_color 词云图片的背景颜色，默认为黑色 background_color=’white’ font_step 字号增大的步进间隔 默认1号 font_path 指定字体路径 默认None，对于中文可用font_path=’msyh.ttc’ mini_font_size 最小字号 默认4号 max_font_size 最大字号 根据高度自动调节 max_words 最大词数 默认200 stop_words 不显示的单词 stop_words={“python”,”java”} Scale 默认值1。值越大，图像密度越大越清晰 prefer_horizontal：默认值0.90，浮点数类型。表示在水平如果不合适，就旋转为垂直方向，水平放置的词数占0.9？ relative_scaling：默认值0.5，浮点型。设定按词频倒序排列，上一个词相对下一位词的大小倍数。有如下取值：“0”表示大小标准只参考频率排名，“1”如果词频是2倍，大小也是2倍 mask 指定词云形状图片，默认为矩形 通过以下代码读入外部词云形状图片（需要先pip install imageio安装imageio） 123456789101112131415w=wordcloud.WordCloud( width=400, height=200, background_color='black', font_path=None, font_step=1, min_font_size=4, max_font_size=None, max_words=200, stoppwords=&#123;&#125;, scale=1, prefer_horizontal=0.9, relative_scaling=0.5, mask=None) 从外部文件读入文本12345678910111213import wordcloud# 从外部.txt文件中读取大段文本，存入变量txt中f=open('/Users/SJCHEN/Downloads/zihaowordcloud-master/code/关于实施乡村振兴战略的意见.txt',encoding='utf-8')txt=f.read()w=wordcloud.WordCloud( width=1000, height=700, background_color='white', font_path='Songti.ttc')w.generate(txt)w.to_file('example3.png')]]></content>
      <categories>
        <category>python</category>
        <category>wordcloud</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac上sublime Text配置万能头文件]]></title>
    <url>%2F2019%2F05%2F04%2Fsublime-Text%E9%85%8D%E7%BD%AE%E4%B8%87%E8%83%BD%E5%A4%B4%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[首先我们要看下头文件所在位置，在访达中按组合键 shift + commond + G访问隐藏的文件，在弹出的框中输入/usr/local 然后找到include这个文件夹，查看它的属性（显示简介） 权限大概像我这样就可以了，没问题之后，进入include这个文件夹，并且在里面建立一个bits文件夹，在文件夹里建一个stdc++.h的头文件，stdc++.h内容如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116// C++ includes used for precompiling -*- C++ -*-// Copyright (C) 2003-2014 Free Software Foundation, Inc.//// This file is part of the GNU ISO C++ Library. This library is free// software; you can redistribute it and/or modify it under the// terms of the GNU General Public License as published by the// Free Software Foundation; either version 3, or (at your option)// any later version.// This library is distributed in the hope that it will be useful,// but WITHOUT ANY WARRANTY; without even the implied warranty of// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the// GNU General Public License for more details.// Under Section 7 of GPL version 3, you are granted additional// permissions described in the GCC Runtime Library Exception, version// 3.1, as published by the Free Software Foundation.// You should have received a copy of the GNU General Public License and// a copy of the GCC Runtime Library Exception along with this program;// see the files COPYING3 and COPYING.RUNTIME respectively. If not, see// &lt;http://www.gnu.org/licenses/&gt;./** @file stdc++.h * This is an implementation file for a precompiled header. */// 17.4.1.2 Headers// C#ifndef _GLIBCXX_NO_ASSERT#include &lt;cassert&gt;#endif#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;ciso646&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;cmath&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#if __cplusplus &gt;= 201103L#include &lt;ccomplex&gt;#include &lt;cfenv&gt;#include &lt;cinttypes&gt;#include &lt;cstdbool&gt;#include &lt;cstdint&gt;#include &lt;ctgmath&gt;#include &lt;cwchar&gt;#include &lt;cwctype&gt;#endif// C++#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;complex&gt;#include &lt;deque&gt;#include &lt;exception&gt;#include &lt;fstream&gt;#include &lt;functional&gt;#include &lt;iomanip&gt;#include &lt;ios&gt;#include &lt;iosfwd&gt;#include &lt;iostream&gt;#include &lt;istream&gt;#include &lt;iterator&gt;#include &lt;limits&gt;#include &lt;list&gt;#include &lt;locale&gt;#include &lt;map&gt;#include &lt;memory&gt;#include &lt;new&gt;#include &lt;numeric&gt;#include &lt;ostream&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;stack&gt;#include &lt;stdexcept&gt;#include &lt;streambuf&gt;#include &lt;string&gt;#include &lt;typeinfo&gt;#include &lt;utility&gt;#include &lt;valarray&gt;#include &lt;vector&gt;#if __cplusplus &gt;= 201103L#include &lt;array&gt;#include &lt;atomic&gt;#include &lt;chrono&gt;#include &lt;condition_variable&gt;#include &lt;forward_list&gt;#include &lt;future&gt;#include &lt;initializer_list&gt;#include &lt;mutex&gt;#include &lt;random&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;scoped_allocator&gt;#include &lt;system_error&gt;#include &lt;thread&gt;#include &lt;tuple&gt;#include &lt;typeindex&gt;#include &lt;type_traits&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#endif 这样我们就成功了。]]></content>
      <tags>
        <tag>bits/stdc++/.h</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[魔兽世界之一：备战]]></title>
    <url>%2F2019%2F04%2F26%2F%E9%AD%94%E5%85%BD%E4%B8%96%E7%95%8C%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%A4%87%E6%88%98%2F</url>
    <content type="text"><![CDATA[题目链接 描述魔兽世界的西面是红魔军的司令部，东面是蓝魔军的司令部。两个司令部之间是依次排列的若干城市。红司令部，City 1，City 2，……，City n，蓝司令部两军的司令部都会制造武士。武士一共有 dragon 、ninja、iceman、lion、wolf 五种。每种武士都有编号、生命值、攻击力这三种属性。双方的武士编号都是从1开始计算。红方制造出来的第n个武士，编号就是n。同样，蓝方制造出来的第n个武士，编号也是n。武士在刚降生的时候有一个生命值。在每个整点，双方的司令部中各有一个武士降生。红方司令部按照iceman、lion、wolf、ninja、dragon的顺序循环制造武士。蓝方司令部按照lion、dragon、ninja、iceman、wolf的顺序循环制造武士。制造武士需要生命元。制造一个初始生命值为m的武士，司令部中的生命元就要减少m个。如果司令部中的生命元不足以制造某个按顺序应该制造的武士，那么司令部就试图制造下一个。如果所有武士都不能制造了，则司令部停止制造武士。给定一个时间，和双方司令部的初始生命元数目，要求你将从0点0分开始到双方司令部停止制造武士为止的所有事件按顺序输出。一共有两种事件，其对应的输出样例如下： 武士降生输出样例： 004 blue lion 5 born with strength 5,2 lion in red headquarter表示在4点整，编号为5的蓝魔lion武士降生，它降生时生命值为5，降生后蓝魔司令部里共有2个lion武士。（为简单起见，不考虑单词的复数形式）注意，每制造出一个新的武士，都要输出此时司令部里共有多少个该种武士。 司令部停止制造武士输出样例： 010 red headquarter stops making warriors表示在10点整，红方司令部停止制造武士 输出事件时：首先按时间顺序输出；同一时间发生的事件，先输出红司令部的，再输出蓝司令部的。 输入第一行是一个整数，代表测试数据组数。每组测试数据共两行。第一行：一个整数M。其含义为， 每个司令部一开始都有M个生命元( 1 &lt;= M &lt;= 10000)。第二行：五个整数，依次是 dragon 、ninja、iceman、lion、wolf 的初始生命值。它们都大于0小于等于10000。 输出对每组测试数据，要求输出从0时0分开始，到双方司令部都停止制造武士为止的所有事件。对每组测试数据，首先输出”Case:n” n是测试数据的编号，从1开始 。接下来按恰当的顺序和格式输出所有事件。每个事件都以事件发生的时间开头，时间以小时为单位，有三位。 样例输入 1 20 3 4 5 6 7 样例输出 Case:1000 red iceman 1 born with strength 5,1 iceman in red headquarter000 blue lion 1 born with strength 6,1 lion in blue headquarter001 red lion 2 born with strength 6,1 lion in red headquarter001 blue dragon 2 born with strength 3,1 dragon in blue headquarter002 red wolf 3 born with strength 7,1 wolf in red headquarter002 blue ninja 3 born with strength 4,1 ninja in blue headquarter003 red headquarter stops making warriors003 blue iceman 4 born with strength 5,1 iceman in blue headquarter004 blue headquarter stops making warriors 思路:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int WARRIOR_NUM = 5;class Headquarter;class Warrior&#123;private: Headquarter * pHeadquarter; int kindNo;//武士种类编号 d,n,i,l,w int no;public: static string names[WARRIOR_NUM];//武士名 static int initialLifeValue[WARRIOR_NUM];//武士生命值 Warrior(Headquarter *p, int no_, int kindNo_);//初始化 void PrintResult(int nTime);//输出结果&#125;;class Headquarter&#123;private: int totalLifeValue;//总的生命值 bool stopped; int totalWarriorNum;//总的武士数目 int color;//红还是蓝 int curMakingSeqIdx;//当前要制造的武士是制造序列中的第几个 int warriorNum[WARRIOR_NUM]; Warrior *pWarrior[1000];public: friend class Warrior; static int makingSeq[2][WARRIOR_NUM];//武士的制造序列,0为红，1为蓝 void Init(int color_,int Lv);//初始化 ~Headquarter();//析构 int Produce(int nTime); string GetColor();&#125;;Warrior::Warrior(Headquarter *p, int no_, int kindNo_)//构造函数&#123; no = no_; kindNo = kindNo_; pHeadquarter = p;&#125;void Warrior::PrintResult(int nTime)&#123; string color = pHeadquarter-&gt;GetColor(); printf("%03d %s %s %d born with strength %d,%d %s in %s headquarter\n" , nTime, color.c_str(), names[kindNo].c_str(), no, initialLifeValue[kindNo], pHeadquarter-&gt;warriorNum[kindNo],names[kindNo].c_str(),color.c_str());&#125;void Headquarter::Init(int color_,int Lv)&#123; color = color_; totalLifeValue = Lv;//初始化生命值 totalWarriorNum = 0;//刚开始时，武士数量为0 stopped = false; curMakingSeqIdx = 0;//还没开始制造 for(int i=0;i&lt;WARRIOR_NUM;i++) warriorNum[i]=0;&#125;Headquarter::~Headquarter()//析构&#123; for(int i=0;i&lt;totalWarriorNum;i++) delete pWarrior[i];&#125;int Headquarter::Produce(int nTime)&#123; if(stopped) return 0; int searchingTimes = 0; while(Warrior::initialLifeValue[makingSeq[color][curMakingSeqIdx]] &gt; totalLifeValue &amp;&amp; searchingTimes &lt; WARRIOR_NUM) &#123; curMakingSeqIdx = (curMakingSeqIdx+1) % WARRIOR_NUM;//制造武士的序列，5个以后，返回到最开始 searchingTimes++; &#125; int kindNo = makingSeq[color][curMakingSeqIdx];//武士制造序列 if(Warrior::initialLifeValue[kindNo] &gt; totalLifeValue) &#123;//生命元不够制造武士 stopped = true; if (color == 0) printf("%03d red headquarter stops making warriors\n",nTime); else printf("%03d blue headquarter stops making warriors\n",nTime); return 0; &#125; //制造士兵 totalLifeValue -= Warrior::initialLifeValue[kindNo];//每制造一个武士，就减去制造该武士的生命元 curMakingSeqIdx = (curMakingSeqIdx+1) % WARRIOR_NUM; pWarrior[totalWarriorNum] = new Warrior(this,totalWarriorNum+1,kindNo);//构造下一个武士 warriorNum[kindNo]++;//该武士的数目加1 pWarrior[totalWarriorNum]-&gt;PrintResult(nTime);//输出该次制造武士的结果 totalWarriorNum++; return 1;&#125;string Headquarter::GetColor()&#123; if (color==0) return "red"; else return "blue";&#125;string Warrior::names[WARRIOR_NUM] = &#123;"dragon","ninja","iceman","lion","wolf"&#125;;//初始顺序int Warrior::initialLifeValue[WARRIOR_NUM];int Headquarter::makingSeq[2][WARRIOR_NUM] = &#123;&#123;2,3,4,1,0&#125;,&#123;3,0,1,2,4&#125;&#125;;//红蓝制作武士的顺序int main()&#123; int t,m; Headquarter RedHead,BlueHead; cin &gt;&gt; t; int nCaseNo=1; while(t--)&#123; cout&lt;&lt;"Case:"&lt;&lt;nCaseNo++&lt;&lt;endl; cin &gt;&gt; m; for(int i=0;i&lt;WARRIOR_NUM;i++) cin&gt;&gt;Warrior::initialLifeValue[i];//初始化生命值 RedHead.Init(0,m);//0为红 BlueHead.Init(1,m); int nTime=0;//时间 while(1)&#123; int temp1 = RedHead.Produce(nTime); int temp2 = BlueHead.Produce(nTime); if(temp1 == 0 &amp;&amp; temp2 == 0) break; nTime++; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[自动售票机]]></title>
    <url>%2F2019%2F04%2F24%2F%E8%87%AA%E5%8A%A8%E5%94%AE%E7%A5%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[我们做一个类似地铁自动售票机的小程序 main.cpp12345678#include "TicketMachine.hpp"int main() &#123; TicketMachine tm; tm.insertMoney(100); tm.showBalance(); return 0;&#125; TicketMachine.hpp12345678910111213141516171819#ifndef TicketMachine_hpp//如果没有定义这个宏#define TicketMachine_hpp//那就定义这个宏class TicketMachine&#123;public: TicketMachine(); virtual ~TicketMachine(); void showPrompt(); void insertMoney(int money); void showBalance(); void printTicket(); void showTotal();private: const int PRICE; int balance; int total;&#125;;#endif /* TicketMachine_hpp */ TicketMachine.cpp1234567891011121314151617181920212223242526#include "TicketMachine.hpp"#include &lt;iostream&gt;using namespace std;//构造函数TicketMachine::TicketMachine() : PRICE(0)&#123;//初始化 //TODO:&#125;TicketMachine::~TicketMachine()&#123;//析构函数 &#125;void TicketMachine::showPrompt()&#123; cout&lt;&lt;"something";&#125;void TicketMachine::insertMoney(int money)&#123; balance +=money;&#125;void TicketMachine::showBalance()&#123; cout&lt;&lt;balance;&#125; ::resolver也就是 解析符 ::这表示这个函数不是自由的，而是羁绊于 Class Name这个类的。 12345void S::f() &#123;//代表f()这个函数属于s ::f();//递归调用自己 ::a++;//代表全局变量 a--;//代表这个函数里的变量&#125; 定义类(Definition of a class) 在c++中，.h和.cpp文件被用来定义一个类 类的定义和函数原型放在.h中(declarations) 累的bodies放在.cpp中(definitions) Declarations vs.Definitions 一个.cpp文件就是一个编译单元 只有声明(declarations)被允许在.h文件中 exterm variables function prototypes(函数原型） class/struct declaration]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[next_permutation和prev_permutation]]></title>
    <url>%2F2019%2F04%2F17%2Fnext-permutation%E5%92%8Cprev-permutation%2F</url>
    <content type="text"><![CDATA[next_permutation 1234567891011121314151617181920212223组合数学中经常用到排列，这里介绍一个计算序列全排列的函数：next_permutation（start,end），和prev_permutation（start,end）。这两个函数作用是一样的，区别就在于前者求的是当前排列的下一个排列，后一个求的是当前排列的上一个排列。至于这里的“前一个”和“后一个”，我们可以把它理解为序列的字典序的前后，严格来讲，就是对于当前序列pn，他的下一个序列pn+1满足：不存在另外的序列pm，使pn&lt;pm&lt;pn+1.#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#define ll long longusing namespace std;int main()&#123; int a[3]=&#123;1,2,3&#125;; sort(a,a+3); do&#123; for(int i=0;i&lt;3;i++) cout&lt;&lt;a[i]&lt;&lt;" "; cout&lt;&lt;endl; &#125;while(next_permutation(a,a+3)); return 0;&#125; 结果为 1 3 22 1 32 3 13 1 23 2 1 prev_permutation123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#define ll long longusing namespace std;int main()&#123; int a[3]=&#123;3,2,1&#125;; do&#123; for(int i=0;i&lt;3;i++) cout&lt;&lt;a[i]&lt;&lt;" "; cout&lt;&lt;endl; &#125;while(prev_permutation(a,a+3)); return 0;&#125; 结果为 3 2 13 1 22 3 12 1 31 3 21 2 3]]></content>
      <categories>
        <category>C++常用STL</category>
      </categories>
      <tags>
        <tag>next_permutation</tag>
        <tag>prev_permutation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速幂]]></title>
    <url>%2F2019%2F04%2F17%2F%E5%BF%AB%E9%80%9F%E5%B9%82%2F</url>
    <content type="text"><![CDATA[前言 在算法程序设计竞赛中，我们竞赛选手会经常碰到对某个数N进行求大数次幂并对1e9+7取模的运算的题目，一方面求大数次幂是一个时间复杂度很高的运算（容易超时），另一方面对1e9+7取模，暗示着结果是连long long都存不下（同余定理），所以这时候快速幂取模算法就派上用场了。 同余定理这里我们不证明了 (a+b)\%c=(a\%c + b\%c)\%c (a*b)\%c = (a \% c)*(b \% c) \%c (a^b)\%c = (a\%c)^b \%c快速幂取模原理首先假设我们有 a^b\%c这里(1&lt;=a,b&lt;=1e5,c=1e9+7),要求算出它的结果，如果我们按照正常的手段去算的话，结果肯定会超时或者溢出，所以我们可以先把式子展开： 把b转换为二进制串 根据同余定理算这里我们用一个例子来说明，已知 2^{10}=1024, 10_{(10)} = 1010_{(2)} 2^{(10)}=2^{0*2^0+1*2^1+0*2^2+1*2^3} 2^{(10)}=2^{0*2^0}*2^{1*2^1}*2^{0*2^2}*2*{1*2^3} 2^{(10)}=1*2^{1*2^1}*1*2^{1*2^3} 2^{(10)}=1*2^2*1*2^8 观察第二条推导式可知从左往右第二项数起每一项的指数都是前一项的平方倍，所以在用代码实现的时候，我们对指数（二进制）按位平方略过为指数为0的项，大大降低了时间复杂度（0较多的前提下）。 代码如下12345678910111213long long quick_mod(long long a,long long b)&#123; long long ans = 1; a %= Mod; //对刚进来的a进行取模运算，避免后面第一次求平方运算溢出 while(b) &#123; if(b&amp;1) //对二进制下的 b 进行按位与1运算，求二进制下 b 的最低位是否为1 ans = ans * a % Mod; //对结果进行保存 b&gt;&gt;=1; //二进制下的 b 右移一位，相当于十进制下的 b 除以2 a = a * a % Mod; &#125; return ans % Mod;&#125; p1226快速幂b,p,k,k为长整型输出b^p mod k = s 输入2 10 9输出2^10 mod 9=7 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#define ll long longusing namespace std;ll b,p,k;ll quick_mod(ll x,ll y)&#123; ll ans=1; x %= k; while(y)&#123; if(y&amp;1)&#123; ans = ans*x%k; &#125; y&gt;&gt;=1; x=x*x%k; &#125; return ans%k;&#125;int main()&#123; cin&gt;&gt;b&gt;&gt;p&gt;&gt;k; printf("%lld^%lld mod %lld=%lld\n",b,p,k,quick_mod(b, p)); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>快速幂</category>
      </categories>
      <tags>
        <tag>快速幂取模</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[桂林电子科技大学第三届ACM程序设计竞赛]]></title>
    <url>%2F2019%2F04%2F15%2F%E6%A1%82%E6%9E%97%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E4%B8%89%E5%B1%8AACM%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[比赛链接 A,串串 不会写 B，重复 查重，直接set就完事了,然后求长度就ok了 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#define ll long longusing namespace std;int main()&#123; ll n,m; cin&gt;&gt;n&gt;&gt;m; string str[n]; for(ll i=0;i&lt;n;i++)&#123; cin&gt;&gt;str[i]; &#125; set&lt;string&gt;map(str,str+n); cout&lt;&lt;map.size()&lt;&lt;endl; return 0;&#125; C，二元 思路： 暂无 二元： 暂无 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#define ll long longusing namespace std;const int maxn=1e5+50;int n,k;struct T&#123; int a,b;&#125;p[maxn&lt;&lt;2];priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;q;bool cmp(const T &amp;a,const T &amp;b)&#123; return a.a&gt;b.a;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;k; for(int i=0;i&lt;n;i++) cin&gt;&gt;p[i].a&gt;&gt;p[i].b; sort(p,p+n,cmp); for(int i=0;i&lt;k;i++) q.push(p[i].b); int ans=q.top()+p[k-1].a; for(int i=k;i&lt;n;i++)&#123; q.pop(); q.push(p[i].b); ans=max(ans,p[i].a+q.top()); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; D，查找 树， 不会 E，区间 直接模拟 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#define ll long longusing namespace std;const int maxn=1000+10;int main()&#123; int t; cin&gt;&gt;t; while(t--)&#123; int n; cin&gt;&gt;n; int a[maxn]; int l=1,min=1;; int cnt=0,max=0; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;a[i]; &#125; for(int i=1;i&lt;n;i++)&#123; if(a[i-1]&lt;=a[i])&#123; cnt++; if(cnt&gt;max)&#123; l=min; max=cnt; &#125; &#125; else &#123; min=i+1; cnt=0; &#125; &#125; printf("%d %d\n",l,l+max); &#125; return 0;&#125; F，点对 有相图，连通性 定义一个大数组，M [a] [b] == 1 &amp;&amp; M[b] [a]==1 成立时， ans++ 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#define ll long longusing namespace std;const int maxn=310;int n,m;int M[maxn][maxn];int main()&#123; cin&gt;&gt;n&gt;&gt;m; int u,v; for(int i=0;i&lt;m;i++)&#123; cin&gt;&gt;u&gt;&gt;v; M[u][v]=1; &#125; for(int k=1;k&lt;=n;k++)&#123; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if(M[i][k]==1&amp;&amp;M[k][j]==1) M[i][j]=1; &#125; &#125; &#125; int ans=0; for(int i=1;i&lt;=n;i++)&#123; for(int j=i+1;j&lt;=n;j++)&#123; if(M[i][j] &amp;&amp; M[j][i]) ans++; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; G，路径 没写 H，分离 模拟就完事了 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;map&gt;#define ll long longusing namespace std;int main()&#123; int t; cin&gt;&gt;t; while(t--)&#123; string str; vector&lt;char&gt;m; cin&gt;&gt;str; m.push_back(str[0]); for(int i=1;i&lt;str.size();i++)&#123; if(i%2==0) m.push_back(str[i]); &#125; for(int i=0;i&lt;m.size();i++)&#123; cout&lt;&lt;m[i]; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; I，选择 还没写 J，相聚 连通性问题，只要找到1，就dfs 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;set&gt;#define ll long longusing namespace std;const int maxn=50+10;char str[maxn][maxn];int n,m;int dir[][2]=&#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125;&#125;;void dfs(int x,int y)&#123; str[x][y]='0';//注意 if(x&lt;0||x&gt;n||y&lt;0||y&gt;m) return;//结束条件 else &#123; for(int i=0;i&lt;4;i++)&#123; int dx=x+dir[i][0]; int dy=y+dir[i][1]; if(str[dx][dy]=='1') dfs(dx,dy); &#125; &#125;&#125;int main()&#123; int t; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n&gt;&gt;m; int ans=0; memset(str, '0',sizeof(str)); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) cin&gt;&gt;str[i][j]; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; if(str[i][j]=='1')&#123; dfs(i,j); ans++; &#125; &#125; &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>dfs</tag>
        <tag>字符串</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迷宫]]></title>
    <url>%2F2019%2F04%2F11%2F%E8%BF%B7%E5%AE%AB%2F</url>
    <content type="text"><![CDATA[题目链接 题目背景迷宫 【问题描述】 给定一个N*M方格的迷宫，迷宫里有T处障碍，障碍处不可通过。给定起点坐标和 终点坐标，问: 每个方格最多经过1次，有多少种从起点坐标到终点坐标的方案。在迷宫 中移动有上下左右四种方式，每次只能移动一个方格。数据保证起点上没有障碍。 输入样例 输出样例 【数据规模】 1≤N,M≤5 题目描述输入输出格式输入格式： 【输入】 第一行N、M和T，N为行，M为列，T为障碍总数。第二行起点坐标SX,SY，终点 坐标FX,FY。接下来T行，每行为障碍点的坐标。 输出格式： 【输出】 给定起点坐标和终点坐标，问每个方格最多经过1次，从起点坐标到终点坐标的方 案总数。 输入样例: 2 2 1 1 1 2 2 1 2 输出样例: 1 解题思路:典型的dfs，我们只需要记录路径即可，这里我们用另一个数组来记录路径。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#define ll long longusing namespace std;int n,m,t;int sx,sy,fx,fy;int vis[10][10];//记录路径int temp[10][10];int dir[][2]=&#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125;&#125;;//四个方向int ans;void dfs(int x,int y)&#123; if(x==fx&amp;&amp;y==fy)&#123;//找到终点 ans++;//次数加1 return; &#125; else&#123; for(int i=0;i&lt;4;i++)&#123; int dx=x+dir[i][0];//寻找方向 int dy=y+dir[i][1]; if(dx&gt;=1&amp;&amp;dx&lt;=n&amp;&amp;dy&gt;=1&amp;&amp;dy&lt;=m&amp;&amp;vis[dx][dy]==0&amp;&amp;temp[dx][dy]==0)&#123;//在地图内且没有被走过 temp[x][y]=1;//标志走过 dfs(dx,dy); temp[x][y]=0;//回溯 &#125; &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;t; cin&gt;&gt;sx&gt;&gt;sy&gt;&gt;fx&gt;&gt;fy; memset(vis,0,sizeof(vis)); memset(temp,0,sizeof(temp)); while(t--)&#123; int xz,yz; cin&gt;&gt;xz&gt;&gt;yz; vis[xz][yz]=1;//障碍 &#125; dfs(sx,sy);//从起点开始dfs printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>dfs</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单词方阵]]></title>
    <url>%2F2019%2F04%2F11%2F%E5%8D%95%E8%AF%8D%E6%96%B9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[题目链接 题目描述给一n×n的字母方阵，内可能蕴含多个“yizhong”单词。单词在方阵中是沿着同一方向连续摆放的。摆放可沿着 8个方向的任一方向，同一单词摆放时不再改变方向，单词与单词之间可以交叉,因此有可能共用字母。输出时，将不是单词的字母用*代替，以突出显示单词。例如: 输入输出格式输入格式： 第一行输入一个数n。(7≤n≤100)。 第二行开始输入n×n的字母矩阵。 输出格式： 突出显示单词的n×nn×n矩阵 解题思路：也是dfs,(dfs大法好)，我们只要找到开头的y，然后dfs查找八个方向中下一个字母为i的方向(dfs的方向不变)，一直到终点即可。 这题关键还是我们要记录路径，也就是要记录我们走过的点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#define ll long longusing namespace std;char str[100][100];char s[9]=&#123;"yizhong"&#125;;int dir[][2]=&#123;&#123;-1,-1&#125;,&#123;-1,0&#125;,&#123;-1,1&#125;,&#123;0,-1&#125;,&#123;0,1&#125;,&#123;1,-1&#125;,&#123;1,0&#125;,&#123;1,1&#125;&#125;;//八个方向int vis[100][100];//标记路径int n;struct node&#123; int x,y;&#125;c[100];//储存路径void dfs(int x,int y,node c[],int k,int cur)&#123; if(cur==7)&#123;//找到完整的路径，标记 for(int i=0;i&lt;7;i++)&#123; vis[c[i].x][c[i].y]=1; &#125; &#125; else&#123; int dx=x+dir[k][0];//根据前一个的方向继续寻找 int dy=y+dir[k][1]; if(cur==6||str[dx][dy]==s[cur+1])&#123; c[cur].x=x;//存储前一个路径 c[cur].y=y; dfs(dx,dy,c,k,cur+1);//dfs下一个字母 &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) cin&gt;&gt;str[i][j]; memset(vis,0,sizeof(vis)); for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n;j++)&#123; if(str[i][j]=='y')&#123; for(int k=0;k&lt;8;k++)&#123; int x=i+dir[k][0];//沿着正确方向走 int y=j+dir[k][1]; if(str[x][y]=='i')&#123; dfs(i,j,c,k,0); &#125; &#125; &#125; &#125; &#125; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n;j++)&#123; if(vis[i][j]) printf("%c",str[i][j]);//代表我们走过的路径 else printf("*"); &#125; printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>dfs</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[八皇后]]></title>
    <url>%2F2019%2F04%2F09%2F%E5%85%AB%E7%9A%87%E5%90%8E%2F</url>
    <content type="text"><![CDATA[题目链接 题目描述检查一个如下的6 x 6的跳棋棋盘，有六个棋子被放置在棋盘上，使得每行、每列有且只有一个，每条对角线(包括两条主对角线的所有平行线)上至多有一个棋子。 上面的布局可以用序列2 4 6 1 3 5来描述，第i个数字表示在第i行的相应位置有一个棋子，如下： 行号 1 2 3 4 5 6 列号 2 4 6 1 3 5 这只是跳棋放置的一个解。请编一个程序找出所有跳棋放置的解。并把它们以上面的序列方法输出。解按字典顺序排列。请输出前3个解。最后一行是解的总个数。 //以下的话来自usaco官方，不代表洛谷观点 特别注意: 对于更大的N(棋盘大小N x N)你的程序应当改进得更有效。不要事先计算出所有解然后只输出(或是找到一个关于它的公式），这是作弊。如果你坚持作弊，那么你登陆USACO Training的帐号删除并且不能参加USACO的任何竞赛。我警告过你了！ 输入输出格式输入格式： 一个数字N (6 &lt;= N &lt;= 13) 表示棋盘是N x N大小的。 输出格式： 前三行为前三个解，每个解的两个数字之间用一个空格隔开。第四行只有一个数字，表示解的总数。 输入样例： 6 输出样例： 2 4 6 1 3 5 3 6 2 5 1 4 4 1 5 2 6 3 4 解题思路：dfs模版题 我们可以注意到从左下角到右上角的对角线上各个元素的（行+列）都相等 从右下角到左上角的各个元素的 (行-列)都相等，为了避免出现负数。我们用(行-列+n)来表示。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define ll long longusing namespace std;int n,sum;int ans[14],check[3][50]=&#123;0&#125;;void print()&#123; int i; sum++; if(sum&lt;=3)&#123; for(i=1;i&lt;=n;i++)&#123; cout&lt;&lt;ans[i]&lt;&lt;" "; &#125; cout&lt;&lt;endl; &#125;&#125;void dfs(int line)&#123; for(int i=1;i&lt;=n;i++)&#123; if(check[0][i]==0&amp;&amp;check[1][line+i]==0&amp;&amp;check[2][line-i+n]==0)&#123; ans[line]=i;//第line行第j个 check[0][i]=1;//占列 check[1][line+i]=1;//占左下角到右上角的对角线 check[2][line-i+n]=1;//占右下到左上的对角线 if(line==n)print(); else dfs(line+1); check[0][i]=0;check[1][line+i]=0;check[2][line-i+n]=0;//回溯 &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n; dfs(1); cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>dfs</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单词接龙]]></title>
    <url>%2F2019%2F04%2F09%2F%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[题目链接 题目描述单词接龙是一个与我们经常玩的成语接龙相类似的游戏，现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的“龙”（每个单词都最多在“龙”中出现两次），在两个单词相连时，其重合部分合为一部分，例如 beast和astonish，如果接成一条龙则变为beastonish，另外相邻的两部分不能存在包含关系，例如at和 atide 间不能相连。 输入输出格式输入格式： 输入的第一行为一个单独的整数n (n≤20)表示单词数，以下n 行每行有一个单词，输入的最后一行为一个单个字符，表示“龙”开头的字母。你可以假定以此字母开头的“龙”一定存在. 输出格式： 只需输出以此字母开头的最长的“龙”的长度 输入样例： 12345678&gt; 5&gt; at&gt; touch&gt; cheat&gt; choose&gt; tact&gt; a&gt; 输出样例： 23 说明：连成的龙为atoucheatactactouchoose. 解题思路：把它转化成二叉树，然后dfs就可以了 具体方式如下（不全，注意思想就好了）: 黄色部分就是最长的了。 这道题最关键的不是dfs，而是我们如何找到下一步要接龙的头。也就是要如何找到两个单词最小重叠部分。 1234567891011121314151617int min_cover_word(int x,int y)//x表示当前单词，y表示下一个要接龙的单词&#123; bool p=true; int y_start=0;//单词y开始搜索位置 for(int k=str[x].size()-1;k&gt;=0;k--)&#123; for(int x_start=k; x_start&lt;str[x].size();x_start++)&#123;//x_start为单词x开始搜索位置 if(str[x][x_start] != str[y][y_start++])&#123;//不等时直接退出 p=false; break; &#125; &#125; if(p==true) return str[x].size()-k;//得到最小重叠长度 y_start=0; p=true; &#125; return 0;&#125; 这步可能不太容易理解，可以在草稿中模拟一下就清楚了。 AC代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#define ll long longusing namespace std;string str[100];//储存单词int vis[100];//判断单词的使用次数int n,ans=-1,now=0;//now每次搜到的f当前最长串int min_cover[100][100];//两个单词最小重叠部分char ch;//龙头int min_cover_word(int x,int y)&#123; bool p=true; int y_start=0;//单词y开始搜索位置 for(int k=str[x].size()-1;k&gt;=0;k--)&#123; for(int x_start=k; x_start&lt;str[x].size();x_start++)&#123;//x_start为单词x开始搜索位置 if(str[x][x_start] != str[y][y_start++])&#123;//不等时直接退出 p=false; break; &#125; &#125; if(p==true) return str[x].size()-k;//得到最小重叠长度 y_start=0; p=true; &#125; return 0;&#125;void dfs(int x)&#123; bool jx=false; for(int i=1;i&lt;=n;i++)&#123; if(vis[i]&gt;=2) continue;//使用了2次就跳过 if(min_cover[x][i]==0) continue;//两个单词没有重合b部分，跳过 if(min_cover[x][i]==str[x].size() || min_cover[x][i] == str[i].size()) continue;//两者存在包含关系，跳过 now += str[i].size()-min_cover[x][i];//两单词合并然后减去重叠部分的长度 vis[i]++;//使用次数增加 jx=true;//标志当前已经成功匹配到一个可以连接的部分 dfs(i);//继续合并 now -= str[i].size()-min_cover[x][i];//回溯,返回到上一步的状态 vis[i]--;//回溯 &#125; if(jx==false) ans=max(ans,now);//n表示已经不能找到可以连接到单词,更新长度 return;&#125;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;str[i]; cin&gt;&gt;ch; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; min_cover[i][j]=min_cover_word(i,j); &#125; &#125; //预处理min_cover数组。min_cover[i][j]就表示，i单词后连接一个j单词的最小重叠部分 //比如 i表示at,j表示att. min_cover[i][j]就为2 但是min_cover[j][i]就为0. //预处理是一个关键 for(int i=1;i&lt;=n;i++)&#123; if(str[i][0]==ch)&#123;//找到和首字母和龙头匹配的单词 vis[i]++;//使用次数增加 now=str[i].size();//更新当前串长度 dfs(i);//连接 vis[i]=0;//清除影响 &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>dfs</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序和归并排序]]></title>
    <url>%2F2019%2F04%2F06%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[快速排序之所比较快，因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。因此总的比较和交换次数就少了，速度自然就提高了。当然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的都是O(N2)，它的平均时间复杂度为O(NlogN)。其实快速排序是基于一种叫做“二分”的思想。我们后面还会遇到“二分”思想。 知道快排的思想后，我们可以看下这道题： 我是链接 题目背景在双人对决的竞技性比赛，如乒乓球、羽毛球、国际象棋中，最常见的赛制是淘汰赛和循环赛。前者的特点是比赛场数少，每场都紧张刺激，但偶然性较高。后者的特点是较为公平，偶然性较低，但比赛过程往往十分冗长。 本题中介绍的瑞士轮赛制，因最早使用于1895年在瑞士举办的国际象棋比赛而得名。它可以看作是淘汰赛与循环赛的折中，既保证了比赛的稳定性，又能使赛程不至于过长。 题目描述2×N名编号为 1∼2N 的选手共进行R 轮比赛。每轮比赛开始前，以及所有比赛结束后，都会按照总分从高到低对选手进行一次排名。选手的总分为第一轮开始前的初始分数加上已参加过的所有比赛的得分和。总分相同的，约定编号较小的选手排名靠前。 每轮比赛的对阵安排与该轮比赛开始前的排名有关：第1 名和第2 名、第 3 名和第 4名、……、第2K−1名和第2K名、…… 、第2N−1名和第2N名，各进行一场比赛。每场比赛胜者得1分，负者得 0分。也就是说除了首轮以外，其它轮比赛的安排均不能事先确定，而是要取决于选手在之前比赛中的表现。 现给定每个选手的初始分数及其实力值，试计算在R 轮比赛过后，排名第Q 的选手编号是多少。我们假设选手的实力值两两不同，且每场比赛中实力值较高的总能获胜。 输入输出格式输入格式： 第一行是三个正整数N,R,Q,每两个数之间用一个空格隔开，表示有 2×N名选手、R 轮比赛，以及我们关心的名次 Q。 第二行是2×N 个非负整数s1,s2,…,s2N，每两个数之间用一个空格隔开，其中si表示编号为i 的选手的初始分数。 第三行是2×N 个正整数w1,w2,…,w2N，每两个数之间用一个空格隔开，其中 wi 表示编号为i 的选手的实力值。 输出格式： 一个整数，即R轮比赛结束后，排名第Q 的选手的编号。 输入样例： 1234&gt; 2 4 2 &gt; 7 6 6 7 &gt; 10 5 20 15&gt; 输出样例: 1 【数据范围】 对于30%的数据，1≤N≤100； 对于50%的数据，1≤N≤10,000； 对于100%的数据，1≤N≤100,000,1≤R≤50,1≤Q≤2N,0≤s1,s2,…,s2N≤10^8,1≤w1,w2,…,w2N≤10^8. noip2011普及组第3题。 解题思路:刚开始没注意看范围，以为直接快排就能过，但是TLE了。 后面看了下，发现赢的基本上位置没有发生变化，当然输的相对位置也没有发生变化， 这不就是归并排序吗？ 下面先附上TLE的代码 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define ll long longusing namespace std;struct xs&#123; ll s,w,id;&#125;p[200000+10];bool cmp(const xs &amp;a, const xs &amp;b)&#123; if (a.s==b.s) return a.id&lt;b.id; return a.s&gt;b.s;&#125;int main()&#123; ll n,r,q; cin &gt;&gt; n &gt;&gt; r &gt;&gt; q; for(ll i=0;i&lt;2*n;i++)&#123; p[i].id = i+1; cin&gt;&gt;p[i].s; &#125; for (ll i=0; i&lt;2*n;i++)&#123; cin &gt;&gt; p[i].w; &#125; while(r--)&#123; ll j = 0; for(j=0;j&lt;2*n;j=j+2)&#123; if(p[j].w&gt;p[j+1].w) p[j].s+=1; else p[j+1].s+=1; &#125; sort(p,p+2*n,cmp); &#125; cout &lt;&lt; p[q-1].id &lt;&lt; endl; return 0;&#125; 下面是归并排序的算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define ll long longusing namespace std;ll n,r,q;struct xs&#123; ll id;//编号 ll s;//总分 ll w;//能力&#125; p[200010], a[200010],b[200010];int cmp(const xs &amp;a, const xs &amp;b)&#123; if (a.s==b.s) return a.id&lt;b.id; return a.s&gt;b.s;&#125;int main()&#123; cin &gt;&gt; n&gt;&gt;r&gt;&gt;q; for(int i=1;i&lt;=2*n; i++)&#123; cin&gt;&gt;p[i].s; p[i].id = i; &#125; for(int i=1; i&lt;=2*n;i++)&#123; cin&gt;&gt;p[i].w; &#125; sort(p+1,p+2*n+1,cmp); for(int i=1;i&lt;=r;i++)&#123; int ai=0,bi=0; for(int j=1;j&lt;=2*n;j = j+2)&#123; if(p[j].w&gt;p[j+1].w)&#123; p[j].s++; b[++bi]=p[j+1];//输的人进b a[++ai]=p[j];//赢的人 &#125; else &#123; p[j+1].s++; b[++bi]=p[j]; a[++ai]=p[j+1]; &#125; &#125; merge(a+1,a+n+1,b+1,b+n+1,p+1,cmp);//归并排序 &#125; cout &lt;&lt; p[q].id &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++中map用法]]></title>
    <url>%2F2019%2F04%2F05%2Fc-%E4%B8%ADmap%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[map的特性是，所有元素都会根据元素的减值自动被排序。map的所有元素都是pair，同时拥有实值(value)和键值(key)。pair的第一个元素会被视为键值，第二个元素会被视为实值。map不允许两个元素拥有相同的键值。 map的基本构造函数 mapstrMap; mapintMap; mapstrMap; map&lt; char ,string&gt;charMap; mapcharMap; mapintMap; map添加元素 map maplive; pair value(1,”a”)；maplive.insert(value); ​ 等价于maplive.insert(pair(1,”a”)); maplive.insert(map::value_type(1,”a”)); maplive[1]=”a”;//map中最简单最常用的插入添加！ map的基本操作函数 begin() 返回指向map头部的迭代器 clear() 删除所有元素 count() 返回指定元素出现的次数 empty() 如果map为空则返回true end() 返回指向map末尾的迭代器 equal_range() 返回特殊条目的迭代器对 erase() 删除一个元素 find() 查找一个元素 get_allocator() 返回map的配置器 insert() 插入元素 key_comp() 返回比较元素key的函数 lower_bound() 返回键值&gt;=给定元素的第一个位置 max_size() 返回可以容纳的最大元素个数 rbegin() 返回一个指向map尾部的逆向迭代器 rend() 返回一个指向map头部的逆向迭代器 size() 返回map中元素的个数 swap() 交换两个map upper_bound() 返回键值&gt;给定元素的第一个位置 value_comp() 返回比较元素value的函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;int main()&#123; map&lt;string,int&gt; strMap; //以string为键值，以int为实值 strMap[string("jjhou")] = 1; strMap[string("jerry")] = 2; strMap[string("jason")] = 3; strMap[string("jimmy")] = 4; pair&lt;string,int&gt; value(string("david"),5); strMap.insert(value);//插入新元素 //遍历操作 for(map&lt;string,int&gt;::iterator it = strMap.begin();it !=strMap.end();it++) &#123; //first为键，second为值 cout&lt;&lt;it-&gt;first&lt;&lt;' '&lt;&lt;it-&gt;second&lt;&lt;endl; &#125; cout&lt;&lt;endl; int number = strMap[string("jjhou")]; cout&lt;&lt;number&lt;&lt;endl; cout&lt;&lt;endl; //查找元素 map&lt;string,int&gt;::iterator iter1; //面对关联式容器，应该使用其所提供的find函数来搜索元素，会比使用STL算法find()更有效率。因为STL算法find()只是循环搜索。 iter1 = strMap.find(string("mchen")); if(iter1 == strMap.end())//找不到默认为末尾 cout&lt;&lt;"mchen no fount"&lt;&lt;endl; cout&lt;&lt;endl; iter1 = strMap.find(string("jerry")); if(iter1 != strMap.end()) cout&lt;&lt;"jerry fount"&lt;&lt;endl; cout&lt;&lt;endl; //修改实值，键值不可修改 iter1-&gt;second = 9; //可以通过map迭代器修改“value”(not key) int number1 = strMap[string("jerry")]; cout&lt;&lt;number1&lt;&lt;endl; //删除元素 for(map&lt;string,int&gt;::iterator it = strMap.begin();it !=strMap.end();it++) &#123; cout&lt;&lt;it-&gt;first&lt;&lt;' '&lt;&lt;it-&gt;second&lt;&lt;endl; &#125; cout&lt;&lt;endl; strMap.erase(iter1);//删除一个条目 strMap.erase(string("jason"));//根据键值删除 map&lt;string,int&gt;::iterator strmap_iter2 = strMap.begin(); for(;strmap_iter2 !=strMap.end();strmap_iter2++) &#123; cout&lt;&lt;strmap_iter2-&gt;first&lt;&lt;' '&lt;&lt;strmap_iter2-&gt;second&lt;&lt;endl; &#125; return 0;&#125; map用的最多的还是key排序和value排序。这里我们重点讲value排序。 我们可能想到要用sort函数来排序，但是直接用的话又不可以， 这里我们就需要用vector来进行排序. 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;stdio.h&gt;#include &lt;vector&gt;#include&lt;string&gt;#include&lt;map&gt;#include &lt;functional&gt; // std::greaterusing namespace std;bool cmp(const pair&lt;string, int&gt;&amp; a, const pair&lt;string, int&gt;&amp; b) &#123;//对成绩进行排序 return a.second &lt; b.second;&#125;int main()&#123; //1、map这里指定less作为其默认比较函数(对象),就是默认按键值升序排列 map&lt;string, int&gt; name_score_map; name_score_map["LiMin"] = 90; name_score_map["ZiLinMi"] = 79; name_score_map["BoB"] = 92; name_score_map.insert(make_pair("Bing", 99)); name_score_map.insert(make_pair("Albert", 86)); //输出添加的内容 map&lt;string, int&gt;::iterator iter; for (iter = name_score_map.begin(); iter != name_score_map.end(); ++iter) &#123; cout &lt;&lt; (*iter).first &lt;&lt; endl; &#125; cout &lt;&lt; endl; // 将map中的内容转存到vector中 vector&lt;pair&lt;string, int&gt;&gt; vec(name_score_map.begin(), name_score_map.end()); //对线性的vector进行排序 sort(vec.begin(), vec.end(), cmp); for (int i = 0; i &lt; vec.size(); ++i) cout &lt;&lt; vec[i].first &lt;&lt; endl; system("pause"); return 0;&#125; 理解之后，我们可以看下下面的题： 题目链接 题目描述世博会志愿者的选拔工作正在 A 市如火如荼的进行。为了选拔最合适的人才，AA市对 所有报名的选手进行了笔试，笔试分数达到面试分数线的选手方可进入面试。面试分数线根 据计划录取人数的150%150%划定，即如果计划录取mm名志愿者，则面试分数线为排名第m×150%m×150% （向下取整）名的选手的分数，而最终进入面试的选手为笔试成绩不低于面试分数线的所有 选手。 现在就请你编写程序划定面试分数线，并输出所有进入面试的选手的报名号和笔试成 绩。 输入输出格式输入格式： 第一行，两个整数 n,m(5≤n≤5000,3≤m≤n)n,m(5≤n≤5000,3≤m≤n)，中间用一个空格隔开，其 中nn表示报名参加笔试的选手总数，mm表示计划录取的志愿者人数。输入数据保证 m×150% 向下取整后小于等于 n。 第二行到第 n+1n+1 行，每行包括两个整数，中间用一个空格隔开，分别是选手的报名号 k(1000≤k≤9999)k(1000≤k≤9999)和该选手的笔试成绩s(1≤s≤100)s(1≤s≤100)。数据保证选手的报名号各不相同。 输出格式： 第一行，有22个整数，用一个空格隔开，第一个整数表示面试分数线；第二个整数为进入面试的选手的实际人数。 从第二行开始，每行包含22个整数，中间用一个空格隔开，分别表示进入面试的选手的报名号和笔试成绩，按照笔试成绩从高到低输出，如果成绩相同，则按报名号由小到大的顺序输出。 输入样例： 6 31000 903239 882390 957231 841005 951001 88 输出样例： 88 51005 952390 951000 901001 883239 88 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;bool cmp(const pair&lt;int, int&gt;&amp; a, const pair&lt;int, int&gt;&amp; b) &#123;//排序，分数相同就比较序号 if(a.second==b.second) return a.first&gt;b.first; else return a.second &lt; b.second;&#125;int main()&#123; int n,m,cnt=0; cin &gt;&gt; n&gt;&gt;m; int a[n],b[n]; map&lt;int,int&gt;p; for(int i=0;i&lt;n;i++)&#123; cin &gt;&gt; a[i]&gt;&gt;b[i]; p[a[i]]=b[i]; &#125; vector&lt;pair&lt;int,int&gt; &gt;sore(p.begin(),p.end()); sort(sore.begin(),sore.end(),cmp); int link=floor((m-1)*1.50); int fenlink = sore[n-link-1].second;//已经按照从小到大排序了，但是题目要求是从大到小. for(int i=0; i&lt;sore.size(); i++)&#123; if(sore[i].second &gt;= fenlink) &#123; cnt++; &#125; &#125; cout &lt;&lt; fenlink &lt;&lt; " "&lt;&lt; cnt &lt;&lt; endl; for(int i=sore.size()-1;i&gt;=0;i--)&#123; if(sore[i].second &gt;= fenlink) &#123; cout &lt;&lt; sore[i].first &lt;&lt; " "&lt;&lt;sore[i].second &lt;&lt; endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>C++常用STL</category>
      </categories>
      <tags>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中set的用法]]></title>
    <url>%2F2019%2F04%2F05%2FC-%E4%B8%ADset%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[set的特性是，所有元素都会根据元素的键值自动排序，set的元素不像map那样可以同时拥有实值(value)和键值(key),set元素的键值就是实值，实值就是键值。set不允许两个元素有相同的键值。 我们常用set来查重。 set的各成员函数列表如下: begin()—返回指向第一个元素的迭代器 clear()—清除所有元素 count()—返回某个值元素的个数 empty()—如果集合为空，返回true end()—返回指向最后一个元素的迭代器 equal_range()—返回集合中与给定值相等的上下限的两个迭代器 erase()—删除集合中的元素 find()—返回一个指向被查找到元素的迭代器 get_allocator()—返回集合的分配器 insert()—在集合中插入元素 lower_bound()—返回指向大于（或等于）某值的第一个元素的迭代器 key_comp()—返回一个用于元素间值比较的函数 max_size()—返回集合能容纳的元素的最大限值 rbegin()—返回指向集合中最后一个元素的反向迭代器 rend()—返回指向集合中第一个元素的反向迭代器 size()—集合中元素的数目 swap()—交换两个集合变量 upper_bound()—返回大于某个值元素的迭代器 value_comp()—返回一个用于比较元素间的值的函数 下面我们主要讲set中遍历： 假设我们对一个数组进行排序，并且里面不能有重复的元素。 123456789101112131415161718#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;set&gt;using namespace std;int main()&#123; int a[11] =&#123;20, 40, 32, 67, 40, 20, 89, 300, 400, 15&#125;; set&lt;int&gt;map(a,a+10); cout &lt;&lt; map.size() &lt;&lt; endl; for (set&lt;int&gt;::iterator it=map.begin(); it!=map.end(); ++it) &#123; cout &lt;&lt; *it &lt;&lt; " "; &#125; return 0;&#125; 大家可以做下面这道题练练手： 我是链接]]></content>
      <categories>
        <category>C++常用STL</category>
      </categories>
      <tags>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩形面积并]]></title>
    <url>%2F2019%2F04%2F04%2F%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[题目链接 H. Mo的面积 单测试点时限: 1.0 秒 内存限制: 512 MB Mo的老师给了他两个矩形，让他求两个矩形的面积并。Mo很忙没时间解决这种小case，请你帮他解决。 输入输入两行，每行四个整数 𝑥,𝑦,𝑥1,𝑦1 。(𝑥,𝑦) 是矩形左下角，(𝑥1,𝑦1) 是矩形的右上角. (0≤𝑥,𝑦,𝑥1,𝑦1≤1000)。 输出输出一个整数表示二个矩形的面积并。 样例input 120 1 2 31 0 3 2 output 17 矩形面积并问题两个矩形相交的情况总共有以下几种（可能有部分遗漏）： 我们可以观察到，如果两个矩阵相交，那么它的边的情况只能是这种情况： 我们假设第一个矩阵的左下角坐标为，a[1],a[2],右上角坐标为a[3],a[4] 第二个矩阵的左下角坐标为a[5],a[6],右上角坐标为a[7],a[8]. left = max ( min( a[1] , a[3] ), min( a[5], a[7] ) ) right = min (max ( a[1], a[3] ), max( a[5], a[7] ) ) up = min (max ( a[2], a[4]), max ( a[6], a[8] ) ) down = max (min ( a[2], a[4] ), min ( a[6], a[8] ) ) 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;map&gt;using namespace std;#define ll long longconst int INF=0x3f3f3f3f;int main()&#123; int a[100]; for (int i=1; i&lt;=8; i++) &#123; cin &gt;&gt; a[i]; &#125; int l = max(min(a[1],a[3]),min(a[5],a[7])); int r = min(max(a[1],a[3]),max(a[5],a[7])); int u = min(max(a[2],a[4]),max(a[6],a[8])); int d = max(min(a[2],a[4]),min(a[6],a[8])); int area; if (r-l &lt; 0 || u-d &lt; 0) area = 0; else area = (r-l)*(u-d); printf("%d\n",(a[3]-a[1])*(a[4]-a[2]) + (a[7]-a[5])*(a[8]-a[6]) - area); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>矩形面积并</category>
      </categories>
      <tags>
        <tag>面积</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo常用技巧]]></title>
    <url>%2F2019%2F04%2F04%2Fhexo%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[一些常用的hexo方法创建一个.md文件可以执行： $ hexo new “文件名” 插入图片 首先把blog（hexo）目录下的_config.yml里的psot_asset_folder:设置为true 在blog（hexo）目录下执行: 12&gt; npm install hexo-asset-image --save&gt; 在blog（hexo）目录下Git Bash Here，运行hexo n “博客名”来生成md博客时，会在_post目录下看到一个与博客同名的文件夹。 将想要上传的图片先扔到文件夹下，然后在博客中使用markdown的格式引入图片： 12&gt; ![你想要输入的替代文字](xxxx/图片名.jpg)&gt;]]></content>
      <categories>
        <category>hexo教程</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建个人博客(一)]]></title>
    <url>%2F2019%2F04%2F04%2Fhexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[前言打算搭建个博客用来记录自己学习的过程，这里就简单介绍下如何搭建一个个人博客。有讲得不好的请大家轻喷。 安装Hexo安装hexo只需几分钟，但是在安装之前请先安装一些东西. node.js Git 安装完成之后，就只需要用npm安装Hexo: 先选好自己要安装的目录 cd &lt;文件名&gt; 然后再安装： $ npm install -g hexo-cli 到这里我们已经安装好了Hexo。 2，利用Hexo初始化我们的站点和目录新建一个文件 $ hexo init &lt;文件夹&gt; $ cd &lt;文件夹&gt; $ npm install 到这步我们的基本框架就完成了 进入你建的目录,然后输入: $ hexo g $ hexo s 然后它会给你发个网址，也就是http://localhost:4000， 在你的浏览器打开就可以看到你的框架了。 到这里你的博客就已经基本搭建好了，但是这只是基于你的本地， 后面我会给大家分享如何更换主题，标签，还有一些markdown的使用技巧。 大家可以看下这里：详情 感谢各位大佬能够看完。]]></content>
      <categories>
        <category>hexo教程</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[first]]></title>
    <url>%2F2019%2F04%2F03%2Ffirst%2F</url>
    <content type="text"><![CDATA[第一次使用]]></content>
  </entry>
</search>
