[{"title":"109_有序链表转换二叉搜索树","url":"/2022/07/14/109_%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","content":"<h1 id=\"有序链表转换二叉搜索树\"><a\nhref=\"https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/\">109.\n有序链表转换二叉搜索树</a></h1>\n<p>给定一个单链表的头节点 <code>head</code>，其中的元素 按升序排序\n，将其转换为高度平衡的二叉搜索树。</p>\n<p>本题中，一个高度平衡二叉树是指一个二叉树每个节点\n的左右两个子树的高度差不超过 1。</p>\n<h2 id=\"示例\">示例：</h2>\n<p><img src=\"109_有序链表转换二叉搜索树/linked.jpg\" /></p>\n<blockquote>\n<p>输入: head = [-10,-3,0,5,9] 输出: [0,-3,9,-10,null,5] 解释:\n一个可能的答案是[0，-3,9，-10,null,5]，它表示所示的高度平衡的二叉搜索树。\n<span id=\"more\"></span></p>\n</blockquote>\n<h3 id=\"思路\">思路：</h3>\n<h4\nid=\"方法一通过快慢双指针找到链表中间节点\">方法一：通过快慢双指针找到链表中间节点</h4>\n<p>由于我们需要构造出平衡二叉树，那么我们第一步就是确定根结点，并且使根结点的左子树和右子树节点个数尽可能接近。这样左右子树的高度才能达到高度差的绝对值不超过1。</p>\n<p>那么如何找到这样的根结点呢？理所当然我们想到找到链表的中心节点。</p>\n<p>时间复杂度为<code>O(nlogn)</code></p>\n<p>空间复杂度为<code>O(logn)</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution1</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>: </span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">sortedListToBST</span><span class=\"params\">(ListNode* head)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">build</span>(head, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 把链表左闭右开区间[begin,end) 的节点构造成 BST</span></span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">build</span><span class=\"params\">(ListNode *begin, ListNode *end)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(begin == end)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ListNode *mid = <span class=\"built_in\">getMid</span>(begin, end);</span><br><span class=\"line\">        TreeNode *root = <span class=\"keyword\">new</span> <span class=\"built_in\">TreeNode</span>(mid-&gt;val);</span><br><span class=\"line\">        root-&gt;left = <span class=\"built_in\">build</span>(begin, mid);</span><br><span class=\"line\">        root-&gt;right = <span class=\"built_in\">build</span>(mid-&gt;next, end);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 通过双指针获取链表左闭右开区间的中心结点</span></span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">getMid</span><span class=\"params\">(ListNode *begin, ListNode *end)</span></span>&#123;</span><br><span class=\"line\">        ListNode *slow = begin, *fast = begin;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(fast != <span class=\"literal\">nullptr</span> &amp;&amp; fast-&gt;next != <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            slow = slow-&gt;next;</span><br><span class=\"line\">            fast = fast-&gt;next-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> slow;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二中序遍历\">方法二：中序遍历</h4>\n<p>方法一中我们的时间都浪费在了查找中间节点上，我们每次获取链表的头结点O(1),它对应BST的最左子树的根结点</p>\n<p>我们根据中序遍历原则，分别构建左子树，根结点，右子树</p>\n<p>时间复杂度：<code>O(n)</code></p>\n<p>空间复杂度：<code>O(logn)</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    ListNode *cur;</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">sortedListToBST</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> len = <span class=\"number\">0</span>;</span><br><span class=\"line\">      \t<span class=\"comment\">//计算链表长度</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(ListNode *p = head; p != <span class=\"literal\">nullptr</span>; p = p-&gt;next)&#123;</span><br><span class=\"line\">            len++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cur = head;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">inorderBuild</span>(<span class=\"number\">0</span>, len - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">inorderBuild</span><span class=\"params\">(<span class=\"type\">int</span> lo, <span class=\"type\">int</span> hi)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(lo &gt; hi)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> mid = lo + (hi - lo) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 构造左子树</span></span><br><span class=\"line\">        TreeNode *leftTree = <span class=\"built_in\">inorderBuild</span>(lo, mid - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 构造根结点</span></span><br><span class=\"line\">        TreeNode *root = <span class=\"keyword\">new</span> <span class=\"built_in\">TreeNode</span>(cur-&gt;val);</span><br><span class=\"line\">        cur = cur-&gt;next;</span><br><span class=\"line\">        <span class=\"comment\">// 构造右子树</span></span><br><span class=\"line\">        TreeNode *rightTree = <span class=\"built_in\">inorderBuild</span>(mid + <span class=\"number\">1</span>, hi);</span><br><span class=\"line\">        <span class=\"comment\">// 将左右子树链接到根结点上</span></span><br><span class=\"line\">        root-&gt;left = leftTree;</span><br><span class=\"line\">        root-&gt;right = rightTree;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["二叉搜索树"],"tags":["二叉搜索树"]},{"title":"112_路径总和","url":"/2022/06/19/112_%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/","content":"<h1 id=\"路径总和\"><a href=\"https://leetcode.cn/problems/path-sum/\">112.\n路径总和</a></h1>\n<p>给你二叉树的根节点 <code>root</code>和一个表示目标和的整数\n<code>targetSum</code>。判断该树中是否存在 根节点到叶子节点\n的路径，这条路径上所有节点值相加等于目标和\n<code>targetSum</code>。如果存在，返回 <code>true</code>；否则，返回\n<code>false</code>。</p>\n<p>叶子节点 是指没有子节点的节点。</p>\n<h2 id=\"示例\">示例：</h2>\n<p><img src=\"112_路径总和/pathsum1.jpg\" /></p>\n<blockquote>\n<p>输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum =\n22 输出：true 解释：等于目标和的根节点到叶节点路径如上图所示。</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"思路\">思路：</h3>\n<h4 id=\"方法一dfs\">方法一：DFS</h4>\n<p>我们分解为小问题，递归解决</p>\n<p>假设为左子树，那么可以表示为</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">hasPathSum</span>(root-&gt;left, targetSum - root-&gt;val);</span><br></pre></td></tr></table></figure>\n<p>右子树同理</p>\n<p>时间复杂度：O(n) 空间复杂度：O(h) h 为树高</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">hasPathSum</span><span class=\"params\">(TreeNode* root, <span class=\"type\">int</span> targetSum)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root-&gt;left== <span class=\"literal\">nullptr</span> &amp;&amp; root-&gt;right == <span class=\"literal\">nullptr</span> &amp;&amp; root-&gt;val == targetSum)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">hasPathSum</span>(root-&gt;left, targetSum - root-&gt;val) || <span class=\"built_in\">hasPathSum</span>(root-&gt;right, targetSum - root-&gt;val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二bfs\">方法二：BFS</h4>\n<p>我们定义两个队列，分别存储当前节点和该节点的值，分别相加，直到达到叶子节点后判断相加的和和<code>targetSum</code>是否相等</p>\n<p>时间复杂度：<code>O(n)</code></p>\n<p>空间复杂度：<code>O(n)</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution1</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">hasPathSum</span><span class=\"params\">(TreeNode* root, <span class=\"type\">int</span> targetSum)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        queue&lt;TreeNode*&gt; que_node;</span><br><span class=\"line\">        queue&lt;<span class=\"type\">int</span>&gt; que_val;</span><br><span class=\"line\">        que_node.<span class=\"built_in\">push</span>(root);</span><br><span class=\"line\">        que_val.<span class=\"built_in\">push</span>(root-&gt;val);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!que_node.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">            TreeNode *now = que_node.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">            <span class=\"type\">int</span> temp = que_val.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">            que_node.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            que_val.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            <span class=\"comment\">// 为叶子结点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(now-&gt;left == <span class=\"literal\">nullptr</span> &amp;&amp; now-&gt;right == <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(temp == targetSum)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(now-&gt;left != <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">                que_node.<span class=\"built_in\">push</span>(now-&gt;left);</span><br><span class=\"line\">                que_val.<span class=\"built_in\">push</span>(now-&gt;left-&gt;val + temp);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(now-&gt;right != <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">                que_node.<span class=\"built_in\">push</span>(now-&gt;right);</span><br><span class=\"line\">                que_val.<span class=\"built_in\">push</span>(now-&gt;right-&gt;val + temp);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["二叉树"],"tags":["二叉树"]},{"title":"115_不同的子序列","url":"/2022/07/16/115_%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97/","content":"<p>[[toc]]</p>\n<h1 id=\"不同的子序列\"><a\nhref=\"https://leetcode.cn/problems/distinct-subsequences/\">115.\n不同的子序列</a></h1>\n<p>给定一个字符串 s 和一个字符串 <code>t</code> ，计算在 <code>s</code>\n的子序列中 <code>t</code> 出现的个数。</p>\n<p>字符串的一个 子序列\n是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，<code>\"ACE\"</code> 是 <code>\"ABCDE\"</code> 的一个子序列，而 <code>\"AEC\" </code>不是）</p>\n<p>题目数据保证答案符合 32 位带符号整数范围。</p>\n<h2 id=\"示例1\">示例1：</h2>\n<blockquote>\n<p>输入：s = \"rabbbit\", t = \"rabbit\" 输出：3 解释： 如下图所示, 有 3\n种可以从 s 中得到 \"rabbit\" 的方案。 rabbbit rabbbit rabbbit</p>\n</blockquote>\n<h2 id=\"示例2\">示例2:</h2>\n<blockquote>\n<p>输入：s = \"babgbag\", t = \"bag\" 输出：5 解释： 如下图所示, 有 5\n种可以从 s 中得到 \"bag\" 的方案, babgbag babgbag babgbag babgbag\nbabgbag</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"思路\">思路：</h3>\n<p>我们需要计算<code>s</code>中有多少个<code>t</code>，实际上就是穷举，那么我们需要考虑能不能把愿问题分解为规模更小的子问题，然后再根据子问题推导出愿问题的结果。\n首先，我们可以定义这样一个<code>dp</code>函数： <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义：s[i..] 的子序列中 t[j..]出现的次数为 dp(s,i,t,j)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dp</span><span class=\"params\">(string s, <span class=\"type\">int</span> i, string t, <span class=\"type\">int</span> j)</span></span></span><br></pre></td></tr></table></figure>\n那么我们想要的结果就为<code>dp(s, 0, t, 0)</code><br>\n<code>base case</code>为： * 1. 全部匹配完成，<code>j == t.size()</code>\n* 2. s[i..]比t[j..]还短，那么必然不可能匹配</p>\n<p>至此，我们可以写出大概的算法框架： <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">numDecodings</span><span class=\"params\">(string s, string t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">dp</span>(s, <span class=\"number\">0</span>, t, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dp</span><span class=\"params\">(string s, <span class=\"type\">int</span> i, string t, <span class=\"type\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// base case 1, 全部匹配完成</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(j == t.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// base case 2, s[i..]的长度比t[j..]的长度短，匹配失败</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(s.<span class=\"built_in\">size</span>() - i &lt; t.<span class=\"built_in\">size</span>() - j) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>现在我们需要考虑如何将大问题分解为小问题，即如何求出状态转移方程。</p>\n<p>有两种思路，第一种就是从<code>t</code>的角度进行思考，第二种是从<code>s</code>的角度进行思考。</p>\n<p><strong>角度一：从<code>t</code>的角度</strong></p>\n<p>我们的问题是求<code>s[i..]</code>的所有子序列中<code>t[j..]</code>出现的次数，那么我们肯定是先判断<code>t[0]</code>在<code>s</code>中出现的位置。\n假如<code>s[2],s[6]</code>是字符<code>t[0]</code>，那么原问题就转化为在<code>s[2..] ,s[6..]</code>的所有子序列中计算<code>t[1..]</code>出现的次数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dp</span><span class=\"params\">(string s, <span class=\"type\">int</span> i, string t, <span class=\"type\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 在s[i..]中寻找 k,使得 s[k] == t[j]</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k = i; k &lt; s.<span class=\"built_in\">size</span>(); k++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s[k] == t[j]) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 累加结果</span></span><br><span class=\"line\">            res += <span class=\"built_in\">dp</span>(s, k + <span class=\"number\">1</span>, t, j + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后我们只需要加上备忘录消除重叠子问题即可。 <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; memo;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">numDistinct</span><span class=\"params\">(string s, string t)</span> </span>&#123;</span><br><span class=\"line\">        memo.<span class=\"built_in\">resize</span>(s.<span class=\"built_in\">size</span>(), <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(t.<span class=\"built_in\">size</span>(), <span class=\"number\">-1</span>));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">dp</span>(s, <span class=\"number\">0</span>, t, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 定义：s[i...] 的子序列中 t[j...]出现的次数为dp(s, i, t, j)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dp</span><span class=\"params\">(string s, <span class=\"type\">int</span> i, string t, <span class=\"type\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// base case 1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(j == t.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// base case 2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s.<span class=\"built_in\">size</span>() - i &lt; t.<span class=\"built_in\">size</span>() - j) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(memo[i][j] != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> memo[i][j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 状态转移方程</span></span><br><span class=\"line\">        <span class=\"comment\">// 在 s[i..]中寻找k,使得s[k] == t[j]</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k = i; k &lt; s.<span class=\"built_in\">size</span>(); k++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[k] == t[j]) &#123;</span><br><span class=\"line\">                res += <span class=\"built_in\">dp</span>(s, k + <span class=\"number\">1</span>, t, j + <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        memo[i][j] = res;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>时间复杂度：O(m*n) * O(m)</p>\n<p>m表示s的长度，n为t的长度。 子问题的个数 * 函数本身的时间复杂度</p>\n<p><strong>角度二：从<code>s</code>的监督</strong></p>\n<p>我们的问题是计算<code>s[0..]</code>的所有子序列中<code>t[0..]</code>出现的次数，那么我们可以先看下<code>s[0]</code>是否能匹配<code>t[0]</code>,\n如果不匹配，那么愿问题就可以转化为计算<code>s[1..]</code>的所有子序列中<code>t[0..]</code>出现的次数。\n如果匹配，那么有以下两种情况，这两种情况是累加的关系： * 1.\n让<code>s[0]</code>匹配<code>t[0]</code>，那么原问题转化为在<code>s[1..]</code>的所有子序列中计算<code>t[1..]</code>出现的次数。\n* 2.\n不让<code>s[0]</code>匹配<code>t[0]</code>，那么原问题转化为在<code>s[1..]</code>的所有子序列中计算<code>t[0..]</code>出现的次数。</p>\n<p>那么状态转移方程为： <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dp</span><span class=\"params\">(string s, <span class=\"type\">int</span> i, string t, <span class=\"type\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(s[i] == t[j]) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 匹配，两种情况</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">dp</span>(s, i + <span class=\"number\">1</span>, t, j + <span class=\"number\">1</span>) + <span class=\"built_in\">dp</span>(s, i + <span class=\"number\">1</span>, t, j);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 不匹配</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">dp</span>(s, i + <span class=\"number\">1</span>, t, j);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>加上备忘录，代码如下： <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; memo;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">numDistinct</span><span class=\"params\">(string s, string t)</span> </span>&#123;</span><br><span class=\"line\">        memo.<span class=\"built_in\">resize</span>(s.<span class=\"built_in\">size</span>(), <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(t.<span class=\"built_in\">size</span>() , <span class=\"number\">-1</span>));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">dp</span>(s, <span class=\"number\">0</span>, t, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dp</span><span class=\"params\">(string s, <span class=\"type\">int</span> i, string t, <span class=\"type\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// base case 1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(j == t.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// base case 2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s.<span class=\"built_in\">size</span>() - i &lt; t.<span class=\"built_in\">size</span>() - j) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(memo[i][j] != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> memo[i][j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 状态转移方程</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s[i] == t[j]) &#123;</span><br><span class=\"line\">            res += <span class=\"built_in\">dp</span>(s, i + <span class=\"number\">1</span>, t, j + <span class=\"number\">1</span>) + <span class=\"built_in\">dp</span>(s, i + <span class=\"number\">1</span>, t, j);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            res += <span class=\"built_in\">dp</span>(s, i + <span class=\"number\">1</span>, t, j);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 将结果存入备忘录</span></span><br><span class=\"line\">        memo[i][j] = res;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>时间复杂度为：<code>O(mn)</code></p>\n","categories":["动态规划"],"tags":["动态规划"]},{"title":"117_填充每个节点的下一个右侧节点指针II","url":"/2022/06/29/117_%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88II/","content":"<h1 id=\"填充每个节点的下一个右侧节点指针-ii\"><a\nhref=\"https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/\">117.\n填充每个节点的下一个右侧节点指针 II</a></h1>\n<p>给定一个二叉树</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> val;</span><br><span class=\"line\">  Node *left;</span><br><span class=\"line\">  Node *right;</span><br><span class=\"line\">  Node *next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>填充它的每个\n<code>next</code>指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将\n<code>next</code>指针设置为 <code>NULL</code>。</p>\n<p>初始状态下，所有 <code>next</code>指针都被设置为\n<code>NULL</code>。</p>\n<h2 id=\"示例\">示例：</h2>\n<p><img\nsrc=\"117_填充每个节点的下一个右侧节点指针II/117_sample.png\" /></p>\n<blockquote>\n<p>输入：root = [1,2,3,4,5,null,7] 输出：[1,#,2,3,#,4,5,7,#]\n解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next\n指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由\nnext 指针连接），'#' 表示每层的末尾。</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"思路\">思路：</h3>\n<p>和前面的<a href=\"https://sjchen404.github.io/2022/03/07/二叉树/\">116\n填充每个节点的下一个右侧节点指针</a>不同的是，现在给定的不是一个完美二叉树，所以递归的话不好实现。</p>\n<p>这道题希望我们把二叉树各个层的点组织成链表，一个非常直观的思路是层次遍历。树的层次遍历基于广度优先搜索，它按照层的顺序遍历二叉树，在遍历第\n<code>i</code>层前，一定会遍历完第 <code>i - 1</code> 层。</p>\n<p>算法如下：初始化一个队列\n<code>q</code>，将根结点放入队列中。当队列不为空的时候，记录当前队列大小为\nn，从队列中以此取出 n 个元素并通过这 n\n个元素拓展新节点。如此循环，直到队列为空。我们不难写出这样的代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">Node* <span class=\"title\">connect</span><span class=\"params\">(Node* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 二叉树层次遍历</span></span><br><span class=\"line\">        queue&lt;Node*&gt; q;</span><br><span class=\"line\">        q.<span class=\"built_in\">push</span>(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> sz = q.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">            <span class=\"comment\">// pre 为表示访问下一个节点前一个节点</span></span><br><span class=\"line\">            Node* pre = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; sz; i++)&#123;</span><br><span class=\"line\">                Node* cur = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">                q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                <span class=\"comment\">// 链接当前层所有节点的 next 指针</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(pre != <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">                    pre-&gt;next = cur;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                pre = cur;</span><br><span class=\"line\">                <span class=\"comment\">// 将下一层节点装入队列</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(cur-&gt;left != <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">                    q.<span class=\"built_in\">push</span>(cur-&gt;left);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(cur-&gt;right != <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">                    q.<span class=\"built_in\">push</span>(cur-&gt;right);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["二叉树"],"tags":["二叉树"]},{"title":"129_求根节点到叶节点数字之和","url":"/2022/06/29/129_%E6%B1%82%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/","content":"<h1 id=\"求根节点到叶节点数字之和\"><a\nhref=\"https://leetcode.cn/problems/sum-root-to-leaf-numbers/\">129.\n求根节点到叶节点数字之和</a></h1>\n<p>给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9\n之间的数字。 每条从根节点到叶节点的路径都代表一个数字：</p>\n<p>例如，从根节点到叶节点的路径 1 -&gt; 2 -&gt; 3 表示数字 123 。\n计算从根节点到叶节点生成的 所有数字之和 。</p>\n<p>叶节点 是指没有子节点的节点。</p>\n<h2 id=\"示例\">示例：</h2>\n<p><img src=\"129_求根节点到叶节点数字之和/num1tree.jpg\" /></p>\n<blockquote>\n<p>输入：root = [1,2,3] 输出：25 解释： 从根到叶子节点路径 1-&gt;2\n代表数字 12 从根到叶子节点路径 1-&gt;3 代表数字 13 因此，数字总和 = 12 +\n13 = 25</p>\n</blockquote>\n<p><img src=\"129_求根节点到叶节点数字之和/num2tree.jpg\" /></p>\n<blockquote>\n<p>输入：root = [4,9,0,5,1] 输出：1026 解释： 从根到叶子节点路径\n4-&gt;9-&gt;5 代表数字 495 从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491\n从根到叶子节点路径 4-&gt;0 代表数字 40 因此，数字总和 = 495 + 491 + 40 =\n1026</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"思路\">思路：</h3>\n<p>深度优先搜索（DFS），从根结点出发，遍历每个节点，如果遇到叶子结点，则将叶子结点对应的数字加到数字之和。如果不是叶子结点，则计算其子结点对应的数字，然后对子结点递归遍历。</p>\n<p>时间复杂度：<code>O(n)</code></p>\n<p>空间复杂度：<code>O(n)</code></p>\n<p><img src=\"129_求根节点到叶节点数字之和/fig1.png\" /></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">sumNumbers</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">dfs</span>(root, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(TreeNode* root, <span class=\"type\">int</span> prevSum)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> sum = prevSum * <span class=\"number\">10</span> + root-&gt;val;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root-&gt;left == <span class=\"literal\">nullptr</span> &amp;&amp; root-&gt;right == <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">dfs</span>(root-&gt;left, sum) + <span class=\"built_in\">dfs</span>(root-&gt;right, sum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["二叉树"],"tags":["二叉树"]},{"title":"173_二叉搜索树迭代器","url":"/2022/07/02/173_%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8/","content":"<h1 id=\"二叉搜索树迭代器\"><a\nhref=\"https://leetcode.cn/problems/binary-search-tree-iterator/\">173.\n二叉搜索树迭代器</a></h1>\n<p>实现一个二叉搜索树迭代器类<code>BSTIterator</code>，表示一个按中序遍历二叉搜索树（<code>BST</code>）的迭代器：\n<code>BSTIterator(TreeNode root)</code>初始化\n<code>BSTIterator</code>类的一个对象。<code>BST</code>的根节点\n<code>root</code>会作为构造函数的一部分给出。指针应初始化为一个不存在于\n<code>BST</code>中的数字，且该数字小于 BST 中的任何元素。\n<code>boolean hasNext()</code>如果向指针右侧遍历存在数字，则返回\n<code>true</code>；否则返回 <code>false</code>。\n<code>int next()</code>将指针向右移动，然后返回指针处的数字。\n注意，指针初始化为一个不存在于\n<code>BST</code>中的数字，所以对<code>next()</code>的首次调用将返回\n<code>BST</code>中的最小元素。</p>\n<p>你可以假设 <code>next()</code>\n调用总是有效的，也就是说，当调用<code>next()</code>\n时，<code>BST</code>的中序遍历中至少存在一个下一个数字。</p>\n<h2 id=\"示例\">示例：</h2>\n<p><img src=\"173_二叉搜索树迭代器/bst-tree.png\" /></p>\n<blockquote>\n<p>输入 [\"BSTIterator\", \"next\", \"next\", \"hasNext\", \"next\", \"hasNext\",\n\"next\", \"hasNext\", \"next\", \"hasNext\"] [[[7, 3, 15, null, null, 9, 20]],\n[], [], [], [], [], [], [], [], []] 输出 [null, 3, 7, true, 9, true, 15,\ntrue, 20, false]</p>\n<p>解释 BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null,\n9, 20]); bSTIterator.next(); // 返回 3 bSTIterator.next(); // 返回 7\nbSTIterator.hasNext(); // 返回 True bSTIterator.next(); // 返回 9\nbSTIterator.hasNext(); // 返回 True bSTIterator.next(); // 返回 15\nbSTIterator.hasNext(); // 返回 True bSTIterator.next(); // 返回 20\nbSTIterator.hasNext(); // 返回 False</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"思路\">思路：</h3>\n<h4 id=\"方法一扁平化\">方法一：扁平化</h4>\n<p>我们可以直接对二叉搜索树做一次完全的递归遍历，获取中序遍历的全部结果并保存在数组中。随后，我们利用得到的数组本身来实现迭代器。</p>\n<p>时间复杂度：O(n)</p>\n<p>空间复杂度：O(n)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BSTIterator</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; arr;</span><br><span class=\"line\">    <span class=\"type\">int</span> idx;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">inorder</span><span class=\"params\">(TreeNode* root, vector&lt;<span class=\"type\">int</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!root)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">inorder</span>(root-&gt;left, res);</span><br><span class=\"line\">        res.<span class=\"built_in\">push_back</span>(root-&gt;val);</span><br><span class=\"line\">        <span class=\"built_in\">inorder</span>(root-&gt;right, res);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode* root)</span></span>&#123;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; res;</span><br><span class=\"line\">        <span class=\"built_in\">inorder</span>(root, res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">BSTIterator</span>(TreeNode* root): <span class=\"built_in\">idx</span>(<span class=\"number\">0</span>), <span class=\"built_in\">arr</span>(<span class=\"built_in\">inorderTraversal</span>(root)) &#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> arr[idx++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (idx &lt; arr.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二迭代\">方法二：迭代</h4>\n<p>利用栈，通过迭代的方式对二叉树做中序遍历。此时，我们无需预先计算出中序遍历的全部结果，只需要实时维护当前栈的情况即可。</p>\n<p>时间复杂度：O(n)</p>\n<p>空间复杂度：O(n)，取决于栈的深度，最坏情况为一条链。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BSTIterator1</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    TreeNode* cur;</span><br><span class=\"line\">    stack&lt;TreeNode*&gt; stk;</span><br><span class=\"line\">    <span class=\"built_in\">BSTIterator</span>(TreeNode* root): <span class=\"built_in\">cur</span>(root) &#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur != <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            stk.<span class=\"built_in\">push</span>(cur);</span><br><span class=\"line\">            cur = cur-&gt;left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cur = stk.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        stk.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> ret = cur-&gt;val;</span><br><span class=\"line\">        cur = cur-&gt;right;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cur != <span class=\"literal\">nullptr</span> || !stk.<span class=\"built_in\">empty</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["二叉树 - 二叉搜索树"],"tags":["二叉树 - 二叉搜索树 - 迭代器"]},{"title":"199_二叉树的右视图","url":"/2022/07/31/199_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/","content":"<h1 id=\"二叉树的右视图\"><a\nhref=\"https://leetcode.cn/problems/binary-tree-right-side-view/\">199.\n二叉树的右视图</a></h1>\n<p>给定一个二叉树的 <strong>根节点</strong>\n<code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>\n<h2 id=\"示例\">示例：</h2>\n<p><img\nsrc=\"https://sjchen404.oss-cn-shenzhen.aliyuncs.com/img/4.jpg\" /></p>\n<blockquote>\n<p>输入: [1,2,3,null,5,null,4] 输出: [1,3,4]</p>\n</blockquote>\n<blockquote>\n<p>输入: [] 输出: []</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"思路\">思路：</h3>\n<h4 id=\"方法一bfs\">方法一：BFS</h4>\n<p>每次把当前层最后一个结点输出即可 时间复杂度：O(n)\n空间复杂度：O(n)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">rightSideView</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">        queue&lt;TreeNode*&gt; q;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; res;</span><br><span class=\"line\">        q.<span class=\"built_in\">push</span>(root);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> sz = q.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; sz; i++) &#123;</span><br><span class=\"line\">                TreeNode* cur = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">                q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(i == sz - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    res.<span class=\"built_in\">push_back</span>(cur-&gt;val);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(cur-&gt;left != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                    q.<span class=\"built_in\">push</span>(cur-&gt;left);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(cur-&gt;right != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                    q.<span class=\"built_in\">push</span>(cur-&gt;right);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二dfs\">方法二：DFS</h4>\n<p>反过来的DFS,先遍历右子树再遍历左子树 每层添加一个元素\n时间复杂度：O(n) 空间复杂度：O(n)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; res;</span><br><span class=\"line\">    <span class=\"type\">int</span> depth = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">rightSideView</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        depth++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(res.<span class=\"built_in\">size</span>() &lt; depth)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 每层增加一个</span></span><br><span class=\"line\">            res.<span class=\"built_in\">push_back</span>(root-&gt;val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(root-&gt;right);</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(root-&gt;left);</span><br><span class=\"line\">        depth--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["二叉树"],"tags":["二叉树"]},{"title":"467环绕字符串中唯一的子字符串","url":"/2022/05/25/467%E7%8E%AF%E7%BB%95%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%94%AF%E4%B8%80%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/","content":"<h1 id=\"环绕字符串中唯一的子字符串\"><a\nhref=\"https://leetcode.cn/problems/unique-substrings-in-wraparound-string/\">467.\n环绕字符串中唯一的子字符串</a></h1>\n<p>把字符串 <code>s</code>看作是\n<code>“abcdefghijklmnopqrstuvwxyz”</code>的无限环绕字符串，所以 s\n看起来是这样的：</p>\n<p><code>\"...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....\"</code>\n. 现在给定另一个字符串 <code>p</code>。返回 <code>s</code>中 唯一 的\n<code>p</code>的 非空子串 的数量 。</p>\n<h2 id=\"示例\">示例：</h2>\n<blockquote>\n<p>输入: p = \"a\" 输出: 1 解释: 字符串 s 中只有一个\"a\"子字符。</p>\n</blockquote>\n<blockquote>\n<p>输入: p = \"cac\" 输出: 2 解释: 字符串 s\n中的字符串“cac”只有两个子串“a”、“c”。.</p>\n</blockquote>\n<blockquote>\n<p>输入: p = \"zab\" 输出: 6 解释: 在字符串 s\n中有六个子串“z”、“a”、“b”、“za”、“ab”、“zab”。</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"思路\">思路：</h3>\n<p>线性dp，<code>dp[i]</code> 是以\n<code>p[i]</code>为结尾的最大有效子串长度\n如果<code>p[i] - p[i - 1] == 1</code>或<code>p[i] == 'a' &amp;&amp; p[i - 1] == 'z'</code>,则<code>dp[i] = dp[i - 1] + 1</code>\n否则只能自己组成子串</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">findSubstringInWraproundString</span><span class=\"params\">(string p)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> mp[<span class=\"number\">26</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = p.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(n, <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">        mp[p[<span class=\"number\">0</span>] - <span class=\"string\">&#x27;a&#x27;</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p[i] - p[i - <span class=\"number\">1</span>] == <span class=\"number\">1</span> || p[i] == <span class=\"string\">&#x27;a&#x27;</span> &amp;&amp; p[i - <span class=\"number\">1</span>] == <span class=\"string\">&#x27;z&#x27;</span>)&#123;</span><br><span class=\"line\">                dp[i] = dp[i - <span class=\"number\">1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            mp[p[i] - <span class=\"string\">&#x27;a&#x27;</span>] = <span class=\"built_in\">max</span>(mp[p[i] - <span class=\"string\">&#x27;a&#x27;</span>], dp[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">26</span>; i++)&#123;</span><br><span class=\"line\">            res += mp[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["动态规划"],"tags":["动态规划"]},{"title":"508_出现次数最多的子树元素和","url":"/2022/06/19/508_%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AD%90%E6%A0%91%E5%85%83%E7%B4%A0%E5%92%8C/","content":"<h1 id=\"出现次数最多的子树元素和\"><a\nhref=\"https://leetcode.cn/problems/most-frequent-subtree-sum/\">508.\n出现次数最多的子树元素和</a></h1>\n<p>给你一个二叉树的根结点\n<code>root</code>，请返回出现次数最多的子树元素和。如果有多个元素出现的次数相同，返回所有出现次数最多的子树元素和（不限顺序）。</p>\n<p>一个结点的 「子树元素和」\n定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）。</p>\n<h2 id=\"示例\">示例：</h2>\n<p><img src=\"508_出现次数最多的子树元素和/freq1-tree.jpg\" /></p>\n<blockquote>\n<p>输入: root = [5,2,-3] 输出: [2,-3,4]</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"思路\">思路：</h3>\n<p><strong>DFS + 哈希表：</strong></p>\n<p>我们每次判断</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">unordered_map&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt; mp;</span><br><span class=\"line\">sum = root-&gt;val + leftSum + rightSum;</span><br><span class=\"line\">maxCnt = <span class=\"built_in\">max</span>(maxCnt, ++mp[sum]);</span><br></pre></td></tr></table></figure>\n<p>时间复杂度为：<code>O(n)</code></p>\n<p>空间复杂度为：<code>O(n)</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> maxCnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    unordered_map&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt; mp;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">findFrequentTreeSum</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(root);</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;[s, c] : mp)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(c == maxCnt)&#123;</span><br><span class=\"line\">                res.<span class=\"built_in\">push_back</span>(s);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(TreeNode *root)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> sum = root-&gt;val + <span class=\"built_in\">dfs</span>(root-&gt;left) + <span class=\"built_in\">dfs</span>(root-&gt;right);</span><br><span class=\"line\">        <span class=\"comment\">// 更新出现度最大次数</span></span><br><span class=\"line\">        maxCnt = <span class=\"built_in\">max</span>(maxCnt, ++mp[sum]);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["二叉树"],"tags":["二叉树"]},{"title":"91_解码方法","url":"/2022/07/15/91_%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/","content":"<p>[[toc]] # <a href=\"https://leetcode.cn/problems/decode-ways/\">91.\n解码方法</a></p>\n<p>一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：</p>\n<blockquote>\n<p>'A' -&gt; \"1\" 'B' -&gt; \"2\" ... 'Z' -&gt; \"26\"</p>\n</blockquote>\n<p>要 解码\n已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，\"11106\"\n可以映射为：</p>\n<p>\"AAJF\" ，将消息分组为 (1 1 10 6) \"KJF\" ，将消息分组为 (11 10 6)\n注意，消息不能分组为  (1 11 06) ，因为 \"06\" 不能映射为 \"F\" ，这是由于\n\"6\" 和 \"06\" 在映射中并不等价。</p>\n<p>给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数\n。</p>\n<p>题目数据保证答案肯定是一个 32 位 的整数。</p>\n<h2 id=\"示例1\">示例1:</h2>\n<blockquote>\n<p>输入：s = \"12\" 输出：2 解释：它可以解码为 \"AB\"（1 2）或者\n\"L\"（12）。</p>\n</blockquote>\n<blockquote>\n<p>输入：s = \"226\" 输出：3 解释：它可以解码为 \"BZ\" (2 26), \"VF\" (22 6),\n或者 \"BBF\" (2 2 6) 。</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"思路\">思路：</h3>\n<p>我们设<code>dp[i]</code>表示<code>s[0...i-1]</code>的解码数量。\n不难发现对于字符串<code>s</code>的某个位置<code>i</code>而言，我们只关心「位置<code>i</code>自己是否能独立形成一个字母」和「位置<code>i</code>能够与上一个位置<code>[i-1]</code>能否形成一个字母」，\n不关心<code>i-1</code>之前的位置。</p>\n<p>所以一共有两种情况： * <code>s[i]</code>本身作为一个字母 *\n<code>s[i]</code>和<code>s[i-1]</code>结合起来为一个字母</p>\n<p><strong>状态转移方程为：</strong></p>\n<p><span class=\"math display\">\\[\ndp[i]= \\begin{cases}\ndp[i] + dp[i-1], &amp; \\text {s[i] &gt;= &#39;1&#39; \\&amp;\\&amp; s[i]\n&lt;= &#39;9&#39;} \\\\\ndp[i] + dp[i-2], &amp; \\text{(s[i-2] == 1 || s[i-2] == 2) \\&amp;\\&amp;\ns[i-1] &lt;= &#39;6&#39;}\n\\end{cases}\n\\]</span></p>\n<p>时间复杂度：<code>O(n)</code> 空间复杂度：<code>O(n)</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">numDecodings</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n &lt; <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// dp[i] 表示 s[0..i-1] 的解码方式数量</span></span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(n + <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"comment\">// bace case</span></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        dp[<span class=\"number\">1</span>] = s[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;0&#x27;</span> ? <span class=\"number\">0</span> : <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">2</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">char</span> c = s[i - <span class=\"number\">1</span>], d = s[i - <span class=\"number\">2</span>];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"string\">&#x27;1&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class=\"string\">&#x27;9&#x27;</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 1. s[i] 本身可以作为一个字母</span></span><br><span class=\"line\">                dp[i] += dp[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(d == <span class=\"string\">&#x27;1&#x27;</span> || d == <span class=\"string\">&#x27;2&#x27;</span> &amp;&amp; c &lt;= <span class=\"string\">&#x27;6&#x27;</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 2. s[i] 和 d[i - 1] 结合起来表示一个字母</span></span><br><span class=\"line\">                dp[i] += dp[i - <span class=\"number\">2</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>空间优化：</strong></p>\n<p>根据上面情况，我们可以看出<code>dp[i]</code>只依赖<code>dp[i-1]</code>和<code>dp[i-2]</code>两个状态。\n因此我们可以使用滚动数组的思路来优化空间。</p>\n<p>时间复杂度：<code>O(n)</code> 空间复杂度：<code>O(1)</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">numDecodings</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n &lt; <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> dp_i_2 = <span class=\"number\">0</span>, dp_i_1 = <span class=\"number\">1</span>, dp_i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            dp_i = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[i - <span class=\"number\">1</span>] != <span class=\"string\">&#x27;0&#x27;</span>) &#123;</span><br><span class=\"line\">                dp_i += dp_i_1;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i &gt; <span class=\"number\">1</span> &amp;&amp; s[i - <span class=\"number\">2</span>] != <span class=\"string\">&#x27;0&#x27;</span> &amp;&amp; ((s[i - <span class=\"number\">2</span>] - <span class=\"string\">&#x27;0&#x27;</span>) * <span class=\"number\">10</span> + (s[i - <span class=\"number\">1</span>] - <span class=\"string\">&#x27;0&#x27;</span>) &lt;= <span class=\"number\">26</span>)) &#123;</span><br><span class=\"line\">                dp_i += dp_i_2;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            dp_i_2 = dp_i_1;</span><br><span class=\"line\">            dp_i_1 = dp_i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp_i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["动态规划"],"tags":["动态规划"]},{"title":"BFS算法解题套路","url":"/2022/04/06/BFS%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E5%A5%97%E8%B7%AF/","content":"<p>BFS相对DFS的最主要的区别是：<strong>BFS找到的路径一定是最短的，但代价就是空间复杂度可能比DFS大很多</strong>。我们后面可以看出来，这里先介绍下BFS框架。</p>\n<span id=\"more\"></span>\n<h1 id=\"算法框架\">算法框架</h1>\n<p>==BFS的本质就是让你在一副「图」中找到从起点start\n到终点rarget的最近距离。==</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//计算从起点 start 到终点 target 的最近距离</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">BFS</span><span class=\"params\">(Node* start, Node* target)</span></span>&#123;</span><br><span class=\"line\">  queue&lt;Node*&gt; q;</span><br><span class=\"line\">  set&lt;Node*&gt; visited; <span class=\"comment\">//避免走回头路</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  q.<span class=\"built_in\">push</span>(start);<span class=\"comment\">//将起点加入队列</span></span><br><span class=\"line\">  visited.<span class=\"built_in\">push</span>(start);</span><br><span class=\"line\">  <span class=\"type\">int</span> step = <span class=\"number\">0</span>; <span class=\"comment\">//记录扩散的步数</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> sz = q.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"comment\">/*将当前队列中的所有节点向四周扩散*/</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; sz; i++)&#123;</span><br><span class=\"line\">      Node* cur = q.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">      q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">      <span class=\"comment\">/*重点：这里判断是否达到终点*/</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(cur is target)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> step;</span><br><span class=\"line\">      <span class=\"comment\">/*将 cur 的相邻节点加入队列*/</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span>(Node x : cur.<span class=\"built_in\">adj</span>())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x <span class=\"keyword\">not</span> in visited)&#123;</span><br><span class=\"line\">          q.<span class=\"built_in\">push</span>(x);</span><br><span class=\"line\">          visited.<span class=\"built_in\">push</span>(x);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//重点：更新步数在这里</span></span><br><span class=\"line\">    step++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二叉树的最小深度\"><a\nhref=\"https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/\">111.\n二叉树的最小深度</a></h2>\n<p>给定一个二叉树，找出其最小深度。</p>\n<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>\n<p><strong>说明：</strong>叶子节点是指没有子节点的节点。</p>\n<h3 id=\"示例\">示例：</h3>\n<figure>\n<img src=\"BFS算法解题套路/1.jpg\" alt=\"BFS算法解题套路\" />\n<figcaption aria-hidden=\"true\">BFS算法解题套路</figcaption>\n</figure>\n<blockquote>\n<p>输入：root = [3,9,20,null,null,15,7] 输出：2</p>\n</blockquote>\n<h3 id=\"思路\">思路：</h3>\n<p>我们首先需要明确一下起点 start 和终点 target\n是什么，怎么判断是否到达了终点？</p>\n<p>显然起点就是根节点，终点就是最靠近根节点的那个叶子节点。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(cur-&gt;left == <span class=\"literal\">nullptr</span> &amp;&amp; cur-&gt;right == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t<span class=\"comment\">//达到叶子节点</span></span><br></pre></td></tr></table></figure>\n<p>完整代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">minDepth</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//bfs</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        queue&lt;TreeNode*&gt; q;</span><br><span class=\"line\">        q.<span class=\"built_in\">push</span>(root);</span><br><span class=\"line\">        <span class=\"comment\">//root 本身为一层</span></span><br><span class=\"line\">        <span class=\"type\">int</span> depth = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> sz = q.<span class=\"built_in\">size</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; sz; i++)&#123;</span><br><span class=\"line\">                TreeNode* cur = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">                q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">//判断是否达到叶子节点</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(cur-&gt;left == <span class=\"literal\">nullptr</span> &amp;&amp; cur-&gt;right == <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> depth;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(cur-&gt;left != <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">                    q.<span class=\"built_in\">push</span>(cur-&gt;left);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(cur-&gt;right != <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">                    q.<span class=\"built_in\">push</span>(cur-&gt;right);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            depth++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> depth;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这里我们解答下两个问题：</p>\n<p><strong>1，为什么BFS可以找到最短路径，DFS不行吗？</strong></p>\n<p>首先，BFS的<code>depth</code>每增加一次，队列中的所有节点都向前迈一步，这保证了第一次到达终点的时候，走的步数是最短的。</p>\n<p>而DFS当然也可以找到最短路径，但是复杂度相对高很多。因为DFS需要把二叉树所有的分支都搜索完才能对比出最短的路径。</p>\n<p><strong>2，既然BFS那么好，为啥还需要DFS</strong></p>\n<p>BFS可以找到最短路径，但是空间复杂度高，而DFS的空间复杂度较低。</p>\n<p>例如，给你一颗满二叉树，节点数为<code>N</code>，对于DFS来说最坏情况下顶多就是树的高度，也就是<code>O(logN)</code></p>\n<p>而BFS，最坏情况下空间复杂度应该是树的最底层节点的数量，也就是<code>N/2</code>，<code>O(N)</code></p>\n<p>由此可以看出，BFS还是有代价的，一般来说在找最短路径的时候使用BFS，其他时候还是DFS使用比较多一点。</p>\n","categories":["BFS"],"tags":["BFS","leetcode"]},{"title":"C++智能指针","url":"/2022/05/08/C++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/","content":"<p>为了更容易（同时也更安全）地使用动态内存，新的标准库提供了两种<strong>智能指针</strong>类型来管理动态对象。智能指针的行为类似常规指针，最重要的区别是它负责自动释放所指向的对象。不需要考虑内存泄露。</p>\n<p><code>shared_ptr</code>允许多个指针指向同一个对象；</p>\n<p><code>unique_ptr</code>则独占所指向的对象；</p>\n<p>标准库还定义了一个名为<code>weak_ptr</code>的伴随类，它是一种弱引用，指向<code>shared_ptr</code>所管理的对象。这三种类型都定义在<code>memory</code>头文件中。</p>\n<span id=\"more\"></span>\n<h1 id=\"unique_ptr\">1. unique_ptr</h1>\n<p>一个<code>unique_ptr</code>拥有它所指向的对象。</p>\n<p>当我们定义一个<code>unique_ptr</code>时，需要将其绑定到一个<code>new</code>返回的指针上，初始化<code>unique_ptr</code>必须采用直接初始化形式。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;memory&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">unique_ptr&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">unPtr1</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"type\">int</span>(<span class=\"number\">10</span>))</span></span>;</span><br><span class=\"line\">    cout &lt;&lt; *unPtr1 &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<blockquote>\n<p>10</p>\n</blockquote>\n<p><strong><code>unique_ptr</code>不支持普通的拷贝或赋值操作。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">unique_ptr&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">unPtr1</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"type\">int</span>(<span class=\"number\">10</span>))</span></span>;</span><br><span class=\"line\"><span class=\"function\">unique_ptr&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">unPtr2</span><span class=\"params\">(unPtr1)</span></span>;\t\t<span class=\"comment\">//error: unique_ptr 不支持拷贝</span></span><br><span class=\"line\">unique_ptr&lt;<span class=\"type\">int</span>&gt; unPtr2 = unPtr1;\t<span class=\"comment\">//error: unique_ptr 不支持赋值</span></span><br></pre></td></tr></table></figure>\n<p>虽然我们不能拷贝或赋值<code>unique_ptr</code>，但可以通过调用<code>move</code>来转移所有权。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">unique_ptr&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">unPtr1</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"type\">int</span>(<span class=\"number\">10</span>))</span></span>;</span><br><span class=\"line\">unique_ptr&lt;<span class=\"type\">int</span>&gt; unPtr2 = <span class=\"built_in\">move</span>(unPtr1);</span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">&quot;unptr2 = &quot;</span> &lt;&lt; *unPtr2 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<blockquote>\n<p>unptr2 = 10</p>\n</blockquote>\n<p><strong>需要注意的是，一旦你转移了指针的所有权，之前的所有者，也就是<code>unPtr1</code>就变为了空指针。</strong></p>\n<p>C++\n11标准库中默认实现了<code>make_shared</code>，但是没有给出一个<code>make_unique</code>的实现。\n本例实现<code>make_unique</code>。 技术要点：\n1.使用模板函数重载，分别支持普通指针，变长数组，不支持定长数组\n2.<code>std::enable_if</code>关键字根据不同条件，调用不同模板\n3.<code>std::unique_ptr</code>能构造和析构数组</p>\n<p><code>make_unique.h</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> _MAKE_UNIQUE_HPP_</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _MAKE_UNIQUE_HPP_</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;type_traits&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;memory&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 单一元素类模板定义</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">using</span> Ele = <span class=\"keyword\">typename</span> std::enable_if&lt;!std::is_array&lt;T&gt;::value, std::unique_ptr&lt;T&gt; &gt;::type;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 变长数组类模板定义</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">using</span> Slice = <span class=\"keyword\">typename</span> std::enable_if&lt;std::is_array&lt;T&gt;::value &amp;&amp; std::extent&lt;T&gt;::value == <span class=\"number\">0</span>, std::unique_ptr&lt;T&gt;&gt;::type;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定长数组类模板定义</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">using</span> Arr = <span class=\"keyword\">typename</span> std::enable_if&lt;std::extent&lt;T&gt;::value != <span class=\"number\">0</span>, <span class=\"type\">void</span>&gt;::type;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 支持普通指针</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span> ... Args&gt; <span class=\"function\"><span class=\"keyword\">inline</span></span></span><br><span class=\"line\"><span class=\"function\">Ele&lt;T&gt; <span class=\"title\">make_unique</span><span class=\"params\">(Args &amp;&amp; ... args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> std::<span class=\"built_in\">unique_ptr</span>&lt;T&gt;(<span class=\"keyword\">new</span> <span class=\"built_in\">T</span>(std::forward&lt;Args&gt;(args)...));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 支持动态数组</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"function\"><span class=\"keyword\">inline</span></span></span><br><span class=\"line\"><span class=\"function\">Slice&lt;T&gt; <span class=\"title\">make_unique</span><span class=\"params\">(<span class=\"type\">size_t</span> size)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">using</span> U = <span class=\"keyword\">typename</span> std::remove_extent&lt;T&gt;::type;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> std::<span class=\"built_in\">unique_ptr</span>&lt;T&gt;(<span class=\"keyword\">new</span> U[size]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 过滤定长数组</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span> ... Args&gt;</span><br><span class=\"line\"><span class=\"function\">Arr&lt;T&gt; <span class=\"title\">make_unique</span><span class=\"params\">(Args &amp;&amp;...)</span> </span>= <span class=\"keyword\">delete</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;memory&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;make_unique.h&quot;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">myClass</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">myClass</span>()&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;Constructor invoked \\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">myClass</span>()&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;Destructor invoked \\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    unique_ptr&lt;myClass&gt; unPtr1 = <span class=\"built_in\">make_unique</span>&lt;myClass&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<blockquote>\n<p>Constructor invoked Destructor invoked</p>\n</blockquote>\n<h1 id=\"shared_ptr\">2. shared_ptr</h1>\n<p>共享指针可以被共享，可以被多个所有者共享。智能指针也是模版，当我们创建一个智能指针时，必须提供额外的信息------指针可以指向的类型。</p>\n<h2 id=\"如何创建shared_ptr\">2.1 如何创建<code>shared_ptr</code></h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;memory&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">myClass</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">myClass</span>()&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;Constructor invoked \\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">myClass</span>()&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;Destructor invoked \\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    shared_ptr&lt;myClass&gt; shPtr1 = <span class=\"built_in\">make_shared</span>&lt;myClass&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"C++智能指针/2.jpg\" /></p>\n<p>共享指针有所有指向这个指针的引用次数。我们可以通过<code>use_count</code>方法来查询：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;memory&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">myClass</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">myClass</span>()&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;Constructor invoked \\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">myClass</span>()&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;Destructor invoked \\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    shared_ptr&lt;myClass&gt; shPtr1 = <span class=\"built_in\">make_shared</span>&lt;myClass&gt;();</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Shared count: &quot;</span> &lt;&lt; shPtr1.<span class=\"built_in\">use_count</span>() &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果为：</p>\n<blockquote>\n<p>Constructor invoked Shared count: 1 Destructor invoked</p>\n</blockquote>\n<p>可以看出我们只有一个指向这个类的指针。所以结果为<code>1</code>,我们再创建一个类共享指针。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">shared_ptr&lt;myClass&gt; shPtr1 = <span class=\"built_in\">make_shared</span>&lt;myClass&gt;();</span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">&quot;Shared count: &quot;</span> &lt;&lt; shPtr1.<span class=\"built_in\">use_count</span>() &lt;&lt; endl;</span><br><span class=\"line\">shared_ptr&lt;myClass&gt; shPtr2 = shPtr1;</span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">&quot;Shared count: &quot;</span> &lt;&lt; shPtr1.<span class=\"built_in\">use_count</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<blockquote>\n<p>Constructor invoked Shared count: 1 Shared count: 2 Destructor\ninvoked</p>\n</blockquote>\n<p>可以看出此时结果为2。当我们销毁一个指向这个类的指针时，引用次数减一，直到引用次数为<code>0</code>，内存才会被释放。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">shared_ptr&lt;myClass&gt; shPtr1 = <span class=\"built_in\">make_shared</span>&lt;myClass&gt;();</span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">&quot;Shared count: &quot;</span> &lt;&lt; shPtr1.<span class=\"built_in\">use_count</span>() &lt;&lt; endl;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    shared_ptr&lt;myClass&gt; shPtr2 = shPtr1;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Shared count: &quot;</span> &lt;&lt; shPtr1.<span class=\"built_in\">use_count</span>() &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">&quot;Shared count: &quot;</span> &lt;&lt; shPtr1.<span class=\"built_in\">use_count</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>\n<p>输出结果为：</p>\n<blockquote>\n<p>Shared count: 1 Shared count: 2 Shared count: 1</p>\n</blockquote>\n<p>可以看到<code>shPtr2</code>超出它的作用域之后就被销毁了，所以最后的引用次数为<code>1</code>。</p>\n<h1 id=\"weak_ptr\">3. weak_ptr</h1>\n<p>弱引用<code>weak_ptr</code>是一种不控制所指向对象生存期的智能指针，它指向由一个<code>shared_ptr</code>管理的对象。前面我们知道多个<code>shared_ptr</code>指向一个特定的内存位置时，会导致引用次数的增加。而将一个<code>weak_ptr</code>绑定到一个<code>shared_ptr</code>不会改变<code>share_ptr</code>的引用次数。一旦最后一个指向对象的<code>shared_ptr</code>被销毁，对象就会被释放，即使<code>weak_ptr</code>指向对象，对象也会被释。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">weak_ptr&lt;<span class=\"type\">int</span>&gt; wePtr1;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        shared_ptr&lt;<span class=\"type\">int</span>&gt; shPtr1 = <span class=\"built_in\">make_shared</span>&lt;<span class=\"type\">int</span>&gt;(<span class=\"number\">25</span>);</span><br><span class=\"line\">        wePtr1 = shPtr1;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><code>weptr1</code>就被赋值为<code>25</code></p>\n","categories":["智能指针"],"tags":["智能指针"]},{"title":"C++中set的用法","url":"/2019/04/05/C-%E4%B8%ADset%E7%9A%84%E7%94%A8%E6%B3%95/","content":"<p>set的特性是，所有元素都会根据元素的键值自动排序，set的元素不像map那样可以同时拥有实值(value)和键值(key),set元素的键值就是实值，实值就是键值。set不允许两个元素有相同的键值。</p>\n<p>我们常用set来查重。</p>\n<span id=\"more\"></span>\n<p><strong>set的各成员函数列表如下:</strong></p>\n<ol type=\"1\">\n<li><p>begin()--返回指向第一个元素的迭代器</p></li>\n<li><p>clear()--清除所有元素</p></li>\n<li><p>count()--返回某个值元素的个数</p></li>\n<li><p>empty()--如果集合为空，返回true</p></li>\n<li><p>end()--返回指向最后一个元素的迭代器</p></li>\n<li><p>equal_range()--返回集合中与给定值相等的上下限的两个迭代器</p></li>\n<li><p>erase()--删除集合中的元素</p></li>\n<li><p>find()--返回一个指向被查找到元素的迭代器</p></li>\n<li><p>get_allocator()--返回集合的分配器</p></li>\n<li><p>insert()--在集合中插入元素</p></li>\n<li><p>lower_bound()--返回指向大于（或等于）某值的第一个元素的迭代器</p></li>\n<li><p>key_comp()--返回一个用于元素间值比较的函数</p></li>\n<li><p>max_size()--返回集合能容纳的元素的最大限值</p></li>\n<li><p>rbegin()--返回指向集合中最后一个元素的反向迭代器</p></li>\n<li><p>rend()--返回指向集合中第一个元素的反向迭代器</p></li>\n<li><p>size()--集合中元素的数目</p></li>\n<li><p>swap()--交换两个集合变量</p></li>\n<li><p>upper_bound()--返回大于某个值元素的迭代器</p></li>\n<li><p>value_comp()--返回一个用于比较元素间的值的函数</p></li>\n</ol>\n<p>下面我们主要讲set中遍历：</p>\n<p>假设我们对一个数组进行排序，并且里面不能有重复的元素。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;set&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> a[<span class=\"number\">11</span>] =&#123;<span class=\"number\">20</span>, <span class=\"number\">40</span>, <span class=\"number\">32</span>, <span class=\"number\">67</span>, <span class=\"number\">40</span>, <span class=\"number\">20</span>, <span class=\"number\">89</span>, <span class=\"number\">300</span>, <span class=\"number\">400</span>, <span class=\"number\">15</span>&#125;;</span><br><span class=\"line\">    set&lt;<span class=\"type\">int</span>&gt;<span class=\"built_in\">map</span>(a,a+<span class=\"number\">10</span>);</span><br><span class=\"line\">    cout &lt;&lt; map.<span class=\"built_in\">size</span>() &lt;&lt; endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (set&lt;<span class=\"type\">int</span>&gt;::iterator it=map.<span class=\"built_in\">begin</span>(); it!=map.<span class=\"built_in\">end</span>(); ++it) &#123;</span><br><span class=\"line\">        cout &lt;&lt; *it &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>大家可以做下面这道题练练手：</p>\n<p><a\nhref=\"https://www.luogu.org/problemnew/show/P1059\">我是链接</a></p>\n","categories":["C++常用STL"],"tags":["set"]},{"title":"CSAPP 第一章 计算机系统漫游","url":"/2022/04/06/CSAPP-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8/","content":"<p>计算机系统由<code>硬件</code>和<code>系统软件</code>组成。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;hello, world\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"信息就是位-上下文\">1.1 信息就是位 + 上下文</h1>\n<p>hello\n程序的生命周期是从一个<strong>源程序（源文件）</strong>开始的，文件名为<code>hello.c</code>。源程序实际就是由一个值为\n0 和 1 组成的位（比特）序列，8 个位被组织为一组，称为<em>字节</em>。</p>\n<p>大部分的现代计算机系统都使用 ASCII 标准来表示文本字符。</p>\n<span id=\"more\"></span>\n<h1 id=\"程序被其他程序翻译成不同的格式\">1.2\n程序被其他程序翻译成不同的格式</h1>\n<p>hello 程序的生命周期是从一个高级 C\n语言程序开始，因为这种形式能够被人读懂。然而，为了在系统上运行hello.c\n程序，每条C\n语句都必须被其他程序转化为一系列的<strong>低级机器语言</strong>指令。然后这些指令按照一种称为<em>可执行目标程序</em>的格式打好包，并以二进制磁盘文件的形式存放起来。目标程序也可称为<em>可执行目标文件</em>。</p>\n<p>在 Unix\n系统上，从源文件到目标文件的转化是由<em>编译器驱动程序</em>完成的：</p>\n<blockquote>\n<p>linux&gt; gcc -o hello hello.c</p>\n</blockquote>\n<p><img src=\"CSAPP-第一章-计算机系统漫游/1.jpg\" /></p>\n<ul>\n<li><strong>预处理阶段</strong>。预处理器(cpp)根据以字符#开头的命令，修改原始的C程序。以<code>.i</code>作为文件扩展名。</li>\n<li><strong>编译阶段</strong>。编译器(ccl)将文本文件hello.i\n翻译成文本文件 hello.s，它包含一个<em>汇编语言程序</em>。</li>\n<li><strong>汇编阶段</strong>。接下来，汇编器(as)将hello.s\n翻译成机器语言指令，把这些指令打包成一种叫做<em>可重定位目标程序</em>的格式，并把结果保存在目标文件hello.o\n中，hello.o 文件是一个二进制文件。</li>\n<li><strong>链接阶段</strong>。链接器(ld)负责处理合并，结果就得到了hello\n文件，它是一个<em>可执行目标文件</em>，可以被加载到内存中，由系统执行。</li>\n</ul>\n<h1 id=\"了解编译系统如何工作是大有益处的\">1.3\n了解编译系统如何工作是大有益处的</h1>\n<ul>\n<li>优化程序性能</li>\n<li>理解链接时出现的错误</li>\n<li>避免安全漏洞</li>\n</ul>\n<h1 id=\"处理器读并解释存储在内存中的指令\">1.4\n处理器读并解释存储在内存中的指令</h1>\n<p>此时，hello.c\n源程序已经被编译系统翻译成了可执行目标文件hello,并被存放在磁盘上。要想在Unix\n系统上运行该可执行文件，我们将它的文件名输入到称为\n<code>shell</code>的应用程序中：</p>\n<blockquote>\n<p>linux&gt; ./hello</p>\n<p>hello, world</p>\n<p>linux&gt;</p>\n</blockquote>\n<p><code>shell</code>是一个命令行解释器。</p>\n<h2 id=\"系统的硬件组成\">1.4.1 系统的硬件组成</h2>\n<p><img src=\"CSAPP-第一章-计算机系统漫游/2.jpg\" /></p>\n<h3 id=\"总线\">1. 总线</h3>\n<p>它携带信息字节并负责在各个部件间传递。通常总线被设计成传送<strong>定长的字节块</strong>，也就是<strong>字</strong>。</p>\n<h3 id=\"io-设备\">2. I/O 设备</h3>\n<h3 id=\"主存\">3. 主存</h3>\n<p>主存是一个临时存储设备，在处理执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组<strong>动态随机存取存粗器(DRAM)</strong>芯片组成的。从逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引），这些地址是从零开始的。</p>\n<h3 id=\"处理器\">4. 处理器</h3>\n<p>中央处理器（cpu),简称处理器，是解释（执行）存储在主存中指令的引擎。</p>\n<h1 id=\"高速缓存至关重要\">1.5 高速缓存至关重要</h1>\n<p>​ hello\n程序的机器指令最初存放在磁盘上，当程序加载时，它们被复制到主存；当处理器开始运行程序时，指令又从主存复制到处理器。从程序员角度看，这些复制就是开销，减慢了程序“真正”的工作。</p>\n<p>​\n一个磁盘驱动器可能比主存大1000倍，但是对于处理器而言，从磁盘驱动器上读取一个字的时间开销要比从主存中读取的开销大1000万倍。</p>\n<p>​\n针对这种处理器与内存之间的差异，系统设计者采用了更小更快的存储设备，称为<strong>高速缓存存储器(cache)</strong>,作为暂时的集结区域，存放处理器近期可能会需要的信息。</p>\n<h1 id=\"存储设备形成层次结构\">1.6 存储设备形成层次结构</h1>\n<p><img src=\"CSAPP-第一章-计算机系统漫游/3.jpg\" /></p>\n<h1 id=\"操作系统管理硬件\">1.7 操作系统管理硬件</h1>\n<p>所有应用程序对硬件的操作尝试都必须经过操作系统。</p>\n<p>操作系统有两个基本功能：</p>\n<ul>\n<li>防止硬件被失控的应用程序滥用；</li>\n<li>向应用程序提供简单一致的机制来控制复杂而又大不相同的低级硬件设备；</li>\n</ul>\n<p>操作系统通过几个基本的抽象概念<code>（进程，虚拟内存和文件）</code>来实现这两个功能。</p>\n<p>（1），文件是对I/O设备的抽象表示。</p>\n<p>（2），虚拟内存是对主存和磁盘I/O设备的抽象表示。</p>\n<p>（3），进程是对处理器，内存和I/O设备的抽象表示。</p>\n<h2 id=\"进程\">1.7.1 进程</h2>\n<p>进程是操作系统对一个正在运行的程序的一种抽象。</p>\n<p>操作系统保持跟踪进程运行所需要的所有状态信息。这种状态，就是<strong>上下文</strong>。</p>\n<p>==进程是系统进行资源分配和调度的一个独立单位。==</p>\n<p>引入进程的目的是为了更好地使多道程序并发执行，提高资源利用率和系统吞吐率。</p>\n<h2 id=\"线程\">1.7.2 线程</h2>\n<p>一个进程实际上可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。</p>\n<p>==线程是一个基本CPU执行单元，也是程序执行的最小单元==</p>\n<p>引入线程的目的则是为了减小程序在并发时所付出的时空开销，提高操作系统的并发性能。</p>\n<h2 id=\"虚拟内存\">1.7.3 虚拟内存</h2>\n<p>虚拟内存时一个抽象概念，它为每一个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为<strong>虚拟地址空间</strong></p>\n<p><img src=\"CSAPP-第一章-计算机系统漫游/4.jpg\" /></p>\n<p>每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能。我们从最低的地址开始：</p>\n<ul>\n<li><strong>程序代码和数据</strong>。</li>\n<li><strong>堆</strong>。</li>\n<li><strong>共享库</strong>。用来存放像C标准库和数学库这样的共享库的代码和数据的区域。</li>\n<li><strong>栈</strong>。</li>\n<li><strong>内核虚拟内存</strong>。地址空间顶部的区域是为内核保留的。</li>\n</ul>\n<h2 id=\"文件\">1.7.4 文件</h2>\n<p>文件就是字节序列。每个I/O设备，甚至网络，都可以看生是文件。</p>\n<h1 id=\"系统之间利用网络通信\">1.8 系统之间利用网络通信</h1>\n","categories":["深入理解计算机系统"],"tags":["CSAPP"]},{"title":"CSAPP 第三章 程序的机器级表示","url":"/2022/06/17/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/","content":"<h1 id=\"程序编码\">3.2 程序编码</h1>\n<p>有两个文件<code>p1.c</code>和<code>p2.c</code>,我们用<code>Unix</code>命令编译这些代码</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gcc -Og -o p p1.c p2.c</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>gcc</code>:指<code>GCC</code>C编译器</p>\n<p><code>-Og</code>:告诉编译器使用生成符合原始C语言整体结构的机器代码的优化等级，使用<code>-O1,-O2</code>会导致产出的机器代码变形，难以理解。</p>\n</blockquote>\n<p><code>gcc</code>命令调用了一整套的程序，将源代码转化成可执行代码。</p>\n<p>首先，C预处理器扩展源代码，插入所有用<code>#include</code>命令指定的文件，并扩展所有用<code>#define</code>声明指定的宏。</p>\n<p>其次，编译器产出两个源文件的汇编代码，名字为<code>p1.s</code>和<code>p2.s</code></p>\n<p>接下来汇编器会将汇编代码转化成二进制目标文件<code>p1.o</code>和<code>p2.o</code></p>\n<span id=\"more\"></span>\n<p><code>main.c</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">mulstore</span><span class=\"params\">(<span class=\"type\">long</span>, <span class=\"type\">long</span>, <span class=\"type\">long</span>*)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> d;</span><br><span class=\"line\">    mulstore(<span class=\"number\">2</span>, <span class=\"number\">3</span>, &amp;d);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;2 * 3 --&gt; %ld\\n&quot;</span>, d);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"title function_\">mult2</span><span class=\"params\">(<span class=\"type\">long</span> a, <span class=\"type\">long</span> b)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> s = a * b;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>mstore.c</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">long</span> <span class=\"title function_\">mult2</span><span class=\"params\">(<span class=\"type\">long</span>,<span class=\"type\">long</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">mulstore</span><span class=\"params\">(<span class=\"type\">long</span> x, <span class=\"type\">long</span> y, <span class=\"type\">long</span> *dest)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> t = mult2(x, y);</span><br><span class=\"line\">    *dest = t;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2\nid=\"编译生成汇编文件mstore.s\">编译生成汇编文件<code>mstore.s</code></h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gcc -Og -S mstore.c</span><br></pre></td></tr></table></figure>\n<p>使用<code>vim</code>打开</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">\t.section\t__TEXT,__text,regular,pure_instructions</span><br><span class=\"line\">\t.build_version macos, <span class=\"number\">12</span>, <span class=\"number\">0</span>\tsdk_version <span class=\"number\">12</span>, <span class=\"number\">3</span></span><br><span class=\"line\">\t.globl\t_mulstore                       ## -- Begin function mulstore</span><br><span class=\"line\">\t.p2align\t<span class=\"number\">4</span>, <span class=\"number\">0x90</span></span><br><span class=\"line\">_mulstore:                              ## @mulstore</span><br><span class=\"line\">\t.cfi_startproc</span><br><span class=\"line\">## %bb<span class=\"number\">.0</span>:</span><br><span class=\"line\">\tpushq\t%rbp</span><br><span class=\"line\">\t.cfi_def_cfa_offset <span class=\"number\">16</span></span><br><span class=\"line\">\t.cfi_offset %rbp, <span class=\"number\">-16</span></span><br><span class=\"line\">\tmovq\t%rsp, %rbp</span><br><span class=\"line\">\t.cfi_def_cfa_register %rbp</span><br><span class=\"line\">\tpushq\t%rbx</span><br><span class=\"line\">\tpushq\t%rax</span><br><span class=\"line\">\t.cfi_offset %rbx, <span class=\"number\">-24</span></span><br><span class=\"line\">\tmovq\t%rdx, %rbx</span><br><span class=\"line\">\tcallq\t_mult2</span><br><span class=\"line\">\tmovq\t%rax, (%rbx)</span><br><span class=\"line\">\taddq\t$<span class=\"number\">8</span>, %rsp</span><br><span class=\"line\">\tpopq\t%rbx</span><br><span class=\"line\">\tpopq\t%rbp</span><br><span class=\"line\">\tretq</span><br><span class=\"line\">\t.cfi_endproc</span><br><span class=\"line\">                                        ## -- End function</span><br><span class=\"line\">.subsections_via_symbols</span><br></pre></td></tr></table></figure>\n<p>其中以<code>.</code>开头的行都是指导汇编器和链接器工作的伪指令，直接忽略</p>\n<p>可以简化为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">mulstore:</span><br><span class=\"line\">\tpushq\t%rbx</span><br><span class=\"line\">\tmovq\t%rdx, %rbx</span><br><span class=\"line\">\tcall\tmult2</span><br><span class=\"line\">\tmovq\t%rax, (%rbx)</span><br><span class=\"line\">\tpopq\t%rbx</span><br><span class=\"line\">\tretq</span><br></pre></td></tr></table></figure>\n<p><code>pushq %rbx</code>：将寄存器<code>rbx</code>的值压入程序栈进行保存</p>\n<blockquote>\n<p>为什么程序一开始要保存<code>rbx</code> 的内容</p>\n<p>我们先了解调用者保存寄存器和被调用者保存寄存器</p>\n<p>假如函数A调用了函数B，所以函数A就称为调用者（<code>Caller</code>），函数B为被调用者（<code>Callee</code>）</p>\n<p>由于调用了函数B，寄存器<code>rbx</code>在函数中被修改了，逻辑上寄存器<code>rbx</code>的内容在调用函数B的前后应该保持一致，解决这个问题有两个策略，</p>\n<p>第一，调用者保存：函数A在调用函数B之前，提前保存寄存器<code>rbx</code>的内容，执行完函数B之后恢复寄存器<code>rbx</code>原来存储的内容</p>\n<p>第二，被调用者保存：函数B在使用寄存器<code>rbx</code>之前，先保存寄存器<code>rbx</code>的值，在函数B返回之前，先回复寄存器<code>rbx</code>原来存储的内容</p>\n</blockquote>\n<p><code>popq %rbx</code>：在函数返回之前，恢复寄存器<code>rbx</code>的内容</p>\n<p>第二行：<code>movq   %rdx, %rbx</code>：将寄存器<code>rdx</code>的内容复制到寄存器<code>rbx</code></p>\n<p>根据寄存器用法的定义</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">mulstore</span><span class=\"params\">(<span class=\"type\">long</span> x, <span class=\"type\">long</span> y, <span class=\"type\">long</span> *dest)</span>;</span><br><span class=\"line\">x-&gt;%rdi, y-&gt;%rsi, dest-&gt;%rdx</span><br></pre></td></tr></table></figure>\n<p><code>mov</code>指令的后缀<code>\"q\"</code>表示数据的大小</p>\n<p><code>Size of Data Type in x86-64</code></p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>C 声明</th>\n<th>Inter 数据类型</th>\n<th>汇编代码后缀</th>\n<th>大小（字节）</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>char</td>\n<td>Byte</td>\n<td>b</td>\n<td>1</td>\n</tr>\n<tr class=\"even\">\n<td>short</td>\n<td>Word</td>\n<td>w</td>\n<td>2</td>\n</tr>\n<tr class=\"odd\">\n<td>int</td>\n<td>Double word</td>\n<td>l</td>\n<td>4</td>\n</tr>\n<tr class=\"even\">\n<td>long</td>\n<td>Quad word</td>\n<td>q</td>\n<td>8</td>\n</tr>\n<tr class=\"odd\">\n<td>char *</td>\n<td>Quad word</td>\n<td>q</td>\n<td>8</td>\n</tr>\n<tr class=\"even\">\n<td>float</td>\n<td>Single precision（单精度）</td>\n<td>s</td>\n<td>4</td>\n</tr>\n<tr class=\"odd\">\n<td>double</td>\n<td>Double precision（双精度）</td>\n<td>l</td>\n<td>9</td>\n</tr>\n</tbody>\n</table>\n<p><code>call mult2</code>:对应函数调用，该函数的返回值会保存到寄存器<code>rax</code>中</p>\n<p><code>movq   %rax, (%rbx)</code>：将寄存器<code>rax</code>的值送到内存中，内存的地址就存放在寄存器<code>rbx</code>中</p>\n<p><code>ret</code>:就是函数返回</p>\n<h2 id=\"翻译为机器代码-mstore.o\">翻译为机器代码\n<code>mstore.o</code></h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gcc -Og -c mstore.c</span><br></pre></td></tr></table></figure>\n<p>由于该文件是二进制的无法直接查看，我们需要用到反汇编工具----<code>objdump</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">objdump -d mstore.o</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">mstore.o:\tfile format mach-o <span class=\"number\">64</span>-bit x86<span class=\"number\">-64</span></span><br><span class=\"line\"></span><br><span class=\"line\">Disassembly of section __TEXT,__text:</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">0000000000000000</span> &lt;_mulstore&gt;:</span><br><span class=\"line\">       <span class=\"number\">0</span>: <span class=\"number\">55</span>                           \tpushq\t%rbp</span><br><span class=\"line\">       <span class=\"number\">1</span>: <span class=\"number\">48</span> <span class=\"number\">89</span> e5                     \tmovq\t%rsp, %rbp</span><br><span class=\"line\">       <span class=\"number\">4</span>: <span class=\"number\">53</span>                           \tpushq\t%rbx</span><br><span class=\"line\">       <span class=\"number\">5</span>: <span class=\"number\">50</span>                           \tpushq\t%rax</span><br><span class=\"line\">       <span class=\"number\">6</span>: <span class=\"number\">48</span> <span class=\"number\">89</span> d3                     \tmovq\t%rdx, %rbx</span><br><span class=\"line\">       <span class=\"number\">9</span>: e8 <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span> <span class=\"number\">00</span>               \tcallq\t<span class=\"number\">0xe</span> &lt;_mulstore+<span class=\"number\">0xe</span>&gt;</span><br><span class=\"line\">       e: <span class=\"number\">48</span> <span class=\"number\">89</span> <span class=\"number\">03</span>                     \tmovq\t%rax, (%rbx)</span><br><span class=\"line\">      <span class=\"number\">11</span>: <span class=\"number\">48</span> <span class=\"number\">83</span> c4 <span class=\"number\">08</span>                  \taddq\t$<span class=\"number\">8</span>, %rsp</span><br><span class=\"line\">      <span class=\"number\">15</span>: <span class=\"number\">5b</span>                           \tpopq\t%rbx</span><br><span class=\"line\">      <span class=\"number\">16</span>: <span class=\"number\">5</span>d                           \tpopq\t%rbp</span><br><span class=\"line\">      <span class=\"number\">17</span>: c3                           \tretq</span><br></pre></td></tr></table></figure>\n<h1 id=\"数据格式\">3.3 数据格式</h1>\n<p>大多数指令有一个或多个操作数，指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。</p>\n<p>各种不同的操作数的被分为三种类型：</p>\n<ul>\n<li>立即数：在<code>ATT</code>格式的汇编代码中是<code>$</code>后面跟一个用标准C表示法表示的整数</li>\n<li>寄存器：</li>\n<li>内存引用：<span class=\"math inline\">\\(M_b[addr]\\)</span></li>\n</ul>\n<p>内存引用：</p>\n<blockquote>\n<p>Imm(<span class=\"math inline\">\\(r_b,r_i,s\\)</span>) ----&gt; Imm +\n<span class=\"math inline\">\\(R[r_b] + R[r_i]*s\\)</span></p>\n<p>Imm ----&gt; 立即数</p>\n<p><span class=\"math inline\">\\(r_b\\)</span>----&gt; 基址寄存器</p>\n<p><span class=\"math inline\">\\(r_i\\)</span>----&gt;变址寄存器</p>\n<p>s ----&gt; 比例因子【1,2,4,8】</p>\n<p>编译器会根据数组类型来确定比例因子的数值</p>\n</blockquote>\n<p><code>Mov</code>指令</p>\n<blockquote>\n<p>MOV 源操作数 目的操作数</p>\n<p>源操作数可以为：立即数，寄存器，内存</p>\n<p>目的操作数可以为：寄存器，内存，但是不能为立即数</p>\n<p>MOV指令的源操作数和目的操作数不能都是内存的地址</p>\n<p>当需要从内存一个地方复制到另一个地方时，需要用两条mov指令</p>\n<p>mov memory , register</p>\n<p>mov register, memory</p>\n<p>MOV指令的后缀需要与寄存器的大小匹配</p>\n</blockquote>\n<p><img src=\"CSAPP-第三章-程序的机器级表示/1.jpg\" /></p>\n<h1 id=\"栈与数据传送\">3.4 栈与数据传送</h1>\n<p><img src=\"CSAPP-第三章-程序的机器级表示/2.jpg\" /></p>\n<blockquote>\n<p><code>long</code>:64 --&gt; %rax</p>\n<p><code>int</code>:32 --&gt; %eax</p>\n<p><code>short</code>:16 --&gt; %ax</p>\n<p>低8位 --&gt; %al</p>\n</blockquote>\n<p><strong>数据传送示例：</strong></p>\n<p><code>main.c</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"title function_\">exchange</span><span class=\"params\">(<span class=\"type\">long</span>*, <span class=\"type\">long</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">  <span class=\"type\">long</span> a = <span class=\"number\">4</span>;</span><br><span class=\"line\">  <span class=\"type\">long</span> b = exchange(&amp;a, <span class=\"number\">3</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;a = %ld, b = %ld\\n&quot;</span>, a, b);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>exchange.c</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">long</span> <span class=\"title function_\">exchange</span><span class=\"params\">(<span class=\"type\">long</span> *xp, <span class=\"type\">long</span> y)</span>&#123;</span><br><span class=\"line\">  <span class=\"type\">long</span> x = *xp;</span><br><span class=\"line\">  *xp = y;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编译<code>exchange.c</code>为汇编代码</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gcc -Og -S exchange.c</span><br></pre></td></tr></table></figure>\n<p>去除多余没用信息后</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">exchange:</span><br><span class=\"line\">\tmovq\t(%rdi), %rax</span><br><span class=\"line\">\tmovq\t%rsi, (%rdi)</span><br><span class=\"line\">\tretq</span><br></pre></td></tr></table></figure>\n<p><code>%rdi</code>保存函数的第一个参数，<code>%rsi</code>保存函数的第二个参数</p>\n<p>所以可以这样理解</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">exchange:</span><br><span class=\"line\">\txp in %rdi, y in %rsi</span><br><span class=\"line\">\t<span class=\"title function_\">movq</span>\t<span class=\"params\">(%rdi)</span>, %rax    <span class=\"comment\">//Memory --&gt; Registor long x = *xp</span></span><br><span class=\"line\">\tmovq\t%rsi, <span class=\"params\">(%rdi)</span>\t\t<span class=\"comment\">//Register --&gt; Memory *xp = y</span></span><br><span class=\"line\">\tretq</span><br></pre></td></tr></table></figure>\n<h2 id=\"栈\">栈</h2>\n<p><img src=\"CSAPP-第三章-程序的机器级表示/3.jpg\" /></p>\n<p>栈顶是栈中地址最低的。</p>\n<p><strong>入栈push:</strong></p>\n<p>先将地址减小，再入栈</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">pushq %rax</span><br><span class=\"line\">subq $8, %rsp</span><br><span class=\"line\">movq %rax, (%rsp)</span><br></pre></td></tr></table></figure>\n<p><code>pushq</code>就等于上面两条指令</p>\n<p><strong>出栈pop:</strong></p>\n<p>先出栈，再把地址增加</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">popq %rbx</span><br><span class=\"line\">movq (%rsp), %rbx</span><br><span class=\"line\">addq $8, %rsp</span><br></pre></td></tr></table></figure>\n<h1 id=\"算术和逻辑操作\">3.5 算术和逻辑操作</h1>\n<h2 id=\"加载有效地址leaq\">加载有效地址leaq</h2>\n<p><code>leaq</code>：它的指令形式是从内存读数据到寄存器</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">leaq S, D</span><br></pre></td></tr></table></figure>\n<p>例如：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">leaq 7(%rdx, %rdx, 4), %rax</span><br></pre></td></tr></table></figure>\n<p>表示：</p>\n<p>假设 <code>%rdx</code> 的值为<code>x</code></p>\n<p>有效地址 = <code>7 + %rdx + %rdx * 4</code> = 5x + 7</p>\n<p><strong>目的操作数必须是一个寄存器</strong></p>\n<p><code>leaq</code>指令还可以执行加法和有限形式的乘法</p>\n<p><code>scale.c</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">long</span> <span class=\"title function_\">scalse</span><span class=\"params\">(<span class=\"type\">long</span> x, <span class=\"type\">long</span> y, <span class=\"type\">long</span> z)</span>&#123;</span><br><span class=\"line\">  <span class=\"type\">long</span> t = x + <span class=\"number\">4</span> * y + <span class=\"number\">12</span> * z;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编译后形成的汇编代码为：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">scale:                                 </span><br><span class=\"line\">\tleaq\t(%rdi,%rsi,4), %rax</span><br><span class=\"line\">\tleaq\t(%rdx,%rdx,2), %rcx</span><br><span class=\"line\">\tleaq\t(%rax,%rcx,4), %rax</span><br><span class=\"line\">\tretq</span><br></pre></td></tr></table></figure>\n<p>理解：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">scale:</span><br><span class=\"line\">\tx in %rdi, y in %rsi, z in %rdx</span><br><span class=\"line\">\tleaq\t(%rdi,%rsi,4), %rax\t\t\t--&gt; %rdi + 4 * %rsi = x + 4 * y --&gt; %rax</span><br><span class=\"line\">\tleaq\t(%rdx,%rdx,2), %rcx\t\t\t--&gt; %rdx + 2 * %rdx = z + 2 * z --&gt; %rcx</span><br><span class=\"line\">\tleaq\t(%rax,%rcx,4), %rax\t\t\t--&gt; %rax + 4 * %rcx = (x + 4 * y) + 4 * (z + 2 * z)</span><br><span class=\"line\">\tretq</span><br></pre></td></tr></table></figure>\n<p>因为比例因子只能为<code>[1,2,4,8]</code>,所以需要将12拆分</p>\n<h2 id=\"一元和二元操作\">一元和二元操作</h2>\n<p><strong>一元操作数：</strong>即是源操作数又是目的操作数</p>\n<p><strong>二元操作数：</strong></p>\n<p>例如：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">ADD S, D</span><br></pre></td></tr></table></figure>\n<p>第二个操作数（<code>D</code>）即是源又是目的操作数，第一个操作数可以是立即数，寄存器或是内存位置</p>\n<p>第二个操作数可以是寄存器或是内存位置，但不能是立即数</p>\n<h2 id=\"移位操作\">移位操作</h2>\n<p><strong>左移：</strong></p>\n<p>SAL和SHL，两者的效果一样，都是将右边填上0</p>\n<p><strong>右移：</strong></p>\n<p>SAR执行算术运算（填上符号位）</p>\n<p>SHR执行逻辑运算（填上0）</p>\n<h1 id=\"控制\">3.6 控制</h1>\n<h2 id=\"条件码\">3.6.1 条件码</h2>\n<p>最常用的条件码：</p>\n<ul>\n<li>CF：进位标志。最近的操作使最高位产生了进位，CF =\n1。可用来检查无符号操作的溢出。</li>\n<li>ZF：零标志。最近的操作得出的结果位0，ZF = 1</li>\n<li>SF：符号标志。最近的操作得到的结果为负数，SF = 1</li>\n<li>OF：溢出标志。最近的操作导致一个补码溢出----正溢出或负溢出</li>\n</ul>\n<p>执行<code>XOR</code>时，<code>ZF = 0, OF = 0</code></p>\n<p><code>INC(+1),DEC(-1)</code>时，只会改变<code>OF,ZF</code>,不会改变<code>CF</code></p>\n<p><code>CMP和TEST</code>指令也可以设置条件码</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">cmpq %rax, %rdx</span><br></pre></td></tr></table></figure>\n<p>cmp指令是根据两个操作数的差来设置条件码寄存器，并不会更新目的寄存器的值</p>\n<p>test指令设置条件码寄存器，并不会更新目的寄存器的值</p>\n<h3 id=\"条件码的使用\">条件码的使用</h3>\n<p><code>setl</code>和<code>setb</code>表示“小于时设置(set\nless)\"和\"低于时设置(set below)\"</p>\n<p><code>comp.c</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">comp</span><span class=\"params\">(<span class=\"type\">long</span> a, <span class=\"type\">long</span> b)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (a == b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编译为汇编代码：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">gcc -Og -S comp.c</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">comp:</span><br><span class=\"line\">\t(a in %rdi, b in %rsi)</span><br><span class=\"line\">\tcomq %rsi, %rdi  --&gt; a - b,当 a = b 时，ZF = 1</span><br><span class=\"line\">\tsete %al</span><br><span class=\"line\">\t(</span><br><span class=\"line\">\tif ZF = 1, %al = 1</span><br><span class=\"line\">\tif ZF = 0, %al = 0 </span><br><span class=\"line\">\t）</span><br><span class=\"line\">\tmovzbl %al, %eax --&gt; 对寄存器al进行零扩展</span><br><span class=\"line\">\tret</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">comp</span><span class=\"params\">(<span class=\"type\">char</span> a, <span class=\"type\">char</span> b)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (a &lt; b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>汇编为：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">comp:</span><br><span class=\"line\">\tcomb %sil, %dil</span><br><span class=\"line\">\tsetl %al</span><br><span class=\"line\">\tmovzbl %al, %eax</span><br><span class=\"line\">\tret</span><br></pre></td></tr></table></figure>\n<p>a &lt; b --&gt; SF ^ OF</p>\n<p>t = a - b</p>\n<p>Case1: a &lt; b, t &lt; 0, SF = 1, SF ^ OF = 1</p>\n<p>Case2: a &gt; b, t &gt; 0, SF = 0, SF ^ OF = 0</p>\n<p>Case3: a &lt; b, a = -2, b = 127</p>\n<p>a = 1111 1110</p>\n<p>b = 0111 1111</p>\n<p>t = a - b</p>\n<p>a = 1111 1110</p>\n<p>(-b) = 1000 0001(按位取反，末位+1)</p>\n<p>a + (-b) = 1 0111 1111</p>\n<p>t = 127 &gt; 0, SF = 0, OF = 1, SF ^ OF = 1</p>\n<p><strong>综上：</strong></p>\n<p>对于有符号数的比较，采用的是SF和ZF的组合</p>\n<p>对于无符号数的比较，采用的是CF和ZF的组合</p>\n<p><img src=\"CSAPP-第三章-程序的机器级表示/4.jpg\" /></p>\n<h2 id=\"访问条件码\">3.6.2 访问条件码</h2>\n<p>常用的使用方式：</p>\n<ul>\n<li>可以根据条件码的某种组合，将一个字节设置为0或者1，2</li>\n<li>可以条件跳转到程序的某个其他的部分</li>\n<li>可以有条件地传送数据</li>\n</ul>\n<h2 id=\"跳转指令\">3.6.3 跳转指令</h2>\n<p><code>jump.c</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">long</span> <span class=\"title function_\">absDiff_se</span><span class=\"params\">(<span class=\"type\">long</span> x, <span class=\"type\">long</span> y)</span>&#123;</span><br><span class=\"line\">  <span class=\"type\">long</span> res;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(x &lt; y)&#123;</span><br><span class=\"line\">    res = y - x;</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    res = x - y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">absDiff_se:</span><br><span class=\"line\"> (x in %rdi, y in %rsi)</span><br><span class=\"line\">\tcmpq %rsi, %rdi --&gt; set SF, OF</span><br><span class=\"line\">\tj1 .L4 --&gt; SF ^ OF</span><br><span class=\"line\">\tmovq %rdi, %rax</span><br><span class=\"line\">\tsubq %rsi, %rax --&gt; x - y</span><br><span class=\"line\">\tret</span><br><span class=\"line\">\t</span><br><span class=\"line\">.L4:</span><br><span class=\"line\">\tmovq %rsi, %rax</span><br><span class=\"line\">\tsubq %rdi, %rax --&gt; y - x</span><br><span class=\"line\">\tret</span><br></pre></td></tr></table></figure>\n<p>另一种实现方式，效率更高：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">long</span> <span class=\"title function_\">comvdiff_se</span><span class=\"params\">(<span class=\"type\">long</span> x, <span class=\"type\">long</span> y)</span>&#123;</span><br><span class=\"line\">  <span class=\"type\">long</span> rval = y - x;</span><br><span class=\"line\">  <span class=\"type\">long</span> eval = x - y;</span><br><span class=\"line\">  <span class=\"type\">long</span> ntest = x &gt;= y;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(ntest)</span><br><span class=\"line\">    rval = eval;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> rval;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">cmovdiff_se:</span><br><span class=\"line\">\t(x in %rdi, y in %rsi)</span><br><span class=\"line\">\tmovq %rsi, %rdx</span><br><span class=\"line\">\tsubq %rdi, %rdx --&gt; rval = y - x</span><br><span class=\"line\">  movq %rdi, %rax</span><br><span class=\"line\">  subq %rsi, %rax --&gt; eval = x - y</span><br><span class=\"line\">  cmpq %rsi, %rdi</span><br><span class=\"line\">  cmovge %rdx, %rax --&gt; ~(SF ^ OF)</span><br><span class=\"line\">  ret</span><br></pre></td></tr></table></figure>\n<p><strong>为什么基于条件传送的代码会比基于跳转指令的代码效率高？</strong></p>\n<blockquote>\n<p>处理器会根据分支预测器来猜测每条跳转指令是否执行，</p>\n<p>当发生错误预测时，会浪费大量的时间，导致程序性能严重下降（流水线相关）</p>\n</blockquote>\n","categories":["深入理解计算机系统"],"tags":["CSAPP"]},{"title":"CSAPP 第二章 信息的表示和处理","url":"/2022/04/09/CSAPP-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/","content":"<h1 id=\"信息的表示与处理\">信息的表示与处理</h1>\n<h2 id=\"信息存储\">2.1 信息存储</h2>\n<p>大多数计算机使用8位的块，或者字节，作为最小的可寻址的内存单位，而不是访问内存中单独的位。</p>\n<h3 id=\"十六进制表示法\">2.1.1 十六进制表示法</h3>\n<p><img src=\"CSAPP-第二章-信息的表示和处理/1.jpg\" /></p>\n<p>十进制 x 转化为十六进制，可以反复用 16 除 x，得到一个商 q 和一个余数\nr，也就是 <code>x = q * 16 + r</code></p>\n<p><img src=\"CSAPP-第二章-信息的表示和处理/2.jpg\" /></p>\n<p>反过来也一样，比如我们给定数字 <code>0X7AF</code>,十进制就为</p>\n<p><span class=\"math inline\">\\(7 * 16^2 + 10 * 16 + 15 =\n1967\\)</span></p>\n<span id=\"more\"></span>\n<h3 id=\"字数据大小\">2.1.2 字数据大小</h3>\n<p>每台计算机都有一个<strong>字长</strong>，指明指针数据的标称大小。因为虚拟地址是以这样一个字来编码的，所以字长决定了<em>虚拟地址</em>空间的最大大小。也就是说，对于一个字长为<code>w</code>的机器，虚拟地址的范围为<code>0~2^w - 1</code>，程序最多访问<span\nclass=\"math inline\">\\(2^w\\)</span>个字节。</p>\n<h3 id=\"寻址和字节顺序\">2.1.3 寻址和字节顺序</h3>\n<ul>\n<li><strong>小端法：</strong>\n从最低有效字节到最高有效字节到顺序存储</li>\n<li><strong>大端法：</strong>\n从最高有效字节到最低有效字节的顺序存储</li>\n</ul>\n<p><img src=\"CSAPP-第二章-信息的表示和处理/3.jpg\" /></p>\n<p>例如：</p>\n<blockquote>\n<p>40004d3: 01 05 43 0b 20 00 add %0x200b43(%rip)</p>\n</blockquote>\n<p>如果我们取出最后4个字节，43 0b 20 00,并且按照相反的顺序写出，得到 00\n20 0b 43 去掉开头的0,得到值\n0x200b43，这就是右端的数值，所以可以判断是<strong>小端法机器</strong>。</p>\n<h3 id=\"表示字符串\">2.1.4 表示字符串</h3>\n<p>C语言中字符串被编码为一个以null（其值为0）字符结尾的字符数组，每个字符由ASCII码来表示。例如<code>\"12345\"</code>,结果为<code>31 32 33 34 35 00</code>。</p>\n<h3 id=\"表示代码\">2.1.5 表示代码</h3>\n<p>程序仅仅只是字节序列。</p>\n<h3 id=\"布尔代数\">2.1.6 布尔代数</h3>\n<p><img src=\"CSAPP-第二章-信息的表示和处理/4.jpg\" /></p>\n<p><code>^</code>表示异或，相同为<code>0</code>，不同为<code>1</code>。</p>\n<p><code>(a ^ b) ^ a = b</code></p>\n<h3 id=\"c语言中的位级运算\">2.1.7 C语言中的位级运算</h3>\n<p><code>|</code>:或</p>\n<p><code>&amp;</code>:与</p>\n<p><code>~</code>: 取反</p>\n<p><code>^</code>: 异或</p>\n<h3 id=\"c语言中的逻辑运算\">2.1.8 C语言中的逻辑运算</h3>\n<p><code>||</code>: OR</p>\n<p><code>&amp;&amp;</code>: AND</p>\n<p><code>!</code>: NOT</p>\n<p><code>1</code>表示<code>true</code>,<code>0</code>表示<code>false</code></p>\n<h3 id=\"c语言中的移位运算\">2.1.9 C语言中的移位运算</h3>\n<p>逻辑右移和算数右移</p>\n<blockquote>\n<p>x &gt;&gt; k</p>\n<p>逻辑右移：在左端补 K 个 0</p>\n<p>算数右移：在左端补 K 个最高有效位的值</p>\n</blockquote>\n<p>如果移动的<code>k</code>很大，假设我们的\n<code>int为 w = 32</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> lval = <span class=\"number\">0xFEDCBA98</span> &lt;&lt; <span class=\"number\">32</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> aval = <span class=\"number\">0xFEDCBA98</span> &gt;&gt; <span class=\"number\">36</span>;</span><br><span class=\"line\"><span class=\"type\">unsigned</span> uval = <span class=\"number\">0xFEDCBA98</span> &gt;&gt; <span class=\"number\">40</span>;</span><br></pre></td></tr></table></figure>\n<p>在许多机器上，当移动一个<code>w</code>位的值时，移位指令只考虑位移量的低<span\nclass=\"math inline\">\\(log_2w\\)</span>位，因此实际上位移量就是通过计算<code>k mod w</code>得到的。</p>\n<p>对于无符号数，右移必须是逻辑的。</p>\n<p>则上面的就相当于</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">lval = <span class=\"number\">0xFEDCBA98</span> &lt;&lt; <span class=\"number\">0</span> = <span class=\"number\">0xFEDCBA98</span></span><br><span class=\"line\">aval = <span class=\"number\">0xFEDCBA98</span> &gt;&gt; <span class=\"number\">4</span> = <span class=\"number\">0xFFEDCBA9</span></span><br><span class=\"line\">uval = <span class=\"number\">0xFEDCBA98</span> &gt;&gt; <span class=\"number\">8</span> = <span class=\"number\">0x00FEDCBA</span></span><br></pre></td></tr></table></figure>\n<p>在C语言中，加减法的优先级比移位运算要高。</p>\n<h2 id=\"整数表示\">2.2 整数表示</h2>\n<p><img src=\"CSAPP-第二章-信息的表示和处理/5.jpg\" /></p>\n<h3 id=\"整形数据类型\">2.2.1 整形数据类型</h3>\n<p><img src=\"CSAPP-第二章-信息的表示和处理/6.jpg\" /></p>\n<p><img src=\"CSAPP-第二章-信息的表示和处理/7.jpg\" /></p>\n<p>由上面我们可以看出，<strong>负数的范围比正数的范围大1</strong></p>\n<h3 id=\"无符号数的编码\">2.2.2 无符号数的编码</h3>\n<p>假设有一个整数数据类型有<code>w</code>位，我们用一个函数<span\nclass=\"math display\">\\[B2U_w\\]</span>(Binary to Unsigned的缩写，长度为 w\n)来表示。</p>\n<p><img src=\"CSAPP-第二章-信息的表示和处理/2.2.2.jpg\" /></p>\n<p>无符号数的二进制表示有一个很重要的属性，也就是每个介于<span\nclass=\"math display\">\\[0-2^w -\n1\\]</span>之间的数都有唯一一个<code>w</code>位的值编码。</p>\n<h3 id=\"补码编码\">2.2.3 补码编码</h3>\n<p>表示负数值，最常用的有符号数的计算机表示方式就是补码，将最高有效位解释为负权。</p>\n<p>最高位为<code>1</code>，表示负数，为<code>0</code>表示非负数。</p>\n<p>补码编码具有唯一性。</p>\n<h3 id=\"有符号数和无符号数之间的转换\">2.2.4\n有符号数和无符号数之间的转换</h3>\n<p>对于大多数C语言的实现，处理同样字长的有符号数和无符号数之间相互转换的一般规则是：数值可能会改变，但是位模式不变。</p>\n<h3 id=\"c语言中的有符号数与无符号数\">2.2.5\nC语言中的有符号数与无符号数</h3>\n<h3 id=\"扩展一个数字的位表示\">2.2.6 扩展一个数字的位表示</h3>\n<p>零扩展：要求一个无符号数转换为一个更大的数据类型时，我们只需要在表示的开头添加<code>0</code></p>\n<p>要求一个补码数字转换为一个更大的数据类型，可以执行一个符号扩展，在表示中添加最高有效位的值。</p>\n<h2 id=\"整数运算\">2.3 整数运算</h2>\n<h2 id=\"浮点数\">2.4 浮点数</h2>\n<h3 id=\"二进制小数\">2.4.1 二进制小数</h3>\n<p><span class=\"math display\">\\[\nb = \\sum_{i = -n}^{m} 2^i * b_i\n\\]</span></p>\n<p>例如 <span class=\"math inline\">\\(101.11_2\\)</span> 表示数字 <span\nclass=\"math display\">\\[\n1 * 2 ^2 + 0 * 2 ^ 1 + 1 * 2 ^ 0 + 1 * 2^{-1} + 1 * 2^{-2} = 4 + 0 + 1 +\n\\frac{1}{2} + \\frac{1}{4} = 5\\frac{3}{4}\n\\]</span> 小数的二进制表示法只能表示那些能够被写成 <span\nclass=\"math inline\">\\(x * 2^y\\)</span>\n的数。其他的数只能被近似表示。</p>\n<h3 id=\"ieee浮点表示\">2.4.2 IEEE浮点表示</h3>\n<p>前面提到的定点表示法不能很有效地表示非常大的数。</p>\n<p>IEEE 浮点标准用 <span class=\"math inline\">\\(V = (-1)^s * M *\n2^E\\)</span> 的形式表示一个数。</p>\n<ul>\n<li>符号：<code>s</code>决定这个数是负数(<code>s = 1</code>)还是正数(<code>s = 0</code>)</li>\n<li>尾数：M 是一个二进制小数</li>\n<li>阶码：E 的作用是对浮点数加权，这个权重是2的E次幂。</li>\n</ul>\n<p>将浮点数的位表示划分为三个字段。</p>\n<ul>\n<li>一个单独的符号位<code>s</code>直接编码符号</li>\n<li><code>k</code>位的阶码字段编码E</li>\n<li><code>n</code>位小数字段编码尾数M</li>\n</ul>\n<p>在单精度浮点格式中，<code>s = 1, k = 8, n = 23</code></p>\n<p><img src=\"CSAPP-第二章-信息的表示和处理/8.jpg\" /></p>\n<p><strong>情况一：规格化的值</strong></p>\n<p>阶码的值：<code>E = e - Bias</code>其中<code>e</code>是无符号数，其位表示为\n<span class=\"math inline\">\\(e_{k-1}...e_1e_0\\)</span> ,而 Bias\n是一个等于 <span class=\"math inline\">\\(2 ^{k - 1} - 1\\)</span>\n，（单精度是 127，双精度为 1023）的偏置值。</p>\n<p>小数字段 frac 被解释为描述小数值 f ,总是隐含的以 1 开头，尾数定义为 M\n= 1 + f</p>\n<p><strong>情况二：非规格化的值</strong></p>\n<p>当阶码为全0时，所表示的数是非规格化形式。阶码值是\n<code>E = 1 - Bias</code>,尾数值为<code>M = f</code>，不包含隐含的开头的1。</p>\n<p>非规格化数有两个用途：</p>\n<ol type=\"1\">\n<li>提供了一种表示数值 0 的方法</li>\n<li>表示那些非常接近 0.0 的数，它们提供了一种属性，称为<em>逐渐溢出</em>\n。其中，可能的数值分布均匀地接近于 0.0</li>\n</ol>\n<p><strong>情况三：特殊值</strong></p>\n<p>当阶码全为 0 时</p>\n<p>当小数域全为0，得到的值表示无穷，当<code>s = 0</code>时是+∞，或者当<code>s = 1</code>时是-∞。</p>\n<p>当小数域为非零时，结果值就称为<code>\"NaN\"</code>,即“不是一个数”的缩写。</p>\n<h3 id=\"舍入\">2.4.4 舍入</h3>\n<p><img src=\"CSAPP-第二章-信息的表示和处理/9.jpg\" /></p>\n<p>向偶数舍入是在<code>50%</code>的时间里，它将向上舍入，<code>50%</code>的时间向下舍入，就避免了向下舍入时最后平均值偏小和向上舍入时平均值偏大的问题。</p>\n<h3 id=\"浮点运算\">2.4.5 浮点运算</h3>\n<p>浮点加法不具有结合性。</p>\n","categories":["深入理解计算机系统"],"tags":["CSAPP"]},{"title":"CSAPP第二章家庭作业","url":"/2022/05/30/CSAPP%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%AE%B6%E5%BA%AD%E4%BD%9C%E4%B8%9A/","content":"<h1 id=\"第二章-信息的表示和处理\">第二章 信息的表示和处理</h1>\n<span id=\"more\"></span>\n<h2 id=\"section\">2-55 ～ 2-57</h2>\n<p>头文件<code>show_bytes.c</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">unsigned</span> <span class=\"type\">char</span>* byte_pointer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">show_bytes</span><span class=\"params\">(byte_pointer start, <span class=\"type\">size_t</span> len)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; len; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.2x&quot;</span>, start[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">unsigned</span> <span class=\"type\">char</span>* byte_pointer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">show_bytes</span><span class=\"params\">(byte_pointer start, <span class=\"type\">size_t</span> len)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; len; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.2x&quot;</span>, start[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">show_int</span><span class=\"params\">(<span class=\"type\">int</span> x)</span>&#123;</span><br><span class=\"line\">    show_bytes((byte_pointer) &amp;x, <span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">show_short</span><span class=\"params\">(<span class=\"type\">short</span> x)</span>&#123;</span><br><span class=\"line\">    show_bytes((byte_pointer) &amp;x, <span class=\"keyword\">sizeof</span>(<span class=\"type\">short</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">show_long</span><span class=\"params\">(<span class=\"type\">long</span> x)</span>&#123;</span><br><span class=\"line\">    show_bytes((byte_pointer) &amp;x, <span class=\"keyword\">sizeof</span>(<span class=\"type\">long</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">show_double</span><span class=\"params\">(<span class=\"type\">double</span> x)</span>&#123;</span><br><span class=\"line\">    show_bytes((byte_pointer) &amp;x, <span class=\"keyword\">sizeof</span>(<span class=\"type\">double</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">show_pointer</span><span class=\"params\">(<span class=\"type\">void</span> *x)</span>&#123;</span><br><span class=\"line\">    show_bytes((byte_pointer) &amp;x, <span class=\"keyword\">sizeof</span>(<span class=\"type\">void</span> *));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// test</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">test_show_bytes</span><span class=\"params\">(<span class=\"type\">int</span> val)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> ival = val;</span><br><span class=\"line\">    <span class=\"type\">short</span> sval = (<span class=\"type\">short</span>) ival;</span><br><span class=\"line\">    <span class=\"type\">long</span> lval = (<span class=\"type\">long</span>) ival;</span><br><span class=\"line\">    <span class=\"type\">double</span> dval = (<span class=\"type\">double</span>) ival;</span><br><span class=\"line\">    <span class=\"type\">int</span> *pval = &amp;ival;</span><br><span class=\"line\"></span><br><span class=\"line\">    show_int(ival);</span><br><span class=\"line\">    show_short(sval);</span><br><span class=\"line\">    show_long(lval);</span><br><span class=\"line\">    show_double(dval);</span><br><span class=\"line\">    show_pointer(pval);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//main</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    test_show_bytes(<span class=\"number\">12345</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>show_bytes</code>打印出每个以十六进制表示的字节。</p>\n<p>上面程序使用强制类型转换来访问和打印不同程序对象的字节表示。</p>\n<p>我们将<code>byte_pointer</code>定义为一个指向类型为<code>unsigned char</code>的对象指针，这样一个字节指针引用一个字节序列，其中每个字节都被认为是一个非负整数。该字节数指定为数据类型<code>size_t</code>，表示数据结构大小的首选数据类型。</p>\n<blockquote>\n<p>c格式化指针\n<code>\"%.2x\"</code>表明整数必须用至少两个数字的十六进制格式输出</p>\n<p><code>sizeof(T)</code>返回存储一个类型为<code>T</code>的对象所需要的字节数。需要注意的是<code>sizeof</code>不是一个固定的值，在不同机器上可能会不同</p>\n</blockquote>\n<p>输出十六进制：</p>\n<blockquote>\n<p>39300000 3930 3930000000000000 00000000801cc840 e8c779b7f77f0000</p>\n</blockquote>\n<h2 id=\"section-1\">2-58</h2>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">unsigned</span> <span class=\"type\">char</span>* byte_pointer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">is_litter_endian</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> test = <span class=\"number\">0x01</span>;</span><br><span class=\"line\">    byte_pointer p = (byte_pointer) &amp; test;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(*p)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> is_litter_endian();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编译运行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gcc 2_58.c &amp;&amp; ./a.out ; <span class=\"built_in\">echo</span> $?</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<blockquote>\n<p>1</p>\n</blockquote>\n<h2 id=\"section-2\">2-59</h2>\n<p>很明显我们只需要</p>\n<blockquote>\n<p>ox89ABCDEF &amp; 0xFF = 0x000000EF</p>\n<p>0x76543210 &amp; ~0xFF = 0x76543200</p>\n<p>最后</p>\n<p>0x000000EF | 0x76543200 = 0x765432EF</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x = <span class=\"number\">0x89ABCDEF</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> y = <span class=\"number\">0x76543210</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;0x%.8x\\n&quot;</span>, (x &amp; <span class=\"number\">0xff</span>) | (y &amp; ~<span class=\"number\">0xff</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编译运行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gcc 2_59.c &amp;&amp; ./a.out</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<blockquote>\n<p>0x765432ef</p>\n</blockquote>\n<h2 id=\"section-3\">2-60</h2>\n<p>为了使<code>replace_byte(0x12345678, 2, 0xAB) --&gt; 0x12AB5678</code></p>\n<p>我们先算出左移的位，也就是<code>move = 2 * 8 = 16</code></p>\n<p><code>x &amp; ~(0xff &lt;&lt; move)</code> =\n<code>0x12005678</code></p>\n<p><code>b &lt;&lt; move = 0xAB0000</code></p>\n<p><code>0x12005678 | 0xAB0000 = 0x12AB5678</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"title function_\">replace_byte</span><span class=\"params\">(<span class=\"type\">unsigned</span> x, <span class=\"type\">int</span> i, <span class=\"type\">unsigned</span> <span class=\"type\">char</span> b)</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> move = i * <span class=\"number\">8</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x &amp; ~(<span class=\"number\">0xff</span> &lt;&lt; move) | b &lt;&lt; move;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.8x\\n&quot;</span>, replace_byte(<span class=\"number\">0x12345678</span>, <span class=\"number\">2</span>, <span class=\"number\">0xAB</span>));</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%.8x\\n&quot;</span>, replace_byte(<span class=\"number\">0x12345678</span>, <span class=\"number\">0</span>, <span class=\"number\">0xAB</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编译运行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">gcc 2_60.c &amp;&amp; ./a.out</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<blockquote>\n<p>0x12AB5678</p>\n<p>0x123456AB</p>\n</blockquote>\n<h2 id=\"section-4\">2-61</h2>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* A: Any bit x is equal to 1 */</span></span><br><span class=\"line\">    x = <span class=\"number\">0xffffff00</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, !~x);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* B: Any bit x is equal to 0 */</span></span><br><span class=\"line\">    x = <span class=\"number\">0x000000ff</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, !x);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* C: The bits in the least significant byte of x are equal to 1 */</span></span><br><span class=\"line\">    x = <span class=\"number\">0xffffff00</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, !~(x | ~<span class=\"number\">0xff</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* D: The bits in the highest significant byte of x are equal to 0*/</span></span><br><span class=\"line\">    x = <span class=\"number\">0x00ffffff</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,!((x &gt;&gt; ((<span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>)<span class=\"number\">-1</span>) &lt;&lt; <span class=\"number\">3</span>)) &amp; <span class=\"number\">0xff</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编译运行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gcc 2_61.c &amp;&amp; ./a.out</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<blockquote>\n<p>0</p>\n<p>0</p>\n<p>0</p>\n<p>1</p>\n</blockquote>\n<h2 id=\"section-5\">2-62</h2>\n<table>\n<thead>\n<tr class=\"header\">\n<th></th>\n<th>码制</th>\n<th>添补代码</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>正数</td>\n<td>源码，补码，反码</td>\n<td>0</td>\n</tr>\n<tr class=\"even\">\n<td>负数</td>\n<td>源码</td>\n<td>0</td>\n</tr>\n<tr class=\"odd\">\n<td></td>\n<td>补码</td>\n<td>左移补0</td>\n</tr>\n<tr class=\"even\">\n<td></td>\n<td></td>\n<td>右移补1</td>\n</tr>\n<tr class=\"odd\">\n<td></td>\n<td>反码</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<p>所以这里我们只需要判断<code>(-1 &gt;&gt; 1) == -1</code>即可，因为<code>-1</code>的补码为<code>11</code>,右移一位后也是<code>11</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">int_shift_are_arithmetic</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> test = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (test &gt;&gt; <span class=\"number\">1</span>) == <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    int_shift_are_arithmetic();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编译运行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gcc 2_58.c &amp;&amp; ./a.out ; <span class=\"built_in\">echo</span> $?</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<blockquote>\n<p>0</p>\n</blockquote>\n<h2 id=\"section-6\">2-63</h2>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"title function_\">srl</span><span class=\"params\">(<span class=\"type\">unsigned</span> x, <span class=\"type\">int</span> k)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* Perform shift arithmetically */</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> xsra = (<span class=\"type\">int</span>) x &gt;&gt; k;</span><br><span class=\"line\">    <span class=\"type\">int</span> w = <span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>) * <span class=\"number\">8</span>;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> z = <span class=\"number\">2</span> &lt;&lt; (w - k - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (z - <span class=\"number\">1</span>) &amp; xsra;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">sra</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> k)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* Perform shift logically */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> xsrl = (<span class=\"type\">unsigned</span>) x &gt;&gt; k;</span><br><span class=\"line\">    <span class=\"type\">int</span> w = <span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>) * <span class=\"number\">8</span>;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> z = <span class=\"number\">1</span> &lt;&lt; (w - k - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> mask = z - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> right = mask &amp; xsrl;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> left = ~mask &amp; (~(z &amp; xsrl) + z);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> left | right;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%x\\n&quot;</span>, srl(<span class=\"number\">8</span>, <span class=\"number\">2</span>));</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%x\\n&quot;</span>, sra(<span class=\"number\">8</span>, <span class=\"number\">2</span>));</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%x\\n&quot;</span>, sra(<span class=\"number\">-8</span>, <span class=\"number\">2</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    test();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"section-7\">2-64</h2>\n<p>如果奇位都为1，则返会1，否则返回0</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> Return 1 when any odd bit of x equals 1; 0 otherwise.</span></span><br><span class=\"line\"><span class=\"comment\"> Assume w = 32</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">any_odd_one</span><span class=\"params\">(<span class=\"type\">unsigned</span> x)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// A = 1010,刚好偶数都为1</span></span><br><span class=\"line\">    <span class=\"type\">int</span> mask = <span class=\"number\">0xAAAAAAAA</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span> != (x &amp; mask);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> test1 = <span class=\"number\">0x5</span>; <span class=\"comment\">// 00000000 00000000 00000000 00000101</span></span><br><span class=\"line\">    <span class=\"type\">int</span> test2 = <span class=\"number\">0x7</span>; <span class=\"comment\">// 00000000 00000000 00000000 00000111</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, any_odd_one(test1));</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, any_odd_one(test2));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编译运行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">gcc 2_64.c &amp;&amp; ./a.out</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<blockquote>\n<p>0</p>\n<p>1</p>\n</blockquote>\n","categories":["CSAPP"],"tags":["CSAPP"]},{"title":"C和C++面试秘籍","url":"/2022/02/23/C%E5%92%8CC++%E9%9D%A2%E8%AF%95%E7%A7%98%E7%B1%8D/","content":"<p><code>C++</code>一些常见问题</p>\n<span id=\"more\"></span>\n<h3 id=\"c和c的区别是什么\">1. C和C++的区别是什么？</h3>\n<p>1，C是面向过程的语言，C++是面向对象的编程语言。面向对象是一种对现实世界理解和抽象的方法。</p>\n<p>2，C中函数不能进行重载，C++中函数可以重载。</p>\n<p>3，C++在C的基础上增添类。</p>\n<p>4，C中struct和C++的类(class)，除了默认访问权限外(struct的成员默认访问修饰符是public,而class默认的是private;)，别的功能几乎相同。</p>\n<p>5，C和C++动态管理管理内存的方法不同，C是使用malloc/free函数，而C++除此之外还有new/delete关键字。</p>\n<p>6，C++中有引用而C没有。</p>\n<h3 id=\"关键字staticconstextern作用\">2.\n关键字static、const、extern作用</h3>\n<p><strong>static关键字的作用：</strong>\n1）隐藏，当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。</p>\n<p>​ 2）保持变量内容的持久。</p>\n<p>​ 3）默认初始化为0</p>\n<p>​ 4）C++中的类成员声明static</p>\n<p><strong>const关键字的作用：</strong> （1）阻止一个变量被改变\n（2）声明常量指针和指针常量\n（3）const修饰形参，表明该输入参数在函数内部不能改变其值\n（4）对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量(const成员一般在成员初始化列表处初始化)\n（5）对于类的成员函数，有时候必须指定其返回值为const类型\n<strong>extern关键字的作用：</strong> （1）<a\nhref=\"https://so.csdn.net/so/search?q=extern&amp;spm=1001.2101.3001.7020\">extern</a>可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。\n（2）extern \"C\"的作用是让 C++ 编译器将extern \"C\"声明的代码当作 C\n语言代码处理，可以避免 C++\n因符号修饰导致代码不能和C语言库中的符号进行链接。</p>\n<h3 id=\"内存有哪几种类型及分配方式\">3. 内存有哪几种类型及分配方式</h3>\n<p>类型：</p>\n<p>​ 1，栈区(stack)：如局部变量，函数参数</p>\n<p>​\n2，堆区(heap)：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统回收。</p>\n<p>​ 3，全局/静态区：如全局变量、static变量</p>\n<p>​ 4，常量存储区：存放常量字符串</p>\n<p>​ 5，程序代码区：存放函数体的二进制代码</p>\n<p>​ 6，c++中还有所谓的自由存储区(new)</p>\n<p>分配方式：</p>\n<p>​ 1，从静态存储区域分配</p>\n<p>​ 2，在栈上分配</p>\n<p>​ 3，在堆上分配，也被称为动态内存分配</p>\n<h3 id=\"堆和栈的区别\">4. 堆和栈的区别？</h3>\n<p>1)堆存放动态分配的对象——即那些在程序运行时动态分配的对象，比如 new\n出来的对象，其生存期由程序控制；</p>\n<p>2)栈用来保存定义在函数内的非static对象，如局部变量，仅在其定义的程序块运行时才存在；</p>\n<p>3)静态内存用来保存static对象，类static数据成员以及定义在任何函数外部的变量，static对象在使用之前分配，程序结束时销毁；</p>\n<p>4)栈和静态内存的对象由编译器自动创建和销毁。</p>\n<p>###5.\n什么是内存泄漏？面对内存泄漏和指针越界，你有哪些方法？你通常采用哪些方法来避免和减少这类错误？</p>\n<p>用动态存储分配函数动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元即为内存泄露。</p>\n<p>方法：</p>\n<p>1). 使用的时候要记得指针的长度.</p>\n<p>2). malloc的时候得确定在那里free.</p>\n<p>3). 对指针赋值的时候应该注意被赋值指针需要不需要释放.</p>\n<p>4). 动态分配内存的指针最好不要再次赋值.</p>\n<p>5). 在C++中应该优先考虑使用智能指针.</p>\n<h3 id=\"引用和指针的区别\">6. 引用和指针的区别？</h3>\n<ol type=\"1\">\n<li><p>指针是一个实体，需要分配内存空间。引用只是变量的别名，不需要分配内存空间。</p></li>\n<li><p>引用在定义时必须初始化，并且不能够改变。（引用的值不能为NULL）指针在定义时不一定需要初始化，并且指向的空间可变。</p></li>\n<li><p>有多级指针，但是没有多级引用，只能有一级引用。</p></li>\n<li><p>指针和引用的自增运算结果不同。（指针是指向下一个空间，引用是引用的变量加1）</p></li>\n<li><p>sizeof引用得到的是所指向的变量的大小，sizeof指针得到的是指针的大小。</p></li>\n<li><p>引用访问一个变量是直接访问，而指针访问是间接访问。</p></li>\n<li><p>作为参数时也不一样，传指针本质上是传值，传递的值是指针的地址；传引用本质是传地址，传递的是变量的地址。</p></li>\n</ol>\n<h4 id=\"面向对象的三大特性\">7. 面向对象的三大特性</h4>\n<ol type=\"1\">\n<li><p>抽象</p></li>\n<li><p>继承</p></li>\n<li><p>多态</p></li>\n</ol>\n<h4 id=\"形参和实参的区别\">8. 形参和实参的区别？</h4>\n<p>1）形参变量只有在被调用时才分配内存单元，在调用结束时，\n即刻释放所分配的内存单元。</p>\n<p>2）实参可以是常量、变量、表达式、函数等，\n无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值，\n以便把这些值传送给形参。</p>\n<p>3）函数调用中发生的数据传送是单向的。只能把实参的值传送给形参，而不能把形参的值反向地传送给实参。</p>\n<h3 id=\"vitrual-关键字\">9. vitrual 关键字</h3>\n<p>（1） <strong>静态函数可以声明为虚函数吗？</strong></p>\n<p>原因主要有两方面：</p>\n<p><strong>静态函数不可以声明为虚函数，同时也不能被const 和\nvolatile关键字修饰</strong></p>\n<p>static成员函数不属于任何类对象或类实例，所以即使给此函数加上virutal也是没有任何意义</p>\n<p>虚函数依靠vptr和vtable来处理。vptr是一个指针，在类的构造函数中创建生成，并且只能用this指针来访问它，静态成员函数没有this指针，所以无法访问vptr。</p>\n<p>（2）<strong>构造函数可以为虚函数吗？</strong></p>\n<p>构造函数不可以声明为虚函数。同时除了inline|explicit之外，构造函数不允许使用其它任何关键字。</p>\n<p>为什么构造函数不可以为虚函数？</p>\n<p>尽管虚函数表vtable是在编译阶段就已经建立的，但指向虚函数表的指针vptr是在运行阶段实例化对象时才产生的。\n如果类含有虚函数，编译器会在构造函数中添加代码来创建vptr。\n问题来了，如果构造函数是虚的，那么它需要vptr来访问vtable，可这个时候vptr还没产生。\n因此，构造函数不可以为虚函数。</p>\n<p>我们之所以使用虚函数，是因为需要在信息不全的情况下进行多态运行。而构造函数是用来初始化实例的，实例的类型必须是明确的。\n因此，构造函数没有必要被声明为虚函数。</p>\n<p>（3）<strong>析构函数可以为虚函数吗？</strong></p>\n<p><strong>析构函数可以声明为虚函数。如果我们需要删除一个指向派生类的基类指针时，应该把析构函数声明为虚函数。\n事实上，只要一个类有可能会被其它类所继承，\n就应该声明虚析构函数(哪怕该析构函数不执行任何操作)。</strong></p>\n<p>（4）<strong>虚函数可以为私有函数吗？</strong></p>\n<ul>\n<li>基类指针指向继承类对象，则调用继承类对象的函数；</li>\n<li>int main()必须声明为Base类的友元，否则编译失败。 编译器报错：\nptr无法访问私有函数。 当然，把基类声明为public，\n继承类为private，该问题就不存在了。</li>\n</ul>\n<p>5）<strong>虚函数可以被内联吗？</strong></p>\n<p><strong>通常类成员函数都会被编译器考虑是否进行内联。\n但通过基类指针或者引用调用的虚函数必定不能被内联。\n当然，实体对象调用虚函数或者静态调用时可以被内联，虚析构函数的静态调用也一定会被内联展开。</strong></p>\n<ul>\n<li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li>\n<li>内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</li>\n<li><code>inline virtual</code>\n唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如\n<code>Base::who()</code>），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li>\n</ul>\n<h3 id=\"volatile常见问题\">volatile常见问题</h3>\n<p>（1）一个参数既可以是const还可以是volatile吗？为什么？</p>\n<p>​\n可以。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。</p>\n<p>（2）一个指针可以是volatile吗？为什么？\n可以。尽管这并不常见。一个例子是当一个中断服务子程序修该一个指向一个buffer的指针时。（3）下面的函数有什么错误？</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">square</span><span class=\"params\">(<span class=\"keyword\">volatile</span> <span class=\"type\">int</span> *ptr)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; </span><br><span class=\"line\"><span class=\"keyword\">return</span> *ptr * *ptr; </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p>这段代码有点变态，其目的是用来返回指针ptr指向值的平方，但是，由于ptr指向一个volatile型参数，编译器将产生类似下面的代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">square</span><span class=\"params\">(<span class=\"keyword\">volatile</span> <span class=\"type\">int</span> *ptr)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; </span><br><span class=\"line\"><span class=\"type\">int</span> a,b; </span><br><span class=\"line\">a = *ptr; </span><br><span class=\"line\">b = *ptr; </span><br><span class=\"line\"><span class=\"keyword\">return</span> a * b; </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p>由于*ptr的值可能被意想不到地改变，因此a和b可能是不同的。结果，这段代码可能返回的不是你所期望的平方值！正确的代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">long</span> <span class=\"title\">square</span><span class=\"params\">(<span class=\"keyword\">volatile</span> <span class=\"type\">int</span> *ptr)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; </span><br><span class=\"line\"><span class=\"type\">int</span> a=*ptr; </span><br><span class=\"line\"><span class=\"keyword\">return</span> a * a; </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<ul>\n<li>volatile\n关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用\nvolatile 告诉编译器不应对这样的对象进行优化。</li>\n<li>volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被\nvolatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</li>\n<li>const 可以是 volatile （如只读的状态寄存器）</li>\n<li>指针可以是 volatile</li>\n</ul>\n<h3 id=\"c和c中的struct区别\">C和C++中的Struct区别</h3>\n<table>\n<colgroup>\n<col style=\"width: 47%\" />\n<col style=\"width: 52%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>C</th>\n<th>C++</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>不能将函数放在结构体声明</td>\n<td>能将函数放在结构体声明</td>\n</tr>\n<tr class=\"even\">\n<td>在C结构体声明中不能使用C++访问修饰符。</td>\n<td>public、protected、private 在C++中可以使用。</td>\n</tr>\n<tr class=\"odd\">\n<td>在C中定义结构体变量，如果使用了下面定义必须加struct。</td>\n<td>可以不加struct</td>\n</tr>\n<tr class=\"even\">\n<td>结构体不能继承（没有这一概念）。</td>\n<td>可以继承</td>\n</tr>\n<tr class=\"odd\">\n<td>若结构体的名字与函数名相同，可以正常运行且正常的调用！</td>\n<td>若结构体的名字与函数名相同，使用结构体，只能使用带struct定义！</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"struct与class区别\">struct与class区别</h3>\n<p>区别:</p>\n<p>最本质的一个区别就是默认的访问控制</p>\n<p>默认的继承访问权限。struct 是 public 的，class 是 private 的。</p>\n<p>struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而\nclass 作为对象的实现体，它默认的成员变量访问控制是 private 的。</p>\n<h3 id=\"友元函数与友元类\">友元函数与友元类</h3>\n<ul>\n<li>能访问私有成员</li>\n<li>破坏封装性</li>\n<li>友元关系不可传递</li>\n<li>友元关系的单向性</li>\n<li>友元声明的形式及数量不受限制</li>\n</ul>\n","categories":["C++","面试"],"tags":["C++"]},{"title":"DFS解决所有岛屿问题","url":"/2022/04/17/DFS%E8%A7%A3%E5%86%B3%E6%89%80%E6%9C%89%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98/","content":"<p>岛屿系列题⽬的核⼼考点就是⽤ DFS/BFS 算法遍历⼆维数组。</p>\n<p>我们可以根据二叉树遍历框架写出DFS框架。</p>\n<p>DFS代码框架如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt;&amp; grid, <span class=\"type\">int</span> i, <span class=\"type\">int</span> j, vector&lt;<span class=\"type\">bool</span>&gt;&amp; visited)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> m = grid.<span class=\"built_in\">size</span>(), n = grid[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">  <span class=\"comment\">//base case</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(i &lt; <span class=\"number\">0</span> || j &lt; <span class=\"number\">0</span> || i &gt;= m || j &gt;= n) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  <span class=\"comment\">//已经访问过</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(visited[i][j]) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  <span class=\"comment\">//进入节点(i,j)</span></span><br><span class=\"line\">  visited[i][j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"built_in\">dfs</span>(grid, i - <span class=\"number\">1</span>, j, visited);</span><br><span class=\"line\">  <span class=\"built_in\">dfs</span>(grid, i + <span class=\"number\">1</span>, j, visited);</span><br><span class=\"line\">  <span class=\"built_in\">dfs</span>(grid, i, j - <span class=\"number\">1</span>, visited);</span><br><span class=\"line\">  <span class=\"built_in\">dfs</span>(grid, i, j + <span class=\"number\">1</span>, visited);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为⼆维矩阵本质上是⼀幅「图」，所以遍历的过程中需要⼀个 visited\n布尔数组防⽌⾛回头路，如果你理解了之后，那么所有的岛屿问题就迎刃而解了。</p>\n<span id=\"more\"></span>\n<h1 id=\"岛屿数量\"><a\nhref=\"https://leetcode-cn.com/problems/number-of-islands/\">200.\n岛屿数量</a></h1>\n<p>给你一个由 '1'（陆地）和\n'0'（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>\n<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>\n<p>此外，你可以假设该网格的四条边均被水包围。</p>\n<h2 id=\"示例\">示例：</h2>\n<blockquote>\n<p>输入：grid = [ [\"1\",\"1\",\"1\",\"1\",\"0\"], [\"1\",\"1\",\"0\",\"1\",\"0\"],\n[\"1\",\"1\",\"0\",\"0\",\"0\"], [\"0\",\"0\",\"0\",\"0\",\"0\"]] 输出：1</p>\n</blockquote>\n<h3 id=\"思路\">思路：</h3>\n<p>我们遇到“1”就开始<code>dfs</code>，遍历它的四边，直到没有，我们结果加1。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">numIslands</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> m = grid.<span class=\"built_in\">size</span>(), n = grid[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(grid[i][j] == <span class=\"string\">&#x27;1&#x27;</span>)&#123;</span><br><span class=\"line\">                    res++;</span><br><span class=\"line\">                    <span class=\"built_in\">dfs</span>(grid, i, j);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> dx[<span class=\"number\">4</span>] = &#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\">    <span class=\"type\">int</span> dy[<span class=\"number\">4</span>] = &#123;<span class=\"number\">1</span>,<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">char</span>&gt; &gt;&amp; grid, <span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//base case</span></span><br><span class=\"line\">        <span class=\"type\">int</span> m = grid.<span class=\"built_in\">size</span>(), n = grid[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x &lt; <span class=\"number\">0</span> || y &lt; <span class=\"number\">0</span> || x &gt;= m || y &lt; <span class=\"number\">0</span> || y &gt;= n) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"comment\">//已经是水了</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(grid[x][y] == <span class=\"string\">&#x27;0&#x27;</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"comment\">//淹没</span></span><br><span class=\"line\">        grid[x][y] = <span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> nx = x + dx[i];</span><br><span class=\"line\">            <span class=\"type\">int</span> ny = y + dy[i];</span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(grid, nx, ny);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>为什么每次遇到岛屿，都要⽤ DFS\n算法把岛屿「淹了」呢？主要是为了省事，避免维护 visited\n数组。</strong></p>\n<p>因为 dfs 函数遍历到值为 0\n的位置会直接返回，所以只要把经过的位置都设置为\n0，就可以起到不⾛回头路的作用。</p>\n<p>#<a\nhref=\"https://leetcode-cn.com/problems/number-of-closed-islands/\">1254.\n统计封闭岛屿的数目</a></p>\n<p>二维矩阵 grid 由 0 （土地）和 1 （水）组成。岛是由最大的4个方向连通的\n0 组成的群，封闭岛是一个 完全 由1包围（左、上、右、下）的岛。</p>\n<p>请返回 封闭岛屿 的数目。</p>\n<h2 id=\"示例-1\">示例：</h2>\n<p><img src=\"DFS解决所有岛屿问题/1.png\" /></p>\n<blockquote>\n<p>输入：grid =\n[[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]\n输出：2 解释：\n灰色区域的岛屿是封闭岛屿，因为这座岛屿完全被水域包围（即被 1\n区域包围）。</p>\n</blockquote>\n<h3 id=\"思路-1\">思路：</h3>\n<p>注意这道题与上一道题有两个不同的地方</p>\n<ul>\n<li>用<code>0</code>代表土地，<code>1</code>代表水</li>\n<li>计算的是「封闭岛屿」，上下左右都被<code>1</code>包围的<code>0</code>，也就是说靠边的陆地不算做「封闭岛屿」</li>\n</ul>\n<p>那我们先单独处理四边界，把它淹没成水。那么剩下的岛屿就是「封闭岛屿」</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> m, n;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">closedIsland</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class=\"line\">        m = grid.<span class=\"built_in\">size</span>(), n = grid[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//处理上边界</span></span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(grid, <span class=\"number\">0</span>, i);</span><br><span class=\"line\">            <span class=\"comment\">//处理下边界</span></span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(grid, m - <span class=\"number\">1</span>, i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//处理左边界</span></span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(grid, i, <span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"comment\">//处理右边界</span></span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(grid, i, n - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//遍历grid，剩下的岛屿就是封闭岛屿</span></span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; m - <span class=\"number\">1</span>; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt; n - <span class=\"number\">1</span>; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(grid[i][j] == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    res++;</span><br><span class=\"line\">                    <span class=\"built_in\">dfs</span>(grid, i, j);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> dx[<span class=\"number\">4</span>] = &#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\">    <span class=\"type\">int</span> dy[<span class=\"number\">4</span>] = &#123;<span class=\"number\">1</span>,<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt;&amp; grid, <span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//base case</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x &lt; <span class=\"number\">0</span> || y &lt; <span class=\"number\">0</span> || x &gt;= m || y &gt;= n) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(grid[x][y] == <span class=\"number\">1</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"comment\">//淹没</span></span><br><span class=\"line\">        grid[x][y] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> nx = x + dx[i];</span><br><span class=\"line\">            <span class=\"type\">int</span> ny = y + dy[i];</span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(grid, nx, ny);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"飞地的数量\"><a\nhref=\"https://leetcode-cn.com/problems/number-of-enclaves/\">1020.\n飞地的数量</a></h1>\n<p>给你一个大小为 m x n 的二进制矩阵 grid ，其中 0 表示一个海洋单元格、1\n表示一个陆地单元格。</p>\n<p>一次 移动\n是指从一个陆地单元格走到另一个相邻（上、下、左、右）的陆地单元格或跨过\ngrid 的边界。</p>\n<p>返回网格中 无法\n在任意次数的移动中离开网格边界的陆地单元格的数量。</p>\n<h2 id=\"示例-2\">示例：</h2>\n<p><img src=\"DFS解决所有岛屿问题/2.jpg\" /></p>\n<blockquote>\n<p>输入：grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]] 输出：3\n解释：有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。</p>\n</blockquote>\n<h3 id=\"思路-2\">思路：</h3>\n<p>和上一题（1254）类似，也是求封闭岛屿，只是现在每块地都算一个岛屿了，我们也是从边界出发，最后遍历整个二维数组，看还剩几个<code>1</code>即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> dx[<span class=\"number\">4</span>] = &#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\">    <span class=\"type\">int</span> dy[<span class=\"number\">4</span>] = &#123;<span class=\"number\">-1</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">numEnclaves</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//从边界开始dfs，然后把能去到的岛屿淹没，最后遍历剩余的1的个数即为答案</span></span><br><span class=\"line\">        <span class=\"type\">int</span> m = grid.<span class=\"built_in\">size</span>(), n = grid[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//从上面开始淹没</span></span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(grid, <span class=\"number\">0</span>, i);</span><br><span class=\"line\">            <span class=\"comment\">//从下面开始淹没</span></span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(grid, m - <span class=\"number\">1</span>, i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//从左边开始淹没</span></span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(grid, j, <span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"comment\">//从右边开始淹没</span></span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(grid, j, n - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//遍历输出 1 的个数</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(grid[i][j] == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                    res++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt;&amp; grid, <span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> m = grid.<span class=\"built_in\">size</span>(), n = grid[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"comment\">//base case</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x &lt; <span class=\"number\">0</span> || y &lt; <span class=\"number\">0</span> || x &gt;= m || y &gt;= n) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(grid[x][y] == <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"comment\">//把岛屿淹没</span></span><br><span class=\"line\">        grid[x][y] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> nx = x + dx[i];</span><br><span class=\"line\">            <span class=\"type\">int</span> ny = y + dy[i];</span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(grid, nx, ny);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"岛屿的最大面积\"><a\nhref=\"https://leetcode-cn.com/problems/max-area-of-island/\">695.\n岛屿的最大面积</a></h1>\n<p>给你一个大小为 m x n 的二进制矩阵 grid 。</p>\n<p>岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1\n必须在 水平或者竖直的四个方向上 相邻。你可以假设 grid 的四个边缘都被\n0（代表水）包围着。</p>\n<p>岛屿的面积是岛上值为 1 的单元格的数目。</p>\n<p>计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。</p>\n<h2 id=\"示例-3\">示例：</h2>\n<p><img src=\"DFS解决所有岛屿问题/3.jpg\" /></p>\n<blockquote>\n<p>输入：grid =\n[[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]\n输出：6 解释：答案不应该是 11 ，因为岛屿只能包含水平或垂直这四个方向上的\n1 。</p>\n</blockquote>\n<h3 id=\"思路-3\">思路：</h3>\n<p>这题的⼤体思路和之前完全⼀样，只不过 dfs\n函数淹没岛屿的同时，还应该想办法记录这个岛屿的⾯积。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maxAreaOfIsland</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt;&amp; grid)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> m = grid.<span class=\"built_in\">size</span>(), n = grid[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(grid[i][j] == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                    <span class=\"type\">int</span> ans = <span class=\"built_in\">dfs</span>(grid, i, j);</span><br><span class=\"line\">                    res = <span class=\"built_in\">max</span>(res, ans);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt;&amp; grid, <span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> m = grid.<span class=\"built_in\">size</span>(), n = grid[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"comment\">//base case</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x &lt; <span class=\"number\">0</span> || y &lt; <span class=\"number\">0</span> || x &gt;= m || y &gt;= n) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(grid[x][y] == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//淹没成水</span></span><br><span class=\"line\">        grid[x][y] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">dfs</span>(grid, x + <span class=\"number\">1</span>, y)</span><br><span class=\"line\">             + <span class=\"built_in\">dfs</span>(grid, x, y + <span class=\"number\">1</span>)</span><br><span class=\"line\">             + <span class=\"built_in\">dfs</span>(grid, x - <span class=\"number\">1</span>, y)</span><br><span class=\"line\">             + <span class=\"built_in\">dfs</span>(grid, x, y - <span class=\"number\">1</span>) + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["DFS"],"tags":["DFS"]},{"title":"Dijkstra 最短路径算法","url":"/2022/04/20/Dijkstra-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/","content":"<p>#Dijkstra思想</p>\n<p>前面我们讲<a\nhref=\"https://sjchen404.github.io/2022/04/14/图的遍历/\">图的遍历</a>的时候讲过，图的存储主要就是邻接矩阵和邻接表。</p>\n<p>我们知道广度优先搜索(BFS)也可以查找最短路径，但是却只能针对无权图。</p>\n<p><strong>最短路径：</strong>带权路径长度最短的那条路就是最短路径。</p>\n<p>带权有向图的最短路径问题可以分为两类：一是单源最短路径，即求图中某一顶点到其他顶点的最短路径，可以通过经典的<code>Dijkstra</code>（狄杰斯特拉）算法求解；二是求每对顶点间的最短路径，可通过<code>Floyd</code>（佛洛依德）算法求解。</p>\n<p><code>Dijkstra</code>和<code>Floyd</code>还有一个很大的区别就是<code>Dijkstra</code>不能求解权值为负的问题，<code>Floyd</code>可以求解。</p>\n<span id=\"more\"></span>\n<p>这里先简单介绍下<code>Dijkstra</code>算法思想。</p>\n<p><img src=\"Dijkstra-最短路径算法/1.jpg\" /></p>\n<p>我们计算从顶点<code>1</code>到其他顶点的最短距离。</p>\n<p>开始会选择从以<code>1</code>开始的边中最短的，也就是<code>1-&gt;5</code>，到了<code>5</code>发现有<code>5-&gt;2,5-&gt;3,5-&gt;4</code>可以选，我们该选哪个呢，肯定会选<code>5-&gt;4</code>,因为权值最小，到了<code>4</code>又有<code>4-&gt;1,4-&gt;3</code>可以选因为前面我们<code>1</code>是顶点了，已经取过了，就不能再取了，那只能选<code>4-&gt;3</code>了，可是我们真的能选吗？现在<code>1-&gt;5-&gt;4-&gt;3</code>的权值为<code>5+2+6 = 13</code>可是<code>1-&gt;5-&gt;2-&gt;3</code>的权值只有<code>5+3+1 = 9</code>这不是更短吗？</p>\n<p>所以这就需要我们时时维护更新到达该点的路径，发现更短的就更新。</p>\n<p><img src=\"Dijkstra-最短路径算法/2.jpg\" /></p>\n<p>我们每轮确定一个顶点的最短路径。</p>\n<p>下面我们先采用临接矩阵来实现。</p>\n<p><img src=\"Dijkstra-最短路径算法/3.png\" /></p>\n<p>邻接矩阵<code>graph</code>为：</p>\n<p><img src=\"Dijkstra-最短路径算法/4.png\" /></p>\n<p>我们还需要用一个一维数组 <code>dis</code> 来存储 <code>1</code>\n号顶点到其余各个顶点的初始路程，如下。</p>\n<p><img src=\"Dijkstra-最短路径算法/7.3.png\" /></p>\n<p>我们将此时 dis 数组中的值称为最短路的“估计值”。</p>\n<p>既然是求 <code>1</code>\n号顶点到其余各个顶点的最短路程，那就先找一个离 <code>1</code>\n号顶点最近的顶点。通过数组 <code>dis</code> 可知当前离 <code>1</code>\n号顶点最近是 <code>2</code> 号顶点。当选择了 <code>2</code>\n号顶点后，<code>dis[2]</code>的值就已经从“估计值”变为了“确定值”，即\n<code>1</code> 号顶点到 <code>2</code> 号顶点的最短路程就是当前\n<code>dis[2]</code>值。为什么呢？你想啊，目前离 <code>1</code>\n号顶点最近的是 <code>2</code>\n号顶点，并且这个图所有的边都是正数，那么肯定不可能通过第三个顶点中转，使得\n<code>1</code> 号顶点到 <code>2</code> 号顶点的路程进一步缩短了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//找到离 1 号顶点最近的顶点</span></span><br><span class=\"line\"><span class=\"type\">int</span> minDis = inf;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//没有访问过并且距离小于当前距离，更新</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(visited[j] == <span class=\"number\">0</span> &amp;&amp; dis[j] &lt; minDis)&#123;</span><br><span class=\"line\">        minDis = dis[j];</span><br><span class=\"line\">        u = j;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//标记已经访问过</span></span><br><span class=\"line\">visited[u] = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<p>既然选了 <code>2</code> 号顶点，接下来再来看 <code>2</code>\n号顶点有哪些出边呢。有 <code>2-&gt;3</code> 和\n<code>2-&gt;4</code>这两条边。先讨论通过 <code>2-&gt;3</code>\n这条边能否让 <code>1</code> 号顶点到 <code>3</code>\n号顶点的路程变短。也就是说现在来比较 <code>dis[3]</code>和\n<code>dis[2]+graph[2][3]</code>的大小。其中 <code>dis[3]</code>表示\n<code>1</code> 号顶点到 <code>3</code>\n号顶点的路程。<code>dis[2]+graph[2][3]</code>中 <code>dis[2]</code>表示\n<code>1</code> 号顶点到 <code>2</code>\n号顶点的路程，<code>graph[2][3]</code>表示 <code>2-&gt;3</code>\n这条边。所以 <code>dis[2]+graph[2][3]</code>就表示从 <code>1</code>\n号顶点先到 <code>2</code> 号顶点，再通过 <code>2-&gt;3</code>\n这条边，到达 <code>3</code> 号顶点的路程。</p>\n<p>我们发现\n<code>dis[3]=12，dis[2]+graph[2][3]=1+9=10，dis[3] &gt; dis[2]+graph[2][3]</code>，因此\n<code>dis[3]</code>要更新为\n<code>10</code>。这个过程有个专业术语叫做“松弛”。即\n<code>1</code>号顶点到 <code>3</code>号顶点的路程即\n<code>dis[3]</code>，通过<code>2-&gt;3</code> 这条边松弛成功。这便是\n<code>Dijkstra</code> 算法的主要思想：通过“边”来松弛\n<code>1</code>号顶点到其余各个顶点的路程。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> v = <span class=\"number\">1</span>; v &lt;= n; v++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(graph[u][v] &lt; inf)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//dis[v]表示原来到顶点 v 的距离，dis[u] + graph[u][v]是从新顶点到 v 的距离</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(dis[v] &gt; dis[u] + graph[u][v])&#123;</span><br><span class=\"line\">            dis[v] = dis[u] + graph[u][v];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面同理：</p>\n<p>刚才我们对 <code>2</code> 号顶点所有的出边进行了松弛。松弛完毕之后\n<code>dis</code> 数组为：</p>\n<p><img src=\"Dijkstra-最短路径算法/7.4.png\" /></p>\n<p>同理：</p>\n<p>最终的<code>dis</code>为</p>\n<p><img src=\"Dijkstra-最短路径算法/7.8.png\" /></p>\n<p>OK，现在来总结一下刚才的算法。算法的基本思想是：每次找到离源点（上面例子的源点就是\n<code>1</code>\n号顶点）最近的一个顶点，然后以该顶点为中心进行扩展，最终得到源点到其余所有点的最短路径。基本步骤如下：</p>\n<ul>\n<li>将所有的顶点分为两部分：已知最短路程的顶点集合 P\n和未知最短路径的顶点集合 Q。最开始，已知最短路径的顶点集合 P\n中只有源点一个顶点。我们这里用一个<code>visited[i]</code>数组来记录哪些点在集合\nP 中。例如对于某个顶点 i，如果 <code>visited[i]</code>为 1\n则表示这个顶点在集合 P 中，如果 <code>visited[i]</code>为 0\n则表示这个顶点在集合 Q 中。</li>\n<li>设置源点 <code>s</code> 到自己的最短路径为 0 即\n<code>dis=0</code>。若存在源点有能直接到达的顶点 i，则把\n<code>dis[i]</code>设为\n<code>graph[s][i]</code>。同时把所有其它（源点不能直接到达的）顶点的最短路径为设为\n∞。</li>\n<li>在集合 Q 的所有顶点中选择一个离源点 <code>s</code>最近的顶点\n<code>u</code>（即 <code>dis[u]</code>最小）加入到集合 P。并考察所有以点\nu 为起点的边，对每一条边进行松弛操作。例如存在一条从 u 到 v\n的边，那么可以通过将边 u-&gt;v 添加到尾部来拓展一条从 s 到 v\n的路径，这条路径的长度是\n<code>dis[u]+graph[u][v]</code>。如果这个值比目前已知的\n<code>dis[v]</code>的值要小，我们可以用新值来替代当前<code>dis[v]</code>中的值。</li>\n<li>重复第 3 步，如果集合 Q 为空，算法结束。最终\n<code>dis</code>数组中的值就是源点到所有顶点的最短路径。</li>\n</ul>\n<p>完整代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ll;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">double</span> ld;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; pii;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> vector&lt;<span class=\"type\">int</span>&gt; vi;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> graph[<span class=\"number\">10</span>][<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> dis[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> visited[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> n,m;    <span class=\"comment\">// n 表示顶点个数，m表示边数</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> inf = INT_MAX / <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i == j) graph[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> graph[i][j] = inf;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//构建边</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> from, <span class=\"type\">int</span> to, <span class=\"type\">int</span> weight)</span></span>&#123;</span><br><span class=\"line\">    graph[from][to] = weight;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dijkstra</span><span class=\"params\">(<span class=\"type\">int</span> u)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n - <span class=\"number\">1</span>; i++)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//找到离 1 号顶点最近的顶点</span></span><br><span class=\"line\">        <span class=\"type\">int</span> minDis = inf;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//没有访问过并且距离小于当前距离，更新</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(visited[j] == <span class=\"number\">0</span> &amp;&amp; dis[j] &lt; minDis)&#123;</span><br><span class=\"line\">                minDis = dis[j];</span><br><span class=\"line\">                u = j;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//标记已经访问过</span></span><br><span class=\"line\">        visited[u] = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> v = <span class=\"number\">1</span>; v &lt;= n; v++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(graph[u][v] &lt; inf)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//dis[v]表示原来到顶点 v 的距离，dis[u] + graph[u][v]是从新顶点到 v 的距离</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(dis[v] &gt; dis[u] + graph[u][v])&#123;</span><br><span class=\"line\">                    dis[v] = dis[u] + graph[u][v];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">    <span class=\"comment\">//初始化</span></span><br><span class=\"line\">    <span class=\"built_in\">init</span>();</span><br><span class=\"line\">    <span class=\"comment\">//读入边</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; i++)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> from, to, weight;</span><br><span class=\"line\">        cin &gt;&gt; from &gt;&gt; to &gt;&gt; weight;</span><br><span class=\"line\">        <span class=\"built_in\">add</span>(from, to, weight);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//初始化 dis 数组，这里是 1 号顶点到其余各个顶点的初始路程</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">        dis[i] = graph[<span class=\"number\">1</span>][i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//初始化visited数组,标记有没有访问过</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i&lt;= n; i++)&#123;</span><br><span class=\"line\">        visited[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//1号节点访问过</span></span><br><span class=\"line\">    visited[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">//dijskra算法</span></span><br><span class=\"line\">    <span class=\"built_in\">dijkstra</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">//输出最后结果</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i == n) cout &lt;&lt; dis[i] &lt;&lt; endl;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> cout &lt;&lt; dis[i] &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输入：</p>\n<blockquote>\n<p>6 9 1 2 1 1 3 12 2 3 9 2 4 3 3 5 5 4 3 4 4 5 13 4 6 15 5 6 4</p>\n</blockquote>\n<p>输出：</p>\n<blockquote>\n<p>0 1 8 4 13 17</p>\n</blockquote>\n<h2 id=\"网络延迟时间\"><a\nhref=\"https://leetcode-cn.com/problems/network-delay-time/\">743.\n网络延迟时间</a></h2>\n<p>有 <code>n</code>个网络节点，标记为 <code>1</code>到\n<code>n</code>。</p>\n<p>给你一个列表 <code>times</code>，表示信号经过 <strong>有向</strong>\n边的传递时间。 <code>times[i] = (ui, vi, wi)</code>，其中\n<code>ui</code>是源节点，<code>vi</code>是目标节点，\n<code>wi</code>是一个信号从源节点传递到目标节点的时间。</p>\n<p>现在，从某个节点\n<code>K</code>发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回\n<code>-1</code> 。</p>\n<p>###<strong>示例 1：</strong></p>\n<p><img src=\"Dijkstra-最短路径算法/5.png\" /></p>\n<blockquote>\n<p>输入：times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2 输出：2</p>\n</blockquote>\n<h4 id=\"思想\">思想：</h4>\n<h5 id=\"方法一dijkstra邻接矩阵\">方法一：Dijkstra邻接矩阵</h5>\n<p>负责度为<code>O(N^2)</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> inf = INT_MAX / <span class=\"number\">2</span>;</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; graph;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; dis;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; visited;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">networkDelayTime</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; times, <span class=\"type\">int</span> n, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        graph.<span class=\"built_in\">resize</span>(n + <span class=\"number\">1</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(n + <span class=\"number\">1</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\">        dis.<span class=\"built_in\">resize</span>(n + <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        visited.<span class=\"built_in\">resize</span>(n + <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"comment\">//初始化 graph</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(i == j) graph[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> graph[i][j] = inf;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(vector&lt;<span class=\"type\">int</span>&gt; tmp : times)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> from = tmp[<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"type\">int</span> to = tmp[<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"type\">int</span> weight = tmp[<span class=\"number\">2</span>];</span><br><span class=\"line\">            graph[from][to] = weight;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//初始化dis</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">            dis[i] = graph[k][i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        visited[k] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"built_in\">dijkstra</span>(k, n);</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dis[i] &gt;= inf) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> res = <span class=\"built_in\">max</span>(dis[i], res);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dijkstra</span><span class=\"params\">(<span class=\"type\">int</span> u, <span class=\"type\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n - <span class=\"number\">1</span>; i++)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> minDis = inf;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(visited[j] == <span class=\"number\">0</span> &amp;&amp; dis[j] &lt; minDis)&#123;</span><br><span class=\"line\">                    minDis = dis[j];</span><br><span class=\"line\">                    u = j;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            visited[u] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> v = <span class=\"number\">1</span>; v &lt;= n; v++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(graph[u][v] &lt; inf)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(dis[v] &gt; dis[u] + graph[u][v])&#123;</span><br><span class=\"line\">                        dis[v] = dis[u] + graph[u][v];</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"方法二-邻接矩阵小根堆\">方法二： 邻接矩阵+小根堆</h5>\n<p>复杂度为<code>O(N^2)</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> inf = INT_MAX / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">networkDelayTime</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; times, <span class=\"type\">int</span> n, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;vector&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; &gt; &gt; <span class=\"built_in\">edge</span>(n + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(vector&lt;<span class=\"type\">int</span>&gt; tmp : times)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//构建邻接表</span></span><br><span class=\"line\">            edge[tmp[<span class=\"number\">0</span>]].<span class=\"built_in\">push_back</span>(<span class=\"built_in\">make_pair</span>(tmp[<span class=\"number\">1</span>], tmp[<span class=\"number\">2</span>]));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//以节点 k 为起点到其他节点的最短路径</span></span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dist</span><span class=\"params\">(n + <span class=\"number\">1</span>, inf)</span></span>;</span><br><span class=\"line\">        <span class=\"comment\">//k 到 k 的最短距离为 0 </span></span><br><span class=\"line\">        dist[k] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//小根堆greater&lt;&gt;,大根堆less&lt;&gt;</span></span><br><span class=\"line\">        priority_queue&lt;pair&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt;, vector&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; &gt;, greater&lt;&gt;&gt;q;</span><br><span class=\"line\">        <span class=\"comment\">//从起点开始BFS</span></span><br><span class=\"line\">        q.<span class=\"built_in\">emplace</span>(<span class=\"number\">0</span>, k);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(! q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">            <span class=\"comment\">// pair&lt;int,int&gt; p = q.top();</span></span><br><span class=\"line\">            <span class=\"keyword\">auto</span> p = q.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">            q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            <span class=\"type\">int</span> curDistFromStart = p.first;</span><br><span class=\"line\">            <span class=\"type\">int</span> curNodeID = p.second;</span><br><span class=\"line\">          \t<span class=\"comment\">//小于就跳过</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dist[curNodeID] &lt; curDistFromStart)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//将 x 的相邻节点装入队列</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;neighbor : edge[curNodeID])&#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> nextNodeID = neighbor.first;</span><br><span class=\"line\">                <span class=\"type\">int</span> distToNextNode = dist[curNodeID] + neighbor.second;</span><br><span class=\"line\">                <span class=\"comment\">//更新,距离小于原来节点到当前节点的距离</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(distToNextNode &lt; dist[nextNodeID])&#123;</span><br><span class=\"line\">                    dist[nextNodeID] = distToNextNode;</span><br><span class=\"line\">                    q.<span class=\"built_in\">emplace</span>(distToNextNode, nextNodeID);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dist[i] &gt;= inf) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> res = <span class=\"built_in\">max</span>(res, dist[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"方法三floyd\">方法三：floyd</h5>\n<p>floyd</p>\n<p>时间复杂度：<code>O(n^3)</code></p>\n<p>空间复杂度：<code>O(n^2)</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; graph;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> inf = INT_MAX / <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">networkDelayTime</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; times, <span class=\"type\">int</span> n, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        graph.<span class=\"built_in\">resize</span>(n + <span class=\"number\">1</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(n + <span class=\"number\">1</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(i == j) graph[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> graph[i][j] = inf;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//存图</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(vector&lt;<span class=\"type\">int</span>&gt; tmp : times)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> from = tmp[<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"type\">int</span> to = tmp[<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"type\">int</span> weight = tmp[<span class=\"number\">2</span>];</span><br><span class=\"line\">            graph[from][to] = weight;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//最短路</span></span><br><span class=\"line\">        <span class=\"built_in\">floyd</span>(n);</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(graph[k][i] &gt;= inf) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> res = <span class=\"built_in\">max</span>(res, graph[k][i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">floyd</span><span class=\"params\">(<span class=\"type\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//floyd基本流程三层循环</span></span><br><span class=\"line\">        <span class=\"comment\">//枚举中转点 - 枚举起点 - 枚举终点 - 松弛操作</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> p = <span class=\"number\">1</span>; p &lt;= n; p++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++)&#123;</span><br><span class=\"line\">                    graph[i][j] = <span class=\"built_in\">min</span>(graph[i][j], graph[i][p] + graph[p][j]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["图"],"tags":["图","最短路径"]},{"title":"Docker安装Linux","url":"/2022/05/25/Docker%E5%AE%89%E8%A3%85/","content":"<h1 id=\"安装docker\">1. 安装docker</h1>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">brew install --cask --appdir=/Applications docker</span><br></pre></td></tr></table></figure>\n<p>启动终端后，通过命令可以检查安装后的 Docker 版本。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker --version</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<blockquote>\n<p>Docker version 20.10.14, build a224086</p>\n</blockquote>\n<span id=\"more\"></span>\n<h1 id=\"镜像加速\">2. 镜像加速</h1>\n<p>Preference -- Docker Engine</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;debug&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;experimental&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">false</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;registry-mirrors&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">    <span class=\"string\">&quot;https://e29lwva9.mirror.aliyuncs.com&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>然后重启一下</p>\n<p>在终端输入</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker info</span><br></pre></td></tr></table></figure>\n<p>如果出现<code>Registry Mirrors</code>则成功</p>\n<h1 id=\"安装linux系统\">3. 安装Linux系统</h1>\n<p>这里安装的是centos系统</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker pull centos</span><br></pre></td></tr></table></figure>\n<p>拉取<code>centos</code>系统后，输入</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker images</span><br></pre></td></tr></table></figure>\n<p>查看镜像，发现<code>centos</code>我们已经安装成功</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -it centos</span><br></pre></td></tr></table></figure>\n<p>启动一个centos镜像并交互式运行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">ls</span></span><br></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<blockquote>\n<p>bin dev etc home lib lib64 lost+found media mnt opt proc root run\nsbin srv sys tmp usr var</p>\n</blockquote>\n<p>至此，Linux系统成功配置</p>\n","categories":["Docker"],"tags":["Docker"]},{"title":"Essential C++ 第三章 范型编程风格","url":"/2022/04/04/Essential-C++-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%8C%83%E5%9E%8B%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC/","content":"<h1 id=\"指针的算术运算\">3.1 指针的算术运算</h1>\n<p>假设我们需要完成以下工作。写一个函数可以同时处理<code>vector</code>和<code>array</code>内的任意类型元素。</p>\n<span id=\"more\"></span>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> elemType&gt;</span><br><span class=\"line\"><span class=\"function\">elemType* <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">const</span> elemType *first, <span class=\"type\">const</span> elemType *last, <span class=\"type\">const</span> elemType &amp;value)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!first || !last)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(; first != last; ++first)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(*first == value)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> first;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> ia[<span class=\"number\">8</span>] = &#123;<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>,<span class=\"number\">13</span>,<span class=\"number\">21</span>&#125;;</span><br><span class=\"line\">    <span class=\"type\">double</span> da[<span class=\"number\">6</span>] = &#123;<span class=\"number\">1.5</span>, <span class=\"number\">2.0</span>, <span class=\"number\">2.5</span>, <span class=\"number\">3.0</span>, <span class=\"number\">3.5</span>, <span class=\"number\">4.0</span>&#125;; </span><br><span class=\"line\">    string sa[<span class=\"number\">4</span>] = &#123;<span class=\"string\">&quot;pooh&quot;</span>, <span class=\"string\">&quot;piglet&quot;</span>, <span class=\"string\">&quot;eeyore&quot;</span>, <span class=\"string\">&quot;tigger&quot;</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> *pi = <span class=\"built_in\">find</span>(ia, ia + <span class=\"number\">8</span>, ia[<span class=\"number\">3</span>]);</span><br><span class=\"line\">    <span class=\"type\">double</span> *pd = <span class=\"built_in\">find</span>(da, da + <span class=\"number\">6</span>, da[<span class=\"number\">3</span>]);</span><br><span class=\"line\">    string *ps = <span class=\"built_in\">find</span>(sa, sa + <span class=\"number\">4</span>, sa[<span class=\"number\">3</span>]);</span><br><span class=\"line\">    cout &lt;&lt; *pi &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; *pd &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; *ps &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"了解iterator范型指针\">3.2 了解Iterator(范型指针)</h1>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(iter = svec.<span class=\"built_in\">begin</span>(); iter != svec.<span class=\"built_in\">end</span>(); ++iter)</span><br><span class=\"line\">\tcout &lt;&lt; *iter &lt;&lt; <span class=\"string\">&#x27; &#x27;</span>;</span><br></pre></td></tr></table></figure>\n<p><code>vector&lt;string&gt;::iterator iter = sevc.begin()</code></p>\n<p>此处<code>iter</code>被定义为一个<code>iterator</code>，指向一个<code>vector</code>，后者的元素类型为<code>string</code>。其初值指向\nsvec 的第一个元素。</p>\n<h1 id=\"所有容器的共通操作\">3.3 所有容器的共通操作</h1>\n<ul>\n<li>equality(==) 和inequality(!=)</li>\n<li>assignment(=)，将某个容器复制给另一个容器</li>\n<li>empty()会在容器无任何元素时返回 true,否则返回 false</li>\n<li>size() 返回容器内目前持有的元素个数</li>\n<li>clear() 删除所有元素</li>\n</ul>\n<h1 id=\"使用顺序性容器\">3.4 使用顺序性容器</h1>\n<p>顺序性容器用来维护一组排列有序，类型相同的元素。<code>vector</code>和<code>list</code>是两个最组要的顺序性容器。</p>\n<p><code>vector</code>以一块连续的内存来存放元素，可以进行随机访问，但是插入效率低。</p>\n<p><code>list</code>以双向链接来存储内容，因此可以执行前进或后退操作。<code>list</code>的每个元素都包含三个字段：<code>value</code>，<code>back</code>指针（指向前一个元素），<code>front</code>指针（指向下一个元素）,所以<code>list</code>插入，删除效率高，随机访问效率低。</p>\n<p>第三种顺序性容器是<code>deque</code>，<code>deque</code>也是以连续内存存储元素。和<code>vector</code>不同的是，<code>deque</code>对于前端元素的插入和删除操作，效率更高；末端亦同。如果我们需要在容器最前端插入元素，并执行末端删除操作，那么<code>deque</code>便很理想。</p>\n<h1 id=\"使用范型算法\">3.5 使用范型算法</h1>\n<p>引入头文件</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>find()\n用于搜索无序集合中是否存在某值。如果找到，则返回一个<code>iterator</code>指向该值，否则返回一个<code>iterator</code>指向\nlast</li>\n<li>binary_search() 用于有序集合的搜索。如果找到目标，就返回 true，否则\nfalse</li>\n<li>count() 返回数值相符的元素数目</li>\n<li>search()\n对比某个容器内是否存在某个子序列。例如{1,3,5,7,2,9}，如果搜索子序列{5,7,2}，则search()会返回一个<code>iterator</code>指向子序列的起始处，如果子序列不存在，就返回一个<code>iterator</code>指向容器末端。</li>\n</ul>\n<h1 id=\"如何设计一个范型算法\">3.6 如何设计一个范型算法</h1>\n<h1 id=\"使用map\">3.7 使用map</h1>\n<p>map 被定义为一对（pair）数值。</p>\n<h1 id=\"使用set\">3.8 使用set</h1>\n<p>如果想知道某值是否在某个集合中，就可以用<code>set</code>，不统计出现的次数。</p>\n<h1 id=\"如何使用iterator-inserter\">3.9 如何使用Iterator Inserter</h1>\n<h1 id=\"使用iostream-iterator\">3.10 使用iostream Iterator</h1>\n","categories":["Essential C++"],"tags":["Essential C++"]},{"title":"Essential C++ 第二章 面向过程的编程风格","url":"/2022/04/03/Essential-C++-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC/","content":"<h1 id=\"如何编写函数\">2.1 如何编写函数</h1>\n<p><strong>每个函数必须定义一下四个部分：</strong></p>\n<p>1，放回类型</p>\n<p>2，函数名</p>\n<p>3，参数列表</p>\n<p>4，函数体</p>\n<p><strong>函数必须先被声明才能调用</strong></p>\n<span id=\"more\"></span>\n<h1 id=\"调用函数\">2.2 调用函数</h1>\n<p><strong>两种参数传递方式：传址(by reference) 和传值(by\nvalue)</strong></p>\n<p>传值：比如我们交换两个数的值</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">mySwap</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> temp = a;</span><br><span class=\"line\">\ta = b;</span><br><span class=\"line\">\tb = temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> a = <span class=\"number\">4</span>, b = <span class=\"number\">5</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">mySwap</span>(a, b);</span><br><span class=\"line\">\tcout &lt;&lt; a &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; b;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时<code>a</code>和<code>b</code>的结果为什么呢？很显然<code>a = 4, b = 5</code>，结果并没有改变，因为像我们这样传值进入函数，默认情况下其值会被复制一份，只在函数中有效，和我们主函数中的<code>a,b</code>没有什么联系。</p>\n<p>那么我们应该如何修改让<code>a</code>和<code>b</code>可以交换呢？答案就是我们传地址进入。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">mySwap</span><span class=\"params\">(<span class=\"type\">int</span>&amp; a, <span class=\"type\">int</span>&amp; b)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> temp = a;</span><br><span class=\"line\">\ta = b;</span><br><span class=\"line\">\tb = temp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> a = <span class=\"number\">4</span>, b = <span class=\"number\">5</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">mySwap</span>(a, b);</span><br><span class=\"line\">\tcout &lt;&lt; a &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; b;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样结果就为<code>a = 5, b = 4</code></p>\n<h1 id=\"提供默认参数值\">2.3 提供默认参数值</h1>\n<p><strong>关于默认参数值的提供，有两个规则：</strong></p>\n<p>1，默认值的解析操作由最右边开始进行</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//错误：没有为vec提供默认值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">display</span><span class=\"params\">(ostream &amp;os = cout, <span class=\"type\">const</span> vector&lt;<span class=\"type\">int</span>&gt;&amp; vec)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//正确</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">display</span><span class=\"params\">(<span class=\"type\">const</span> vector&lt;<span class=\"type\">int</span>&gt;&amp; vec, ostream &amp;os = cout)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>2，默认值只能够指定一次，可以在函数声明处，也可以在函数定义处，但不能在两个地方都指定。</p>\n<p>通常，函数声明会被放在头文件。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> CIRCLE_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CIRCLE_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//头文件 NumericSeq.h</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">mySwap</span><span class=\"params\">(<span class=\"type\">int</span>&amp;, <span class=\"type\">int</span>&amp;)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//mySwap.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;mySwap.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">mySwap</span><span class=\"params\">(<span class=\"type\">int</span>&amp; a, <span class=\"type\">int</span>&amp; b)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> temp = a;</span><br><span class=\"line\">\ta = b;</span><br><span class=\"line\">\tb = temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//main.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;mySwap.cpp&quot;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> a = <span class=\"number\">4</span>, b= <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"built_in\">mySwap</span>(a,b);</span><br><span class=\"line\">    cout &lt;&lt; a &lt;&lt; <span class=\"string\">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"使用局部静态对象\">2.4 使用局部静态对象</h1>\n<p>局部静态<code>static</code>对象和局部非静态对象不同的是，局部静态对象所处的内存空间，即使在不同的函数调用过程中，依然持续存在，不像局部非静态对象一样，每次在被调用时重新建立，调用完就破坏。</p>\n<h1 id=\"声明-inline-函数\">2.5 声明 inline 函数</h1>\n<p>将函数声明为<code>inline</code>，表示要求编译器在每个函数调用点上，将函数的内容展开。</p>\n<p>只要在一个函数前面加上关键字<code>inline</code>，便可将该函数声明为\ninline.</p>\n<p>一般而言，最适合声明为<code>inline</code>的函数：体积小，经常被调用，所从事的计算并不复杂</p>\n<h1 id=\"提供重载函数\">2.6 提供重载函数</h1>\n<p>参数列表不相同（可能是参数类型不同，可能是参数个数不同）的两个或多个函数，可以拥有<strong>相同的函数名称</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">display</span><span class=\"params\">(<span class=\"type\">char</span> ch)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">display</span><span class=\"params\">(string&amp;)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">display</span><span class=\"params\">(<span class=\"type\">int</span>, <span class=\"type\">int</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">display</span><span class=\"params\">(string&amp; <span class=\"type\">int</span>, <span class=\"type\">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n<h1 id=\"定义并使用模版函数\">2.7 定义并使用模版函数</h1>\n<p>假设我们增加三个display_message() 函数，分别用来处理 int, double,\nstring 三种vector。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">display_message</span><span class=\"params\">(<span class=\"type\">const</span> string&amp;, <span class=\"type\">const</span> vector&lt;<span class=\"type\">int</span>&gt;&amp;)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">display_message</span><span class=\"params\">(<span class=\"type\">const</span> string&amp;, <span class=\"type\">const</span> vector&lt;<span class=\"type\">double</span>&gt;&amp;)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">display_message</span><span class=\"params\">(<span class=\"type\">const</span> string&amp;, <span class=\"type\">const</span> vector&lt;string&gt;&amp;)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>我们希望可以只通过一个函数就可以满足这三种情况，模版函数将参数列表的全部（部分）参数的类型抽离出来。</p>\n<p>模版函数以关键字<code>template</code>开场，其后紧接着以尖括号(&lt;&gt;)包围起来的一个或多个标识符。</p>\n<h1 id=\"函数指针带来更大的弹性\">2.8 函数指针带来更大的弹性</h1>\n<p>函数指针必须指明其所指的返回类型及参数列表。</p>\n<h1 id=\"设定头文件\">2.9 设定头文件</h1>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> CIRCLE_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CIRCLE_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//头文件 NumericSeq.h</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">mySwap</span><span class=\"params\">(<span class=\"type\">int</span>&amp;, <span class=\"type\">int</span>&amp;)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//mySwap.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;mySwap.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">mySwap</span><span class=\"params\">(<span class=\"type\">int</span>&amp; a, <span class=\"type\">int</span>&amp; b)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> temp = a;</span><br><span class=\"line\">\ta = b;</span><br><span class=\"line\">\tb = temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["Essential C++"],"tags":["Essential C++"]},{"title":"Essential C++ 第五章 面向对象编程风格","url":"/2022/04/23/Essential-C++-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC/","content":"<h1 id=\"第五章-面向对象编程风格\">第五章 面向对象编程风格</h1>\n<h2 id=\"面向对象编程概念\">5.1 面向对象编程概念</h2>\n<p>面向对象编程概念的两项最主要特质是：<strong>继承</strong>和<strong>多态</strong>。前者使我们得以将一群相关的类组织起来，并让我们得以分享其间的共通数据和操作行为，后者让我们在这些类之上进行编程时，可以如同操作单一个体，而非互相独立的类，并赋予我们更多弹性来加入或移除任何特定类。</p>\n<p><strong>继承</strong>机制定义了父子关系。父类定义了所有子类共通的共有接口和私有实现。每个子类都可以增加或覆盖（<code>override</code>）继承而来的东西，以实现其自身独特的行为。</p>\n<p>在C++中，父类被称为<strong>基类（base\nclass）</strong>，子类被称为<strong>派生类(derived\nclass)</strong>。父类和子类之间的关系则称为继承体系。</p>\n<p><strong>抽象基类：</strong>\n例如下面的<code>LibMat</code>，<code>LibMat</code>用来定义图书馆系统中所有馆藏的共通操作行为，包括<code>check_in()</code>,<code>check_on()</code>,<code>due_data()</code>,<code>find()</code>等等。<code>LibMat</code>并不代表图书馆借阅管理系统中实际存在的任何一个馆藏，仅仅是为了我们设计上的需要而存在。但事实上这个抽象十分关键。我们称之为\"抽象基类\"。</p>\n<span id=\"more\"></span>\n<p><img src=\"Essential-C++-第五章-面向对象编程风格/5.1.jpg\" /></p>\n<p>在面向对象应用程序时中，我们会间接利用「指向抽象基类」的指针或引用来操作系统中的各对象，而不是直接操作各个实际对象。这让我们得以在不更动旧友程序的前提下，加入或移除任何一个派生类。如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">loan_check_in</span><span class=\"params\">(LiMat &amp;mat)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//mat 实际上代表派生类的对象</span></span><br><span class=\"line\">    <span class=\"comment\">//诸如Book,RentalBook,Magazines等</span></span><br><span class=\"line\">    mat.<span class=\"built_in\">check_in</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(mat.<span class=\"built_in\">is_late</span>())</span><br><span class=\"line\">        mat.<span class=\"built_in\">assest_fine</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(mat.<span class=\"built_in\">waiting_list</span>())</span><br><span class=\"line\">        mat.<span class=\"built_in\">notify_available</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们的程序中并不存在<code>LiMat</code>对象，只有<code>Book</code>,<code>RentalBook</code>等类对象。</p>\n<p>面向对象编程风格的第二个独特概念是<strong>多态：</strong>\n让基类的指针或引用得以十分透明地指向其任何一个派生类的对象。以上述的<code>loan_check_in()</code>为例，<code>mat</code>总是指向（代表）<code>LiMat</code>的某个派生对象。但究竟是哪个？除非程序实际运行的当下，否则无法确定。而且，<code>loan_check_in()</code>的每次执行情况都可能不同。</p>\n<p><strong>动态绑定</strong>是面向对象编程风格的第三个独特概念。就是直到运行时，我们才能找出实际被调用的是哪个派生类的函数。</p>\n<p><strong>总结：</strong></p>\n<blockquote>\n<p>继承特性让我们得以定义一整群互有关联的类，并享有共通的接口，就像上述的各种图书馆藏。多态则让我们得以用一种与类型无关的方式来操作这些类对象。我们通过抽象基类的指针或引用来操作其共通接口，而实际执行起来的操作则需要等到运行时，依据指针或引用所指的实际对象的类型才能决定。<strong>多态和动态绑定的特性，只有在使用指针或引用时才能发挥。</strong></p>\n</blockquote>\n<h2 id=\"漫游面向对象编程思维\">5.2 漫游：面向对象编程思维</h2>\n<p>我们从<code>LibMat</code>排生出<code>Book</code>，再从<code>Book</code>派生出<code>AudioBook</code>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">LibMat</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">LibMat</span>()&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;调用构造函数LibMat::LibMat()\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">LibMat</span>()&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;调用析构函数LibMat::~LibMat()\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;调用LibMat::print(),我是一个LibMat对象!\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"type\">const</span> LibMat &amp;mat)</span></span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;调用mat.print()\\n&quot;</span>;</span><br><span class=\"line\">    mat.<span class=\"built_in\">print</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//继承LibMat</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Book</span> :<span class=\"keyword\">public</span> LibMat&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">Book</span>(<span class=\"type\">const</span> string &amp;title, <span class=\"type\">const</span> string &amp;author)</span><br><span class=\"line\">    :_title(title),_author(author)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;调用构造函数Book::Book()\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Book</span>()&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;调用析构函数Book::~Book()\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;调用Book::print()\\n我是一个Book对象\\n&quot;</span></span><br><span class=\"line\">        &lt;&lt; <span class=\"string\">&quot;我的名称是：&quot;</span> &lt;&lt; _title &lt;&lt; <span class=\"string\">&quot;我的作者是：&quot;</span> &lt;&lt; _author &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"comment\">//protected的成员派生类都可以访问</span></span><br><span class=\"line\">    string _title;</span><br><span class=\"line\">    string _author;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//继承Book</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">AudioBook</span> :<span class=\"keyword\">public</span> Book&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">AudioBook</span>(<span class=\"type\">const</span> string &amp;title, <span class=\"type\">const</span> string &amp;author, <span class=\"type\">const</span> string &amp;narr)</span><br><span class=\"line\">    :<span class=\"built_in\">Book</span>(title,author), _narr(narr)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;调用构造函数AudioBook::AudioBook\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//析构函数</span></span><br><span class=\"line\">    ~<span class=\"built_in\">AudioBook</span>()&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;调用AudioBook::print()\\n&quot;</span> &lt;&lt; <span class=\"string\">&quot;我是一个AudioBook对象!\\n&quot;</span></span><br><span class=\"line\">\t\t\t&lt;&lt; <span class=\"string\">&quot;我的名称是：&quot;</span> &lt;&lt; _title &lt;&lt; <span class=\"string\">&quot;我的作者是&quot;</span> &lt;&lt; _author</span><br><span class=\"line\">\t\t\t&lt;&lt; <span class=\"string\">&quot;我的旁白是&quot;</span> &lt;&lt; _narr &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    string _narr;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">AudioBook <span class=\"title\">ab</span><span class=\"params\">(<span class=\"string\">&quot;Esstential C++&quot;</span>,<span class=\"string\">&quot;候杰&quot;</span>,<span class=\"string\">&quot;KKKK&quot;</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(ab);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<blockquote>\n<p>调用构造函数LibMat::LibMat() 调用构造函数Book::Book()\n调用构造函数AudioBook::AudioBook 调用mat.print() 调用Book::print()\n我是一个Book对象 我的名称是：Esstential C++我的作者是：候杰\n调用AudioBook::print() 我是一个AudioBook对象! 我的名称是：Esstential\nC++我的作者是候杰我的旁白是KKKK 调用析构函数Book::~Book()\n调用析构函数LibMat::~LibMat()</p>\n</blockquote>\n<h2 id=\"不带继承的多态\">5.3 不带继承的多态</h2>\n<p>利用函数指针数组和枚举在某种程度上也能模拟多态，但是每次维护所需要的成本极大。</p>\n<h2 id=\"定义一个抽象基类\">5.4 定义一个抽象基类</h2>\n<p>我们要为<strong>斐波那契数列</strong>设计一个共享的抽象基类，然后继承它。</p>\n<p><strong>定义抽象类的第一个步骤就是找出所有子类共通的操作行为。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">num_sequence</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//elem(pos): 返回 pos 位置上的元素</span></span><br><span class=\"line\">    <span class=\"comment\">//gen_elems(pos): 产生直到 pos 位置的所有元素</span></span><br><span class=\"line\">    <span class=\"comment\">//what_am_i(): 返回确切的数列类型</span></span><br><span class=\"line\">    <span class=\"comment\">//print(os): 将所有元素写入 os</span></span><br><span class=\"line\">    <span class=\"comment\">//check_integrity(pos): 检查 pos 是否为有效位置</span></span><br><span class=\"line\">    <span class=\"comment\">//max_elems(): 返回所支持的最大位置值</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">elem</span><span class=\"params\">(<span class=\"type\">int</span> pos)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">gen_elems</span><span class=\"params\">(<span class=\"type\">int</span> pos)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">const</span> <span class=\"type\">char</span>* <span class=\"title\">what_am_i</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\">    <span class=\"function\">ostream&amp; <span class=\"title\">print</span><span class=\"params\">(ostream &amp;os = cout)</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">check_integrity</span><span class=\"params\">(<span class=\"type\">int</span> pos)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title\">max_elems</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>设计抽象基类的下一步，便是设法找出哪些操作行为与类型相关</strong>----也就是说有哪些操作行为必须根据不同的派生类而有不同的实现方式。这些操作行为应该成为整个类继承体系中的虚函数。</p>\n<blockquote>\n<p>需要注意的是static修饰的函数无法被声明为虚函数</p>\n</blockquote>\n<p><strong>设计抽象基类的第三步，便是试着找出每个操作行为的访问层级。</strong></p>\n<ul>\n<li><p>如果某个操作行为应该让一般程序都能访问，我们应该将它声明为<code>public</code>，例如<code>elem()</code>,<code>max_elems()</code>,<code>what_am_i()</code>。</p></li>\n<li><p>如果某个操作行为在基类之外不需要被用到，我们就将它声明为<code>private</code>。即使是该基类的派生类，亦无法访问基类中的<code>private member</code>。本例的所有操作都必须给派生类使用，所以我们不能把它们声明为<code>private</code>。</p></li>\n<li><p>第三种访问层级，是所谓的<code>protected</code>，这种层级的操作行为可让派生类访问，却不允许一般程序使用。例如<code>check_integrity（）</code>和<code>gen_elems()</code>都是派生类必须调用的，却不是一般程序会用到的。</p></li>\n</ul>\n<p>下面就是重新修改后的<code>num_sequence</code>class定义：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">num_sequence</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">num_sequence</span>()&#123;&#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">int</span> <span class=\"title\">elem</span><span class=\"params\">(<span class=\"type\">int</span> pos)</span> <span class=\"type\">const</span> </span>= <span class=\"number\">0</span>;        <span class=\"comment\">//返回 pos 位置上的元素</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">const</span> <span class=\"type\">char</span>* <span class=\"title\">what_am_i</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>= <span class=\"number\">0</span>;  <span class=\"comment\">//返回确切的数列类型</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title\">max_elems</span><span class=\"params\">()</span></span>&#123;                     <span class=\"comment\">//返回所支持的最大位置值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> _max_elems;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> ostream&amp; <span class=\"title\">print</span><span class=\"params\">(ostream &amp;os = cout)</span> <span class=\"type\">const</span> </span>= <span class=\"number\">0</span>;   <span class=\"comment\">//将所有元素写入 os</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">gen_elems</span><span class=\"params\">(<span class=\"type\">int</span> pos)</span> <span class=\"type\">const</span> </span>= <span class=\"number\">0</span>;              <span class=\"comment\">//产生直到 pos 位置的所有元素</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">check_integrity</span><span class=\"params\">(<span class=\"type\">int</span> pos)</span> <span class=\"type\">const</span></span>;                    <span class=\"comment\">//检查 pos 是否为有效位置</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">static</span> <span class=\"type\">int</span> _max_elems = <span class=\"number\">1024</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>每个虚函数，要么有定义，要么可设为<strong>“纯”虚函数</strong>------如果对于该类而言，这个虚函数并无实质意义的话，将虚函数赋值为0，意思便是令它成为一个纯虚函数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">gen_elems</span><span class=\"params\">(<span class=\"type\">int</span> pos)</span> </span>= <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n<p>任何类如果有一个（或多个）纯虚函数，那么，由于其接口的不完整性，程序无法为它产生任何对象。这种类只能作为<strong>派生类的子对象使用</strong>，而且前提是这些派生类必须为所有虚函数提供确切的定义。</p>\n<blockquote>\n<p>这里有几点要注意的点，由于static成员所有对象只有一份，所有类也只有一份，所以static成员函数没法声明成虚函数。</p>\n<p>由于虚函数是运行的时候才决定要调用哪一个，所以我们在使用那个接口以前虚函数必须有定义，如果这个虚函数在基类中什么也不干的话可以设计成纯虚函数。</p>\n</blockquote>\n<p>对于抽象基类，如果这个基类没有需要初始化的数据成员，那么就没必要给他写构造函数。</p>\n<p>对于析构函数，最好不要在抽象基类中把他声明成纯虚函数。</p>\n<p>以下为一个数列的抽象基类。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">num_sequence</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">num_sequence</span>()&#123;&#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">int</span> <span class=\"title\">elem</span><span class=\"params\">(<span class=\"type\">int</span> pos)</span> <span class=\"type\">const</span> </span>= <span class=\"number\">0</span>;        <span class=\"comment\">//返回 pos 位置上的元素</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">const</span> <span class=\"type\">char</span>* <span class=\"title\">what_am_i</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>= <span class=\"number\">0</span>;  <span class=\"comment\">//返回确切的数列类型</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title\">max_elems</span><span class=\"params\">()</span></span>&#123;                     <span class=\"comment\">//返回所支持的最大位置值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> _max_elems;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> ostream&amp; <span class=\"title\">print</span><span class=\"params\">(ostream &amp;os = cout)</span> <span class=\"type\">const</span> </span>= <span class=\"number\">0</span>;   <span class=\"comment\">//将所有元素写入 os</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">gen_elems</span><span class=\"params\">(<span class=\"type\">int</span> pos)</span> <span class=\"type\">const</span> </span>= <span class=\"number\">0</span>;              <span class=\"comment\">//产生直到 pos 位置的所有元素</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">check_integrity</span><span class=\"params\">(<span class=\"type\">int</span> pos)</span> <span class=\"type\">const</span></span>;                    <span class=\"comment\">//检查 pos 是否为有效位置</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">static</span> <span class=\"type\">int</span> _max_elems = <span class=\"number\">1024</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">num_sequence::check_integrity</span><span class=\"params\">(<span class=\"type\">int</span> pos)</span> <span class=\"type\">const</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pos &lt;= <span class=\"number\">0</span> || pos &gt; _max_elems)&#123;</span><br><span class=\"line\">        cerr &lt;&lt; <span class=\"string\">&quot;!!位置非法\\n&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(ostream &amp;os, <span class=\"type\">const</span> num_sequence &amp;ns)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ns.<span class=\"built_in\">print</span>(os);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"定义一个派生类\">5.5 定义一个派生类</h2>\n<p>派生类由两部分组成：一是基类构成的子对象，二是派生类的部分。派生类的名称之后紧跟着冒号，关键字<code>public</code>，以及基类的名称。唯一的规则就是，类进行继承声明之前，其基类的定义必须已经存在。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;num_sequence.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Fibonacci</span> : <span class=\"keyword\">public</span> num_sequence&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>派生类由基类的非静态数据成员和派生类自己的特有部分组成。</strong></p>\n<p><strong>派生类必须对从基类继承来的每个纯虚函数给出具体的实现。</strong></p>\n<p><code>Fibonacci class</code>必须为其基类继承而来的每个纯虚函数提供对应的实现。除此之外，它还必须声明<code>Fibonacci</code>class\n专属的<code>member</code>。以下为<code>Fibonacci</code>class\n的定义：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;num_sequence.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Fibonacci</span> : <span class=\"keyword\">public</span> num_sequence&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Fibonacci</span>(<span class=\"type\">int</span> len = <span class=\"number\">1</span>, <span class=\"type\">int</span> beg_pos = <span class=\"number\">1</span>)</span><br><span class=\"line\">    :_length(len), _beg_pos(beg_pos)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">int</span> <span class=\"title\">elem</span><span class=\"params\">(<span class=\"type\">int</span> pos)</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">const</span> <span class=\"type\">char</span>* <span class=\"title\">what_am_i</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Fibonacci&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> ostream&amp; <span class=\"title\">print</span><span class=\"params\">(ostream &amp;os = cout)</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">length</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _length;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">beg_pos</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _beg_pos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">gen_elems</span><span class=\"params\">(<span class=\"type\">int</span> pos)</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> _length;</span><br><span class=\"line\">    <span class=\"type\">int</span> _beg_pos;</span><br><span class=\"line\">    <span class=\"type\">static</span> vector&lt;<span class=\"type\">int</span>&gt; _elems;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>我们把没有把长度和起始位置，<code>length()</code>和<code>beg_pos()</code>设置为虚函数，因为它们并无基类所提供的实体可供覆盖。但这样的话我们也无法通过基类的指针或引用来访问。所以我们最好在基类中加入两个纯虚函数。</p>\n<p>以下便是<code>elem()</code>的实现。派生类的虚函数必须精确吻合基类中的函数原型。在类之外对虚函数进行定义时，不必指明关键字<code>virtual</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Fibonacci::elem</span><span class=\"params\">(<span class=\"type\">int</span> pos)</span> <span class=\"type\">const</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//不合法</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!<span class=\"built_in\">check_integrity</span>(pos))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pos &gt; _elems.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">        Fibonacci::<span class=\"built_in\">gen_elems</span>(pos);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _elems[pos - <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一般来说，继承而来的<code>public</code>成员和<code>protected</code>成员，都可以视为派生类自身拥有的成员。基类的<code>public member</code>在派生类中同样是<code>public</code>，同样开发给派生类用户使用。基类的<code>protected member</code>在派生类中同样也是<code>protected</code>，同样只能给后续的派生类使用，无法给目前这个派生类的用户使用。基类的<code>private member</code>，则完全无法让派生类使用。</p>\n<p>在返回<code>pos</code>位置上的元素前，我们会检查<code>_elems</code>拥有的元素是否足够。如果不够，<code>elem()</code>会调用<code>gen_elems()</code>，计算必要的元素并填入<code>_elems</code>。这个操作必须写成<code>Fibonacci::gen_elems(pos)</code>，因为我们很清楚我们想调用的究竟是哪一个<code>gen_elems()</code>，不必等到运行时才进行<code>gen_elems()</code>的解析操作。</p>\n<p>下面我们实现<code>gen_elems()</code>和<code>print()</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//计算斐波那契数列元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Fibonacci::gen_elems</span><span class=\"params\">(<span class=\"type\">int</span> pos)</span> <span class=\"type\">const</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//pos = 0 和 pos = 1时，斐波那契为 1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(_elems.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">        _elems.<span class=\"built_in\">push_back</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">        _elems.<span class=\"built_in\">push_back</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(_elems.<span class=\"built_in\">size</span>() &lt;= pos)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> ix = _elems.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"comment\">//后一个数等于前两个数之和</span></span><br><span class=\"line\">        <span class=\"type\">int</span> n_2 = _elems[ix - <span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span> n_1 = _elems[ix - <span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(; ix &lt;= pos; ++ix)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> elem = n_2 + n_1;</span><br><span class=\"line\">            _elems.<span class=\"built_in\">push_back</span>(elem);</span><br><span class=\"line\">            n_2 = n_1;</span><br><span class=\"line\">            n_1 = elem;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//输出</span></span><br><span class=\"line\"><span class=\"function\">ostream&amp; <span class=\"title\">Fibonacci::print</span><span class=\"params\">(ostream &amp;os)</span> <span class=\"type\">const</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//开始位置</span></span><br><span class=\"line\">    <span class=\"type\">int</span> elem_pos = _beg_pos - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">//结束位置</span></span><br><span class=\"line\">    <span class=\"type\">int</span> end_pos = elem_pos + _length;</span><br><span class=\"line\">    <span class=\"comment\">//不够就计算</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(end_pos &gt; _elems.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">        Fibonacci::<span class=\"built_in\">gen_elems</span>(end_pos);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(elem_pos &lt; end_pos)&#123;</span><br><span class=\"line\">        os &lt;&lt; _elems[elem_pos++]&lt;&lt; <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> os;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们把<code>check_integrity()</code>的功能改造一下，能够直接帮我们把填充数据那一步做了，给基类的<code>check_integrity()</code>函数改造一下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">num_sequence::check_integrity</span><span class=\"params\">(<span class=\"type\">int</span> pos, <span class=\"type\">int</span> size)</span> <span class=\"type\">const</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pos &lt;= <span class=\"number\">0</span> || pos &gt; _max_elems)&#123;</span><br><span class=\"line\">        cerr &lt;&lt; <span class=\"string\">&quot;!!位置非法\\n&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pos &gt; size)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">gen_elems</span>(pos);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>elem()</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Fibonacci::elem</span><span class=\"params\">(<span class=\"type\">int</span> pos)</span> <span class=\"type\">const</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//不合法</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!<span class=\"built_in\">check_integrity</span>(pos, _elems.<span class=\"built_in\">size</span>()))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pos &gt; _elems.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">        Fibonacci::<span class=\"built_in\">gen_elems</span>(pos);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _elems[pos - <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>完整代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> CIRCLE_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CIRCLE_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">num_sequence</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">num_sequence</span>()&#123;&#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">int</span> <span class=\"title\">elem</span><span class=\"params\">(<span class=\"type\">int</span> pos)</span> <span class=\"type\">const</span> </span>= <span class=\"number\">0</span>;        <span class=\"comment\">//返回 pos 位置上的元素</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">const</span> <span class=\"type\">char</span>* <span class=\"title\">what_am_i</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>= <span class=\"number\">0</span>;  <span class=\"comment\">//返回确切的数列类型</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title\">max_elems</span><span class=\"params\">()</span></span>&#123;                     <span class=\"comment\">//返回所支持的最大位置值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> _max_elems;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> ostream&amp; <span class=\"title\">print</span><span class=\"params\">(ostream &amp;os = cout)</span> <span class=\"type\">const</span> </span>= <span class=\"number\">0</span>;   <span class=\"comment\">//将所有元素写入 os</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">gen_elems</span><span class=\"params\">(<span class=\"type\">int</span> pos)</span> <span class=\"type\">const</span> </span>= <span class=\"number\">0</span>;              <span class=\"comment\">//产生直到 pos 位置的所有元素</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">check_integrity</span><span class=\"params\">(<span class=\"type\">int</span> pos, <span class=\"type\">int</span> size)</span> <span class=\"type\">const</span></span>;                    <span class=\"comment\">//检查 pos 是否为有效位置</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">static</span> <span class=\"type\">int</span> _max_elems = <span class=\"number\">1024</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">num_sequence::check_integrity</span><span class=\"params\">(<span class=\"type\">int</span> pos, <span class=\"type\">int</span> size)</span> <span class=\"type\">const</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pos &lt;= <span class=\"number\">0</span> || pos &gt; _max_elems)&#123;</span><br><span class=\"line\">        cerr &lt;&lt; <span class=\"string\">&quot;!!位置非法\\n&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pos &gt; size)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">gen_elems</span>(pos);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(ostream &amp;os, <span class=\"type\">const</span> num_sequence &amp;ns)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ns.<span class=\"built_in\">print</span>(os);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;num_sequence.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Fibonacci</span> : <span class=\"keyword\">public</span> num_sequence&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Fibonacci</span>(<span class=\"type\">int</span> len = <span class=\"number\">1</span>, <span class=\"type\">int</span> beg_pos = <span class=\"number\">1</span>)</span><br><span class=\"line\">    :_length(len), _beg_pos(beg_pos)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">int</span> <span class=\"title\">elem</span><span class=\"params\">(<span class=\"type\">int</span> pos)</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">const</span> <span class=\"type\">char</span>* <span class=\"title\">what_am_i</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Fibonacci&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> ostream&amp; <span class=\"title\">print</span><span class=\"params\">(ostream &amp;os = cout)</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">length</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _length;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">beg_pos</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _beg_pos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">gen_elems</span><span class=\"params\">(<span class=\"type\">int</span> pos)</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> _length;</span><br><span class=\"line\">    <span class=\"type\">int</span> _beg_pos;</span><br><span class=\"line\">    <span class=\"type\">static</span> vector&lt;<span class=\"type\">int</span>&gt; _elems;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">返回 pos 位置上的元素前，检查拥有的元素是否足够，不够就通过</span></span><br><span class=\"line\"><span class=\"comment\">gen_elems()构造。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Fibonacci::elem</span><span class=\"params\">(<span class=\"type\">int</span> pos)</span> <span class=\"type\">const</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//不合法</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!<span class=\"built_in\">check_integrity</span>(pos, _elems.<span class=\"built_in\">size</span>()))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pos &gt; _elems.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">        Fibonacci::<span class=\"built_in\">gen_elems</span>(pos);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _elems[pos - <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//计算斐波那契数列元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Fibonacci::gen_elems</span><span class=\"params\">(<span class=\"type\">int</span> pos)</span> <span class=\"type\">const</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//pos = 0 和 pos = 1时，斐波那契为 1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(_elems.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">        _elems.<span class=\"built_in\">push_back</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">        _elems.<span class=\"built_in\">push_back</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(_elems.<span class=\"built_in\">size</span>() &lt;= pos)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> ix = _elems.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"comment\">//后一个数等于前两个数之和</span></span><br><span class=\"line\">        <span class=\"type\">int</span> n_2 = _elems[ix - <span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span> n_1 = _elems[ix - <span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(; ix &lt;= pos; ++ix)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> elem = n_2 + n_1;</span><br><span class=\"line\">            _elems.<span class=\"built_in\">push_back</span>(elem);</span><br><span class=\"line\">            n_2 = n_1;</span><br><span class=\"line\">            n_1 = elem;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//输出</span></span><br><span class=\"line\"><span class=\"function\">ostream&amp; <span class=\"title\">Fibonacci::print</span><span class=\"params\">(ostream &amp;os)</span> <span class=\"type\">const</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//开始位置</span></span><br><span class=\"line\">    <span class=\"type\">int</span> elem_pos = _beg_pos - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">//结束位置</span></span><br><span class=\"line\">    <span class=\"type\">int</span> end_pos = elem_pos + _length;</span><br><span class=\"line\">    <span class=\"comment\">//不够就计算</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(end_pos &gt; _elems.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">        Fibonacci::<span class=\"built_in\">gen_elems</span>(end_pos);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(elem_pos &lt; end_pos)&#123;</span><br><span class=\"line\">        os &lt;&lt; _elems[elem_pos++]&lt;&lt; <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> os;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Fibonacci fib;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;fib: 1 到 1 的斐波那契数列 &quot;</span> &lt;&lt; fib &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"function\">Fibonacci <span class=\"title\">fib2</span><span class=\"params\">(<span class=\"number\">16</span>)</span></span>;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;fib2: 1 到 16 的斐波那契数列 &quot;</span> &lt;&lt; fib2 &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"function\">Fibonacci <span class=\"title\">fib3</span><span class=\"params\">(<span class=\"number\">8</span>, <span class=\"number\">12</span>)</span></span>;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;fib3: 8 到 12 的斐波那契数列 &quot;</span> &lt;&lt; fib2 &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["Essential C++"],"tags":["Essential C++"]},{"title":"Essential C++ 第四章 基于对象的编程风格","url":"/2022/04/08/Essential-C++-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC/","content":"<p>一般·而言，class\n由两部分组成：一组公开的(public)操作函数和运算符，以及一组私有的(private)实现细节。</p>\n<h1 id=\"如何实现一个-class\">4.1 如何实现一个 Class</h1>\n<p>一般而言，我们会从所谓的抽象开始。我们以栈(stack)为例，栈是一种后进先出。</p>\n<p><code>Class</code>定义由两部分组成：class\n的声明，以及紧接在声明之后的主体。主体部分由一对大括号括住，并以分号结尾。主体内的两个关键字<code>public</code>和<code>private</code>，用来标示每个块的\"menber\n访问权限\"。Public menmber 可以在程序的任何地方被访问，private menber\n只能在</p>\n<p>member function或是 class fried内被访问。</p>\n<span id=\"more\"></span>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Stack.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> CIRCLE_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CIRCLE_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//头文件</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Stack</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"type\">const</span> string&amp;)</span></span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">pop</span><span class=\"params\">(string &amp;elem)</span></span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">top</span><span class=\"params\">(string &amp;elem)</span></span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">empty</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123;<span class=\"keyword\">return</span> _stack.<span class=\"built_in\">empty</span>();&#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">full</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123;<span class=\"keyword\">return</span> _stack.<span class=\"built_in\">size</span>() == _stack.<span class=\"built_in\">max_size</span>();&#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123;<span class=\"keyword\">return</span> _stack.<span class=\"built_in\">size</span>();&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">        vector&lt;string&gt; _stack;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//stack.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;Stack.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Stack::pop</span><span class=\"params\">(string &amp;elem)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">empty</span>()) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    elem = _stack.<span class=\"built_in\">back</span>();</span><br><span class=\"line\">    _stack.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Stack::top</span><span class=\"params\">(string &amp;elem)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">empty</span>()) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    elem = _stack.<span class=\"built_in\">back</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Stack::push</span><span class=\"params\">(<span class=\"type\">const</span> string &amp;elem)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">full</span>()) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    _stack.<span class=\"built_in\">push_back</span>(elem);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//main.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;stack.cpp&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Stack st;</span><br><span class=\"line\">    string str;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cin &gt;&gt; str &amp;&amp; !st.<span class=\"built_in\">full</span>())</span><br><span class=\"line\">        st.<span class=\"built_in\">push</span>(str);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(st.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span> &lt;&lt; <span class=\"string\">&quot;Oops: no strings were read -- bailing out\\n&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//求栈顶</span></span><br><span class=\"line\">    st.<span class=\"built_in\">top</span>(str);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(st.<span class=\"built_in\">size</span>() == <span class=\"number\">1</span> &amp;&amp; str.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span> &lt;&lt; <span class=\"string\">&quot;Oops: no strings were read -- bailing out\\n&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span> &lt;&lt; <span class=\"string\">&quot;Read in &quot;</span> &lt;&lt; st.<span class=\"built_in\">size</span>() &lt;&lt; <span class=\"string\">&quot; strings!\\n&quot;</span></span><br><span class=\"line\">         &lt;&lt; <span class=\"string\">&quot;The strings, in reverse order: \\n&quot;</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(st.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(st.<span class=\"built_in\">pop</span>(str))&#123;</span><br><span class=\"line\">            cout &lt;&lt; str &lt;&lt; <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span> &lt;&lt; <span class=\"string\">&quot;There are now &quot;</span> &lt;&lt; st.<span class=\"built_in\">size</span>() &lt;&lt; <span class=\"string\">&quot; elements in the stack!\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"什么是构造函数和析构函数\">4.2 什么是构造函数和析构函数</h1>\n<h2 id=\"构造函数\">构造函数</h2>\n<p>如果我们提供一个或多个特别的初始化函数，编译器就会在每次Class object\n被定义出来时，调用适当的函数加以处理。这些特别的初始化函数称为构造函数。</p>\n<p>构造函数的函数名称必须与class\n名称相同。构造函数不应指定返回类型，亦不用返回任何值。它可以被重载。</p>\n<p>下面的程序包括一个名为 Demo\n的类，其构造函数除了打印消息之外什么都不做。编写它的目的就是为了演示构造函数何时执行。因为\nDemo 对象是在两个 cout\n语句之间创建的，所以构造函数将在这两个语句生成的输出行之间打印它的消息。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"built_in\">Demo</span>()&#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;Now the constructor is running.\\n&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;This is displayed before the object is created. \\n&quot;</span>;</span><br><span class=\"line\">    Demo demoObj;    <span class=\"comment\">// Define a Demo object</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;This is displayed after the object is created.\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>程序输出为：</p>\n<blockquote>\n<p>This is displayed before the object is created. Now the constructor\nis running. This is displayed after the object is created.</p>\n</blockquote>\n<p>程序中，将构造函数定义为类声明中的内联函数。当然，像任何其他类成员函数一样，也可以将其原型放在类声明中，然后将其定义在类之外。在这种情况下，需要添加函数所属类的名称和函数名前面的作用域解析运算符。但是由于构造函数的名称与类名相同，所以名称会出现两次。</p>\n<p>以下就是在类声明之外定义 Demo 构造函数时，其函数头的样子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">Demo:: <span class=\"built_in\">Demo</span> ()    <span class=\"comment\">// 构造函数</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Now the constructor is running. \\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"重载构造函数\">重载构造函数</h3>\n<p>我们知道，当两个或多个函数共享相同的名称时，函数名称被称为重载。只要其形参列表不同，C++\n程序中可能存在具有相同名称的多个函数。</p>\n<p>任何类成员函数都可能被重载，包括构造函数。例如，某个构造函数可能需要一个整数实参，而另一个构造函数则需要一个\ndouble，甚至可能会有第三个构造函数使用两个整数。只要每个构造函数具有不同的形参列表，则编译器就可以将它们分开。</p>\n<p>下面的程序声明并使用一个名为 Sale\n的类，它有两个构造函数。第一个构造函数的形参接受销售税率；第二个构造函数是免税销售，没有形参。它将税率设置为\n0。这样一个没有形参的构造函数称为默认构造函数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iomanip&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Sale class declaration</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sale</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">        <span class=\"type\">double</span> taxRate;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"comment\">// 一个参数的构造函数</span></span><br><span class=\"line\">        <span class=\"built_in\">Sale</span>(<span class=\"type\">double</span> rate)&#123;</span><br><span class=\"line\">            taxRate = rate;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//默认构造函数</span></span><br><span class=\"line\">        <span class=\"built_in\">Sale</span>()&#123;</span><br><span class=\"line\">            taxRate = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">calcSaleTotal</span><span class=\"params\">(<span class=\"type\">double</span> cost)</span></span>&#123;</span><br><span class=\"line\">            <span class=\"type\">double</span> total = cost + cost * taxRate;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> total;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Define a Sale object with 6% sales tax</span></span><br><span class=\"line\">    <span class=\"function\">Sale <span class=\"title\">cashier1</span><span class=\"params\">(<span class=\"number\">.06</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// Define a tax-exempt Sale object</span></span><br><span class=\"line\">    Sale cashier2;</span><br><span class=\"line\">    <span class=\"comment\">// Format the output</span></span><br><span class=\"line\">    cout &lt;&lt; fixed &lt;&lt; showpoint &lt;&lt; <span class=\"built_in\">setprecision</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"comment\">// Get and display the total sale price for two $24.95 sales</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;With a 0.06 sales tax rate, the total\\n&quot;</span>;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;of the $24.95 sale is $&quot;</span>;</span><br><span class=\"line\">    cout &lt;&lt; cashier1.<span class=\"built_in\">calcSaleTotal</span>(<span class=\"number\">24.95</span>) &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;\\nOn a tax-exempt purchase, the total\\n&quot;</span>;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;of the $24.95 sale is, of course, $&quot;</span>;</span><br><span class=\"line\">    cout &lt;&lt; cashier2.<span class=\"built_in\">calcSaleTotal</span>(<span class=\"number\">24.95</span>) &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>程序输出结果：</p>\n<blockquote>\n<p>With a 0.06 sales tax rate, the total of the $24.95 sale is\n$26.45</p>\n<p>On a tax-exempt purchase, the total of the $24.95 sale is, of course,\n$24.95</p>\n</blockquote>\n<p>注意看此程序如何定义的两个 Sale 对象：</p>\n<blockquote>\n<p>Sale cashier1(.06); Sale cashier2;</p>\n</blockquote>\n<p>在 cashier1\n的名称后面有一对括号，用于保存值，发送给有一个形参的构造函数。但是，在\nCashier2 的名称后面就没有括号，它不发送任何参数。在 C++\n中，当使用默认构造函数定义对象时，不用传递实参，所以不能有任何括号，即：</p>\n<blockquote>\n<p>Sale cashier2 () ; // 错误 Sale cashier2; // 正确</p>\n</blockquote>\n<h3 id=\"默认构造函数\">默认构造函数</h3>\n<p>Sale\n类需要一个默认构造函数来处理免税销售的情况，但是其他类可能并不需要这样一个构造函数。例如，如果通过类创建的对象总是希望将实参传递给构造函数。那么，在设计一个具有构造函数的类时，应该包括一个默认构造函数，这在任何时候都会被认为是一个很好的编程实践。</p>\n<p>如果没有这样一个默认构造函数，那么当程序尝试创建一个对象而不传递任何参数时，它将不会编译，这是因为必须有一个构造函数来创建一个对象。为了创建不传递任何参数的对象，必须有一个不需要参数的构造函数，也就是默认构造函数。</p>\n<p>如果程序员没有为类编写任何构造函数，则编译器将自动为其创建一个默认构造函数。但是，当程序员编写了一个或多个构造函数时，即使所有这些构造函数都是有参数的，编译器也不会创建一个默认构造函数，所以程序员有责任这样做。</p>\n<p>类可能有许多构造函数，但只能有一个默认构造函数。这是因为：如果多个函数具有相同的名称，则在任何给定时刻，编译器都必须能够从其形参列表中确定正在调用哪个函数。它使用传递给函数的实参的数量和类型来确定要调用的重载函数。因为一个类名称只能有一个函数能够接受无参数，所以只能有一个默认构造函数。</p>\n<p>一般情况下，就像在 Sale\n类中那样，默认构造函数没有形参。但是，也可能有另一种的默认构造函数，其所有形参都具有默认值，所以，它也可以无实参调用。如果创建了一个接受无实参的构造函数，同时又创建了另外一个有参数但允许所有参数均为默认值的构造函数，那么这将是一个错误，因为这实际上是创建了两个“默认”构造函数。以下语句就进行了这种非法的声明：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Sale</span> <span class=\"comment\">//非法声明</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">        <span class=\"type\">double</span> taxRate;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"built_in\">Sale</span>()    <span class=\"comment\">//无实参的默认构造函数</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            taxRate = <span class=\"number\">0.05</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">Sale</span> (<span class=\"type\">double</span> r = <span class=\"number\">0.05</span>)    <span class=\"comment\">//有默认实参的默认构造函数</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            taxRate = r;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">calcSaleTotal</span><span class=\"params\">(<span class=\"type\">double</span> cost)</span></span></span><br><span class=\"line\"><span class=\"function\">        </span>&#123;</span><br><span class=\"line\">            <span class=\"type\">double</span> total = cost + cost * taxRate;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> total;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>可以看到，第一个构造函数没有形参，第二个构造函数有一个形参，但它有一个默认实参。如果一个对象被定义为没有参数列表，那么编译器将无法判断要执行哪个构造函数。</p>\n<h2 id=\"析构函数\">析构函数</h2>\n<p>析构函数是具有与类相同名称的公共成员函数，前面带有波浪符号（〜）。例如，Rectangle\n类的析构函数将被命名为 〜Rectangle。</p>\n<p>当对象被销毁时，会自动调用析构函数。在创建对象时，构造函数使用某种方式来进行设置，那么当对象停止存在时，析构函数也会使用同样的方式来执行关闭过程。例如，当具有对象的程序停止执行或从创建对象的函数返回时，就会发生这种情况。</p>\n<p>下面的程序显示了一个具有构造函数和析构函数的简单类。它说明了在程序执行过程中这两个函数各自被调用的时间：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"built_in\">Demo</span>();     <span class=\"comment\">//构造函数</span></span><br><span class=\"line\">        ~<span class=\"built_in\">Demo</span>();    <span class=\"comment\">//析构函数</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Demo::<span class=\"built_in\">Demo</span>()&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;An object has just been defined,so the constructor&quot;</span> &lt;&lt; <span class=\"string\">&quot; is running.\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Demo::~<span class=\"built_in\">Demo</span>()&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Now the destructor is running.\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Demo demoobj;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;The object now exists, but is about to be destroyed.\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>程序输出结果：</p>\n<blockquote>\n<p>An object has just been defined,so the constructor is running. The\nobject now exists, but is about to be destroyed. Now the destructor is\nrunning.</p>\n</blockquote>\n<p>除了需要知道在对象被销毁时会自动调用析构函数外，还应注意以下事项：</p>\n<ol type=\"1\">\n<li>像构造函数一样，析构函数没有返回类型。</li>\n<li>析构函数不能接收实参，因此它们从不具有形参列表。</li>\n<li>由于析构函数不能接收实参，因此只能有一个析构函数。</li>\n</ol>\n<h1 id=\"mutable-和-const\">4.3 mutable 和 const</h1>\n<h2 id=\"const修饰变量\">const修饰变量</h2>\n<p>在C++中，一般用const完全替代C语言的define，且功能更多。用const修饰变量，使之成为常量（或常数），这很简单，但结构体中成员如果用了const，需要注意，请看下面例子。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">const</span> <span class=\"type\">double</span> CONSTANT;</span><br><span class=\"line\">CONSTANT pi = <span class=\"number\">3.14159265</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">mytype</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> x;</span><br><span class=\"line\">    <span class=\"type\">int</span> y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span> <span class=\"params\">( )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//pi = 3.14;    //编译出错，常量不能赋值</span></span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">//常量定义必须有初始值</span></span><br><span class=\"line\">    <span class=\"comment\">//mytype s;    //编译出错，结构体中的x成员常量没有初始值</span></span><br><span class=\"line\">    mytype s1 = &#123;<span class=\"number\">15</span>, <span class=\"number\">20</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//s1.x = 3     //编译出错，常量不能赋值</span></span><br><span class=\"line\">    s1.y = <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">const</span> mytype s2 = &#123;<span class=\"number\">25</span>, <span class=\"number\">30</span>&#125;;</span><br><span class=\"line\">    <span class=\"comment\">//s2.y = 125;  //编译出错，整个s2的所有成员都变成了常量</span></span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;s1: &quot;</span> &lt;&lt; s1.x &lt;&lt; <span class=\"string\">&quot;, &quot;</span> &lt;&lt; s1.y &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;s2: &quot;</span> &lt;&lt; s2.x &lt;&lt; <span class=\"string\">&quot;, &quot;</span> &lt;&lt; s2.y &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>程序输出结果：</p>\n<blockquote>\n<p>s1: 15, 100 s2: 25, 30</p>\n</blockquote>\n<h2 id=\"const修饰类的成员函数\">const修饰类的成员函数</h2>\n<p>用const修饰类的成员函数，可以使函数内不能对任何成员变量修改。不是成员变量当然可以修改。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">classA</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x;</span><br><span class=\"line\">    string y;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"type\">int</span>&amp; i, string&amp; s)</span> <span class=\"type\">const</span></span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> k;</span><br><span class=\"line\">         k = <span class=\"number\">10</span>;         <span class=\"comment\">//非成员变量可以修改</span></span><br><span class=\"line\">         <span class=\"comment\">//x = k;        //成员变量不能修改</span></span><br><span class=\"line\">         <span class=\"comment\">//y = &quot;SJCHEN&quot;  //成员变量不能修改</span></span><br><span class=\"line\">         i = x, s = y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set</span><span class=\"params\">(<span class=\"type\">int</span> i, string s)</span></span>&#123;</span><br><span class=\"line\">        x = i;</span><br><span class=\"line\">        y = s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    classA ca;</span><br><span class=\"line\">    ca.<span class=\"built_in\">set</span>(<span class=\"number\">100</span>, <span class=\"string\">&quot;SJCEHN&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    string s;</span><br><span class=\"line\">    ca.<span class=\"built_in\">get</span>(i, s);</span><br><span class=\"line\">    cout &lt;&lt; s &lt;&lt; <span class=\"string\">&quot;--&quot;</span> &lt;&lt; i &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>程序输出结果：</p>\n<blockquote>\n<p>SJCEHN--100</p>\n</blockquote>\n<h2 id=\"mutable与const为敌\">mutable与const为敌</h2>\n<p>用mutable修饰成员变量，可以使该成员变量即使在const成员函数中也能被修改。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">classA</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">mutable</span> string y;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"type\">int</span>&amp; i, string&amp; s)</span> <span class=\"type\">const</span></span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> k;</span><br><span class=\"line\">         k = <span class=\"number\">10</span>;         \t\t<span class=\"comment\">//非成员变量可以修改</span></span><br><span class=\"line\">         <span class=\"comment\">//x = k;        \t\t//成员变量不能修改</span></span><br><span class=\"line\">         y = <span class=\"string\">&quot;SJCHEN&quot;</span>;  \t \t<span class=\"comment\">//mutable变量能修改</span></span><br><span class=\"line\">         i = x, s = y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set</span><span class=\"params\">(<span class=\"type\">int</span> i, string s)</span></span>&#123;</span><br><span class=\"line\">        x = i;</span><br><span class=\"line\">        y = s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    classA ca;</span><br><span class=\"line\">    ca.<span class=\"built_in\">set</span>(<span class=\"number\">100</span>, <span class=\"string\">&quot;SJCEHN&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    string s;</span><br><span class=\"line\">    ca.<span class=\"built_in\">get</span>(i, s);</span><br><span class=\"line\">    cout &lt;&lt; s &lt;&lt; <span class=\"string\">&quot;--&quot;</span> &lt;&lt; i &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>程序输出结果：</p>\n<blockquote>\n<p>SJCEHN--100</p>\n</blockquote>\n<h1 id=\"什么是-this-指针\">4.4 什么是 this 指针</h1>\n<p>this 是 C++ 中的一个关键字，也是一个 const\n指针，它指向当前对象，通过它可以访问当前对象的所有成员。</p>\n<p>所谓当前对象，是指正在使用的对象。例如对于<code>stu.show();</code>，stu\n就是当前对象，this 就指向 stu。</p>\n<p>下面是使用 this 的一个完整示例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Student</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setName</span><span class=\"params\">(string name)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"type\">int</span> age)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setScore</span><span class=\"params\">(<span class=\"type\">float</span> score)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    string name;</span><br><span class=\"line\">    <span class=\"type\">int</span> age;</span><br><span class=\"line\">    <span class=\"type\">float</span> score;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Student::setName</span><span class=\"params\">(string name)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Student::setAge</span><span class=\"params\">(<span class=\"type\">int</span> age)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Student::setScore</span><span class=\"params\">(<span class=\"type\">float</span> score)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;score = score;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Student::show</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"keyword\">this</span>-&gt;name&lt;&lt;<span class=\"string\">&quot;的年龄是&quot;</span>&lt;&lt;<span class=\"keyword\">this</span>-&gt;age&lt;&lt;<span class=\"string\">&quot;，成绩是&quot;</span>&lt;&lt;<span class=\"keyword\">this</span>-&gt;score&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    Student *pstu = <span class=\"keyword\">new</span> Student;</span><br><span class=\"line\">    pstu -&gt; <span class=\"built_in\">setName</span>(<span class=\"string\">&quot;李华&quot;</span>);</span><br><span class=\"line\">    pstu -&gt; <span class=\"built_in\">setAge</span>(<span class=\"number\">16</span>);</span><br><span class=\"line\">    pstu -&gt; <span class=\"built_in\">setScore</span>(<span class=\"number\">96.5</span>);</span><br><span class=\"line\">    pstu -&gt; <span class=\"built_in\">show</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>程序输出结果：</p>\n<blockquote>\n<p>李华的年龄是16，成绩是96.5</p>\n</blockquote>\n<p>this 只能用在类的内部，通过 this 可以访问类的所有成员，包括\nprivate、protected、public 属性的。</p>\n<p>本例中成员函数的参数和成员变量重名，只能通过 this\n区分。以成员函数<code>setname(string name)</code>为例，它的形参是<code>name</code>，和成员变量<code>name</code>重名，如果写作<code>name = name;</code>这样的语句，就是给形参<code>name</code>赋值，而不是给成员变量<code>name</code>赋值。而写作<code>this -&gt; name = name;</code>后，<code>=</code>左边的<code>name</code>就是成员变量，右边的<code>name</code>就是形参，一目了然。</p>\n<p>this 虽然用在类的内部，但是只有在对象被创建以后才会给 this\n赋值，并且这个赋值的过程是编译器自动完成的，不需要用户干预，用户也不能显式地给\nthis 赋值。本例中，this 的值和 pstu 的值是相同的。</p>\n<p>我们不妨来证明一下，给 Student\n类添加一个成员函数<code>printThis()</code>，专门用来输出 this\n的值，如下所示：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Student::printThis</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"keyword\">this</span>&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">Student *pstu1 = <span class=\"keyword\">new</span> Student;</span><br><span class=\"line\">pstu1 -&gt; <span class=\"built_in\">printThis</span>();</span><br><span class=\"line\">cout&lt;&lt;pstu1&lt;&lt;endl;</span><br><span class=\"line\"></span><br><span class=\"line\">Student *pstu2 = <span class=\"keyword\">new</span> Student;</span><br><span class=\"line\">pstu2 -&gt; <span class=\"built_in\">printThis</span>();</span><br><span class=\"line\">cout&lt;&lt;pstu2&lt;&lt;endl;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<blockquote>\n<p>0x7b17d8 0x7b17d8 0x7b17f0 0x7b17f0</p>\n</blockquote>\n<p>可以发现，this 确实指向了当前对象，而且对于不同的对象，this\n的值也不一样。</p>\n<p>几点注意：</p>\n<ul>\n<li>this 是 const\n指针，它的值是不能被修改的，一切企图修改该指针的操作，如赋值、递增、递减等都是不允许的。</li>\n<li>this 只能在成员函数内部使用，用在其他地方没有意义，也是非法的。</li>\n<li>只有当对象被创建后 this 才有意义，因此不能在 static\n成员函数中使用（后续会讲到 static 成员）。</li>\n</ul>\n<h1 id=\"静态类成员\">4.5 静态类成员</h1>\n<p>我们可以使用 <strong>static</strong>\n关键字来把类成员定义为静态的。当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都<strong>只有一个副本。</strong></p>\n<p>静态成员在类的所有对象中是共享的。如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零。我们不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符\n<strong>::</strong>\n来重新声明静态变量从而对它进行初始化，如下面的实例所示。</p>\n<p>下面的实例有助于更好地理解静态成员数据的概念：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Box</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">double</span> length;</span><br><span class=\"line\">    <span class=\"type\">double</span> breadth;</span><br><span class=\"line\">    <span class=\"type\">double</span> height;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">int</span> objectCount;</span><br><span class=\"line\">    <span class=\"comment\">//构造函数定义</span></span><br><span class=\"line\">    <span class=\"built_in\">Box</span>(<span class=\"type\">double</span> l = <span class=\"number\">2.0</span>, <span class=\"type\">double</span> b = <span class=\"number\">2.0</span>, <span class=\"type\">double</span> h = <span class=\"number\">2.0</span>)&#123;</span><br><span class=\"line\">        cout &lt;&lt;<span class=\"string\">&quot;Constructor called.&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">        length = l;</span><br><span class=\"line\">        breadth = b;</span><br><span class=\"line\">        height = h;</span><br><span class=\"line\">        <span class=\"comment\">// 每次创建对象时增加 1</span></span><br><span class=\"line\">        objectCount++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">Volume</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> length * breadth * height;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//初始化类 Box 的静态成员</span></span><br><span class=\"line\"><span class=\"type\">int</span> Box::objectCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Box <span class=\"title\">Box1</span><span class=\"params\">(<span class=\"number\">3.3</span>, <span class=\"number\">1.2</span>, <span class=\"number\">1.5</span>)</span></span>;    <span class=\"comment\">// 声明 box1</span></span><br><span class=\"line\">    <span class=\"function\">Box <span class=\"title\">Box2</span><span class=\"params\">(<span class=\"number\">8.5</span>, <span class=\"number\">6.0</span>, <span class=\"number\">2.0</span>)</span></span>;    <span class=\"comment\">// 声明 box2</span></span><br><span class=\"line\">    <span class=\"comment\">// 输出对象的总数</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Total objects: &quot;</span> &lt;&lt; Box::objectCount &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<blockquote>\n<p>Constructor called. Constructor called. Total objects: 2</p>\n</blockquote>\n<h2 id=\"静态成员函数\">静态成员函数</h2>\n<p>如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，<strong>静态函数</strong>只要使用类名加范围解析运算符\n<strong>::</strong> 就可以访问。</p>\n<p>静态成员函数只能访问静态成员数据、其他静态成员函数和类外部的其他函数。</p>\n<p>静态成员函数有一个类范围，他们不能访问类的 this\n指针。您可以使用静态成员函数来判断类的某些对象是否已被创建。</p>\n<p><strong>静态成员函数与普通成员函数的区别：</strong></p>\n<ul>\n<li>静态成员函数没有 this\n指针，只能访问静态成员（包括静态成员变量和静态成员函数）。</li>\n<li>普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有\nthis 指针。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Box</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">double</span> length;</span><br><span class=\"line\">    <span class=\"type\">double</span> breadth;</span><br><span class=\"line\">    <span class=\"type\">double</span> height;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">int</span> objectCount;</span><br><span class=\"line\">    <span class=\"comment\">//构造函数定义</span></span><br><span class=\"line\">    <span class=\"built_in\">Box</span>(<span class=\"type\">double</span> l = <span class=\"number\">2.0</span>, <span class=\"type\">double</span> b = <span class=\"number\">2.0</span>, <span class=\"type\">double</span> h = <span class=\"number\">2.0</span>)&#123;</span><br><span class=\"line\">        cout &lt;&lt;<span class=\"string\">&quot;Constructor called.&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">        length = l;</span><br><span class=\"line\">        breadth = b;</span><br><span class=\"line\">        height = h;</span><br><span class=\"line\">        <span class=\"comment\">// 每次创建对象时增加 1</span></span><br><span class=\"line\">        objectCount++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">Volume</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> length * breadth * height;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title\">getCount</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> objectCount;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//初始化类 Box 的静态成员</span></span><br><span class=\"line\"><span class=\"type\">int</span> Box::objectCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在创建对象之前输出对象的总数</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Inital Stage Count: &quot;</span> &lt;&lt; Box::<span class=\"built_in\">getCount</span>() &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"function\">Box <span class=\"title\">Box1</span><span class=\"params\">(<span class=\"number\">3.3</span>, <span class=\"number\">1.2</span>, <span class=\"number\">1.5</span>)</span></span>;    <span class=\"comment\">// 声明 box1</span></span><br><span class=\"line\">    <span class=\"function\">Box <span class=\"title\">Box2</span><span class=\"params\">(<span class=\"number\">8.5</span>, <span class=\"number\">6.0</span>, <span class=\"number\">2.0</span>)</span></span>;    <span class=\"comment\">// 声明 box2</span></span><br><span class=\"line\">    <span class=\"comment\">// 在创建对象之后输出对象的总数</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;Final Stage Count: &quot;</span> &lt;&lt; Box::<span class=\"built_in\">getCount</span>() &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<blockquote>\n<p>Inital Stage Count: 0 Constructor called. Constructor called. Final\nStage Count: 2</p>\n</blockquote>\n<h1 id=\"iterator-class\">4.6 Iterator Class</h1>\n<h1 id=\"友元函数和友元类\">4.7 友元函数和友元类</h1>\n<p>私有成员只能在类的成员函数内部访问，如果想在别处访问对象的私有成员，只能通过类提供的接口（成员函数）间接地进行。这固然能够带来数据隐藏的好处，利于将来程序的扩充，但也会增加程序书写的麻烦。</p>\n<p>c++\n是从结构化的C语言发展而来的，需要照顾结构化设计程序员的习惯，所以在对私有成员可访问范围的问题上不可限制太死。</p>\n<p>C++ 设计者认为，\n如果有的程序员真的非常怕麻烦，就是想在类的成员函数外部直接访问对象的私有成员，那还是做一点妥协以满足他们的愿望为好，这也算是眼前利益和长远利益的折中。因此，C++\n就有了<strong>友元（friend）</strong>的概念。打个比方，这相当于是说：朋友是值得信任的，所以可以对他们公开一些自己的隐私。</p>\n<p>友元分为两种：友元函数和友元类。</p>\n<h2 id=\"友元函数\">友元函数</h2>\n<p>在定义一个类的时候，可以把一些函数（包括全局函数和其他类的成员函数）声明为“友元”，这样那些函数就成为该类的友元函数，在友元函数内部就可以访问该类对象的私有成员了。</p>\n<p>将全局函数声明为友元的写法如下：</p>\n<blockquote>\n<p>friend 返回值类型 函数名(参数表);</p>\n</blockquote>\n<p>将其他类的成员函数声明为友元的写法如下：</p>\n<blockquote>\n<p>friend 返回值类型 其他类的类名::成员函数名(参数表);</p>\n</blockquote>\n<p>但是，不能把其他类的私有成员函数声明为友元。</p>\n<p>关于友元，看下面的程序示例。</p>\n<h3 id=\"将非成员函数声明为友元函数\">1) 将非成员函数声明为友元函数。</h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Student</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Student</span>(string name, <span class=\"type\">int</span> age, <span class=\"type\">float</span> score);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">friend</span> <span class=\"type\">void</span> <span class=\"title\">show</span><span class=\"params\">(Student *pstu)</span></span>;    <span class=\"comment\">//将show()声明为友元类</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    string m_name;</span><br><span class=\"line\">    <span class=\"type\">int</span> m_age;</span><br><span class=\"line\">    <span class=\"type\">float</span> m_score;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Student::<span class=\"built_in\">Student</span>(string name, <span class=\"type\">int</span> age, <span class=\"type\">float</span> score)</span><br><span class=\"line\">:<span class=\"built_in\">m_name</span>(name), <span class=\"built_in\">m_age</span>(age), <span class=\"built_in\">m_score</span>(score)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//非成员函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">show</span><span class=\"params\">(Student *pstu)</span></span>&#123;</span><br><span class=\"line\">    cout&lt;&lt;pstu-&gt;m_name&lt;&lt;<span class=\"string\">&quot;的年龄是 &quot;</span>&lt;&lt;pstu-&gt;m_age&lt;&lt;<span class=\"string\">&quot;，成绩是 &quot;</span>&lt;&lt;pstu-&gt;m_score&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Student <span class=\"title\">stu</span><span class=\"params\">(<span class=\"string\">&quot;小明&quot;</span>, <span class=\"number\">15</span>, <span class=\"number\">90.6</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">show</span>(&amp;stu); <span class=\"comment\">//调用友元函数</span></span><br><span class=\"line\">    Student *pstu = <span class=\"keyword\">new</span> <span class=\"built_in\">Student</span>(<span class=\"string\">&quot;李磊&quot;</span>, <span class=\"number\">16</span>, <span class=\"number\">80.5</span>);</span><br><span class=\"line\">    <span class=\"built_in\">show</span>(pstu); <span class=\"comment\">//调用友元函数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<blockquote>\n<p>小明的年龄是 15，成绩是 90.6 李磊的年龄是 16，成绩是 80.5</p>\n</blockquote>\n<p>show()\n是一个全局范围内的非成员函数，它不属于任何类，它的作用是输出学生的信息。m_name、m_age、m_score\n是 Student 类的 private 成员，原则上不能通过对象访问，但在 show()\n函数中又必须使用这些 private 成员，所以将 show() 声明为 Student\n类的友元函数。读者可以亲自测试一下，将上面程序中的第 8\n行删去，观察编译器的报错信息。</p>\n<p><strong>注意，友元函数不同于类的成员函数，在友元函数中不能直接访问类的成员，必须要借助对象。</strong>\n下面的写法是错误的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cout&lt;&lt;m_name&lt;&lt;<span class=\"string\">&quot;的年龄是 &quot;</span>&lt;&lt;m_age&lt;&lt;<span class=\"string\">&quot;，成绩是 &quot;</span>&lt;&lt;m_score&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>成员函数在调用时会隐式地增加 this\n指针，指向调用它的对象，从而使用该对象的成员；而 show()\n是非成员函数，没有 this\n指针，编译器不知道使用哪个对象的成员，要想明确这一点，就必须通过参数传递对象（可以直接传递对象，也可以传递对象指针或对象引用），并在访问成员时指明对象。</p>\n<h3 id=\"将其他类的成员函数声明为友元函数\">2)\n将其他类的成员函数声明为友元函数</h3>\n<p>friend\n函数不仅可以是全局函数（非成员函数），还可以是另外一个类的成员函数。请看下面的例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Address</span>; <span class=\"comment\">//提前声明Addres类</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Student</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Student</span>(string name, <span class=\"type\">int</span> age, <span class=\"type\">float</span> score);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">show</span><span class=\"params\">(Address *addr)</span></span>;    <span class=\"comment\">//将show()声明为友元类</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    string m_name;</span><br><span class=\"line\">    <span class=\"type\">int</span> m_age;</span><br><span class=\"line\">    <span class=\"type\">float</span> m_score;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//声明Address类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Address</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    string m_province;  <span class=\"comment\">//省</span></span><br><span class=\"line\">    string m_city;      <span class=\"comment\">//市</span></span><br><span class=\"line\">    string m_district;  <span class=\"comment\">//区</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Address</span>(string province, string city, string distict);</span><br><span class=\"line\">    <span class=\"comment\">//将Student类中的成员函数show()声明为友元函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">friend</span> <span class=\"type\">void</span> <span class=\"title\">Student::show</span><span class=\"params\">(Address *addr)</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Student::<span class=\"built_in\">Student</span>(string name, <span class=\"type\">int</span> age, <span class=\"type\">float</span> score)</span><br><span class=\"line\">:<span class=\"built_in\">m_name</span>(name), <span class=\"built_in\">m_age</span>(age), <span class=\"built_in\">m_score</span>(score)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Student::show</span><span class=\"params\">(Address *addr)</span></span>&#123;</span><br><span class=\"line\">    cout&lt;&lt;m_name&lt;&lt;<span class=\"string\">&quot;的年龄是 &quot;</span>&lt;&lt;m_age&lt;&lt;<span class=\"string\">&quot;，成绩是 &quot;</span>&lt;&lt;m_score&lt;&lt;endl;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;家庭住址：&quot;</span>&lt;&lt;addr-&gt;m_province&lt;&lt;<span class=\"string\">&quot;省&quot;</span>&lt;&lt;addr-&gt;m_city&lt;&lt;<span class=\"string\">&quot;市&quot;</span>&lt;&lt;addr-&gt;m_district&lt;&lt;<span class=\"string\">&quot;区&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//实现Address类</span></span><br><span class=\"line\">Address::<span class=\"built_in\">Address</span>(string province, string city, string distict)</span><br><span class=\"line\">:<span class=\"built_in\">m_province</span>(province), <span class=\"built_in\">m_city</span>(city), <span class=\"built_in\">m_district</span>(distict)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Student <span class=\"title\">stu</span><span class=\"params\">(<span class=\"string\">&quot;小明&quot;</span>, <span class=\"number\">15</span>, <span class=\"number\">90.6</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Address <span class=\"title\">addr</span><span class=\"params\">(<span class=\"string\">&quot;陕西&quot;</span>,<span class=\"string\">&quot;西安&quot;</span>,<span class=\"string\">&quot;雁塔&quot;</span>)</span></span>;</span><br><span class=\"line\">    stu.<span class=\"built_in\">show</span>(&amp;addr);</span><br><span class=\"line\"></span><br><span class=\"line\">    Student *pstu = <span class=\"keyword\">new</span> <span class=\"built_in\">Student</span>(<span class=\"string\">&quot;李磊&quot;</span>, <span class=\"number\">16</span>, <span class=\"number\">80.5</span>);</span><br><span class=\"line\">    Address *paddr = <span class=\"keyword\">new</span> <span class=\"built_in\">Address</span>(<span class=\"string\">&quot;河北&quot;</span>, <span class=\"string\">&quot;衡水&quot;</span>, <span class=\"string\">&quot;桃城&quot;</span>);</span><br><span class=\"line\">    pstu-&gt;<span class=\"built_in\">show</span>(paddr);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<blockquote>\n<p>小明的年龄是 15，成绩是 90.6 家庭住址：陕西省西安市雁塔区\n李磊的年龄是 16，成绩是 80.5 家庭住址：河北省衡水市桃城区</p>\n</blockquote>\n<p>本例定义了两个类 Student 和 Address，程序第 27 行将 Student\n类的成员函数 show() 声明为 Address 类的友元函数，由此，show() 就可以访问\nAddress 类的 private 成员变量了。</p>\n<p>几点注意： ① 程序第 4 行对 Address 类进行了提前声明，是因为在 Address\n类定义之前、在 Student\n类中使用到了它，如果不提前声明，编译器会报错，提示<code>'Address' has not been declared</code>。类的提前声明和函数的提前声明是一个道理。</p>\n<p>② 程序将 Student 类的声明和实现分开了，而将 Address\n类的声明放在了中间，这是因为编译器从上到下编译代码，show()\n函数体中用到了 Address 的成员 province、city、district，如果提前不知道\nAddress 的具体声明内容，就不能确定 Address\n是否拥有该成员（类的声明中指明了类有哪些成员）。</p>\n<p>==这里简单介绍一下类的提前声明。一般情况下，类必须在正式声明之后才能使用；但是某些情况下（如上例所示），只要做好提前声明，也可以先使用。==</p>\n<p>③ 一个函数可以被多个类声明为友元函数，这样就可以访问多个类中的\nprivate 成员。</p>\n<h2 id=\"友元类\">友元类</h2>\n<p>不仅可以将一个函数声明为一个类的“朋友”，还可以将整个类声明为另一个类的“朋友”，这就是友元类。友元类中的所有成员函数都是另外一个类的友元函数。</p>\n<p>例如将类 B 声明为类 A 的友元类，那么类 B 中的所有成员函数都是类 A\n的友元函数，可以访问类 A 的所有成员，包括 public、protected、private\n属性的。</p>\n<p>更改上例的代码，将 Student 类声明为 Address 类的友元类：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Address</span>; <span class=\"comment\">//提前声明Addres类</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Student</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Student</span>(string name, <span class=\"type\">int</span> age, <span class=\"type\">float</span> score);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">show</span><span class=\"params\">(Address *addr)</span></span>;    <span class=\"comment\">//将show()声明为友元类</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    string m_name;</span><br><span class=\"line\">    <span class=\"type\">int</span> m_age;</span><br><span class=\"line\">    <span class=\"type\">float</span> m_score;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//声明Address类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Address</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    string m_province;  <span class=\"comment\">//省</span></span><br><span class=\"line\">    string m_city;      <span class=\"comment\">//市</span></span><br><span class=\"line\">    string m_district;  <span class=\"comment\">//区</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Address</span>(string province, string city, string distict);</span><br><span class=\"line\">    <span class=\"comment\">//将Student类声明为Address类的友元类</span></span><br><span class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Student</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Student::<span class=\"built_in\">Student</span>(string name, <span class=\"type\">int</span> age, <span class=\"type\">float</span> score)</span><br><span class=\"line\">:<span class=\"built_in\">m_name</span>(name), <span class=\"built_in\">m_age</span>(age), <span class=\"built_in\">m_score</span>(score)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Student::show</span><span class=\"params\">(Address *addr)</span></span>&#123;</span><br><span class=\"line\">    cout&lt;&lt;m_name&lt;&lt;<span class=\"string\">&quot;的年龄是 &quot;</span>&lt;&lt;m_age&lt;&lt;<span class=\"string\">&quot;，成绩是 &quot;</span>&lt;&lt;m_score&lt;&lt;endl;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;家庭住址：&quot;</span>&lt;&lt;addr-&gt;m_province&lt;&lt;<span class=\"string\">&quot;省&quot;</span>&lt;&lt;addr-&gt;m_city&lt;&lt;<span class=\"string\">&quot;市&quot;</span>&lt;&lt;addr-&gt;m_district&lt;&lt;<span class=\"string\">&quot;区&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//实现Address类</span></span><br><span class=\"line\">Address::<span class=\"built_in\">Address</span>(string province, string city, string distict)</span><br><span class=\"line\">:<span class=\"built_in\">m_province</span>(province), <span class=\"built_in\">m_city</span>(city), <span class=\"built_in\">m_district</span>(distict)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Student <span class=\"title\">stu</span><span class=\"params\">(<span class=\"string\">&quot;小明&quot;</span>, <span class=\"number\">15</span>, <span class=\"number\">90.6</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Address <span class=\"title\">addr</span><span class=\"params\">(<span class=\"string\">&quot;陕西&quot;</span>,<span class=\"string\">&quot;西安&quot;</span>,<span class=\"string\">&quot;雁塔&quot;</span>)</span></span>;</span><br><span class=\"line\">    stu.<span class=\"built_in\">show</span>(&amp;addr);</span><br><span class=\"line\"></span><br><span class=\"line\">    Student *pstu = <span class=\"keyword\">new</span> <span class=\"built_in\">Student</span>(<span class=\"string\">&quot;李磊&quot;</span>, <span class=\"number\">16</span>, <span class=\"number\">80.5</span>);</span><br><span class=\"line\">    Address *paddr = <span class=\"keyword\">new</span> <span class=\"built_in\">Address</span>(<span class=\"string\">&quot;河北&quot;</span>, <span class=\"string\">&quot;衡水&quot;</span>, <span class=\"string\">&quot;桃城&quot;</span>);</span><br><span class=\"line\">    pstu-&gt;<span class=\"built_in\">show</span>(paddr);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>关于友元，有两点需要说明：</p>\n<ul>\n<li>友元的关系是单向的而不是双向的。如果声明了类 B 是类 A\n的友元类，不等于类 A 是类 B 的友元类，类 A 中的成员函数不能访问类 B 中的\nprivate 成员。</li>\n<li>友元的关系不能传递。如果类 B 是类 A 的友元类，类 C 是类 B\n的友元类，不等于类 C 是类 A 的友元类。</li>\n</ul>\n<p>除非有必要，一般不建议把整个类声明为友元类，而只将某些成员函数声明为友元函数，这样更安全一些。</p>\n","categories":["Essential C++"],"tags":["Essential C++"]},{"title":"HJ43 迷宫问题","url":"/2022/03/21/HJ43-%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98/","content":"<p>#<a\nhref=\"https://www.nowcoder.com/practice/cf24906056f4488c9ddb132f317e03bc?tpId=37&amp;tqId=21266&amp;rp=1&amp;ru=/ta/huawei&amp;qru=/ta/huawei&amp;difficulty=&amp;judgeStatus=&amp;tags=/question-ranking\">HJ43\n迷宫问题</a></p>\n<h2 id=\"描述\">描述</h2>\n<p>定义一个二维数组 N*M ，如 5 × 5 数组下所示：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> maze[<span class=\"number\">5</span>][<span class=\"number\">5</span>] = &#123;</span><br><span class=\"line\"><span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\"><span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\"><span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\"><span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\"><span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>,</span><br><span class=\"line\">&#125;; </span><br></pre></td></tr></table></figure>\n<p>它表示一个迷宫，其中的1表示墙壁，<code>0</code>表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的路线。入口点为<code>[0,0]</code>,既第一格是可以走的路。</p>\n<p>数据范围： <code>2≤n,m≤10 2≤*n*,*m*≤10</code>， 输入的内容只包含\n<code>0≤val≤1 0≤*v**a**l*≤1</code></p>\n<span id=\"more\"></span>\n<h2 id=\"输入描述\">输入描述：</h2>\n<p>输入两个整数，分别表示二维数组的行数，列数。再输入相应的数组，其中的<code>1</code>表示墙壁，<code>0</code>表示可以走的路。数据保证有唯一解,不考虑有多解的情况，即迷宫只有一条通道。</p>\n<h2 id=\"输出描述\">输出描述：</h2>\n<p>左上角到右下角的最短路径，格式如样例所示。</p>\n<h2 id=\"示例\">示例：</h2>\n<blockquote>\n<p>输入：</p>\n<p>5 5 0 1 0 0 0 0 1 1 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 1 0</p>\n<p>输出：</p>\n<p>(0,0) (1,0) (2,0) (2,1) (2,2) (2,3) (2,4) (3,4) (4,4)</p>\n</blockquote>\n<h3 id=\"思路\">思路：</h3>\n<p><code>dfs</code>直接输出即可。使用<code>pair</code>来记录路径。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> n,m;</span><br><span class=\"line\"><span class=\"type\">int</span> maze[<span class=\"number\">10</span>][<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"comment\">//记录路径</span></span><br><span class=\"line\"><span class=\"type\">int</span> vis[<span class=\"number\">10</span>][<span class=\"number\">10</span>];</span><br><span class=\"line\">vector&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; &gt;mp;</span><br><span class=\"line\"><span class=\"comment\">//上，下，左，右</span></span><br><span class=\"line\"><span class=\"type\">int</span> dir[][<span class=\"number\">2</span>] = &#123;&#123;<span class=\"number\">-1</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">1</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">0</span>,<span class=\"number\">-1</span>&#125;,&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>&#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//base case</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x == n - <span class=\"number\">1</span> &amp;&amp; y == m - <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//输出，要不然会回退</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; mp.<span class=\"built_in\">size</span>(); i++)&#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;(&quot;</span> &lt;&lt; mp[i].first &lt;&lt; <span class=\"string\">&quot;,&quot;</span> &lt;&lt; mp[i].second &lt;&lt; <span class=\"string\">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i &lt; <span class=\"number\">4</span>; i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//寻找方向</span></span><br><span class=\"line\">            <span class=\"type\">int</span> dx = x + dir[i][<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"type\">int</span> dy = y + dir[i][<span class=\"number\">1</span>];</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dx &gt;= <span class=\"number\">0</span> &amp;&amp; dx &lt; n &amp;&amp; dy &gt;= <span class=\"number\">0</span> &amp;&amp; dy &lt; m &amp;&amp; vis[dx][dy] == <span class=\"number\">0</span> &amp;&amp; maze[dx][dy] == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//标记走过</span></span><br><span class=\"line\">                vis[dx][dy] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                mp.<span class=\"built_in\">push_back</span>(<span class=\"built_in\">make_pair</span>(dx, dy));</span><br><span class=\"line\">                <span class=\"built_in\">dfs</span>(dx,dy);</span><br><span class=\"line\">              \t<span class=\"comment\">//回退</span></span><br><span class=\"line\">                vis[dx][dy] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                mp.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(vis, <span class=\"number\">0</span>, <span class=\"built_in\">sizeof</span>(vis));</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j++)&#123;</span><br><span class=\"line\">            cin &gt;&gt; maze[i][j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mp.<span class=\"built_in\">push_back</span>(<span class=\"built_in\">make_pair</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\">    vis[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["dfs","华为机试"],"tags":["dfs"]},{"title":"HJ61 放苹果","url":"/2022/03/23/HJ61-%E6%94%BE%E8%8B%B9%E6%9E%9C/","content":"<p>#<a\nhref=\"https://www.nowcoder.com/practice/bfd8234bb5e84be0b493656e390bdebf?tpId=37&amp;rp=1&amp;ru=%2Fta%2Fhuawei&amp;qru=%2Fta%2Fhuawei&amp;difficulty=&amp;judgeStatus=&amp;tags=&amp;title=&amp;sourceUrl=&amp;gioEnter=menu\"><strong>HJ61</strong>\n<strong>放苹果</strong></a></p>\n<h2 id=\"描述\">描述</h2>\n<p>把m个<strong>同样</strong>的苹果放在n个<strong>同样</strong>的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？</p>\n<p>注意：如果有7个苹果和3个盘子，（5，1，1）和（1，5，1）被视为是同一种分法。</p>\n<p>数据范围：0≤m≤10 0≤<em>m</em>≤10 ，1≤n≤10 1≤<em>n</em>≤10 。</p>\n<h2 id=\"示例\">示例：</h2>\n<blockquote>\n<p>输入：</p>\n<p>7 3</p>\n<p>输出：</p>\n<p>8</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"思路\">思路：</h3>\n<p>因为不区分顺序，所以只考虑苹果分了几份，每份多少个。</p>\n<p>很容易我们知道当苹果为 0 或者盘子只有 1 个时候，只有 1 种分法。</p>\n<p>我们再来分析下，假如盘子的数量比苹果的数量多，假设有 2个苹果，3\n个盘子，我们是不是最多放 2 个盘子，换句话就是说至少有 3 - 2\n个盘子是空的，分法只能在 2 个盘子中进行。</p>\n<p>那苹果的数量大于等于盘子的时候呢，假如 5 个苹果，3\n个盘子，可以分成两类：</p>\n<ul>\n<li>至少有一个盘子空着，那就变成 5 个苹果，2 个盘子的分法。</li>\n<li>全部盘子都有苹果，那就变成了 （5 - 3）= 2 个苹果，\n3个盘子的分法。</li>\n</ul>\n<p><img src=\"HJ61-放苹果/1.jpg\" /></p>\n<p>综上：</p>\n<h4 id=\"第一步明确状态和选择\">第一步：明确「状态」和「选择」：</h4>\n<p>状态就是 有 i 个盘子， j 个苹果，选择就是放在哪个盘子</p>\n<p>####第二步：明确 dp 定义：</p>\n<p>我们可以定义一个\n<code>dp</code>数组，<code>dp[i][j]</code>的定义：</p>\n<blockquote>\n<p>表示 i 个苹果， j 个苹果，共有 <code>dp[i][j]</code>种分法。</p>\n</blockquote>\n<h4 id=\"第三步根据定义明确状态转移\">第三步：根据定义明确状态转移：</h4>\n<ul>\n<li><p>当苹果 m &gt; 盘子 n 时</p>\n<p>​ $ dp[i][j] = dp[i][j - 1] $</p></li>\n<li><p>当苹果 m &lt;= 盘子 n 时</p>\n<p>$ dp[i][j] = dp[i][j - 1] + do[i - j][j] $</p></li>\n</ul>\n<h4 id=\"代码\">代码：</h4>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> m, n;</span><br><span class=\"line\">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; <span class=\"built_in\">dp</span>(m + <span class=\"number\">1</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(n + <span class=\"number\">1</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// base case</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= m; i++)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//只有一个盘子</span></span><br><span class=\"line\">        dp[i][<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//0个苹果</span></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i &lt; j)&#123;</span><br><span class=\"line\">                dp[i][j] = dp[i][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                dp[i][j] = dp[i][j - <span class=\"number\">1</span>] + dp[i - j][j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; dp[m][n] &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["动态规划"],"tags":["动态规划"]},{"title":"HJ65 查找两个字符串a,b中的最长公共子串","url":"/2022/03/24/HJ65-%E6%9F%A5%E6%89%BE%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2a,b%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2/","content":"<h1 id=\"描述\">描述</h1>\n<p>查找两个字符串a,b中的最长公共子串。若有多个，输出在较短串中最先出现的那个。</p>\n<p>注：子串的定义：将一个字符串删去前缀和后缀（也可以不删）形成的字符串。请和“子序列”的概念分开！</p>\n<p>数据范围：字符串长度<code>1&lt;= length&lt;=30</code></p>\n<p>进阶：时间复杂度：<code>O(n^3)</code>\n，空间复杂度：<code>O(n)</code></p>\n<h2 id=\"示例\">示例</h2>\n<blockquote>\n<p>输入：</p>\n<p>abcdefghijklmnop abcsafjklmnopqrstuvw</p>\n<p>输出：</p>\n<p>jklmnop</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"思路\">思路：</h3>\n<h4 id=\"方法一暴力搜索\">方法一：暴力搜索</h4>\n<p>我们把<code>s1</code>设置为较短的字符串，然后截取子串在<code>s2</code>中查找，维护最长的即可。</p>\n<p>时机复杂度为：<code>O(m^3n)</code>，因为枚举 s1\n所有的子串需要<code>O(m^2)</code>，find 函数查找 s2\n中是否含有子串需要<code>O(mn)</code></p>\n<p>空复杂度：<code>O(1)</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">暴力</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    string s1,s2;</span><br><span class=\"line\">    cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = s1.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span> m = s2.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"comment\">//把 s1 设置为较短的字符串</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n &gt; m)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">swap</span>(s1, s2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    string res = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; s1.<span class=\"built_in\">size</span>(); i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = i; j &lt; s1.<span class=\"built_in\">size</span>(); j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s2.<span class=\"built_in\">find</span>(s1.<span class=\"built_in\">substr</span>(i, j - i + <span class=\"number\">1</span>)) == string::npos)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//截取子串能够在 s2 中找不到</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(res.<span class=\"built_in\">size</span>() &lt; j - i + <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 更新较长的子串</span></span><br><span class=\"line\">                res = s1.<span class=\"built_in\">substr</span>(i, j - i + <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法二优化\">方法二：优化</h3>\n<p>我们不需要像方法一一样完全枚举，我们可以遍历两个字符串的所有字符串作为起点，然后同时开始检查字符是否相等，相等则不断后移，增加子串长度，否则说明这个子串截止了，不需要再遍历了，后续比较维护最大值即可。</p>\n<p>时机复杂度为：<code>O(m^2n)</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    string s1,s2;</span><br><span class=\"line\">    cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = s1.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span> m = s2.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"comment\">//把 s1 设置为较短的字符串</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n &gt; m)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">swap</span>(s1, s2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    string res = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; s1.<span class=\"built_in\">size</span>(); i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; s2.<span class=\"built_in\">size</span>(); j++)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> len = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> x = i, y = j;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(x &lt; s1.<span class=\"built_in\">size</span>() &amp;&amp; y &lt; s2.<span class=\"built_in\">size</span>() &amp;&amp; s1[x] == s2[y])&#123;</span><br><span class=\"line\">                x++;</span><br><span class=\"line\">                y++;</span><br><span class=\"line\">                len++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(res.<span class=\"built_in\">size</span>() &lt; len)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//更新更大的公共子串</span></span><br><span class=\"line\">                res = s1.<span class=\"built_in\">substr</span>(i, x - i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法三动态规划\">方法三：动态规划</h3>\n<p><code>dp[i][j]</code> 表示在 s1 中以 第 i 个字符结尾在 s2 中以第 j\n个字符结尾时的公共子串长度，</p>\n<p>遍历两个字符串dp数组，在这个过程中比较维护最大值即可。</p>\n<p>转移方程为：如果遍历到的该位两个字符相等，则此时长度等于两个前一位长度+1，</p>\n<p><code>dp[i][j]=dp[i−1][j−1]+1</code>，如果遍历到该位时两个字符不相等，则置为0，因为这是子串，必须连续相等，断开要重新开始。</p>\n<p>时机复杂度为：O(mn)</p>\n<p>空间复杂度：O(mn)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    string s1,s2;</span><br><span class=\"line\">    cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = s1.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span> m = s2.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"comment\">//把 s1 设置为较短的字符串</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n &gt; m)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">swap</span>(s1, s2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; <span class=\"built_in\">dp</span>(s1.<span class=\"built_in\">size</span>() + <span class=\"number\">1</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(s2.<span class=\"built_in\">size</span>() + <span class=\"number\">1</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\">    <span class=\"type\">int</span> max = <span class=\"number\">0</span>, end = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= s1.<span class=\"built_in\">size</span>(); i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= s2.<span class=\"built_in\">size</span>(); j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s1[i - <span class=\"number\">1</span>] == s2[j - <span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                dp[i][j] = dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 重新开始</span></span><br><span class=\"line\">                dp[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dp[i][j] &gt; max)&#123;</span><br><span class=\"line\">                max = dp[i][j];</span><br><span class=\"line\">                end = i - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; s1.<span class=\"built_in\">substr</span>(end - max + <span class=\"number\">1</span>, max) &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["动态规划","字符串"],"tags":["动态规划","字符串"]},{"title":"HJ82 将真分数分解为埃及分数","url":"/2022/03/28/HJ82-%E5%B0%86%E7%9C%9F%E5%88%86%E6%95%B0%E5%88%86%E8%A7%A3%E4%B8%BA%E5%9F%83%E5%8F%8A%E5%88%86%E6%95%B0/","content":"<p>#<a\nhref=\"https://www.nowcoder.com/practice/e0480b2c6aa24bfba0935ffcca3ccb7b?tpId=37&amp;rp=1&amp;ru=%2Fta%2Fhuawei&amp;qru=%2Fta%2Fhuawei&amp;difficulty=&amp;judgeStatus=&amp;tags=&amp;title=&amp;sourceUrl=&amp;gioEnter=menu\"><strong>HJ82</strong>\n<strong>将真分数分解为埃及分数</strong></a></p>\n<h2 id=\"描述\">描述</h2>\n<p>分子为1的分数称为埃及分数。现输入一个真分数(分子比分母小的分数，叫做真分数)，请将该分数分解为埃及分数。如：8/11\n= 1/2+1/5+1/55+1/110。</p>\n<p>注：真分数指分子小于分母的分数，分子和分母有可能gcd不为1！</p>\n<p>如有多个解，请输出任意一个。</p>\n<h3 id=\"示例\">示例：</h3>\n<blockquote>\n<p>输入：</p>\n<p>8/11 2/4</p>\n<p>输出：</p>\n<p>1/2+1/5+1/55+1/110 1/3+1/6</p>\n<p>说明：</p>\n<p>第二个样例直接输出1/2也是可以的</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"思路\">思路：</h2>\n<h3 id=\"方法一投机取巧\">方法一：投机取巧</h3>\n<p>直接输出当前字母的各种 1/字母即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    string str;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cin &gt;&gt; str)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> index = str.<span class=\"built_in\">find</span>(<span class=\"string\">&#x27;/&#x27;</span>);</span><br><span class=\"line\">        string a = str.<span class=\"built_in\">substr</span>(<span class=\"number\">0</span>, index);</span><br><span class=\"line\">        string b = str.<span class=\"built_in\">substr</span>(index + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"type\">int</span> n = <span class=\"built_in\">stoi</span>(a);</span><br><span class=\"line\">        string res;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(n--)&#123;</span><br><span class=\"line\">            res += <span class=\"string\">&quot;1/&quot;</span> + b + <span class=\"string\">&quot;+&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        res = res.<span class=\"built_in\">substr</span>(<span class=\"number\">0</span>, res.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>);</span><br><span class=\"line\">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法二数学推导\">方法二：数学推导</h3>\n<p>我们假设 <code>a/b</code> <span class=\"math display\">\\[\n\\frac{b}{a} = x{\\ldots}y\n\\]</span></p>\n<p><span class=\"math display\">\\[\nb = ax + y\n\\]</span></p>\n<p><span class=\"math display\">\\[\n\\frac{a}{b} = \\frac{a}{ax + y} = \\frac{a(x+1)}{ax+y(x+1)}\n\\]</span></p>\n<p><span class=\"math display\">\\[\n\\implies = \\frac{a(x+1) + y - y}{(ax+y)(x+1)} = \\frac {1}{x+1} + \\frac\n{a-y}{y} * \\frac {1}{x+1}\n\\]</span></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    string str;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cin &gt;&gt; str)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> index = str.<span class=\"built_in\">find</span>(<span class=\"string\">&#x27;/&#x27;</span>);</span><br><span class=\"line\">        string tmp1 = str.<span class=\"built_in\">substr</span>(<span class=\"number\">0</span>, index);</span><br><span class=\"line\">        string tmp2 = str.<span class=\"built_in\">substr</span>(index + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"type\">int</span> a = <span class=\"built_in\">stoi</span>(tmp1);</span><br><span class=\"line\">        <span class=\"type\">int</span> b = <span class=\"built_in\">stoi</span>(tmp2);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(a != <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(b % a == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                b = b / a;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//按照公式划分</span></span><br><span class=\"line\">            <span class=\"type\">int</span> x = b / a;</span><br><span class=\"line\">            <span class=\"type\">int</span> y = b % a;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"number\">1</span> &lt;&lt; <span class=\"string\">&quot;/&quot;</span> &lt;&lt; x + <span class=\"number\">1</span> &lt;&lt; <span class=\"string\">&quot;+&quot;</span>;</span><br><span class=\"line\">            a -= y;</span><br><span class=\"line\">            b *= (x + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"number\">1</span> &lt;&lt; <span class=\"string\">&quot;/&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["数学"],"tags":["数学"]},{"title":"HJ77 火车进站","url":"/2022/03/28/HJ77-%E7%81%AB%E8%BD%A6%E8%BF%9B%E7%AB%99/","content":"<p>#<a\nhref=\"https://www.nowcoder.com/practice/97ba57c35e9f4749826dc3befaeae109?tpId=37&amp;tqId=21300&amp;rp=1&amp;ru=/ta/huawei&amp;qru=/ta/huawei&amp;difficulty=&amp;judgeStatus=&amp;tags=/question-ranking\"><strong>HJ77</strong>\n<strong>火车进站</strong></a></p>\n<h2 id=\"描述\">描述</h2>\n<p>给定一个正整数N代表火车数量，0&lt;N&lt;10，接下来输入火车入站的序列，一共N辆火车，每辆火车以数字1-9\n编号，火车站只有一个方向进出，同时停靠在火车站的列车中，只有后进站的出站了，先进站的才能出站。</p>\n<p>要求输出所有火车出站的方案，以字典序排序输出。</p>\n<p>数据范围：<code>1≤ n ≤10 1 ≤ n ≤10</code></p>\n<p>进阶：时间复杂度：<code>O(n!)</code>\n，空间复杂度：<code>O(n)</code></p>\n<h3 id=\"输入描述\">输入描述：</h3>\n<p>第一行输入一个正整数N（0 &lt; N &lt;=\n10），第二行包括N个正整数，范围为1到10。</p>\n<h3 id=\"输出描述\">输出描述：</h3>\n<p>输出以字典序从小到大排序的火车出站序列号，每个编号以空格隔开，每个输出序列换行，具体见sample。</p>\n<span id=\"more\"></span>\n<h2 id=\"示例1\">示例1</h2>\n<blockquote>\n<p>输入：</p>\n<p>3 1 2 3</p>\n<p>输出：</p>\n<p>1 2 3 1 3 2 2 1 3 2 3 1 3 2 1</p>\n<p>说明：</p>\n<p>第一种方案：1进、1出、2进、2出、3进、3出\n第二种方案：1进、1出、2进、3进、3出、2出\n第三种方案：1进、2进、2出、1出、3进、3出\n第四种方案：1进、2进、2出、3进、3出、1出\n第五种方案：1进、2进、3进、3出、2出、1出\n请注意，[3,1,2]这个序列是不可能实现的。</p>\n</blockquote>\n<h2 id=\"思路\">思路：</h2>\n<h3 id=\"方法一全排列\">方法一：全排列</h3>\n<h4 id=\"算法步骤\">算法步骤：</h4>\n<ul>\n<li>从小到大全排列所有的出栈顺序</li>\n<li>根据入栈顺序判断出栈顺序是否合法</li>\n<li>如果合法就输出该出栈顺序</li>\n</ul>\n<p><strong>问题一：如何全排列？</strong></p>\n<p>可以调用<code>next_permutation</code>来进行全排列</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sort</span>(tmp.<span class=\"built_in\">begin</span>(), tmp.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    <span class=\"comment\">// 全排列出栈列表</span></span><br><span class=\"line\">    <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">check</span>(tmp))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">                cout &lt;&lt; tmp[i] &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cout &lt;&lt; endl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span>(<span class=\"built_in\">next_permutation</span>(tmp.<span class=\"built_in\">begin</span>(), tmp.<span class=\"built_in\">end</span>()));</span><br></pre></td></tr></table></figure>\n<p><strong>问题二：如何判断出栈顺序是否合法？</strong></p>\n<p>例如：</p>\n<p>入栈顺序为： 1 2 3</p>\n<p>出栈顺序为：3 1 2</p>\n<p>我们直接看，可以明显的看出是不合法的。那么计算机应该如何判断呢？我们只需要借助栈模拟下输出即可。</p>\n<blockquote>\n<p>我们先让nums的元素入栈，然后判断栈是否为空和栈顶元素是否等于出栈顺序的首数字，如果等于出栈顺序\n+ 1，并且把栈顶元素出栈，最后判断栈是否为空，空就代表合法，否则非法</p>\n</blockquote>\n<p><img src=\"HJ77-火车进站/1.jpg\" style=\"zoom:67%;\" /></p>\n<p>我们可以写出如下代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">check</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; tmp)</span></span>&#123;</span><br><span class=\"line\">    stack&lt;<span class=\"type\">int</span>&gt; st;</span><br><span class=\"line\">    <span class=\"type\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; tmp.<span class=\"built_in\">size</span>(); i++)&#123;</span><br><span class=\"line\">        st.<span class=\"built_in\">push</span>(nums[i]);</span><br><span class=\"line\">        <span class=\"comment\">//如果栈顶元素等于出栈序列元素，则栈顶元素出栈并出栈序列下标加一</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!st.<span class=\"built_in\">empty</span>() &amp;&amp; tmp[j] == st.<span class=\"built_in\">top</span>())&#123;</span><br><span class=\"line\">            st.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> st.<span class=\"built_in\">empty</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>完整代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> n;</span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; nums;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">check</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; tmp)</span></span>&#123;</span><br><span class=\"line\">    stack&lt;<span class=\"type\">int</span>&gt; st;</span><br><span class=\"line\">    <span class=\"type\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; tmp.<span class=\"built_in\">size</span>(); i++)&#123;</span><br><span class=\"line\">        st.<span class=\"built_in\">push</span>(nums[i]);</span><br><span class=\"line\">        <span class=\"comment\">//如果栈顶元素等于出栈序列元素，则栈顶元素出栈并出栈序列下标加一</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!st.<span class=\"built_in\">empty</span>() &amp;&amp; tmp[j] == st.<span class=\"built_in\">top</span>())&#123;</span><br><span class=\"line\">            st.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> st.<span class=\"built_in\">empty</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin &gt;&gt; n;</span><br><span class=\"line\">    nums.<span class=\"built_in\">resize</span>(n,<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        cin &gt;&gt; nums[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">tmp</span><span class=\"params\">(nums)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(tmp.<span class=\"built_in\">begin</span>(), tmp.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    <span class=\"comment\">// 全排列出栈列表</span></span><br><span class=\"line\">    <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">check</span>(tmp))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">                cout &lt;&lt; tmp[i] &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cout &lt;&lt; endl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span>(<span class=\"built_in\">next_permutation</span>(tmp.<span class=\"built_in\">begin</span>(), tmp.<span class=\"built_in\">end</span>()));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>全排列的时间复杂度为<code>O(n!)</code>，判断出栈序列是否合法为<code>O(n)</code>，所以总的时间复杂度为：<code>O(n*n!)</code></p>\n<p>空间复杂度为：<code>O(n)</code></p>\n<h3 id=\"方法二dfs\">方法二：dfs</h3>\n<p>dfs\n遍历整个全排列，最坏情况下全排列都要输出，时间复杂度为<code>O(n!log2(n!))</code></p>\n<p>空间复杂度为：<code>O(n * n!)</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> n;</span><br><span class=\"line\"><span class=\"type\">int</span> nums[<span class=\"number\">15</span>],c[<span class=\"number\">15</span>],tmp[<span class=\"number\">15</span>], vis[<span class=\"number\">15</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">check</span><span class=\"params\">(<span class=\"type\">int</span> b[])</span></span>&#123;</span><br><span class=\"line\">    stack&lt;<span class=\"type\">int</span>&gt; st;</span><br><span class=\"line\">    <span class=\"type\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        st.<span class=\"built_in\">push</span>(nums[i]);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!st.<span class=\"built_in\">empty</span>() &amp;&amp; b[j] == st.<span class=\"built_in\">top</span>())&#123;</span><br><span class=\"line\">            st.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> st.<span class=\"built_in\">empty</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// base case</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x == n)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">check</span>(tmp))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">                cout &lt;&lt; tmp[i] &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cout &lt;&lt; endl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> y = c[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(vis[y] == <span class=\"number\">0</span>)&#123;    <span class=\"comment\">//没有访问过</span></span><br><span class=\"line\">            vis[y] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            tmp[x] = y;</span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(x + <span class=\"number\">1</span>);</span><br><span class=\"line\">            vis[y] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cin &gt;&gt; n)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            cin &gt;&gt; nums[i];</span><br><span class=\"line\">            c[i] = nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//排序</span></span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(c, c + n);</span><br><span class=\"line\">        <span class=\"comment\">// dfs</span></span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["栈","dfs"],"tags":["dfs","栈","全排列"]},{"title":"LC寻找数组的中心索引","url":"/2020/12/30/LC%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95/","content":"<h1 id=\"寻找数组的中心索引\">寻找数组的中心索引</h1>\n<p><a\nhref=\"https://leetcode-cn.com/leetbook/read/array-and-string/yf47s/\">题目链接</a></p>\n<p>给定一个整数类型的数组 nums，请编写一个能够返回数组 “中心索引”\n的方法。</p>\n<p>我们是这样定义数组 中心索引\n的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。</p>\n<p>如果数组不存在中心索引，那么我们应该返回\n-1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。</p>\n<span id=\"more\"></span>\n<h4 id=\"示例1\">示例1:</h4>\n<blockquote>\n<h4 id=\"输入\">输入：</h4>\n<p>nums = [1,7,3,6,5,6]</p>\n<h4 id=\"输出3\">输出：3</h4>\n<p>解释：</p>\n<p>索引 3 (nums[3] = 6) 的左侧数之和 (1 + 7 + 3 = 11)，与右侧数之和 (5 +\n6 = 11) 相等。 同时, 3 也是第一个符合要求的中心索引。</p>\n</blockquote>\n<h4 id=\"示例2\">示例2:</h4>\n<blockquote>\n<h4 id=\"输入-1\">输入：</h4>\n<p>nums = [1,2,3]</p>\n<h4 id=\"输出-1\">输出：-1</h4>\n<p>解释：</p>\n<p>数组中不存在满足此条件的中心索引</p>\n</blockquote>\n<h5 id=\"说明\">说明：</h5>\n<ul>\n<li>nums 的长度范围为【0，10000】。</li>\n<li>任何一个nums[i]将会是一个范围在[-1000，1000]的整数。</li>\n</ul>\n<h3 id=\"思路\">思路</h3>\n<blockquote>\n<p>第一种思路是我们定义leftsum 和 rightsum,分别从两头加，直到leftsum ==\nrightsum且它们之间还有一个元素。</p>\n</blockquote>\n<blockquote>\n<p>第二种思路就是我们可以知道totalSum = leftsum + rightsum + mums[i]</p>\n<p>leftsum == rightsum</p>\n<p>所以 2*leftsum = totalSum - nums[i]</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">pivotIndex</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span>(nums.<span class=\"built_in\">size</span>() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    \t<span class=\"type\">int</span> sum = <span class=\"number\">0</span>, leftsum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    \t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;nums.<span class=\"built_in\">size</span>();i++)&#123;</span><br><span class=\"line\">    \t\tsum += nums[i];</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    \t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;nums.<span class=\"built_in\">size</span>();i++)&#123;</span><br><span class=\"line\">    \t\t<span class=\"keyword\">if</span>(leftsum * <span class=\"number\">2</span> == sum - nums[i]) <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    \t\t<span class=\"keyword\">else</span> leftsum += nums[i];</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"总的代码如下\">总的代码如下：</h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">思路：</span></span><br><span class=\"line\"><span class=\"comment\">leftsum + rightsum + nums[i] = sum</span></span><br><span class=\"line\"><span class=\"comment\">leftsum*2 = sum -nums[i]</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">pivotIndex</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span>(nums.<span class=\"built_in\">size</span>() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    \t<span class=\"type\">int</span> sum = <span class=\"number\">0</span>, leftsum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    \t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;nums.<span class=\"built_in\">size</span>();i++)&#123;</span><br><span class=\"line\">    \t\tsum += nums[i];</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    \t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;nums.<span class=\"built_in\">size</span>();i++)&#123;</span><br><span class=\"line\">    \t\t<span class=\"keyword\">if</span>(leftsum * <span class=\"number\">2</span> == sum - nums[i]) <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    \t\t<span class=\"keyword\">else</span> leftsum += nums[i];</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> arr[<span class=\"number\">6</span>]=&#123;<span class=\"number\">1</span>,<span class=\"number\">7</span>,<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>&#125;;</span><br><span class=\"line\">\t<span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">nums</span><span class=\"params\">(arr,*(arr +<span class=\"number\">1</span>))</span></span>;</span><br><span class=\"line\">\tSolution a;</span><br><span class=\"line\">\t<span class=\"type\">int</span> b;</span><br><span class=\"line\">\tb = a.<span class=\"built_in\">pivotIndex</span>(nums);</span><br><span class=\"line\">\tcout &lt;&lt; b &lt;&lt; endl;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["数组"],"tags":["leetcode","数组"]},{"title":"LC最长公共前缀","url":"/2021/01/05/LC%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/","content":"<h3 id=\"lc最长公共前缀\">LC最长公共前缀</h3>\n<p>编写一个函数来查找字符串数组中的最长公共前缀。</p>\n<p>如果不存在公共前缀，返回空字符串 <code>\"\"</code>。</p>\n<h5 id=\"示例1\">示例1:</h5>\n<blockquote>\n<p>输入：[\"flower\",\"flow\",\"flight\"]</p>\n<p>输出：[fl]</p>\n</blockquote>\n<h5 id=\"示例2\">示例2:</h5>\n<blockquote>\n<p>输入：[\"dog\",\"racecar\",\"car\"]</p>\n<p>输出：\"\"</p>\n<p>解释：输入不存在公共前缀</p>\n</blockquote>\n<h6 id=\"说明\">说明：</h6>\n<p>所有人输入只包含小写字母a-z。</p>\n<span id=\"more\"></span>\n<h5 id=\"思路1\">思路1：</h5>\n<blockquote>\n<p>1，当字符串数组长度为0时，则公共前缀为空，直接返回\n2，令最长公共前缀ans的值为第一个字符串，进行初始化\n3，遍历后面的字符串，依次将其与res进行比较，两两找出公共前缀，最终结果即为\n最长公共前缀\n4，如果查找过程中出现了res为空的情况，则公共前缀不存在，直接返回\n时间复杂度为O(s),s为所有字符串的长度之和</p>\n</blockquote>\n<p>比如示例1；</p>\n<blockquote>\n<p>res = flower</p>\n<p>​ flow</p>\n<p>res = flow</p>\n<p>​ flight</p>\n<p>res = fl</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">longestCommonPrefix</span><span class=\"params\">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span>(strs.<span class=\"built_in\">size</span>() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    \tstring res = strs[<span class=\"number\">0</span>];</span><br><span class=\"line\">    \t<span class=\"type\">int</span> minlen = res.<span class=\"built_in\">size</span>();<span class=\"comment\">//记录公共前缀</span></span><br><span class=\"line\">    \t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; strs.<span class=\"built_in\">size</span>(); i++)&#123;</span><br><span class=\"line\">    \t\t<span class=\"type\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    \t\t<span class=\"keyword\">for</span>(; j &lt; res.<span class=\"built_in\">size</span>() &amp;&amp; j &lt; strs[i].<span class=\"built_in\">size</span>(); j++)&#123;</span><br><span class=\"line\">    \t\t\t<span class=\"keyword\">if</span>(res[j] != strs[i][j]) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    \t\t&#125;</span><br><span class=\"line\">    \t\t<span class=\"keyword\">if</span>(j &lt;= minlen)&#123;</span><br><span class=\"line\">    \t\t\tres = <span class=\"built_in\">string</span>(res,<span class=\"number\">0</span>,j);</span><br><span class=\"line\">    \t\t\tminlen = j;</span><br><span class=\"line\">    \t\t&#125;</span><br><span class=\"line\">    \t\t<span class=\"keyword\">if</span>(res.<span class=\"built_in\">empty</span>()) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"思路2\">思路2:</h5>\n<blockquote>\n<p>思路1: 1，我们先对字符串排序 比如abc ab abce 排序完后为 ab abc\nabce</p>\n<p>2，比较头尾即可</p>\n<p>复杂度为sort的复杂度</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">longestCommonPrefix</span><span class=\"params\">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span>(strs.<span class=\"built_in\">empty</span>()) <span class=\"keyword\">return</span> <span class=\"built_in\">string</span>();</span><br><span class=\"line\">    \t<span class=\"built_in\">sort</span>(strs.<span class=\"built_in\">begin</span>(), strs.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    \tstring st = strs.<span class=\"built_in\">front</span>(), end = strs.<span class=\"built_in\">back</span>();</span><br><span class=\"line\">    \t<span class=\"type\">int</span> i, num = <span class=\"built_in\">min</span>(st.<span class=\"built_in\">size</span>(),end.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">    \t<span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; num &amp;&amp; st[i] == end[i]; i++);</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"built_in\">string</span>(st,<span class=\"number\">0</span>,i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["动态规划"],"tags":["动态规划","字符串"]},{"title":"LC最长回文子串","url":"/2021/01/06/LC%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/","content":"<h3 id=\"最长回文子串\">最长回文子串</h3>\n<p>给定一个字符 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为\n1000。</p>\n<h5 id=\"示例1\">示例1:</h5>\n<blockquote>\n<h5 id=\"输入babad\">输入：“babad”</h5>\n<h5 id=\"输出bab\">输出：\"bab\"</h5>\n<p>#####注意：\"aba\"也是一个有效答案。</p>\n</blockquote>\n<h5 id=\"示例2\">示例2:</h5>\n<blockquote>\n<h5 id=\"输入cbbd\">输入：\"cbbd\"</h5>\n<h5 id=\"bb\">：\"bb\"</h5>\n</blockquote>\n<span id=\"more\"></span>\n<h4 id=\"方法一暴力匹配brute-force\">方法一：暴力匹配（Brute Force）</h4>\n<ul>\n<li>根据回文子串的定义，枚举所有长度大于等于2的子串，依次判断它们是否是回文</li>\n<li>在具体实现时，可以只针对大于“当前得到的最长回文子串长度”的子串进行“回文判断”</li>\n<li>在记录最长回文子串时，只记录当前子串的起始位置和子串长度。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">valid</span><span class=\"params\">(string s,<span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//验证子串s[left,right]是否为回文串</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(left &lt;= right)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(s[left] != s[right])&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tleft++;</span><br><span class=\"line\">\t\t\tright--;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">longestPalindrome</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">    \t<span class=\"comment\">//特判</span></span><br><span class=\"line\">    \t<span class=\"type\">int</span> len = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span>(len &lt; <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">    \t\t<span class=\"keyword\">return</span> s;</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    \t<span class=\"type\">int</span> maxLen = <span class=\"number\">1</span>;</span><br><span class=\"line\">    \tstring res = s.<span class=\"built_in\">substr</span>(<span class=\"number\">0</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    \t<span class=\"comment\">//枚举所有长度大于等于2的子串</span></span><br><span class=\"line\">    \t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; len - <span class=\"number\">1</span>; i++)&#123;</span><br><span class=\"line\">    \t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = i + <span class=\"number\">1</span>; j &lt; len; j++)&#123;</span><br><span class=\"line\">    \t\t\t<span class=\"keyword\">if</span>(j - i + <span class=\"number\">1</span> &gt; maxLen &amp;&amp; <span class=\"built_in\">valid</span>(s,i,j))&#123;</span><br><span class=\"line\">    \t\t\t\tmaxLen = j - i + <span class=\"number\">1</span>;</span><br><span class=\"line\">    \t\t\t\tres = s.<span class=\"built_in\">substr</span>(i,maxLen);</span><br><span class=\"line\">    \t\t\t&#125;</span><br><span class=\"line\">    \t\t&#125;</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二动态规划\">方法二：动态规划</h4>\n<h5 id=\"思考状态重点\">1，思考状态（重点）</h5>\n<ul>\n<li>状态的定义，先尝试（题目问什么，就把什么设置为状态）；</li>\n<li>然后思考「状态如何转移」，如果「状态转移方程」不容易得到，尝试修改定义，目的依然是为了方便得到「状态转移方程」。</li>\n</ul>\n<blockquote>\n<p>状态转移方程是原始问题的不同规模的子问题的联系。即大问题的最优解如何由小问题的最优解得到的。</p>\n</blockquote>\n<h5 id=\"思考状态转移方程核心难点\">2，思考状态转移方程（核心，难点）</h5>\n<ul>\n<li>常见的推到技巧是：分类讨论。即：对状态空间进行分类；</li>\n<li>「动态规划」方法依然是「空间换时间」思想的体现，常见的解决问题的过程很像在「填表」。</li>\n</ul>\n<h5 id=\"思考初始化\">3，思考初始化</h5>\n<p>初始化是非常重要的，一步错，步步错。初始化状态一定要设置对，才可能得到正确的结果。</p>\n<ul>\n<li>角度1: 直接从状态的语义出发。</li>\n<li>角度2:\n如果状态的语义不好思考，就考虑「状态转移方程」的边界需要什么样初始化的条件；</li>\n<li>角度3:\n从「状态转移方程」的下标看是否需要多设置一行，一列表示「哨兵」，这样可以避免一些特殊情况的讨论。</li>\n</ul>\n<h5 id=\"思考输出\">4，思考输出</h5>\n<p>有些时候是最后一个状态，有些时候可能会综合之前所有计算过的状态。</p>\n<h5\nid=\"思考优化空间也可以叫表格复用\">5，思考优化空间（也可以叫表格复用）</h5>\n<ul>\n<li>经典的「优化空间」的典型问题是「0-1」背包问题和「完全背包」问题。</li>\n</ul>\n<h4 id=\"分析\">分析</h4>\n<p>对于这道题来说，我们从回文串的定义展开讨论：</p>\n<ul>\n<li><p>如果一个字符串的头尾两个字符不相等，那么这两个字符串一定不是回文串；</p></li>\n<li><p>如果一个字符串的头尾两个字符相等，才有必要继续判断下去</p>\n<p>​ 1，如果里面的子串是回文，整体就是回文</p>\n<p>​ 2，如果里面的子串不是回文，整体就不是回文</p></li>\n</ul>\n<p>综上：\n<strong>在头尾字符相等的情况，里面的回文性质决定了整个子串的回文性质</strong>这就是状态转移。因此可以把「状态」定义为原字符串的一个子串是否是回文子串。</p>\n<h5 id=\"第1步定义状态\">第1步：定义状态</h5>\n<p>^dp[ i ][ j ]表示子串s[ i , j ]是否为回文子串，这里可以取到s[ i ]和s[\nj ]。</p>\n<h5 id=\"第2步思考状态转移方程\">第2步：思考状态转移方程</h5>\n<p>根据我们前面的分析（头尾字符是否相等），可以得到：</p>\n<blockquote>\n<p>dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1]</p>\n</blockquote>\n<p>这里需要注意：</p>\n<ul>\n<li>「动态规划」事实上是在填一张二维表格，由于构成子串，因此 [^ i] 和 [^\nj] 的关系</li>\n</ul>\n<p>是[^i &lt; = j] ，因此，只需要填这张表格对角线以上的部分。</p>\n<ul>\n<li>看到[^ dp[i + 1, j - 1] ] 就得考虑边界情况。</li>\n</ul>\n<p>边界条件是：表达式 [^ [i + 1, j - 1]] 不构成区间，即长度严格小于\n2，即[^ j - 1 - (i + 1) + 1 &lt; 2 ]，整理得[^ j - i &lt; 3]。</p>\n<p>这个结论很显然：j - i &lt; 3 等价于 j - i + 1 &lt; 4，即当子串\ns[i..j] 的长度等于 2 或者等于 3\n的时候，其实只需要判断一下头尾两个字符是否相等就可以直接下结论了。</p>\n<ul>\n<li><p>如果子串 s[i + 1..j - 1] 只有 1\n个字符，即去掉两头，剩下中间部分只有 1个字符，显然是回文；</p></li>\n<li><p>如果子串 s[i + 1..j - 1] 为空串，那么子串 s[i, j]\n一定是回文子串。</p></li>\n</ul>\n<p>因此，在 s[i] == s[j] 成立和 j - i &lt; 3\n的前提下，直接可以下结论，dp[ i ][ j ] = true，否则才执行状态转移。</p>\n<p>##### 第3步：考虑初始化</p>\n<p>初始化的时候，单个字符一定是回文串，因此把对角线先初始化为 true，即\ndp[i][i] = true 。</p>\n<p>事实上，初始化的部分都可以省去。因为只有一个字符的时候一定是回文，dp[\ni ][ i ] 根本不会被其它状态值所参考。</p>\n<h5 id=\"第4步考虑输出\">第4步：考虑输出</h5>\n<p>只要一得到 dp[ i ] [ j ] =\ntrue，就记录子串的长度和起始位置，没有必要截取，这是因为截取字符串也要消耗性能，记录此时的回文子串的「起始位置」和「回文长度」即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">longestPalindrome</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">    \t<span class=\"comment\">//特判</span></span><br><span class=\"line\">    \t<span class=\"type\">int</span> len = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span>(len &lt; <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">    \t\t<span class=\"keyword\">return</span> s;</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    \t<span class=\"type\">int</span> maxLen = <span class=\"number\">1</span>;</span><br><span class=\"line\">    \t<span class=\"type\">int</span> begin = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    \t<span class=\"comment\">//dp[i][j]表示s[i,j]是否是回文串</span></span><br><span class=\"line\">    \tvector&lt;vector&lt;<span class=\"type\">bool</span>&gt;&gt; <span class=\"built_in\">dp</span>(len,<span class=\"built_in\">vector</span>&lt;<span class=\"type\">bool</span>&gt;(len));</span><br><span class=\"line\">    \t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt; len; j++)&#123;</span><br><span class=\"line\">    \t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; j; i++)&#123;</span><br><span class=\"line\">    \t\t\t<span class=\"keyword\">if</span>(s[i] != s[j])&#123;</span><br><span class=\"line\">    \t\t\t\tdp[i][j] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    \t\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    \t\t\t&#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(j - i &lt; <span class=\"number\">3</span>)&#123;</span><br><span class=\"line\">    \t\t\t\tdp[i][j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    \t\t\t&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    \t\t\t\tdp[i][j] = dp[i + <span class=\"number\">1</span>][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">    \t\t\t&#125;</span><br><span class=\"line\">    \t\t\t<span class=\"keyword\">if</span>(dp[i][j] &amp;&amp; (j - i + <span class=\"number\">1</span> &gt; maxLen))&#123;</span><br><span class=\"line\">    \t\t\t\tmaxLen = j - i + <span class=\"number\">1</span>;</span><br><span class=\"line\">    \t\t\t\tbegin = i;</span><br><span class=\"line\">    \t\t\t&#125;</span><br><span class=\"line\">    \t\t&#125;</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> s.<span class=\"built_in\">substr</span>(begin,maxLen);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法三中心扩散法\">方法三：中心扩散法</h4>\n<p>暴力法采用双指针，验证是否是回文串。</p>\n<p>除了枚举字符串的左右边界以外，比较容易想到的是<strong>枚举可能出现的回文子串的“中心位置”，从中心位置尝试尽可能扩散出去，得到一个回文串。</strong></p>\n<h5 id=\"思路\">思路：</h5>\n<p>遍历每一个索引，以这个索引为中心，利用“回文串”中心对称的特点，往两边扩散，看最多能扩散多远。</p>\n<p>枚举“中心位置”时间复杂度为O(N)，从“中心位置”扩散得到“回文子串”的时间复杂度为O(N)，因此时间复杂度可以降到O(N^2)。</p>\n<p><strong>注意：</strong>在这里注意一个细节：回文串在长度为奇数和偶数的时候，“回文中心”的形式是不一样的。</p>\n<ul>\n<li>奇数回文串的“中心”是一个具体的字符，例如：回文串[^ aba]\n的中心是字符[^ b]；</li>\n<li>偶数回文串的\"中心\"是位于中间的两个字符的“空隙”，例如：回文串[^\nabba]的中心是两个[^ b]中间的那个“空隙”。</li>\n</ul>\n<p><img src=\"LC最长回文子串/1.jpg\" /></p>\n<p>我们可以设计一个方法，兼容以上两种情况：</p>\n<p>1、如果传入重合的索引编码，进行中心扩散，此时得到的回文子串的长度是奇数；</p>\n<p>2、如果传入相邻的索引编码，进行中心扩散，此时得到的回文子串的长度是偶数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">centerSpread</span><span class=\"params\">(string s, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// left = right 的时候，此时回文中心是一个空隙，向两边扩散得到的回文子串的长度是奇数</span></span><br><span class=\"line\">        <span class=\"comment\">// right = left + 1 的时候，此时回文中心是一个字符，向两边扩散得到的回文子串的长度是偶数</span></span><br><span class=\"line\">        <span class=\"type\">int</span> size = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> i = left;</span><br><span class=\"line\">        <span class=\"type\">int</span> j = right;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &gt;= <span class=\"number\">0</span> &amp;&amp; j &lt; size) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s[i] == s[j]) &#123;</span><br><span class=\"line\">                i--;</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 这里要小心，跳出 while 循环时，恰好满足 s.charAt(i) != s.charAt(j)，因此不能取 i，不能取 j</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> s.<span class=\"built_in\">substr</span>(i + <span class=\"number\">1</span>, j - i - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">longestPalindrome</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 特判</span></span><br><span class=\"line\">        <span class=\"type\">int</span> size = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> maxLen = <span class=\"number\">1</span>;</span><br><span class=\"line\">        string res = s.<span class=\"built_in\">substr</span>(<span class=\"number\">0</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 中心位置枚举到 len - 2 即可</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; size - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            string oddStr = <span class=\"built_in\">centerSpread</span>(s, i, i);</span><br><span class=\"line\">            string evenStr = <span class=\"built_in\">centerSpread</span>(s, i, i + <span class=\"number\">1</span>);</span><br><span class=\"line\">            string maxLenStr = oddStr.<span class=\"built_in\">size</span>() &gt; evenStr.<span class=\"built_in\">size</span>() ? oddStr : evenStr;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (maxLenStr.<span class=\"built_in\">length</span>() &gt; maxLen) &#123;</span><br><span class=\"line\">                maxLen = maxLenStr.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">                res = maxLenStr;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["动态规划"],"tags":["动态规划","字符串"]},{"title":"LeetCode Hot 100","url":"/2022/03/03/LeetCode-Hot-100/","content":"<p><code>leetcode hot 100</code></p>\n<span id=\"more\"></span>\n<p>####<a href=\"https://leetcode-cn.com/problems/two-sum/\">1.\n两数之和</a></p>\n<p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出\n和为目标值 target 的那 两个 整数，并返回它们的数组下标。</p>\n<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>\n<p>你可以按任意顺序返回答案。</p>\n<h5 id=\"示例\">示例：</h5>\n<blockquote>\n<p>输入：</p>\n<p>nums = [2,7,11,15], target = 9</p>\n<p>输出：</p>\n<p>[0,1]</p>\n<p>解释：因为nums[0] + nuts[1] == 9</p>\n</blockquote>\n<h5 id=\"思路\">思路：</h5>\n<p>方法一：暴力</p>\n<p>方法二：用哈希表</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">twoSum</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        unordered_map&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt;mp;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt;<span class=\"built_in\">res</span>(<span class=\"number\">2</span>,<span class=\"number\">-1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;nums.<span class=\"built_in\">size</span>();i++)&#123;</span><br><span class=\"line\">          <span class=\"comment\">//判断是否有相加等于target的数</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(mp.<span class=\"built_in\">count</span>(target-nums[i])&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                res[<span class=\"number\">0</span>]=mp[target-nums[i]];</span><br><span class=\"line\">                res[<span class=\"number\">1</span>]=i;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            mp[nums[i]]=i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"两数相加\"><a\nhref=\"https://leetcode-cn.com/problems/add-two-numbers/\">2.\n两数相加</a></h4>\n<p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序\n的方式存储的，并且每个节点只能存储 一位 数字。</p>\n<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>\n<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>\n<h5 id=\"示例-1\">示例：</h5>\n<blockquote>\n<p>输入：l1 = [2,4,3], l2 = [5,6,4]</p>\n<p>输出：[7,0,8]</p>\n<p>解释：342 + 465 = 807</p>\n</blockquote>\n<h5 id=\"思路-1\">思路：</h5>\n<p>模拟即可，需要注意进位</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ListNode</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> val;</span><br><span class=\"line\">    ListNode *next;</span><br><span class=\"line\">    <span class=\"built_in\">ListNode</span>() : <span class=\"built_in\">val</span>(<span class=\"number\">0</span>), <span class=\"built_in\">next</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">ListNode</span>(<span class=\"type\">int</span> x) : <span class=\"built_in\">val</span>(x), <span class=\"built_in\">next</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">ListNode</span>(<span class=\"type\">int</span> x, ListNode *next) : <span class=\"built_in\">val</span>(x), <span class=\"built_in\">next</span>(next) &#123;&#125;</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">addTwoNumbers</span><span class=\"params\">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//定义新链表</span></span><br><span class=\"line\">        ListNode* res = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>();</span><br><span class=\"line\">        <span class=\"comment\">//进位</span></span><br><span class=\"line\">        <span class=\"type\">int</span> carry = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//定义一个可移动指针</span></span><br><span class=\"line\">        ListNode* cur = res;</span><br><span class=\"line\">        <span class=\"comment\">//当l1或者l2不为空时</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l1 != <span class=\"literal\">nullptr</span> || l2 != <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果l1不等于null,就取它的值，等于就赋值0，保持两个链表具有相同的位数</span></span><br><span class=\"line\">            <span class=\"type\">int</span> x = l1 != <span class=\"literal\">nullptr</span> ? l1-&gt;val : <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"comment\">//如果l2不等于null,就取它的值，等于就赋值0，保持两个链表具有相同的位数</span></span><br><span class=\"line\">            <span class=\"type\">int</span> y = l2 != <span class=\"literal\">nullptr</span> ? l2-&gt;val : <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//计算两个数的和，注意进位</span></span><br><span class=\"line\">            <span class=\"type\">int</span> sum = x + y + carry;</span><br><span class=\"line\">            <span class=\"comment\">//计算进位</span></span><br><span class=\"line\">            carry = sum/<span class=\"number\">10</span>;</span><br><span class=\"line\">            sum = sum % <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//将结果添加到新节点中</span></span><br><span class=\"line\">            cur-&gt;next = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(sum);</span><br><span class=\"line\">            cur = cur-&gt;next;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">//后移l1,l2</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(l1!=<span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">                l1 = l1-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(l2!=<span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">                l2 = l2-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//如果最后两个数相加有进位，赋予链表新节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(carry)&#123;</span><br><span class=\"line\">            cur-&gt;next = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(carry);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//返回头节点</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"无重复字符的最长子串\"><a\nhref=\"https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/\">3.\n无重复字符的最长子串</a></h4>\n<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的\n<strong>最长子串</strong> 的长度。</p>\n<h5 id=\"示例-2\">示例：</h5>\n<blockquote>\n<p>输入：s=\"abcabcbb\"</p>\n<p>输出：3</p>\n<p>输入：s = \"bbbbb\"</p>\n<p>输出：1</p>\n<p>输入：s = \"pwwkew\"</p>\n<p>输出：3</p>\n</blockquote>\n<h5 id=\"思路-2\">思路：</h5>\n<p>标签：滑动窗口</p>\n<p>暴力解法时间复杂度较高，会达到O(n^2)，故而采取滑动窗口的方法降低时间复杂度</p>\n<p>定义一个 map 数据结构存储 (k, v)，其中 key 值为字符，value\n值为字符位置 +1，加 1 表示从字符位置后一个才开始不重复</p>\n<p>我们定义不重复子串的开始位置为 start，结束位置为 end</p>\n<p>随着 end 不断遍历向后，会遇到与 [start, end]\n区间内字符相同的情况，此时将字符作为 key 值，获取其 value 值，并更新\nstart，此时 [start, end] 区间内不存在重复字符</p>\n<p>无论是否更新 start，都会更新其 map 数据结构和结果 ans = end - start +\n1。</p>\n<p>时间复杂度：O(n)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = s.<span class=\"built_in\">size</span>(),ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//mp用于记录下一个数字从哪开始</span></span><br><span class=\"line\">        map&lt;<span class=\"type\">char</span>,<span class=\"type\">int</span>&gt; mp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> start=<span class=\"number\">0</span>,end=<span class=\"number\">0</span>;end&lt;n;end++)&#123;</span><br><span class=\"line\">            <span class=\"type\">char</span> tmp = s[end];</span><br><span class=\"line\">            <span class=\"comment\">//已经出现过</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(mp.<span class=\"built_in\">count</span>(tmp)&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//移动start到新的窗口</span></span><br><span class=\"line\">                start = <span class=\"built_in\">max</span>(mp[tmp],start);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ans = <span class=\"built_in\">max</span>(ans,end-start+<span class=\"number\">1</span>);</span><br><span class=\"line\">            mp[tmp] = end+<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"两数之和-ii---输入有序数组\"><a\nhref=\"https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/\">两数之和\nII - 输入有序数组</a></h4>\n<p>给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列\n，请你从数组中找出满足相加之和等于目标数 target\n的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1\n&lt;= index1 &lt; index2 &lt;= numbers.length 。</p>\n<p>以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标\nindex1 和 index2。</p>\n<p>你可以假设每个输入 只对应唯一的答案 ，而且你 不可以\n重复使用相同的元素。</p>\n<p>你所设计的解决方案必须只使用常量级的额外空间。</p>\n<h5 id=\"示例-3\">示例：</h5>\n<blockquote>\n<p>输入：numbers = [2,7,11,15], target = 9 输出：[1,2] 解释：2 与 7\n之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。</p>\n</blockquote>\n<h5 id=\"思路-3\">思路：</h5>\n<p>采用双指针，<code>l=0,r=numners.size()-1,sum = numbers[l]+numbers[r]</code></p>\n<p>我们可以得出如果<code>sum &gt; target</code>,那么我们可以排除这一列，因为往后和越大，我们只需要<code>r--</code></p>\n<p>如果<code>sum&lt;target</code>，我们可以排除这一行，<code>l++</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">twoSum</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; numbers, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> l=<span class=\"number\">0</span>,r=numbers.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l&lt;r)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> sum = numbers[l]+numbers[r];</span><br><span class=\"line\">            <span class=\"comment\">//排除这一行</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sum &lt; target) l++;</span><br><span class=\"line\">            <span class=\"comment\">//排除这一列</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(sum &gt; target) r--;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> &#123;l+<span class=\"number\">1</span>,r+<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;<span class=\"number\">-1</span>,<span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>####<a href=\"https://leetcode-cn.com/problems/valid-parentheses/\">20.\n有效的括号</a></p>\n<p>给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s\n，判断字符串是否有效。</p>\n<p>有效字符串需满足：</p>\n<p>左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。</p>\n<h5 id=\"示例-4\">示例：</h5>\n<blockquote>\n<p>输入：s = \"()\" 输出：true</p>\n</blockquote>\n<h5 id=\"思路-4\">思路：</h5>\n<p><strong>方法一：使用哈希表</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isValid</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n % <span class=\"number\">2</span> == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        unordered_map&lt;<span class=\"type\">char</span>, <span class=\"type\">char</span>&gt; pairs = &#123;</span><br><span class=\"line\">            &#123;<span class=\"string\">&#x27;)&#x27;</span>, <span class=\"string\">&#x27;(&#x27;</span>&#125;,</span><br><span class=\"line\">            &#123;<span class=\"string\">&#x27;]&#x27;</span>, <span class=\"string\">&#x27;[&#x27;</span>&#125;,</span><br><span class=\"line\">            &#123;<span class=\"string\">&#x27;&#125;&#x27;</span>, <span class=\"string\">&#x27;&#123;&#x27;</span>&#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        stack&lt;<span class=\"type\">char</span>&gt; stk;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">char</span> ch: s) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pairs.<span class=\"built_in\">count</span>(ch)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (stk.<span class=\"built_in\">empty</span>() || stk.<span class=\"built_in\">top</span>() != pairs[ch]) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                stk.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                stk.<span class=\"built_in\">push</span>(ch);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> stk.<span class=\"built_in\">empty</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>方法二：不使用哈希表</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isValid</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s.<span class=\"built_in\">size</span>() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">//奇数</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s.<span class=\"built_in\">size</span>()&amp;<span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        stack&lt;<span class=\"type\">char</span>&gt; st;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">char</span> c:s)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(c == <span class=\"string\">&#x27;(&#x27;</span> || c==<span class=\"string\">&#x27;[&#x27;</span> || c==<span class=\"string\">&#x27;&#123;&#x27;</span>) st.<span class=\"built_in\">push</span>(c);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(c == <span class=\"string\">&#x27;)&#x27;</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!st.<span class=\"built_in\">empty</span>() &amp;&amp; st.<span class=\"built_in\">top</span>()==<span class=\"string\">&#x27;(&#x27;</span>) st.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(c==<span class=\"string\">&#x27;]&#x27;</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!st.<span class=\"built_in\">empty</span>() &amp;&amp; st.<span class=\"built_in\">top</span>()==<span class=\"string\">&#x27;[&#x27;</span>) st.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(c==<span class=\"string\">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!st.<span class=\"built_in\">empty</span>() &amp;&amp; st.<span class=\"built_in\">top</span>()==<span class=\"string\">&#x27;&#123;&#x27;</span>) st.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(st.<span class=\"built_in\">empty</span>()) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"旋转图像\"><a\nhref=\"https://leetcode-cn.com/problems/rotate-image/\">48.\n旋转图像</a></h4>\n<p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转\n90 度。</p>\n<p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要\n使用另一个矩阵来旋转图像。</p>\n<h5 id=\"示例-5\">示例：</h5>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg\" alt=\"img\" style=\"zoom:50%;\" /></p>\n<blockquote>\n<p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]\n输出：[[7,4,1],[8,5,2],[9,6,3]]</p>\n</blockquote>\n<h5 id=\"思路-5\">思路：</h5>\n<p>顺时针旋转90度</p>\n<p>算法流程：</p>\n<p>1，先对角线反转</p>\n<p>2，再中间对称反转</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">rotate</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt;&amp; matrix)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = matrix.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"comment\">//先沿对角线镜像对称二维矩阵</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = i; j &lt; n; j++)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">swap</span>(matrix[i][j],matrix[j][i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//然后中间对称反转</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">reverse</span>(matrix[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; row)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> i = <span class=\"number\">0</span>, j = row.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(j &gt; i)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">swap</span>(row[i++],row[j--]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"螺旋矩阵\"><a\nhref=\"https://leetcode-cn.com/problems/spiral-matrix/\">54.\n螺旋矩阵</a></h4>\n<p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵\n<code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong>\n，返回矩阵中的所有元素。</p>\n<h5 id=\"示例-6\">示例：</h5>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg\" alt=\"spiral1\" style=\"zoom:50%;\" /></p>\n<blockquote>\n<p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]\n输出：[1,2,3,6,9,8,7,4,5]</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">spiralOrder</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt;&amp; matrix)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//初始化</span></span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; res;</span><br><span class=\"line\">        <span class=\"type\">int</span> m = matrix.<span class=\"built_in\">size</span>(),n = matrix[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(m == <span class=\"number\">0</span> || n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">        <span class=\"comment\">//定义边界</span></span><br><span class=\"line\">        <span class=\"type\">int</span> upper_bound = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> lower_bound = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> left_bound = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> right_bound = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(res.<span class=\"built_in\">size</span>() &lt;= m*n )&#123;</span><br><span class=\"line\">            <span class=\"comment\">//从左往右，行不变，列增大</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = left_bound; i &lt;= right_bound; i++)&#123;</span><br><span class=\"line\">                res.<span class=\"built_in\">push_back</span>(matrix[upper_bound][i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//上边界下移</span></span><br><span class=\"line\">            upper_bound++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(upper_bound &gt; lower_bound) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">//从上往下，列不变，行增大</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = upper_bound; j &lt;= lower_bound; j++)&#123;</span><br><span class=\"line\">                res.<span class=\"built_in\">push_back</span>(matrix[j][right_bound]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//右边界左移</span></span><br><span class=\"line\">            right_bound--;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(right_bound &lt; left_bound) <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//从右往左，行不变，列减小</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = right_bound; i &gt;= left_bound; i--)&#123;</span><br><span class=\"line\">                res.<span class=\"built_in\">push_back</span>(matrix[lower_bound][i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//下边界上移</span></span><br><span class=\"line\">            lower_bound--;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(lower_bound &lt; upper_bound) <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//从上往下，列不变，行减小</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = lower_bound; j &gt;= upper_bound; j--)&#123;</span><br><span class=\"line\">                res.<span class=\"built_in\">push_back</span>(matrix[j][left_bound]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//左边界右移</span></span><br><span class=\"line\">            left_bound++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(left_bound &gt; right_bound) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"螺旋矩阵-ii\"><a\nhref=\"https://leetcode-cn.com/problems/spiral-matrix-ii/\">59. 螺旋矩阵\nII</a></h4>\n<p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到\n<code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的\n<code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p>\n<h5 id=\"示例-7\">示例:</h5>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg\" alt=\"spiraln\" style=\"zoom:50%;\" /></p>\n<blockquote>\n<p>输入：n = 3 输出：[[1,2,3],[8,9,4],[7,6,5]]</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; <span class=\"built_in\">generateMatrix</span>(<span class=\"type\">int</span> n) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//初始化</span></span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; <span class=\"built_in\">res</span>(n,<span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(n));</span><br><span class=\"line\">        <span class=\"type\">int</span> upper_bound = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> lower_bound = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> left_bound = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> right_bound = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> num = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(num &lt;= n * n )&#123;</span><br><span class=\"line\">            <span class=\"comment\">//从左往右，行不变，列增大</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = left_bound; i &lt;= right_bound; i++)&#123;</span><br><span class=\"line\">                res[upper_bound][i] = num++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//上边界下移</span></span><br><span class=\"line\">            upper_bound++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(upper_bound &gt; lower_bound) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">//从上往下，列不变，行增大</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = upper_bound; j &lt;= lower_bound; j++)&#123;</span><br><span class=\"line\">                res[j][right_bound] = num++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//右边界左移</span></span><br><span class=\"line\">            right_bound--;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(right_bound &lt; left_bound) <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//从右往左，行不变，列减小</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = right_bound; i &gt;= left_bound; i--)&#123;</span><br><span class=\"line\">                res[lower_bound][i] = num++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//下边界上移</span></span><br><span class=\"line\">            lower_bound--;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(lower_bound &lt; upper_bound) <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//从上往下，列不变，行减小</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = lower_bound; j &gt;= upper_bound; j--)&#123;</span><br><span class=\"line\">                res[j][left_bound] = num++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//左边界右移</span></span><br><span class=\"line\">            left_bound++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(left_bound &gt; right_bound) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["LeetCode Hot 100"],"tags":["LeetCode Hot 100"]},{"title":"Mac 美化终端","url":"/2022/05/11/Mac-%E7%BE%8E%E5%8C%96%E7%BB%88%E7%AB%AF/","content":"<h1 id=\"美化终端\">美化终端</h1>\n<span id=\"more\"></span>\n<p>##1. 下载<a href=\"https://iterm2.com/downloads.html\">iTerm2</a></p>\n<p>第一步：打开<code>iTerm2</code>,`<code>command + ,</code>调出配置页面</p>\n<p><img src=\"Mac-美化终端/1.jpg\" /></p>\n<p>第二步：点击<code>Profiles</code>驱配置</p>\n<p><img src=\"Mac-美化终端/2.jpg\" /></p>\n<p>我打算选用<code>Dracula</code>主题</p>\n<p>点击<a href=\"https://draculatheme.com/iterm\">Dracula</a></p>\n<p><img src=\"Mac-美化终端/3.jpg\" /></p>\n<p>如果你能够很快的连接<code>github</code>的话，直接在<code>iTerm2</code>中输入：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">git clone https:<span class=\"comment\">//github.com/dracula/iterm.git</span></span><br></pre></td></tr></table></figure>\n<p>否则可以直接下载<code>dracula</code>中给出的<code>.zip</code>文件。</p>\n<blockquote>\n<ol type=\"1\">\n<li><em>iTerm2 &gt; Preferences &gt; Profiles &gt; Colors Tab</em></li>\n<li>Open the <em>Color Presets...</em> drop-down in the bottom right\ncorner</li>\n<li>Select <em>Import...</em> from the list</li>\n<li>Select the <code>Dracula.itermcolors</code> file</li>\n<li>Select the <em>Dracula</em> from <em>Color Presets...</em></li>\n</ol>\n</blockquote>\n<p><img src=\"Mac-美化终端/4.jpg\" /></p>\n<p>导入我们下载的文件即可。</p>\n<h2 id=\"下载oh-my-zsh\">2. 下载<code>oh-my-zsh</code></h2>\n<p>一般<code>mac</code>都会自带<code>zsh</code>，可以输入</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">cat /etc/shells</span><br></pre></td></tr></table></figure>\n<p>如果出现</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">(base) MacBook-Pro:~ SJCHEN$ cat /etc/shells</span><br><span class=\"line\"># <span class=\"function\">List of acceptable shells <span class=\"keyword\">for</span> <span class=\"title\">chpass</span><span class=\"params\">(<span class=\"number\">1</span>)</span>.</span></span><br><span class=\"line\"><span class=\"function\"># Ftpd will <span class=\"keyword\">not</span> allow users to connect who are <span class=\"keyword\">not</span> <span class=\"keyword\">using</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"meta\"># one of these shells.</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">/bin/bash</span></span><br><span class=\"line\"><span class=\"function\">/bin/csh</span></span><br><span class=\"line\"><span class=\"function\">/bin/dash</span></span><br><span class=\"line\"><span class=\"function\">/bin/ksh</span></span><br><span class=\"line\"><span class=\"function\">/bin/sh</span></span><br><span class=\"line\"><span class=\"function\">/bin/tcsh</span></span><br><span class=\"line\"><span class=\"function\">/bin/zsh</span></span><br></pre></td></tr></table></figure>\n<p>则代表已经有了，如果没有就</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">brew install zsh</span><br></pre></td></tr></table></figure>\n<p>具体可看<a\nhref=\"https://www.mintimate.cn/2021/02/05/configZsh/#Tips\">配置zsh</a></p>\n<p>这里我不采用默认的主题，</p>\n<p>直接在终端运行</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">git clone https:<span class=\"comment\">//github.com/spaceship-prompt/spaceship-prompt.git &quot;$ZSH_CUSTOM/themes/spaceship-prompt&quot; --depth=1</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">ln -s <span class=\"string\">&quot;$ZSH_CUSTOM/themes/spaceship-prompt/spaceship.zsh-theme&quot;</span> <span class=\"string\">&quot;$ZSH_CUSTOM/themes/spaceship.zsh-theme&quot;</span></span><br></pre></td></tr></table></figure>\n<p>然后在访达中<code>command + shift + .</code>打开隐藏文件，打开<code>.zshrc</code></p>\n<p><img src=\"Mac-美化终端/5.jpg\" /></p>\n<p>修改<code>ZSH_THEME =</code>为<code>spaceship</code>即可</p>\n<p><img src=\"Mac-美化终端/6.jpg\" /></p>\n","categories":["终端"],"tags":["终端"]},{"title":"Mac 安装配置neovim","url":"/2022/05/11/Mac-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEneovim/","content":"<h1 id=\"mac-安装配置neovim\">Mac 安装配置neovim</h1>\n<span id=\"more\"></span>\n<h2 id=\"安装\">1. 安装</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">brew install neovim</span><br></pre></td></tr></table></figure>\n<p>输入<code>nvim</code>就可以进入</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">nvim</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建路径\">2. 创建路径</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir ~/.config/nvim</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置\">3. 配置</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">nvim ~/.config/nvim/init.vim</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight txt\"><table><tr><td class=\"code\"><pre><span class=\"line\">1 &quot;======================</span><br><span class=\"line\">2 &quot;=== Enhance Editor ===</span><br><span class=\"line\">3 &quot;======================</span><br><span class=\"line\">4 let mapleader = &quot; &quot;</span><br><span class=\"line\">5 syntax on</span><br><span class=\"line\">6 set number</span><br><span class=\"line\">7 set norelativenumber</span><br><span class=\"line\">8 set cursorline</span><br><span class=\"line\">9 set wrap</span><br><span class=\"line\">10 set showcmd</span><br><span class=\"line\">11 set hlsearch</span><br><span class=\"line\">12 exec &quot;nohlsearch&quot;</span><br><span class=\"line\">13 set incsearch</span><br><span class=\"line\">14 set ignorecase</span><br><span class=\"line\">15 set smartcase</span><br><span class=\"line\">16 set wildmenu</span><br><span class=\"line\">17 set notimeout</span><br><span class=\"line\">18 set jumpoptions=stack</span><br><span class=\"line\">19</span><br><span class=\"line\">20 noremap &lt;LEADER&gt;&lt;CR&gt; :nohlsearch&lt;CR&gt;</span><br><span class=\"line\">21 noremap = nzz</span><br><span class=\"line\">22 noremap - Nzz</span><br><span class=\"line\">23 map S :w&lt;CR&gt;</span><br><span class=\"line\">24 map R :source $MYVIMRC&lt;CR&gt;</span><br><span class=\"line\">25 noremap U 5k</span><br><span class=\"line\">26 noremap E 5j</span><br></pre></td></tr></table></figure>\n<h3 id=\"下载插件vim-plug\">4. 下载插件<code>vim-plug</code></h3>\n<p><a href=\"https://github.com/junegunn/vim-plug\">vim-plug</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">sh -c <span class=\"string\">&#x27;curl -fLo &quot;$&#123;XDG_DATA_HOME:-$HOME/.local/share&#125;&quot;/nvim/site/autoload/plug.vim --create-dirs \\</span></span><br><span class=\"line\"><span class=\"string\">       https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>如果出现</p>\n<blockquote>\n<p>curl: (35) LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to\nraw.githubusercontent.com:443</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo vi /etc/hosts</span><br></pre></td></tr></table></figure>\n<p>然后写入</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"># GitHub Start</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">52.74</span><span class=\"number\">.223</span><span class=\"number\">.119</span> github.com</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">192.30</span><span class=\"number\">.253</span><span class=\"number\">.119</span> gist.github.com</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">54.169</span><span class=\"number\">.195</span><span class=\"number\">.247</span> api.github.com</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">185.199</span><span class=\"number\">.111</span><span class=\"number\">.153</span> assets-cdn.github.com</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">151.101</span><span class=\"number\">.76</span><span class=\"number\">.133</span> raw.githubusercontent.com</span><br><span class=\"line\"><span class=\"number\">151.101</span><span class=\"number\">.108</span><span class=\"number\">.133</span> user-images.githubusercontent.com</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">151.101</span><span class=\"number\">.76</span><span class=\"number\">.133</span> gist.githubusercontent.com</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">151.101</span><span class=\"number\">.76</span><span class=\"number\">.133</span> cloud.githubusercontent.com</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">151.101</span><span class=\"number\">.76</span><span class=\"number\">.133</span> camo.githubusercontent.com</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">151.101</span><span class=\"number\">.76</span><span class=\"number\">.133</span> avatars0.githubusercontent.com</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">151.101</span><span class=\"number\">.76</span><span class=\"number\">.133</span> avatars1.githubusercontent.com</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">151.101</span><span class=\"number\">.76</span><span class=\"number\">.133</span> avatars2.githubusercontent.com</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">151.101</span><span class=\"number\">.76</span><span class=\"number\">.133</span> avatars3.githubusercontent.com</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">151.101</span><span class=\"number\">.76</span><span class=\"number\">.133</span> avatars4.githubusercontent.com</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">151.101</span><span class=\"number\">.76</span><span class=\"number\">.133</span> avatars5.githubusercontent.com</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">151.101</span><span class=\"number\">.76</span><span class=\"number\">.133</span> avatars6.githubusercontent.com</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">151.101</span><span class=\"number\">.76</span><span class=\"number\">.133</span> avatars7.githubusercontent.com</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">151.101</span><span class=\"number\">.76</span><span class=\"number\">.133</span> avatars8.githubusercontent.com</span><br><span class=\"line\"></span><br><span class=\"line\"># GitHub End</span><br></pre></td></tr></table></figure>\n<p>如果还不可以，我们直接下载<code>.zip</code>文件，然后把<code>plug.vim</code>放到</p>\n<blockquote>\n<p>.config/nvim/autoload/</p>\n</blockquote>\n<p>这样就解决了。</p>\n<h2 id=\"安装插件\">5. 安装插件</h2>\n<h3 id=\"安装coc.nvim\">5.1 安装<code>coc.nvim</code></h3>\n<p><a\nhref=\"https://github.com/neoclide/coc.nvim\">coc.nvim</a>文档写得很好，我们可以去看下，这里我简单说下我的配置。</p>\n<h4 id=\"安装nodejs依赖\">5.1.1 安装<code>nodejs</code>依赖</h4>\n<p><code>coc.nvim</code>是基于<code>nodejs</code>的，我们可以调用</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">curl -sL install-node.vercel.app/lts | bash</span><br></pre></td></tr></table></figure>\n<p>来安装，如果你是<code>mac</code>，使用</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">brew install nodejs</span><br></pre></td></tr></table></figure>\n<h4 id=\"在vim-plug中安装插件\">5.1.2\n在<code>vim-plug</code>中安装插件</h4>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot; Use release branch (recommend)</span></span><br><span class=\"line\"><span class=\"string\">Plug &#x27;neoclide/coc.nvim&#x27;, &#123;&#x27;branch&#x27;: &#x27;release&#x27;&#125;</span></span><br></pre></td></tr></table></figure>\n<p>调用<code>:PlugInstall</code>安装插件</p>\n<p>安装一些<code>coc</code>扩展</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">:CocInstall coc-json coc-tsserver</span><br></pre></td></tr></table></figure>\n<p>配置文件</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"安装代码高亮插件vim-lsp-cxx-highlight\">5.2\n安装代码高亮插件<code>vim-lsp-cxx-highlight</code></h4>\n<p>配置</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot; ==== jackguo380/vim-lsp-cxx-highlight ====</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">hi default link LspCxxHlSymFunction cxxFunction</span></span><br><span class=\"line\"><span class=\"string\">hi default link LspCxxHlSymFunctionParameter cxxParameter</span></span><br><span class=\"line\"><span class=\"string\">hi default link LspCxxHlSymFileVariableStatic cxxFileVariableStatic</span></span><br><span class=\"line\"><span class=\"string\">hi default link LspCxxHlSymStruct cxxStruct</span></span><br><span class=\"line\"><span class=\"string\">hi default link LspCxxHlSymStructField cxxStructField</span></span><br><span class=\"line\"><span class=\"string\">hi default link LspCxxHlSymFileTypeAlias cxxTypeAlias</span></span><br><span class=\"line\"><span class=\"string\">hi default link LspCxxHlSymClassField cxxStructField</span></span><br><span class=\"line\"><span class=\"string\">hi default link LspCxxHlSymEnum cxxEnum</span></span><br><span class=\"line\"><span class=\"string\">hi default link LspCxxHlSymVariableExtern cxxFileVariableStatic</span></span><br><span class=\"line\"><span class=\"string\">hi default link LspCxxHlSymVariable cxxVariable</span></span><br><span class=\"line\"><span class=\"string\">hi default link LspCxxHlSymMacro cxxMacro</span></span><br><span class=\"line\"><span class=\"string\">hi default link LspCxxHlSymEnumMember cxxEnumMember</span></span><br><span class=\"line\"><span class=\"string\">hi default link LspCxxHlSymParameter cxxParameter</span></span><br><span class=\"line\"><span class=\"string\">hi default link LspCxxHlSymClass cxxTypeAlias</span></span><br></pre></td></tr></table></figure>\n<p>并在<code>ccls</code>中配置。</p>\n<p><code>coc.vim</code>的补全有三种<code>lsp</code>：<code>clangd</code>,<code>ccls</code>,\n<code>cquery</code>。这里说明如何使用<code>ccls</code>补全。</p>\n<h4 id=\"ccls的配置\">5.3 ccls的配置</h4>\n<p>ccls是lsp(language server\nProtocal)（语言补全协议）中的一个，用于补全C/C++</p>\n<h5 id=\"下载ccls\">下载ccls</h5>\n<p>ccls的GitHub地址在<a\nhref=\"https://github.com/MaskRay/ccls\">这里</a>,你可以从源码下载并编译。</p>\n<h5 id=\"macosx\">MacOSX</h5>\n<p>Mac下使用brew可快速安装:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">brew install ccls</span><br></pre></td></tr></table></figure>\n<h5 id=\"配置ccls为补全插件\">配置ccls为补全插件</h5>\n<p>ccls官方提供了很多方法，这里我说明如何使在coc.nvim中进行补全。\n打开VIM，输入<code>:CocConfig</code>后回车可打开coc的配置文件，然后输入:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;languageserver&quot;</span>: &#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;ccls&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;command&quot;</span>: <span class=\"string\">&quot;ccls&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;filetypes&quot;</span>: [<span class=\"string\">&quot;c&quot;</span>, <span class=\"string\">&quot;cc&quot;</span>, <span class=\"string\">&quot;cpp&quot;</span>, <span class=\"string\">&quot;c++&quot;</span>, <span class=\"string\">&quot;objc&quot;</span>, <span class=\"string\">&quot;objcpp&quot;</span>],</span><br><span class=\"line\">    <span class=\"string\">&quot;rootPatterns&quot;</span>: [<span class=\"string\">&quot;.ccls&quot;</span>, <span class=\"string\">&quot;compile_commands.json&quot;</span>, <span class=\"string\">&quot;.git/&quot;</span>, <span class=\"string\">&quot;.hg/&quot;</span>],</span><br><span class=\"line\">    <span class=\"string\">&quot;initializationOptions&quot;</span>: &#123;</span><br><span class=\"line\">      \t<span class=\"string\">&quot;highlight&quot;</span>: &#123;<span class=\"string\">&quot;lsRanges&quot;</span>: <span class=\"literal\">true</span>&#125;,</span><br><span class=\"line\">        <span class=\"string\">&quot;cache&quot;</span>: &#123;</span><br><span class=\"line\">          <span class=\"string\">&quot;directory&quot;</span>: <span class=\"string\">&quot;/tmp/ccls&quot;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"安装debug插件vimspector\">5.4\n安装<code>debug</code>插件<code>vimspector</code></h4>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot; debug</span></span><br><span class=\"line\"><span class=\"string\"> Plug &#x27;puremourning/vimspector&#x27;, &#123;&#x27;do&#x27;: &#x27;./install_gadget.py --enable-rust --enable-python&#x27;&#125;</span></span><br></pre></td></tr></table></figure>\n<p>这个需要我们安装<code>python3</code>依赖。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">brew install python3</span><br></pre></td></tr></table></figure>\n<p>然后在</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim ~/.bash_profile</span><br></pre></td></tr></table></figure>\n<p>中添加</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">alias python=<span class=\"string\">&quot;/usr/bin/python3&quot;</span></span><br></pre></td></tr></table></figure>\n<p>保存文件<code>:wq</code>，然后执行</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">source ~/.bash_profile</span><br></pre></td></tr></table></figure>\n<p>最后输入<code>python</code></p>\n<p>就可以看到安装成功了。</p>\n<p>最后需要我们安装</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">pip3 install neovim</span><br></pre></td></tr></table></figure>\n","categories":["nvim"],"tags":["nvim"]},{"title":"MySQL必知必会","url":"/2022/04/27/MySQL/","content":"<h1 id=\"了解sql\">1. 了解SQL</h1>\n<h2 id=\"数据库基础\">1.1 数据库基础</h2>\n<h3 id=\"什么是数据库\">1.1.1 什么是数据库</h3>\n<p><strong>数据库</strong>保存有组织的数据的容量。</p>\n<h3 id=\"表\">1.1.2 表</h3>\n<p><strong>表</strong>：某种特定类型的结构化清单。</p>\n<blockquote>\n<p>表是一种结构化的文件，可用\n来存储某种特定类型的数据。表可以保存顾客清单、产品目录，或者其\n他信息清单。</p>\n</blockquote>\n<p>存储在表中的数据是一种类型的数据或一个 清单。</p>\n<p>数据库中的每个表都有一个名字，用来标识自己。此名字是唯一的，\n这表示数据库中没有其他表具有相同的名字。</p>\n<p><strong>模式</strong>（schema）\n关于数据库和表的布局及特性的信息。</p>\n<blockquote>\n<p>描述表 的这组信息就是所谓的模式，模式可以用来描述数据库中特定的表以及\n整个数据库（和其中表的关系）。</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"列和数据类型\">1.1.3 列和数据类型</h3>\n<p>表由列组成。列中存储着表中某部分的信息。</p>\n<p><strong>列（column）</strong>:\n表中的一个字段。所有表都是由一个或多个列组成的。</p>\n<blockquote>\n<p>数据库中每个列都有相应的<strong>数据类型</strong>。数据类型定义列可以存储的数据种类。</p>\n</blockquote>\n<p><strong>数据类型</strong>（datatype）\n所容许的数据的类型。每个表列都有相应的数据类型，它限制（或容许）该列中存储的数据。</p>\n<h3 id=\"行\">1.1.4 行</h3>\n<p>表中的数据是按行存储的，所保存的每个记录存储在自己的行内。</p>\n<h3 id=\"主键\">1.1.5 主键</h3>\n<p>表中每一行都应该有可以唯一标识自己的一列（或一组列）。一个顾客表可以使用顾客编号列，而订单表可以使用订单ID，雇员表可以使用\n雇员ID或雇员社会保险号。</p>\n<p><strong>主键</strong>（primary\nkey）一列（或一组列），其值能够唯一区分表中每个行。</p>\n<p>主键用来表示\n一个特定的行。没有主键，更新或删除表中特定行很困难，因为没有安全的方法保证只涉及相关的行。</p>\n<p><strong>表中的任何列都可以作为主键，只要它满足以下条件：</strong></p>\n<ul>\n<li>任意两行都不具有相同的主键值；</li>\n<li>每个行都必须具有一个主键值（主键列不允许NULL值）。</li>\n</ul>\n<h2 id=\"什么是sql\">1.2 什么是SQL</h2>\n<p><code>SQL</code>是结构化查询语言的缩写。<code>SQL</code>是一种专门用来与数据库通信的语言。</p>\n<h1 id=\"mysql简介\">2 MySQL简介</h1>\n<h2 id=\"什么是mysql\">2.1 什么是MySQL</h2>\n<p><code>MySQL</code>是一种<code>DBMS</code>，即它是一种数据库软件</p>\n","categories":["MySQL"],"tags":["MySQL"]},{"title":"NumPy入门","url":"/2022/01/20/NumPy/","content":"<h1 id=\"什么是numpy\">什么是NumPy?</h1>\n<p>NumPy是python中科学计算的基础包。提供多维数组对象，各种派生对象（如掩码数组和矩阵），以及用于数组快速操作的各种API，有包括数学、逻辑、形状操作、排序、选择、输入输出、离散傅立叶变换、基本线性代数，基本统计运算和随机模拟等等。</p>\n<p>NumPy数组 和 原生Python Array（数组）之间有几个重要的区别：</p>\n<ul>\n<li>NumPy\n数组在创建时具有固定的大小，与Python的原生数组对象（可以动态增长）不同。更改ndarray的大小将创建一个新数组并删除原来的数组。</li>\n<li>NumPy 数组中的元素都需要具有相同的数据类型，因此在内存中的大小相同。\n例外情况：Python的原生数组里包含了NumPy的对象的时候，这种情况下就允许不同大小元素的数组。</li>\n<li>NumPy\n数组有助于对大量数据进行高级数学和其他类型的操作。通常，这些操作的执行效率更高，比使用Python原生数组的代码更少。</li>\n<li>越来越多的基于Python的科学和数学软件包使用NumPy数组;\n虽然这些工具通常都支持Python的原生数组作为参数，但它们在处理之前会还是会将输入的数组转换为NumPy的数组，而且也通常输出为NumPy数组。换句话说，为了高效地使用当今科学/数学基于Python的工具（大部分的科学计算工具），你只知道如何使用Python的原生数组类型是不够的\n- 还需要知道如何使用 NumPy 数组。</li>\n</ul>\n<span id=\"more\"></span>\n<h1 id=\"快速入门教程\">快速入门教程</h1>\n<p><a\nhref=\"https://numpy.org/doc/stable/user/whatisnumpy.html\">NumPy官网</a></p>\n<p><a\nhref=\"https://www.numpy.org.cn/user/quickstart.html\">NumPy中文网站</a></p>\n<blockquote>\n<p># 导入包</p>\n<p>import numpy as np</p>\n</blockquote>\n<p>##1.基础知识</p>\n<p>NumPy的数组类被调用为<code>ndarray</code>：一个同质多维数组（同质指所有元素类型相同）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\">a = np.arange(<span class=\"number\">15</span>).reshape(<span class=\"number\">3</span>,<span class=\"number\">5</span>)  <span class=\"comment\">#生成一个3*5的矩阵</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>ndarray.ndim</strong>数组的轴（维度）的个数</li>\n<li><strong>ndarray.shape</strong>数组的维度</li>\n<li><strong>ndarray.size</strong>数组元素的总数</li>\n<li><strong>ndarray.dtype</strong>一个描述数组中元素类型的对象</li>\n<li><strong>ndarray.itemsize</strong>数组中每个元素的字节大小</li>\n<li><strong>ndarray.data</strong>该缓冲区包含数组的实际元素。通常，我们不需要使用此元素，因为我们将使用索引访问数组中的元素。</li>\n</ul>\n<h3 id=\"数组创建\">1.1 数组创建</h3>\n<h4\nid=\"方法一通过python的list或tuple创建ndarray\">方法一：通过Python的list或tuple创建ndarray</h4>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#具体做法就是传入一个list或tuple作为参数</span></span><br><span class=\"line\">a = np.array([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>])</span><br><span class=\"line\"><span class=\"comment\">#一种典型的错误情况：a = np.array(1,2,3,4)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#如果传入又多个参数</span></span><br><span class=\"line\">b = np.array([(<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>),(<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>)])</span><br></pre></td></tr></table></figure>\n<h4\nid=\"方法二用占位符创建已知尺寸的数组\">方法二：用占位符创建已知尺寸的数组</h4>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">d = np.zeros((<span class=\"number\">3</span>,<span class=\"number\">4</span>))</span><br><span class=\"line\">e = np.ones((<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>),dtype=np.int16)</span><br><span class=\"line\">f = np.empty((<span class=\"number\">2</span>,<span class=\"number\">3</span>))\t<span class=\"comment\">#其初始内容是随机的，取决于内存的状态，默认情况下dtype是float64类型</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#arrange类似于python内置的range</span></span><br><span class=\"line\">g = np.arange(<span class=\"number\">10</span>,<span class=\"number\">30</span>,<span class=\"number\">5</span>)</span><br><span class=\"line\">h = np.arange(<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">0.3</span>)\t<span class=\"comment\">#可以使用浮点数,步长为0.3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#arrange函数由于浮点数精度的原因，可能无法知道数组最后有多少个数</span></span><br><span class=\"line\"><span class=\"comment\">#为了解决这一问题可以使用linspace函数</span></span><br><span class=\"line\">i = np.linspace(<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">9</span>)\t<span class=\"comment\">#9个数组从0到2</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"打印数组\">1.2 打印数组</h3>\n<p>如果数组太大而无法打印，NumPy会自动跳过数组的中心部分并打印角点，要禁用此行为并强制NumPy打印整个数组，可以使用打印选项<code>set_printoptions</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">np.set_printoptions(threshold=sys.maxsize)</span><br></pre></td></tr></table></figure>\n<h3 id=\"基本数学操作\">1.3 基本数学操作</h3>\n<p>加减这里就不需要演示了，乘积运算符<code>*</code>在NumPy数组中按元素进行运算。矩阵乘积可以使用<code>@</code>运算符或<code>dot</code>函数或方法执行:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">A = np.array([[<span class=\"number\">1</span>,<span class=\"number\">1</span>],[<span class=\"number\">0</span>,<span class=\"number\">1</span>]])</span><br><span class=\"line\">B = np.array([[<span class=\"number\">2</span>,<span class=\"number\">0</span>],[<span class=\"number\">3</span>,<span class=\"number\">4</span>]])</span><br><span class=\"line\">A*B</span><br><span class=\"line\"><span class=\"comment\">#结果为</span></span><br><span class=\"line\">array([[<span class=\"number\">2</span>,<span class=\"number\">0</span>],[<span class=\"number\">0</span>,<span class=\"number\">4</span>]])</span><br><span class=\"line\">A@B</span><br><span class=\"line\"><span class=\"comment\">#结果为</span></span><br><span class=\"line\">array([[<span class=\"number\">5</span>,<span class=\"number\">4</span>],[<span class=\"number\">3</span>,<span class=\"number\">4</span>]])</span><br><span class=\"line\">A.dot(B)</span><br><span class=\"line\">array([[<span class=\"number\">5</span>,<span class=\"number\">4</span>],[<span class=\"number\">3</span>,<span class=\"number\">4</span>]])</span><br></pre></td></tr></table></figure>\n<p><code>+=</code>,<code>*=</code>等运算符进行原地运算（需要加同类型的，如果不强制转换就会报错）</p>\n<p>默认情况下，这些操作适用于数组，就像它是一个数字列表一样，无论其形状如何。但是，通过指定<code>axis</code>\n参数，您可以沿数组的指定轴应用操作：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b = np.arange(<span class=\"number\">12</span>).reshape(<span class=\"number\">3</span>,<span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b</span><br><span class=\"line\">array([[ <span class=\"number\">0</span>,  <span class=\"number\">1</span>,  <span class=\"number\">2</span>,  <span class=\"number\">3</span>],</span><br><span class=\"line\">       [ <span class=\"number\">4</span>,  <span class=\"number\">5</span>,  <span class=\"number\">6</span>,  <span class=\"number\">7</span>],</span><br><span class=\"line\">       [ <span class=\"number\">8</span>,  <span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>]])</span><br><span class=\"line\">&gt;&gt;&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b.<span class=\"built_in\">sum</span>(axis=<span class=\"number\">0</span>)                            <span class=\"comment\"># sum of each column</span></span><br><span class=\"line\">array([<span class=\"number\">12</span>, <span class=\"number\">15</span>, <span class=\"number\">18</span>, <span class=\"number\">21</span>])</span><br><span class=\"line\">&gt;&gt;&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b.<span class=\"built_in\">min</span>(axis=<span class=\"number\">1</span>)                            <span class=\"comment\"># min of each row</span></span><br><span class=\"line\">array([<span class=\"number\">0</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>])</span><br><span class=\"line\">&gt;&gt;&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b.cumsum(axis=<span class=\"number\">1</span>)                         <span class=\"comment\"># cumulative sum along each row</span></span><br><span class=\"line\">array([[ <span class=\"number\">0</span>,  <span class=\"number\">1</span>,  <span class=\"number\">3</span>,  <span class=\"number\">6</span>],</span><br><span class=\"line\">       [ <span class=\"number\">4</span>,  <span class=\"number\">9</span>, <span class=\"number\">15</span>, <span class=\"number\">22</span>],</span><br><span class=\"line\">       [ <span class=\"number\">8</span>, <span class=\"number\">17</span>, <span class=\"number\">27</span>, <span class=\"number\">38</span>]])</span><br></pre></td></tr></table></figure>\n<h3 id=\"索引切片和迭代\">1.4 索引，切片和迭代</h3>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a = np.arange(<span class=\"number\">10</span>)**<span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a</span><br><span class=\"line\">array([  <span class=\"number\">0</span>,   <span class=\"number\">1</span>,   <span class=\"number\">8</span>,  <span class=\"number\">27</span>,  <span class=\"number\">64</span>, <span class=\"number\">125</span>, <span class=\"number\">216</span>, <span class=\"number\">343</span>, <span class=\"number\">512</span>, <span class=\"number\">729</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a[<span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a[<span class=\"number\">2</span>:<span class=\"number\">5</span>]</span><br><span class=\"line\">array([ <span class=\"number\">8</span>, <span class=\"number\">27</span>, <span class=\"number\">64</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a[:<span class=\"number\">6</span>:<span class=\"number\">2</span>] = -<span class=\"number\">1000</span>    <span class=\"comment\"># equivalent to a[0:6:2] = -1000; from start to position 6, exclusive, set every 2nd element to -1000</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a</span><br><span class=\"line\">array([-<span class=\"number\">1000</span>,     <span class=\"number\">1</span>, -<span class=\"number\">1000</span>,    <span class=\"number\">27</span>, -<span class=\"number\">1000</span>,   <span class=\"number\">125</span>,   <span class=\"number\">216</span>,   <span class=\"number\">343</span>,   <span class=\"number\">512</span>,   <span class=\"number\">729</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a[ : :-<span class=\"number\">1</span>]                                 <span class=\"comment\"># reversed a</span></span><br><span class=\"line\">array([  <span class=\"number\">729</span>,   <span class=\"number\">512</span>,   <span class=\"number\">343</span>,   <span class=\"number\">216</span>,   <span class=\"number\">125</span>, -<span class=\"number\">1000</span>,    <span class=\"number\">27</span>, -<span class=\"number\">1000</span>,     <span class=\"number\">1</span>, -<span class=\"number\">1000</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> a:</span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"built_in\">print</span>(i**(<span class=\"number\">1</span>/<span class=\"number\">3.</span>))</span><br><span class=\"line\">...</span><br><span class=\"line\">nan</span><br><span class=\"line\"><span class=\"number\">1.0</span></span><br><span class=\"line\">nan</span><br><span class=\"line\"><span class=\"number\">3.0</span></span><br><span class=\"line\">nan</span><br><span class=\"line\"><span class=\"number\">5.0</span></span><br><span class=\"line\"><span class=\"number\">6.0</span></span><br><span class=\"line\"><span class=\"number\">7.0</span></span><br><span class=\"line\"><span class=\"number\">8.0</span></span><br><span class=\"line\"><span class=\"number\">9.0</span></span><br></pre></td></tr></table></figure>\n<p>三个点（<code>...</code>）表示产生完整索引元组所需的冒号。例如x是rank为5的数组，则：</p>\n<ul>\n<li><code>x[1,2,...]</code>相当于<code>x[1,2,:,:,:]</code></li>\n<li><code>x[...,3]</code>等效于<code>x[:,:,:,:,3]</code></li>\n<li><code>x[4,...,5,:]</code>等效于<code>x[4,:,:,5,:]</code></li>\n</ul>\n<p>对多维数组进行迭代（Iterating）是相对于第一个轴完成的：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> row <span class=\"keyword\">in</span> b:</span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"built_in\">print</span>(row)</span><br><span class=\"line\">...</span><br><span class=\"line\">[<span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span>]</span><br><span class=\"line\">[<span class=\"number\">10</span> <span class=\"number\">11</span> <span class=\"number\">12</span> <span class=\"number\">13</span>]</span><br><span class=\"line\">[<span class=\"number\">20</span> <span class=\"number\">21</span> <span class=\"number\">22</span> <span class=\"number\">23</span>]</span><br><span class=\"line\">[<span class=\"number\">30</span> <span class=\"number\">31</span> <span class=\"number\">32</span> <span class=\"number\">33</span>]</span><br><span class=\"line\">[<span class=\"number\">40</span> <span class=\"number\">41</span> <span class=\"number\">42</span> <span class=\"number\">43</span>]</span><br></pre></td></tr></table></figure>\n<p>但是，如果想要对数组中的每个元素执行操作，可以使用<code>flat</code>属性，该属性是数组的所有元素的<a\nhref=\"https://docs.python.org/tutorial/classes.html#iterators\">迭代器</a>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> element <span class=\"keyword\">in</span> b.flat:</span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"built_in\">print</span>(element)</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">11</span></span><br><span class=\"line\"><span class=\"number\">12</span></span><br><span class=\"line\"><span class=\"number\">13</span></span><br><span class=\"line\"><span class=\"number\">20</span></span><br><span class=\"line\"><span class=\"number\">21</span></span><br><span class=\"line\"><span class=\"number\">22</span></span><br><span class=\"line\"><span class=\"number\">23</span></span><br><span class=\"line\"><span class=\"number\">30</span></span><br><span class=\"line\"><span class=\"number\">31</span></span><br><span class=\"line\"><span class=\"number\">32</span></span><br><span class=\"line\"><span class=\"number\">33</span></span><br><span class=\"line\"><span class=\"number\">40</span></span><br><span class=\"line\"><span class=\"number\">41</span></span><br><span class=\"line\"><span class=\"number\">42</span></span><br><span class=\"line\"><span class=\"number\">43</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"形状操纵\">2. 形状操纵</h2>\n<p>###2.1 改变数组的形状</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a.ravel()  <span class=\"comment\"># returns the array, flattened</span></span><br><span class=\"line\">array([ <span class=\"number\">2.</span>,  <span class=\"number\">8.</span>,  <span class=\"number\">0.</span>,  <span class=\"number\">6.</span>,  <span class=\"number\">4.</span>,  <span class=\"number\">5.</span>,  <span class=\"number\">1.</span>,  <span class=\"number\">1.</span>,  <span class=\"number\">8.</span>,  <span class=\"number\">9.</span>,  <span class=\"number\">3.</span>,  <span class=\"number\">6.</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a.reshape(<span class=\"number\">6</span>,<span class=\"number\">2</span>)  <span class=\"comment\"># returns the array with a modified shape</span></span><br><span class=\"line\">array([[ <span class=\"number\">2.</span>,  <span class=\"number\">8.</span>],</span><br><span class=\"line\">       [ <span class=\"number\">0.</span>,  <span class=\"number\">6.</span>],</span><br><span class=\"line\">       [ <span class=\"number\">4.</span>,  <span class=\"number\">5.</span>],</span><br><span class=\"line\">       [ <span class=\"number\">1.</span>,  <span class=\"number\">1.</span>],</span><br><span class=\"line\">       [ <span class=\"number\">8.</span>,  <span class=\"number\">9.</span>],</span><br><span class=\"line\">       [ <span class=\"number\">3.</span>,  <span class=\"number\">6.</span>]])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a.T  <span class=\"comment\"># returns the array, transposed</span></span><br><span class=\"line\">array([[ <span class=\"number\">2.</span>,  <span class=\"number\">4.</span>,  <span class=\"number\">8.</span>],</span><br><span class=\"line\">       [ <span class=\"number\">8.</span>,  <span class=\"number\">5.</span>,  <span class=\"number\">9.</span>],</span><br><span class=\"line\">       [ <span class=\"number\">0.</span>,  <span class=\"number\">1.</span>,  <span class=\"number\">3.</span>],</span><br><span class=\"line\">       [ <span class=\"number\">6.</span>,  <span class=\"number\">1.</span>,  <span class=\"number\">6.</span>]])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a.T.shape</span><br><span class=\"line\">(<span class=\"number\">4</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a.shape</span><br><span class=\"line\">(<span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br></pre></td></tr></table></figure>\n<p><code>reshape</code>函数返回带有修改形状的参数，而该<code>ndarray.resize</code>方法会修改数组本身：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a</span><br><span class=\"line\">array([[ <span class=\"number\">2.</span>,  <span class=\"number\">8.</span>,  <span class=\"number\">0.</span>,  <span class=\"number\">6.</span>],</span><br><span class=\"line\">       [ <span class=\"number\">4.</span>,  <span class=\"number\">5.</span>,  <span class=\"number\">1.</span>,  <span class=\"number\">1.</span>],</span><br><span class=\"line\">       [ <span class=\"number\">8.</span>,  <span class=\"number\">9.</span>,  <span class=\"number\">3.</span>,  <span class=\"number\">6.</span>]])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a.resize((<span class=\"number\">2</span>,<span class=\"number\">6</span>))</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a</span><br><span class=\"line\">array([[ <span class=\"number\">2.</span>,  <span class=\"number\">8.</span>,  <span class=\"number\">0.</span>,  <span class=\"number\">6.</span>,  <span class=\"number\">4.</span>,  <span class=\"number\">5.</span>],</span><br><span class=\"line\">       [ <span class=\"number\">1.</span>,  <span class=\"number\">1.</span>,  <span class=\"number\">8.</span>,  <span class=\"number\">9.</span>,  <span class=\"number\">3.</span>,  <span class=\"number\">6.</span>]])</span><br></pre></td></tr></table></figure>\n<p>如果在 reshape 操作中将 size 指定为-1，则会自动计算其他的 size\n大小：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a.reshape(<span class=\"number\">3</span>,-<span class=\"number\">1</span>)</span><br><span class=\"line\">array([[ <span class=\"number\">2.</span>,  <span class=\"number\">8.</span>,  <span class=\"number\">0.</span>,  <span class=\"number\">6.</span>],</span><br><span class=\"line\">       [ <span class=\"number\">4.</span>,  <span class=\"number\">5.</span>,  <span class=\"number\">1.</span>,  <span class=\"number\">1.</span>],</span><br><span class=\"line\">       [ <span class=\"number\">8.</span>,  <span class=\"number\">9.</span>,  <span class=\"number\">3.</span>,  <span class=\"number\">6.</span>]])</span><br></pre></td></tr></table></figure>\n<h3 id=\"将不同数组推叠在一起\">2.2 将不同数组推叠在一起</h3>\n<p>几个数组可以沿不同的轴堆叠在一起，例如：</p>\n<p><code>np.vstack</code>相当于列拼接，<code>np.hstack</code>相当于行拼接</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a = np.floor(<span class=\"number\">10</span>*np.random.random((<span class=\"number\">2</span>,<span class=\"number\">2</span>)))</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a</span><br><span class=\"line\">array([[ <span class=\"number\">8.</span>,  <span class=\"number\">8.</span>],</span><br><span class=\"line\">       [ <span class=\"number\">0.</span>,  <span class=\"number\">0.</span>]])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b = np.floor(<span class=\"number\">10</span>*np.random.random((<span class=\"number\">2</span>,<span class=\"number\">2</span>)))</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b</span><br><span class=\"line\">array([[ <span class=\"number\">1.</span>,  <span class=\"number\">8.</span>],</span><br><span class=\"line\">       [ <span class=\"number\">0.</span>,  <span class=\"number\">4.</span>]])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>np.vstack((a,b))</span><br><span class=\"line\">array([[ <span class=\"number\">8.</span>,  <span class=\"number\">8.</span>],</span><br><span class=\"line\">       [ <span class=\"number\">0.</span>,  <span class=\"number\">0.</span>],</span><br><span class=\"line\">       [ <span class=\"number\">1.</span>,  <span class=\"number\">8.</span>],</span><br><span class=\"line\">       [ <span class=\"number\">0.</span>,  <span class=\"number\">4.</span>]])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>np.hstack((a,b))</span><br><span class=\"line\">array([[ <span class=\"number\">8.</span>,  <span class=\"number\">8.</span>,  <span class=\"number\">1.</span>,  <span class=\"number\">8.</span>],</span><br><span class=\"line\">       [ <span class=\"number\">0.</span>,  <span class=\"number\">0.</span>,  <span class=\"number\">0.</span>,  <span class=\"number\">4.</span>]])</span><br></pre></td></tr></table></figure>\n<h3 id=\"将一个数组拆分成几个较小的数组\">2.3\n将一个数组拆分成几个较小的数组</h3>\n<p>使用<code>hsplit</code>，可以沿数组的水平轴拆分数组，方法是指定要返回的形状相等的数组的数量，或者指定应该在其之后进行分割的列：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a = np.floor(<span class=\"number\">10</span>*np.random.random((<span class=\"number\">2</span>,<span class=\"number\">12</span>)))</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a</span><br><span class=\"line\">array([[ <span class=\"number\">9.</span>,  <span class=\"number\">5.</span>,  <span class=\"number\">6.</span>,  <span class=\"number\">3.</span>,  <span class=\"number\">6.</span>,  <span class=\"number\">8.</span>,  <span class=\"number\">0.</span>,  <span class=\"number\">7.</span>,  <span class=\"number\">9.</span>,  <span class=\"number\">7.</span>,  <span class=\"number\">2.</span>,  <span class=\"number\">7.</span>],</span><br><span class=\"line\">       [ <span class=\"number\">1.</span>,  <span class=\"number\">4.</span>,  <span class=\"number\">9.</span>,  <span class=\"number\">2.</span>,  <span class=\"number\">2.</span>,  <span class=\"number\">1.</span>,  <span class=\"number\">0.</span>,  <span class=\"number\">6.</span>,  <span class=\"number\">2.</span>,  <span class=\"number\">2.</span>,  <span class=\"number\">4.</span>,  <span class=\"number\">0.</span>]])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>np.hsplit(a,<span class=\"number\">3</span>)   <span class=\"comment\"># Split a into 3</span></span><br><span class=\"line\">[array([[ <span class=\"number\">9.</span>,  <span class=\"number\">5.</span>,  <span class=\"number\">6.</span>,  <span class=\"number\">3.</span>],</span><br><span class=\"line\">       [ <span class=\"number\">1.</span>,  <span class=\"number\">4.</span>,  <span class=\"number\">9.</span>,  <span class=\"number\">2.</span>]]), array([[ <span class=\"number\">6.</span>,  <span class=\"number\">8.</span>,  <span class=\"number\">0.</span>,  <span class=\"number\">7.</span>],</span><br><span class=\"line\">       [ <span class=\"number\">2.</span>,  <span class=\"number\">1.</span>,  <span class=\"number\">0.</span>,  <span class=\"number\">6.</span>]]), array([[ <span class=\"number\">9.</span>,  <span class=\"number\">7.</span>,  <span class=\"number\">2.</span>,  <span class=\"number\">7.</span>],</span><br><span class=\"line\">       [ <span class=\"number\">2.</span>,  <span class=\"number\">2.</span>,  <span class=\"number\">4.</span>,  <span class=\"number\">0.</span>]])]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>np.hsplit(a,(<span class=\"number\">3</span>,<span class=\"number\">4</span>))   <span class=\"comment\"># Split a after the third and the fourth column</span></span><br><span class=\"line\">[array([[ <span class=\"number\">9.</span>,  <span class=\"number\">5.</span>,  <span class=\"number\">6.</span>],</span><br><span class=\"line\">       [ <span class=\"number\">1.</span>,  <span class=\"number\">4.</span>,  <span class=\"number\">9.</span>]]), array([[ <span class=\"number\">3.</span>],</span><br><span class=\"line\">       [ <span class=\"number\">2.</span>]]), array([[ <span class=\"number\">6.</span>,  <span class=\"number\">8.</span>,  <span class=\"number\">0.</span>,  <span class=\"number\">7.</span>,  <span class=\"number\">9.</span>,  <span class=\"number\">7.</span>,  <span class=\"number\">2.</span>,  <span class=\"number\">7.</span>],</span><br><span class=\"line\">       [ <span class=\"number\">2.</span>,  <span class=\"number\">1.</span>,  <span class=\"number\">0.</span>,  <span class=\"number\">6.</span>,  <span class=\"number\">2.</span>,  <span class=\"number\">2.</span>,  <span class=\"number\">4.</span>,  <span class=\"number\">0.</span>]])]</span><br></pre></td></tr></table></figure>\n<p><code>vsplit</code>沿垂直轴分割，并<code>array_split</code>允许指定要分割的轴。</p>\n<h2 id=\"拷贝和视图\">3. 拷贝和视图</h2>\n<h3 id=\"完全不复制\">3.1 完全不复制</h3>\n<p>简单分配不会复制数组对象或其数据。</p>\n<p><code>b=a</code></p>\n<h3 id=\"视图或浅拷贝\">3.2 视图或浅拷贝</h3>\n<p>不同的数组对象可以共享相同的数据。该<code>view</code>方法创建一个查看相同数据的新数组对象。</p>\n<p>改变其数值，原来的数组数值也会发生改变。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>c = a.view()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>c <span class=\"keyword\">is</span> a</span><br><span class=\"line\"><span class=\"literal\">False</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>c.base <span class=\"keyword\">is</span> a                        <span class=\"comment\"># c is a view of the data owned by a</span></span><br><span class=\"line\"><span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>c.flags.owndata</span><br><span class=\"line\"><span class=\"literal\">False</span></span><br><span class=\"line\">&gt;&gt;&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>c.shape = <span class=\"number\">2</span>,<span class=\"number\">6</span>                      <span class=\"comment\"># a&#x27;s shape doesn&#x27;t change</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a.shape</span><br><span class=\"line\">(<span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>c[<span class=\"number\">0</span>,<span class=\"number\">4</span>] = <span class=\"number\">1234</span>                      <span class=\"comment\"># a&#x27;s data changes</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a</span><br><span class=\"line\">array([[   <span class=\"number\">0</span>,    <span class=\"number\">1</span>,    <span class=\"number\">2</span>,    <span class=\"number\">3</span>],</span><br><span class=\"line\">       [<span class=\"number\">1234</span>,    <span class=\"number\">5</span>,    <span class=\"number\">6</span>,    <span class=\"number\">7</span>],</span><br><span class=\"line\">       [   <span class=\"number\">8</span>,    <span class=\"number\">9</span>,   <span class=\"number\">10</span>,   <span class=\"number\">11</span>]])</span><br></pre></td></tr></table></figure>\n<p>切片数组会返回一个视图</p>\n<h3 id=\"深拷贝\">3.3 深拷贝</h3>\n<p>该<code>copy</code>方法生成数组及其数据的完整副本。</p>\n<h2 id=\"less基础\">4. Less基础</h2>\n<h3 id=\"广播broadcasting规则\">广播（Broadcasting）规则</h3>\n<p>广播允许通用功能以有意义的方式处理不具有完全相同形状的输入。</p>\n<p>广播的第一个规则是，如果所有输入数组不具有相同数量的维度，则将“1”重复地预先添加到较小数组的形状，直到所有数组具有相同数量的维度。</p>\n<p>广播的第二个规则确保沿特定维度的大小为1的数组表现为具有沿该维度具有最大形状的数组的大小。假定数组元素的值沿着“广播”数组的那个维度是相同的。</p>\n<p>应用广播规则后，所有数组的大小必须匹配。更多细节可以在<a\nhref=\"https://www.numpy.org.cn/user/basics/broadcasting.html\">广播中</a>找到。</p>\n<h2 id=\"花式索引和索引技巧\">5. 花式索引和索引技巧</h2>\n<h3 id=\"使用索引数组进行索引\">使用索引数组进行索引</h3>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a = np.arange(<span class=\"number\">12</span>)**<span class=\"number\">2</span>                       <span class=\"comment\"># the first 12 square numbers</span></span><br><span class=\"line\">array([  <span class=\"number\">0</span>,   <span class=\"number\">1</span>,   <span class=\"number\">4</span>,   <span class=\"number\">9</span>,  <span class=\"number\">16</span>,  <span class=\"number\">25</span>,  <span class=\"number\">36</span>,  <span class=\"number\">49</span>,  <span class=\"number\">64</span>,  <span class=\"number\">81</span>, <span class=\"number\">100</span>, <span class=\"number\">121</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>i = np.array( [ <span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">8</span>,<span class=\"number\">5</span> ] )              <span class=\"comment\"># 显示a中的位置</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a[i]                                       <span class=\"comment\"># the elements of a at the positions i</span></span><br><span class=\"line\">array([ <span class=\"number\">1</span>,  <span class=\"number\">1</span>,  <span class=\"number\">9</span>, <span class=\"number\">64</span>, <span class=\"number\">25</span>])</span><br><span class=\"line\">&gt;&gt;&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>j = np.array( [ [ <span class=\"number\">3</span>, <span class=\"number\">4</span>], [ <span class=\"number\">9</span>, <span class=\"number\">7</span> ] ] )      <span class=\"comment\"># a bidimensional array of indices</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a[j]                                       <span class=\"comment\"># the same shape as j</span></span><br><span class=\"line\">array([[ <span class=\"number\">9</span>, <span class=\"number\">16</span>],</span><br><span class=\"line\">       [<span class=\"number\">81</span>, <span class=\"number\">49</span>]])</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用布尔数组进行索引\">使用布尔数组进行索引</h3>\n<p>我们可以明确地选择我们想要的数组中的哪些项目以及我们不需要的项目。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a = np.arange(<span class=\"number\">12</span>).reshape(<span class=\"number\">3</span>,<span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b = a &gt; <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b                                          <span class=\"comment\"># b is a boolean with a&#x27;s shape</span></span><br><span class=\"line\">array([[<span class=\"literal\">False</span>, <span class=\"literal\">False</span>, <span class=\"literal\">False</span>, <span class=\"literal\">False</span>],</span><br><span class=\"line\">       [<span class=\"literal\">False</span>,  <span class=\"literal\">True</span>,  <span class=\"literal\">True</span>,  <span class=\"literal\">True</span>],</span><br><span class=\"line\">       [ <span class=\"literal\">True</span>,  <span class=\"literal\">True</span>,  <span class=\"literal\">True</span>,  <span class=\"literal\">True</span>]])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a[b]                                       <span class=\"comment\"># 1d array with the selected elements</span></span><br><span class=\"line\">array([ <span class=\"number\">5</span>,  <span class=\"number\">6</span>,  <span class=\"number\">7</span>,  <span class=\"number\">8</span>,  <span class=\"number\">9</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>])</span><br></pre></td></tr></table></figure>\n","categories":["机器学习","NumPy"],"tags":["python","NumPy"]},{"title":"STL 源码剖析","url":"/2022/05/18/STL-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/","content":"<p>源码推荐读<code>SGI STL</code>源码，可以自行下载</p>\n<p><a href=\"https://github.com/steveLauwh/SGI-STL\">SGI STL</a></p>\n<p><img src=\"STL-源码剖析/1.jpg\" /></p>\n<p>这里我从容器开始看起，不要太关注<code>allocator</code>和<code>Iterators</code>等细节，而去关注数据结构和算法的实现。</p>\n<p>学习完一遍容器后再回来学。</p>\n<p>STL\n六大组件的交互关系：容器通过配置器取得数据存储空间，算法通过迭代器存取容器内容，仿函数可以协助算法完成不同的策略变化，配接器可以修饰或套接仿函数。</p>\n<span id=\"more\"></span>\n<h2 id=\"容器\">容器</h2>\n<p>容器分为序列式容器和关联器容器</p>\n<p><img src=\"STL-源码剖析/2.jpg\" /></p>\n<h3 id=\"序列式容器\">序列式容器</h3>\n<p>所谓序列式容器，其中的元素都可序，但未必有序。</p>\n<h3 id=\"vector\">vector</h3>\n<p><code>vector</code>与<code>array</code>非常相似。<code>array</code>是静态空间，一旦配置了就不能改变；如果满了想换个更大的，首先要配置一块新空间，然后将元素从旧址一一搬往新地址，再把原来的空间释放给系统。<code>vector</code>是动态空间，随着元素的加入，它的内部机制会自动扩充空间以容纳新元素。</p>\n<ul>\n<li>vector 与 array 唯一区别是空间的运用的灵活性。</li>\n<li>array 是静态空间，一旦配置了就不能改变。</li>\n<li>vector\n维护的是一个连续线性空间，所以不论其元素类型为何，普通指针都可以作为\nvector 的迭代器而满足所有必要条件。</li>\n<li>增加新元素，如果超过当时的容量，则容量会扩充至两倍。</li>\n<li>&lt;stl_vector.h&gt; 会调用 &lt;stl_bvector.h&gt; 的函数。</li>\n</ul>\n<h4 id=\"vector-上的常见操作复杂度\">vector 上的常见操作复杂度</h4>\n<ul>\n<li>随机访问——常数 O(1)</li>\n<li>在末尾插入或移除元素——均摊常数 O(1)</li>\n<li>插入或移除元素到 vector 结尾的距离成线性 O(n)</li>\n</ul>\n<p>vector\n的迭代器涵盖了指针所有的算术能力(<code>operator*，operator-&gt;，operator++，operator--，operator+，operator-，operator+=，operator-=</code>)，\n同时 vector 支持随机存取，所以 vector 提供是 Random Access\nIterator。</p>\n<p>平时我们使用<code>vector</code>时，声明如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">std::vector&lt;<span class=\"type\">int</span>&gt; vec0;</span><br><span class=\"line\"><span class=\"function\">std::vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">vec1</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\">std::vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">vec2</span><span class=\"params\">(<span class=\"number\">10</span>, <span class=\"number\">1</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>那么它们是如何在源码中定义的，我们看下源码。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">_Tp</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">_Alloc</span>&gt; </span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">_Vector_base</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">typedef</span> _Alloc allocator_type;</span><br><span class=\"line\">  <span class=\"function\">allocator_type <span class=\"title\">get_allocator</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"built_in\">allocator_type</span>(); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">  _Vector_base(<span class=\"type\">const</span> _Alloc&amp;)</span><br><span class=\"line\">    : _M_start(<span class=\"number\">0</span>), _M_finish(<span class=\"number\">0</span>), _M_end_of_storage(<span class=\"number\">0</span>) &#123;&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 初始化，分配空间</span></span><br><span class=\"line\">  _Vector_base(<span class=\"type\">size_t</span> __n, <span class=\"type\">const</span> _Alloc&amp;)</span><br><span class=\"line\">    : _M_start(<span class=\"number\">0</span>), _M_finish(<span class=\"number\">0</span>), _M_end_of_storage(<span class=\"number\">0</span>) </span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    _M_start = _M_allocate(__n);</span><br><span class=\"line\">    _M_finish = _M_start;</span><br><span class=\"line\">    _M_end_of_storage = _M_start + __n;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">  <span class=\"comment\">// 析构函数， 释放空间</span></span><br><span class=\"line\">  ~_Vector_base() &#123; _M_deallocate(_M_start, _M_end_of_storage - _M_start); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">  _Tp* _M_start;\t\t\t\t\t\t<span class=\"comment\">// 表示目前使用空间的头</span></span><br><span class=\"line\">  _Tp* _M_finish;\t\t\t\t\t\t<span class=\"comment\">// 表示目前使用空间的尾</span></span><br><span class=\"line\">  _Tp* _M_end_of_storage;\t\t<span class=\"comment\">// 表示目前可用空间的尾</span></span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">_Tp</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">_Alloc</span> = __STL_DEFAULT_ALLOCATOR(_Tp) &gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> vector : <span class=\"keyword\">protected</span> _Vector_base&lt;_Tp, _Alloc&gt; </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">// requirements:</span></span><br><span class=\"line\"></span><br><span class=\"line\">  __STL_CLASS_REQUIRES(_Tp, _Assignable);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"keyword\">typedef</span> _Vector_base&lt;_Tp, _Alloc&gt; _Base;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"comment\">// vector 的嵌套类型定义</span></span><br><span class=\"line\">  <span class=\"keyword\">typedef</span> _Tp value_type;</span><br><span class=\"line\">  <span class=\"keyword\">typedef</span> value_type* pointer;  </span><br><span class=\"line\">  <span class=\"keyword\">typedef</span> <span class=\"type\">const</span> value_type* const_pointer;</span><br><span class=\"line\">  <span class=\"keyword\">typedef</span> value_type* iterator; <span class=\"comment\">// vector 的迭代器是普通指针</span></span><br><span class=\"line\">  <span class=\"keyword\">typedef</span> <span class=\"type\">const</span> value_type* const_iterator;</span><br><span class=\"line\">  <span class=\"keyword\">typedef</span> value_type&amp; reference;</span><br><span class=\"line\">  <span class=\"keyword\">typedef</span> <span class=\"type\">const</span> value_type&amp; const_reference;</span><br><span class=\"line\">  <span class=\"keyword\">typedef</span> <span class=\"type\">size_t</span> size_type;</span><br><span class=\"line\">  <span class=\"keyword\">typedef</span> <span class=\"type\">ptrdiff_t</span> difference_type;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>可以看到<code>vector</code> 是继承<code>_Vector_base</code></p>\n<blockquote>\n<p>vec0 是通过默认构造函数进行初始化，vec1通过_Vector_base(const\n_Alloc&amp;)来初始化为0，vec2则先初始化为0，然后再赋值</p>\n</blockquote>\n<h4 id=\"基本函数实现\">基本函数实现</h4>\n<p><strong>1. 构造函数</strong></p>\n<ul>\n<li><code>vector()</code>：创建一个空的<code>vector</code></li>\n<li><code>vector(int nSize)</code>：创建一个<code>vector</code>,元素个数为<code>nSize</code></li>\n<li><code>vector(int nSize, const t&amp; t)</code>:创建一个<code>vector</code>,元素个数为<code>nSize</code>，且值均为<code>t</code></li>\n<li><code>vector(const vector&amp;)</code>:复制构造函数</li>\n<li><code>vector(begin, end)</code>:复制<code>[begin, end]</code>区间内另一个数组的元素到<code>vector</code>中</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// 构造拥有 n 个有值 value 的元素的容器</span></span><br><span class=\"line\">  <span class=\"built_in\">vector</span>(size_type __n, <span class=\"type\">const</span> _Tp&amp; __value,</span><br><span class=\"line\">         <span class=\"type\">const</span> allocator_type&amp; __a = <span class=\"built_in\">allocator_type</span>()) </span><br><span class=\"line\">    : _Base(__n, __a)</span><br><span class=\"line\">    &#123; _M_finish = <span class=\"built_in\">uninitialized_fill_n</span>(_M_start, __n, __value); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">vector</span><span class=\"params\">(size_type __n)</span></span></span><br><span class=\"line\"><span class=\"function\">    : _Base(__n, allocator_type())</span></span><br><span class=\"line\"><span class=\"function\">    &#123;</span> _M_finish = <span class=\"built_in\">uninitialized_fill_n</span>(_M_start, __n, _Tp()); &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 拷贝构造，构造拥有 __x 内容的容器</span></span><br><span class=\"line\">  <span class=\"built_in\">vector</span>(<span class=\"type\">const</span> vector&lt;_Tp, _Alloc&gt;&amp; __x) </span><br><span class=\"line\">    : _Base(__x.<span class=\"built_in\">size</span>(), __x.<span class=\"built_in\">get_allocator</span>())</span><br><span class=\"line\">    &#123; _M_finish = <span class=\"built_in\">uninitialized_copy</span>(__x.<span class=\"built_in\">begin</span>(), __x.<span class=\"built_in\">end</span>(), _M_start); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> __STL_MEMBER_TEMPLATES</span></span><br><span class=\"line\">  <span class=\"comment\">// Check whether it&#x27;s an integral type.  If so, it&#x27;s not an iterator.</span></span><br><span class=\"line\">  <span class=\"comment\">// 构造拥有范围 [first, last) 内容的容器。</span></span><br><span class=\"line\">  <span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">_InputIterator</span>&gt;</span><br><span class=\"line\">  <span class=\"built_in\">vector</span>(_InputIterator __first, _InputIterator __last,</span><br><span class=\"line\">         <span class=\"type\">const</span> allocator_type&amp; __a = <span class=\"built_in\">allocator_type</span>()) : _Base(__a) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"keyword\">typename</span> _Is_integer&lt;_InputIterator&gt;::_Integral _Integral;</span><br><span class=\"line\">    _M_initialize_aux(__first, __last, _Integral());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">_Integer</span>&gt;</span><br><span class=\"line\">  <span class=\"type\">void</span> _M_initialize_aux(_Integer __n, _Integer __value, __true_type) &#123;</span><br><span class=\"line\">    _M_start = _M_allocate(__n);</span><br><span class=\"line\">    _M_end_of_storage = _M_start + __n; </span><br><span class=\"line\">    _M_finish = <span class=\"built_in\">uninitialized_fill_n</span>(_M_start, __n, __value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">_InputIterator</span>&gt;</span><br><span class=\"line\">  <span class=\"type\">void</span> _M_initialize_aux(_InputIterator __first, _InputIterator __last,</span><br><span class=\"line\">                         __false_type) &#123;</span><br><span class=\"line\">    _M_range_initialize(__first, __last, __ITERATOR_CATEGORY(__first));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\">  <span class=\"built_in\">vector</span>(<span class=\"type\">const</span> _Tp* __first, <span class=\"type\">const</span> _Tp* __last,</span><br><span class=\"line\">         <span class=\"type\">const</span> allocator_type&amp; __a = <span class=\"built_in\">allocator_type</span>())</span><br><span class=\"line\">    : _Base(__last - __first, __a) </span><br><span class=\"line\">    &#123; _M_finish = <span class=\"built_in\">uninitialized_copy</span>(__first, __last, _M_start); &#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">/* __STL_MEMBER_TEMPLATES */</span></span></span><br></pre></td></tr></table></figure>\n","categories":["STL"],"tags":["STL"]},{"title":"TLV 解析 I","url":"/2022/04/10/TLV-%E8%A7%A3%E6%9E%90-I/","content":"<p>#<strong>■ 题目描述</strong></p>\n<ul>\n<li>TLV 编码是按 <strong>[ Tag Length Value ]</strong>\n格式进行编码的，一段码流中的信元用Tag标识， Tag在码流中\n<strong>唯一不重复</strong>\n，Length表示信元Value的长度，Value表示信元的值。</li>\n<li>码流以某信元的Tag开头，Tag固定占\n<strong>一个字节</strong>，Length固定占\n<strong>两个字节</strong>，字节序为 <strong>小端序</strong> 。</li>\n<li>现给定TLV格式编码的码流，以及需要解码的信元Tag，请输出该信元的Value。</li>\n<li>输入码流的16进制字符中，不包括小写字母，且要求输出的16进制字符串中也不要包含小写字母；</li>\n<li>码流字符串的最大长度不超过50000个字节。</li>\n</ul>\n<p>##<strong>输入描述:</strong></p>\n<ul>\n<li>输入的第一行为一个字符串，表示待解码信元的 <strong>Tag</strong>\n；</li>\n<li>输入的第二行为一个字符串，表示待解码的 <strong>16进制码流</strong>\n，字节之间用 <strong>空格分隔</strong> 。</li>\n</ul>\n<p><strong>输出描述:</strong></p>\n<ul>\n<li>输出一个字符串，表示待解码信元以16进制表示的 <strong>Value</strong>\n。</li>\n</ul>\n<span id=\"more\"></span>\n<p><strong>示例 1：</strong></p>\n<p><strong>输入</strong></p>\n<blockquote>\n<p>31 32 01 00 AE 90 02 00 01 02 30 03 00 AB 32 31 31 02 00 32 33 33 01\n00 CC</p>\n</blockquote>\n<p><strong>输出</strong></p>\n<blockquote>\n<p>32 33</p>\n</blockquote>\n<p><strong>样例解释</strong></p>\n<p><img src=\"TLV-解析-I/1.png\" /></p>\n<p><strong>说明</strong></p>\n<ul>\n<li>需要解析的信元的Tag是31，从码流的起始处开始匹配；</li>\n<li>Tag为32的信元长度为1（01 00，小端序表示为1）；</li>\n<li>第二个信元的Tag是90，其长度为2；</li>\n<li>第三个信元的Tag是30，其长度为3；</li>\n<li>第四个信元的Tag是31，其长度为2（02\n00），所以返回长度后面的两个字节即可，即32 33。</li>\n</ul>\n<h2 id=\"思路\">思路</h2>\n<p>需要注意的是小端排序，例如<code>01 00</code>我们需要先把它翻转变为<code>00 10</code>去掉前面的<code>00</code>变为<code>10</code>，十进制就为<code>1 * 16^0 + 0* 16^1</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unordered_map&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ll;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">double</span> ld;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; pii;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> vector&lt;<span class=\"type\">int</span>&gt; vi;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//判断当前字符的十进制</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">cai</span><span class=\"params\">(<span class=\"type\">char</span> x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">isdigit</span>(x))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x-<span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x-<span class=\"string\">&#x27;A&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    string tag;</span><br><span class=\"line\">    cin &gt;&gt; tag;</span><br><span class=\"line\">    <span class=\"comment\">//要不然后面的getline读不到,忽略换行</span></span><br><span class=\"line\">    cin.<span class=\"built_in\">ignore</span>();</span><br><span class=\"line\">    vector&lt;string&gt; TLV;</span><br><span class=\"line\">    string str;</span><br><span class=\"line\">    <span class=\"built_in\">getline</span>(cin,str);</span><br><span class=\"line\">    stringstream ss;</span><br><span class=\"line\">    ss &lt;&lt; str;</span><br><span class=\"line\">    string p; <span class=\"comment\">//存储不含空格和换行的字符串</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(ss &gt;&gt; p)&#123;</span><br><span class=\"line\">        TLV.<span class=\"built_in\">push_back</span>(p);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; TLV.<span class=\"built_in\">size</span>(); i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(TLV[i] == tag)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//处理小端输入</span></span><br><span class=\"line\">            string s1 = TLV[i + <span class=\"number\">1</span>], s2 = TLV[i + <span class=\"number\">2</span>];</span><br><span class=\"line\">            string s;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s2 == <span class=\"string\">&quot;00&quot;</span>)&#123;</span><br><span class=\"line\">                s = s1;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                s = s1 + s2;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">reverse</span>(s.<span class=\"built_in\">begin</span>(), s.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">            i += <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"comment\">//后面value长度</span></span><br><span class=\"line\">            <span class=\"type\">int</span> len = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; s.<span class=\"built_in\">size</span>(); j++)&#123;</span><br><span class=\"line\">                len += <span class=\"built_in\">cai</span>(s[j]) * <span class=\"built_in\">pow</span>(<span class=\"number\">16</span>,j);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; len; j++)&#123;</span><br><span class=\"line\">                cout &lt;&lt; TLV[i + j + <span class=\"number\">1</span>] &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cout &lt;&lt; endl;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//处理小端输入</span></span><br><span class=\"line\">            string s1 = TLV[i + <span class=\"number\">1</span>], s2 = TLV[i + <span class=\"number\">2</span>];</span><br><span class=\"line\">            string s;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s2 == <span class=\"string\">&quot;00&quot;</span>)&#123;</span><br><span class=\"line\">                s = s1;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                s = s1 + s2;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"built_in\">reverse</span>(s.<span class=\"built_in\">begin</span>(), s.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">            i += <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"comment\">//后面value长度</span></span><br><span class=\"line\">            <span class=\"type\">int</span> len = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; s.<span class=\"built_in\">size</span>(); j++)&#123;</span><br><span class=\"line\">                len += <span class=\"built_in\">cai</span>(s[j]) * <span class=\"built_in\">pow</span>(<span class=\"number\">16</span>,j);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            i += len;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["字符串"],"tags":["字符串"]},{"title":"auto关键字","url":"/2022/08/05/auto/","content":"<p><code>c++11</code>使用<code>auto</code>来做自动类型推导，编译器会在编译期间自动推导出变量的类型。</p>\n<span id=\"more\"></span>\n<p>[[toc]]</p>\n<h1 id=\"基本使用语法\">基本使用语法：</h1>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> name = value;</span><br></pre></td></tr></table></figure>\n<p><code>name</code>: 变量的名字</p>\n<p><code>value</code>: 变量的初始值</p>\n<blockquote>\n<p>auto仅仅是一个占位符，在编译期间它会被真正的类型所替代，或者说，c++中的变量必须是有明确类型的。</p>\n</blockquote>\n<p>例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> n = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> f = <span class=\"number\">3.14</span>;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> p = &amp;n;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> str = <span class=\"string\">&quot;hello world&quot;</span>;</span><br></pre></td></tr></table></figure>\n<p>第1行中，10是一个整数，默认为<code>int</code>类型，<code>auto</code>推导出为<code>int</code>。</p>\n<p>第2行中，3.14为一个浮点数，默认为<code>double</code>，<code>auto</code>也为<code>double</code>。</p>\n<p>第3行中，<code>&amp;n</code>的结果是一个<code>int*</code>类型的指针，所以<code>auto</code>为<code>int*</code>\n.</p>\n<p>第4行中，str为一个字符串为<code>const char*</code>类型，所以<code>auto</code>为<code>const char*</code>，也即一个常量指针。</p>\n<h1 id=\"auto的限制\">auto的限制</h1>\n<ol type=\"1\">\n<li><p>使用<code>auto</code>时必须对变量进行初始化</p></li>\n<li><p><code>auto</code>不能在函数的参数中使用</p></li>\n</ol>\n<blockquote>\n<p>我们在定义函数时只是对函数进行了声明，指明了函数的类型，但是并没有对它进行初始化赋值，只有在实际使用时才会给参数赋值，\n而<code>auto</code>要求必须对变量进行初始化。</p>\n</blockquote>\n<ol start=\"3\" type=\"1\">\n<li><p><code>auto</code>不能作用于类的非静态成员变量（也就是没有<code>static</code>关键字修饰的成员变量）中</p></li>\n<li><p><code>auto</code>关键字不能定义数组</p></li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> word[] = <span class=\"string\">&quot;hello world&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> str[] = word;      <span class=\"comment\">// word为数组，所以不能使用auto</span></span><br></pre></td></tr></table></figure>\n<ol start=\"5\" type=\"1\">\n<li><code>auto</code>不能作用于模版参数</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span></span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">A&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">C1</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    A&lt;<span class=\"keyword\">auto</span>&gt; C2 = C1;    <span class=\"comment\">// error</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"auto的应用\">auto的应用</h1>\n<h2 id=\"使用auto定义迭代器\">使用auto定义迭代器</h2>\n<p>我们的常规写法遍历容器中的元素：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">#<span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; v;</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt;::iterator i = v.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出写起来非常麻烦，并且容易出错，我们可以通过<code>auto</code>类型推导：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; v;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> i = v.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"auto可用于范型编程\">auto可用于范型编程</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">char</span>* <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;hello world&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> val = T::<span class=\"built_in\">get</span>();</span><br><span class=\"line\">    std::cout &lt;&lt; val &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">func</span>&lt;A&gt;();</span><br><span class=\"line\">    <span class=\"built_in\">func</span>&lt;B&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果为：</p>\n<blockquote>\n<p>100<br> hello world</p>\n</blockquote>\n","categories":["c++11"],"tags":["c++11"]},{"title":"VLAN资源池","url":"/2022/04/10/VLAN%E8%B5%84%E6%BA%90%E6%B1%A0/","content":"<h1 id=\"vlan资源池\">VLAN资源池</h1>\n<p><strong>题目描述：</strong></p>\n<p><strong><em>VLAN</em></strong>是一种对局域网设备进行逻辑划分的技术，为了标识不同的VLAN，引入VLAN\nID(1-4094之间的整数)的概念。</p>\n<p>定义一个VLAN\nID的资源池(下称VLAN资源池)，资源池中连续的VLAN用开始VLAN-结束VLAN表示，不连续的用单个整数表示，所有的VLAN用英文逗号连接起来。</p>\n<p>现在有一个VLAN资源池，业务需要从资源池中申请一个VLAN，需要你输出从VLAN资源池中移除申请的VLAN后的资源池。</p>\n<p><strong>输入描述:</strong></p>\n<p>第一行为字符串格式的VLAN资源池，第二行为业务要申请的VLAN，VLAN的取值范围为[1,4094]之间的整数。</p>\n<p><strong>输出描述:</strong></p>\n<p>从输入VLAN资源池中移除申请的VLAN后字符串格式的VLAN资源池，输出要求满足题目描述中的格式，并且按照VLAN从小到大升序输出。</p>\n<p>如果申请的VLAN不在原VLAN资源池内，输出原VLAN资源池升序排序后的字符串即可。</p>\n<span id=\"more\"></span>\n<p><strong>示例1：</strong></p>\n<p><strong>输入</strong></p>\n<blockquote>\n<p>1-5 2</p>\n</blockquote>\n<p><strong>输出</strong></p>\n<blockquote>\n<p>1,3-5</p>\n</blockquote>\n<p><strong>说明</strong></p>\n<p>原VLAN资源池中有VLAN 1、2、3、4、5，从资源池中移除2后，剩下VLAN\n1、3、4、5，按照题目描述格式并升序后的结果为1,3-5。</p>\n<p><strong>示例2：</strong></p>\n<p><strong>输入</strong></p>\n<blockquote>\n<p>20-21,15,18,30,5-10 15</p>\n</blockquote>\n<p><strong>输出</strong></p>\n<blockquote>\n<p>5-10,18,20-21,30</p>\n</blockquote>\n<p><strong>说明</strong></p>\n<p>原VLAN资源池中有VLAN\n5、6、7、8、9、10、15、18、20、21、30，从资源池中移除15后，资源池中剩下的VLAN为\n5、6、7、8、9、10、18、20、21、30，按照题目描述格式并升序后的结果为5-10,18,20-21,30。</p>\n<p><strong>示例3：</strong></p>\n<p><strong>输入</strong></p>\n<blockquote>\n<p>5,1-3 10</p>\n</blockquote>\n<p><strong>输出</strong></p>\n<blockquote>\n<p>1-3,5</p>\n</blockquote>\n<p><strong>说明</strong></p>\n<p>原VLAN资源池中有VLAN 1、2、3，5，申请的VLAN\n10不在原资源池中，将原资源池按照题目描述格式并按升序排序后输出的结果为1-3,5。</p>\n<p><strong>备注:</strong></p>\n<p>输入VLAN资源池中VLAN的数量取值范围为[2-4094]间的整数，资源池中VLAN不重复且合法([1,4094]之间的整数)，输入是乱序的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unordered_map&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ll;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">double</span> ld;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; pii;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> vector&lt;<span class=\"type\">int</span>&gt; vi;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Stringsplit</span><span class=\"params\">(string str, <span class=\"type\">const</span> <span class=\"type\">char</span> split,vector&lt;string&gt;&amp; res)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">istringstream <span class=\"title\">iss</span><span class=\"params\">(str)</span></span>;\t<span class=\"comment\">// 输入流</span></span><br><span class=\"line\">\tstring token;\t\t\t<span class=\"comment\">// 接收缓冲区</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"built_in\">getline</span>(iss, token, split))\t<span class=\"comment\">// 以split为分隔符</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tres.<span class=\"built_in\">push_back</span>(token);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    string VLAN_source;</span><br><span class=\"line\">    cin &gt;&gt; VLAN_source;</span><br><span class=\"line\">    <span class=\"comment\">//输入资源池</span></span><br><span class=\"line\">    vector&lt;string&gt; Vlan_List;</span><br><span class=\"line\">    <span class=\"built_in\">Stringsplit</span>(VLAN_source, <span class=\"string\">&#x27;,&#x27;</span>,Vlan_List);</span><br><span class=\"line\">    cout &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"comment\">//输入要申请的VLAN</span></span><br><span class=\"line\">    <span class=\"type\">int</span> need_vlan;</span><br><span class=\"line\">    cin &gt;&gt; need_vlan;</span><br><span class=\"line\">    <span class=\"comment\">//存取结果</span></span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; res;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//再判断这里面有没有以&#x27;-&#x27;分割的</span></span><br><span class=\"line\">    <span class=\"comment\">// for(string str : Vlan_List)&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; Vlan_List.<span class=\"built_in\">size</span>(); i++)&#123;</span><br><span class=\"line\">        string str = Vlan_List[i];</span><br><span class=\"line\">        <span class=\"comment\">//找到以&#x27;-&#x27;分割的</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str.<span class=\"built_in\">find</span>(<span class=\"string\">&#x27;-&#x27;</span>) != string::npos)&#123;</span><br><span class=\"line\">            vector&lt;string&gt; tmp;</span><br><span class=\"line\">            <span class=\"built_in\">Stringsplit</span>(str, <span class=\"string\">&#x27;-&#x27;</span>, tmp);</span><br><span class=\"line\">            <span class=\"type\">int</span> start = <span class=\"built_in\">stoi</span>(tmp[<span class=\"number\">0</span>]);</span><br><span class=\"line\">            <span class=\"type\">int</span> end = <span class=\"built_in\">stoi</span>(tmp[<span class=\"number\">1</span>]);</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = start; i &lt;= end; i++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(i != need_vlan)&#123;</span><br><span class=\"line\">                    res.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"built_in\">to_string</span>(need_vlan) != str)&#123;</span><br><span class=\"line\">                res.<span class=\"built_in\">push_back</span>(<span class=\"built_in\">stoi</span>(str));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(res.<span class=\"built_in\">begin</span>(), res.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    <span class=\"comment\">//重组,一一遍历，如果下个数等于上个数加1，继续遍历，否则直接加入ans</span></span><br><span class=\"line\">    vector&lt;string&gt; ans;</span><br><span class=\"line\">    <span class=\"type\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(left &lt; res.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> first = res[left];</span><br><span class=\"line\">        <span class=\"type\">int</span> right = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(right &lt;= res.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span> - left)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(res[left] + right == res[left + right])&#123;</span><br><span class=\"line\">                right++;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(right == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            ans.<span class=\"built_in\">push_back</span>(<span class=\"built_in\">to_string</span>(first));</span><br><span class=\"line\">            left++;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            ans.<span class=\"built_in\">push_back</span>(<span class=\"built_in\">to_string</span>(first) + <span class=\"string\">&#x27;-&#x27;</span> + <span class=\"built_in\">to_string</span>(first + right - <span class=\"number\">1</span>));</span><br><span class=\"line\">            left = left + right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; ans.<span class=\"built_in\">size</span>(); i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i == ans.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            cout &lt;&lt; ans[i] &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            cout &lt;&lt; ans[i] &lt;&lt; <span class=\"string\">&#x27;,&#x27;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["字符串"],"tags":["字符串"]},{"title":"c++中map用法","url":"/2019/04/05/c-%E4%B8%ADmap%E7%94%A8%E6%B3%95/","content":"<p>map的特性是，所有元素都会根据元素的减值自动被排序。map的所有元素都是pair，同时拥有实值(value)和键值(key)。pair的第一个元素会被视为键值，第二个元素会被视为实值。map不允许两个元素拥有相同的键值。</p>\n<span id=\"more\"></span>\n<h3 id=\"map的基本构造函数\">map的基本构造函数</h3>\n<blockquote>\n<ul>\n<li><p>map&lt;string,int&gt;strMap;</p></li>\n<li><p>map&lt;int ,string&gt;intMap;</p></li>\n<li><p>map&lt;string, char&gt;strMap;</p></li>\n<li><p>map&lt; char ,string&gt;charMap;</p></li>\n<li><p>map&lt;char, int&gt;charMap;</p></li>\n<li><p>map&lt;int , char &gt;intMap;</p></li>\n</ul>\n</blockquote>\n<h3 id=\"map添加元素\">map添加元素</h3>\n<blockquote>\n<p>map&lt;int ,string&gt; maplive;</p>\n<ol type=\"1\">\n<li>pair&lt;int,string&gt; value(1,\"a\")；maplive.insert(value);</li>\n</ol>\n<p>​ 等价于maplive.insert(pair&lt;int,string&gt;(1,\"a\"));</p>\n<ol start=\"2\" type=\"1\">\n<li>maplive.insert(map&lt;int,string&gt;::value_type(1,\"a\"));</li>\n<li>maplive[1]=\"a\";//map中最简单最常用的插入添加！</li>\n</ol>\n</blockquote>\n<h3 id=\"map的基本操作函数\">map的基本操作函数</h3>\n<blockquote>\n<p>　begin() 返回指向map头部的迭代器 　clear() 删除所有元素 count()\n返回指定元素出现的次数 empty() 如果map为空则返回true end()\n返回指向map末尾的迭代器 equal_range() 返回特殊条目的迭代器对 erase()\n删除一个元素 find() 查找一个元素 get_allocator() 返回map的配置器\ninsert() 插入元素 key_comp() 返回比较元素key的函数 lower_bound()\n返回键值&gt;=给定元素的第一个位置 max_size() 返回可以容纳的最大元素个数\nrbegin() 返回一个指向map尾部的逆向迭代器 rend()\n返回一个指向map头部的逆向迭代器 size() 返回map中元素的个数 swap()\n交换两个map upper_bound() 返回键值&gt;给定元素的第一个位置 value_comp()\n返回比较元素value的函数</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    map&lt;string,<span class=\"type\">int</span>&gt; strMap;  <span class=\"comment\">//以string为键值，以int为实值</span></span><br><span class=\"line\">    strMap[<span class=\"built_in\">string</span>(<span class=\"string\">&quot;jjhou&quot;</span>)] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    strMap[<span class=\"built_in\">string</span>(<span class=\"string\">&quot;jerry&quot;</span>)] = <span class=\"number\">2</span>;</span><br><span class=\"line\">    strMap[<span class=\"built_in\">string</span>(<span class=\"string\">&quot;jason&quot;</span>)] = <span class=\"number\">3</span>;</span><br><span class=\"line\">    strMap[<span class=\"built_in\">string</span>(<span class=\"string\">&quot;jimmy&quot;</span>)] = <span class=\"number\">4</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\">pair&lt;string,<span class=\"type\">int</span>&gt; <span class=\"title\">value</span><span class=\"params\">(string(<span class=\"string\">&quot;david&quot;</span>),<span class=\"number\">5</span>)</span></span>;</span><br><span class=\"line\">    strMap.<span class=\"built_in\">insert</span>(value);<span class=\"comment\">//插入新元素</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//遍历操作</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(map&lt;string,<span class=\"type\">int</span>&gt;::iterator it = strMap.<span class=\"built_in\">begin</span>();it !=strMap.<span class=\"built_in\">end</span>();it++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//first为键，second为值</span></span><br><span class=\"line\">        cout&lt;&lt;it-&gt;first&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;it-&gt;second&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">int</span> number = strMap[<span class=\"built_in\">string</span>(<span class=\"string\">&quot;jjhou&quot;</span>)];</span><br><span class=\"line\">    cout&lt;&lt;number&lt;&lt;endl;</span><br><span class=\"line\">    cout&lt;&lt;endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//查找元素</span></span><br><span class=\"line\">    map&lt;string,<span class=\"type\">int</span>&gt;::iterator iter1;</span><br><span class=\"line\">    <span class=\"comment\">//面对关联式容器，应该使用其所提供的find函数来搜索元素，会比使用STL算法find()更有效率。因为STL算法find()只是循环搜索。</span></span><br><span class=\"line\">    iter1 = strMap.<span class=\"built_in\">find</span>(<span class=\"built_in\">string</span>(<span class=\"string\">&quot;mchen&quot;</span>));</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(iter1 == strMap.<span class=\"built_in\">end</span>())<span class=\"comment\">//找不到默认为末尾</span></span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;mchen no fount&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    cout&lt;&lt;endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    iter1 = strMap.<span class=\"built_in\">find</span>(<span class=\"built_in\">string</span>(<span class=\"string\">&quot;jerry&quot;</span>));</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(iter1 != strMap.<span class=\"built_in\">end</span>())</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;jerry fount&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">    cout&lt;&lt;endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//修改实值，键值不可修改</span></span><br><span class=\"line\">    iter1-&gt;second = <span class=\"number\">9</span>; <span class=\"comment\">//可以通过map迭代器修改“value”(not key)</span></span><br><span class=\"line\">    <span class=\"type\">int</span> number1 = strMap[<span class=\"built_in\">string</span>(<span class=\"string\">&quot;jerry&quot;</span>)];</span><br><span class=\"line\">    cout&lt;&lt;number1&lt;&lt;endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//删除元素</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(map&lt;string,<span class=\"type\">int</span>&gt;::iterator it = strMap.<span class=\"built_in\">begin</span>();it !=strMap.<span class=\"built_in\">end</span>();it++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;it-&gt;first&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;it-&gt;second&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    strMap.<span class=\"built_in\">erase</span>(iter1);<span class=\"comment\">//删除一个条目</span></span><br><span class=\"line\">    strMap.<span class=\"built_in\">erase</span>(<span class=\"built_in\">string</span>(<span class=\"string\">&quot;jason&quot;</span>));<span class=\"comment\">//根据键值删除</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    map&lt;string,<span class=\"type\">int</span>&gt;::iterator strmap_iter2 = strMap.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(;strmap_iter2 !=strMap.<span class=\"built_in\">end</span>();strmap_iter2++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;strmap_iter2-&gt;first&lt;&lt;<span class=\"string\">&#x27; &#x27;</span>&lt;&lt;strmap_iter2-&gt;second&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>map用的最多的还是key排序和value排序。这里我们重点讲value排序。</p>\n<p>我们可能想到要用sort函数来排序，但是直接用的话又不可以，</p>\n<p>这里我们就需要用vector来进行排序.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;functional&gt;</span> <span class=\"comment\">// std::greater</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"type\">const</span> pair&lt;string, <span class=\"type\">int</span>&gt;&amp; a, <span class=\"type\">const</span> pair&lt;string, <span class=\"type\">int</span>&gt;&amp; b)</span> </span>&#123;<span class=\"comment\">//对成绩进行排序</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.second &lt; b.second;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//1、map这里指定less作为其默认比较函数(对象),就是默认按键值升序排列</span></span><br><span class=\"line\">    map&lt;string, <span class=\"type\">int</span>&gt; name_score_map;</span><br><span class=\"line\">    name_score_map[<span class=\"string\">&quot;LiMin&quot;</span>] = <span class=\"number\">90</span>;</span><br><span class=\"line\">    name_score_map[<span class=\"string\">&quot;ZiLinMi&quot;</span>] = <span class=\"number\">79</span>;</span><br><span class=\"line\">    name_score_map[<span class=\"string\">&quot;BoB&quot;</span>] = <span class=\"number\">92</span>;</span><br><span class=\"line\">    name_score_map.<span class=\"built_in\">insert</span>(<span class=\"built_in\">make_pair</span>(<span class=\"string\">&quot;Bing&quot;</span>, <span class=\"number\">99</span>));</span><br><span class=\"line\">    name_score_map.<span class=\"built_in\">insert</span>(<span class=\"built_in\">make_pair</span>(<span class=\"string\">&quot;Albert&quot;</span>, <span class=\"number\">86</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//输出添加的内容</span></span><br><span class=\"line\">    map&lt;string, <span class=\"type\">int</span>&gt;::iterator iter;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (iter = name_score_map.<span class=\"built_in\">begin</span>(); iter != name_score_map.<span class=\"built_in\">end</span>(); ++iter) &#123;</span><br><span class=\"line\">        cout &lt;&lt; (*iter).first &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将map中的内容转存到vector中</span></span><br><span class=\"line\">    vector&lt;pair&lt;string, <span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">vec</span>(name_score_map.<span class=\"built_in\">begin</span>(), name_score_map.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    <span class=\"comment\">//对线性的vector进行排序</span></span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(vec.<span class=\"built_in\">begin</span>(), vec.<span class=\"built_in\">end</span>(), cmp);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; vec.<span class=\"built_in\">size</span>(); ++i)</span><br><span class=\"line\">        cout &lt;&lt; vec[i].first &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>理解之后，我们可以看下下面的题：</p>\n<p><a\nhref=\"https://www.luogu.org/problemnew/show/P1068\">题目链接</a></p>\n<h2 id=\"题目描述\">题目描述</h2>\n<p>世博会志愿者的选拔工作正在 A\n市如火如荼的进行。为了选拔最合适的人才，A<em>A</em>市对</p>\n<p>所有报名的选手进行了笔试，笔试分数达到面试分数线的选手方可进入面试。面试分数线根</p>\n<p>据计划录取人数的150%150%划定，即如果计划录取m<em>m</em>名志愿者，则面试分数线为排名第m×150%<em>m</em>×150%</p>\n<p>（向下取整）名的选手的分数，而最终进入面试的选手为笔试成绩不低于面试分数线的所有</p>\n<p>选手。</p>\n<p>现在就请你编写程序划定面试分数线，并输出所有进入面试的选手的报名号和笔试成</p>\n<p>绩。</p>\n<h2 id=\"输入输出格式\">输入输出格式</h2>\n<p>输入格式：</p>\n<p>第一行，两个整数\nn,m(5≤n≤5000,3≤m≤n)<em>n</em>,<em>m</em>(5≤<em>n</em>≤5000,3≤<em>m</em>≤<em>n</em>)，中间用一个空格隔开，其</p>\n<p>中n<em>n</em>表示报名参加笔试的选手总数，m<em>m</em>表示计划录取的志愿者人数。输入数据保证\nm×150%</p>\n<p>向下取整后小于等于 n。</p>\n<p>第二行到第 n+1<em>n</em>+1\n行，每行包括两个整数，中间用一个空格隔开，分别是选手的报名号\nk(1000≤k≤9999)<em>k</em>(1000≤<em>k</em>≤9999)和该选手的笔试成绩s(1≤s≤100)<em>s</em>(1≤<em>s</em>≤100)。数据保证选手的报名号各不相同。</p>\n<p>输出格式：</p>\n<p>第一行，有22个整数，用一个空格隔开，第一个整数表示面试分数线；第二个整数为进入面试的选手的实际人数。</p>\n<p>从第二行开始，每行包含22个整数，中间用一个空格隔开，分别表示进入面试的选手的报名号和笔试成绩，按照笔试成绩从高到低输出，如果成绩相同，则按报名号由小到大的顺序输出。</p>\n<h3 id=\"输入样例\">输入样例：</h3>\n<blockquote>\n<p>6 3 1000 90 3239 88 2390 95 7231 84 1005 95 1001 88</p>\n</blockquote>\n<h3 id=\"输出样例\">输出样例：</h3>\n<blockquote>\n<p>88 5 1005 95 2390 95 1000 90 1001 88 3239 88</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"type\">const</span> pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&amp; a, <span class=\"type\">const</span> pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&amp; b)</span> </span>&#123;<span class=\"comment\">//排序，分数相同就比较序号</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a.second==b.second)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.first&gt;b.first;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> a.second &lt; b.second;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n,m,cnt=<span class=\"number\">0</span>;</span><br><span class=\"line\">    cin &gt;&gt; n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"type\">int</span> a[n],b[n];</span><br><span class=\"line\">    map&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt;p;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        cin &gt;&gt; a[i]&gt;&gt;b[i];</span><br><span class=\"line\">        p[a[i]]=b[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    vector&lt;pair&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt; &gt;<span class=\"built_in\">sore</span>(p.<span class=\"built_in\">begin</span>(),p.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(sore.<span class=\"built_in\">begin</span>(),sore.<span class=\"built_in\">end</span>(),cmp);</span><br><span class=\"line\">    <span class=\"type\">int</span> link=<span class=\"built_in\">floor</span>((m<span class=\"number\">-1</span>)*<span class=\"number\">1.50</span>);</span><br><span class=\"line\">    <span class=\"type\">int</span> fenlink = sore[n-link<span class=\"number\">-1</span>].second;<span class=\"comment\">//已经按照从小到大排序了，但是题目要求是从大到小.</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;sore.<span class=\"built_in\">size</span>(); i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sore[i].second &gt;= fenlink) &#123;</span><br><span class=\"line\">            cnt++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; fenlink &lt;&lt; <span class=\"string\">&quot; &quot;</span>&lt;&lt; cnt &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=sore.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;i&gt;=<span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sore[i].second &gt;= fenlink) &#123;</span><br><span class=\"line\">            cout &lt;&lt; sore[i].first &lt;&lt; <span class=\"string\">&quot; &quot;</span>&lt;&lt;sore[i].second &lt;&lt; endl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","categories":["C++常用STL"],"tags":["map"]},{"title":"cMake学习之路","url":"/2022/05/15/cMake%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/","content":"<p><code>cMake</code>适用于跨平台的编译</p>\n<span id=\"more\"></span>\n<h1 id=\"cmake学习之路\"><code>cMake</code>学习之路</h1>\n<h2 id=\"cmake安装\">1. <code>cMake</code>安装</h2>\n<p>我使用的是<code>mac</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">brew install cmake</span><br></pre></td></tr></table></figure>\n<h2 id=\"cmake的编译\">2. <code>cMake</code>的编译</h2>\n<p>创建我们的文件所在目录，并来到创建的目录</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">madir cmakeLearn/cmake01</span><br><span class=\"line\"><span class=\"built_in\">cd</span> cmakeLearen/cmake01</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建一个hello-world\">2.1 创建一个<code>hello world</code></h3>\n<p>我是在<code>nvim</code>下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">nvim main.cpp</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//main.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tstd::cout &lt;&lt; <span class=\"string\">&quot;hello world&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们正常编译执行看下结果</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">clang++ main.cpp</span><br><span class=\"line\">./a.out</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<blockquote>\n<p>hello world</p>\n</blockquote>\n<p>然后把<code>a.out</code>删除</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">rm</span> -rf a.out</span><br></pre></td></tr></table></figure>\n<h3 id=\"写cmakelists.txt\">2.2 写<code>CMakeLists.txt</code></h3>\n<p>现在我们用<code>cMake</code>来编译</p>\n<p><strong>新建<code>CMakeLists.txt</code></strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">nvim CMakeLists.txt</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// projext name</span></span><br><span class=\"line\"><span class=\"built_in\">PROJECT</span>(HELLO)</span><br><span class=\"line\"><span class=\"built_in\">SET</span>(SRC_LIST main.cpp)</span><br><span class=\"line\"><span class=\"built_in\">MESSAGE</span>(STATUS <span class=\"string\">&quot;This is BINARY dir&quot;</span> $&#123;HELLO_BINARY_DIR&#125;)</span><br><span class=\"line\"><span class=\"built_in\">MESSAGE</span>(STATUS <span class=\"string\">&quot;This is SOURCES dir&quot;</span> $&#123;HELLO_SOURCE_DIR&#125;)</span><br><span class=\"line\"><span class=\"built_in\">ADD_EXECUTABLE</span>(hello $&#123;SRC_LIST&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用cmake生成makefile文件\">2.3\n使用<code>cmake</code>生成<code>makefile</code>文件</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">cmake .</span><br></pre></td></tr></table></figure>\n<p><img src=\"cMake学习之路/2.3.1.jpg\" /></p>\n<p>没有发生报错，就是成功编译了</p>\n<p>我们执行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">la -a</span><br></pre></td></tr></table></figure>\n<p>查看当前目录下有哪些文件</p>\n<p><img src=\"cMake学习之路/2.3.2.jpg\" /></p>\n<h3 id=\"使用make编译\">2.4 使用<code>make</code>编译</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">make</span><br></pre></td></tr></table></figure>\n<p><img src=\"cMake学习之路/2.3.3.jpg\" /></p>\n<p>可以发现生成了<code>hello</code>这个文件，我们执行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">./hello</span><br></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<blockquote>\n<p>hello world</p>\n</blockquote>\n<h2 id=\"cmake语法介绍\">3. <code>cMake</code>语法介绍</h2>\n<h3 id=\"project关键字\">3.1 <code>PROJECT</code>关键字</h3>\n<p>可以用来指定工程的名字和支持的语言，默认支持所有语言</p>\n<p><code>PROJECT (HELLO)</code> 指定了工程的名字，并且支持所有语言</p>\n<p><code>PROJECT (HELLO CXX)</code>\n指定了工程的名字，并且支持语言是<code>C++</code></p>\n<p><code>PROJECT (HELLO C CXX)</code>\n指定了工程的名字，并且支持语言是<code>C</code>和<code>C++</code></p>\n<p>我们的<code>hello world</code>程序</p>\n<p>该指定隐式定义了两个CMAKE的变量</p>\n<p><code>&lt;projectname&gt;_BINARY_DIR</code>，本例中是\nHELLO_BINARY_DIR</p>\n<p><code>&lt;projectname&gt;_SOURCE_DIR</code>，本例中是\nHELLO_SOURCE_DIR</p>\n<p><code>MESSAGE</code>关键字就可以直接使用者两个变量，当前都指向当前的工作目录，后面会讲外部编译</p>\n<blockquote>\n<p>ps:</p>\n<p>问题：如果改了工程名，这两个变量名也会改变</p>\n<p>解决：又定义两个预定义变量：<code>PROJECT_BINARY_DIR</code>和<code>PROJECT_SOURCE_DIR</code>，这两个变量和<code>HELLO_BINARY_DIR</code>，<code>HELLO_SOURCE_DIR</code>是一致的。所以改了工程名也没有关系</p>\n</blockquote>\n<h3 id=\"set关键字\">3.2 <code>SET</code>关键字</h3>\n<p>用来显示的指定变量的</p>\n<p><code>SET(SRC_LIST main.cpp)</code>\n<code>SRC_LIST</code>变量就包含了<code>main.cpp</code></p>\n<p>如果有多个<code>cpp</code>文件</p>\n<p>也可以 <code>SET(SRC_LIST main.cpp t1.cpp t2.cpp)</code></p>\n<h3 id=\"message关键字\">3.3 <code>MESSAGE</code>关键字</h3>\n<p>向终端输出用户自定义的信息</p>\n<p>主要包含三种信息：</p>\n<ul>\n<li><code>SEND_ERROR</code>，产生错误，生成过程被跳过。</li>\n<li><code>STATUS</code>，输出前缀为<code>—</code>的信息。</li>\n<li><code>FATAL_ERROR</code>，立即终止所有 cmake 过程.</li>\n</ul>\n<h3 id=\"add_executable关键字\">3.4 <code>ADD_EXECUTABLE</code>关键字</h3>\n<p>生成可执行文件</p>\n<p><code>ADD_EXECUTABLE(hello $&#123;SRC_LIST&#125;)</code>\n生成的可执行文件名是<code>hello</code>，源文件读取变量<code>SRC_LIST</code>中的内容</p>\n<p>也可以直接写 <code>ADD_EXECUTABLE(hello main.cpp)</code></p>\n<p>上述例子可以简化的写成</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">PROJECT</span>(HELLO)</span><br><span class=\"line\"><span class=\"built_in\">ADD_EXECUTABLE</span>(hello main.cpp)</span><br></pre></td></tr></table></figure>\n<p>注意：工程名的 <code>HELLO</code>和生成的可执行文件\n<code>hello</code>是没有任何关系的</p>\n<h2 id=\"语法的基本原则\">4. 语法的基本原则</h2>\n<ul>\n<li><p>变量使用<code>$&#123;&#125;</code>方式取值，但是在<code>IF</code>\n控制语句中是直接使用变量名</p></li>\n<li><p>指令(参数 1 参数 2...)\n参数使用括弧括起，参数之间使用空格或分号分开。 以上面的\n<code>ADD_EXECUTABLE</code>指令为例，如果存在另外一个\n<code>func.cpp</code> 源文件</p>\n<p>就要写成：<code>ADD_EXECUTABLE(hello main.cpp func.cpp)</code>或者<code>ADD_EXECUTABLE(hello main.cpp;func.cpp)</code></p></li>\n<li><p>指令是大小写无关的，参数和变量是大小写相关的。但，推荐你全部使用大写指令</p></li>\n</ul>\n<h3 id=\"语法注意事项\">4.1 语法注意事项</h3>\n<ul>\n<li><code>SET(SRC_LIST main.cpp)</code>可以写成\n<code>SET(SRC_LIST “main.cpp”)</code>，如果源文件名中含有空格，就必须要加双引号</li>\n<li><code>ADD_EXECUTABLE(hello main)</code>后缀可以不行，他会自动去找.c和.cpp，最好不要这样写，可能会有这两个文件main.cpp和main</li>\n</ul>\n<h2 id=\"内部构建和外部构建\">5. 内部构建和外部构建</h2>\n<p>我们的<code>hello world</code>使用的就是内部构建，生产的临时文件特别多，不方便清理</p>\n<p>外部构建，就会把生成的临时文件放在<code>build</code>目录下，不会对源文件有任何影响强烈使用外部构建方式</p>\n<p>我们删除到只剩下</p>\n<p><img src=\"cMake学习之路/5.1.jpg\" /></p>\n<p>### 5.1 外部构建</p>\n<p>1、建立一个<code>build</code>目录，可以在任何地方，建议在当前目录下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> build</span><br><span class=\"line\"><span class=\"built_in\">cd</span> build</span><br></pre></td></tr></table></figure>\n<p>2、运行<code>cmake ..</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">cmake ..</span><br></pre></td></tr></table></figure>\n<p>当然<code>..</code>表示上一级目录，你可以写<code>CMakeLists.txt</code>所在的绝对路径，生产的文件都在<code>build</code>目录下了</p>\n<p>3、在<code>build</code>目录下，运行<code>make</code>来构建工程</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">make</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>ps:</p>\n<p>注意外部构建的两个变量</p>\n<p>1、<code>HELLO_SOURCE_DIR</code> 还是工程路径</p>\n<p>2、<code>HELLO_BINARY_DIR</code> 编译路径\n也就是<code>/root/cmake/bulid</code></p>\n</blockquote>\n<h2 id=\"让hello-world看起来更像一个工程\">6. 让Hello\nWorld看起来更像一个工程</h2>\n<ul>\n<li>为工程添加一个子目录 <code>src</code>，用来放置工程源代码</li>\n<li>添加一个子目录 <code>doc</code>，用来放置这个工程的文档\n<code>hello.txt</code></li>\n<li>在工程目录添加文本文件 <code>COPYRIGHT</code>,\n<code>README</code></li>\n<li>在工程目录添加一个 <a href=\"http://runhello.sh/\">runhello.sh</a>\n脚本，用来调用 <code>hello</code>二进制</li>\n<li>将构建后的目标文件放入构建目录的 <code>bin</code>子目录</li>\n<li>将 <code>doc</code>目录 的内容以及<code>COPYRIGHT/README</code>\n安装到<code>/usr/share/doc/cmake/</code></li>\n</ul>\n<h3 id=\"将目标文件放入构建目录的-bin子目录\">6.1 将目标文件放入构建目录的\n<code>bin</code>子目录</h3>\n<p>每个目录下都要有一个<code>CMakeLists.txt</code>说明</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost cmake01]<span class=\"meta\"># tree</span></span><br><span class=\"line\">.</span><br><span class=\"line\">├── build</span><br><span class=\"line\">├── CMakeLists.txt</span><br><span class=\"line\">└── src</span><br><span class=\"line\">    ├── CMakeLists.txt</span><br><span class=\"line\">    └── main.cpp</span><br></pre></td></tr></table></figure>\n<p>回到我们的<code>cmake01</code>，此时路径</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">lab/cmakeLearn/cmake01</span><br></pre></td></tr></table></figure>\n<p>建立<code>src</code>,并把<code>main.cpp</code>移动过来</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> src</span><br><span class=\"line\"><span class=\"built_in\">mv</span> main.cpp src/</span><br></pre></td></tr></table></figure>\n<p>并在<code>src</code>中创建一个<code>CMakeLists.txt</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">touch</span> CMakeLists.txt</span><br></pre></td></tr></table></figure>\n<p>回到我们的根目录下，也就是<code>cmake01</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">[root@localhost cmake01]<span class=\"meta\"># tree</span></span><br><span class=\"line\">.</span><br><span class=\"line\">├── build</span><br><span class=\"line\">├── CMakeLists.txt</span><br><span class=\"line\">└── src</span><br><span class=\"line\">    ├── CMakeLists.txt</span><br><span class=\"line\">    └── main.cpp</span><br></pre></td></tr></table></figure>\n<p>输入</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cat</span> CMakeLists.txt</span><br></pre></td></tr></table></figure>\n<p>可以看到里面有数据</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">PROJECT</span>(HELLO)</span><br><span class=\"line\"><span class=\"built_in\">SET</span>(SRC_LIST main.cpp)</span><br><span class=\"line\"><span class=\"built_in\">MESSAGE</span>(STATUS <span class=\"string\">&quot;This is BINARY dir&quot;</span> $&#123;HELLO_BINARY_DIR&#125;)</span><br><span class=\"line\"><span class=\"built_in\">MESSAGE</span>(STATUS <span class=\"string\">&quot;This is SOURCES dir&quot;</span> $&#123;HELLO_SOURCE_DIR&#125;)</span><br><span class=\"line\"><span class=\"built_in\">ADD_EXECUTABLE</span>(hello $&#123;SRC_LIST&#125;)</span><br></pre></td></tr></table></figure>\n<p>我们把里面的数据删除</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&quot;&quot;</span> &gt; CMakeLists.txt</span><br></pre></td></tr></table></figure>\n<p>重新在<code>CMakeLists.txt</code>中输入</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// CMakeLists.txt</span></span><br><span class=\"line\"><span class=\"built_in\">PROJECT</span>(HELLO)</span><br><span class=\"line\"><span class=\"built_in\">ADD_SUBDIRECTORY</span>(src bin)</span><br></pre></td></tr></table></figure>\n<p><code>ADD_SUBDIRECTORY</code>指令</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">ADD_SUBDIRECTORY</span>(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>这个指令用于向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置</p></li>\n<li><p><code>EXCLUDE_FROM_ALL</code>函数是将写的目录从编译中排除，如程序中的<code>example</code></p></li>\n<li><p><code>ADD_SUBDIRECTORY(src bin)</code></p>\n<p>将<code>src</code>子目录加入工程并指定编译输出(包含编译中间结果)路径为<code>bin</code>目录</p>\n<p>如果不进行\n<code>bin</code>目录的指定，那么编译结果(包括中间结果)都将存放在<code>build/src</code>\n目录</p></li>\n</ul>\n<p>接下来我们写<code>src</code>下的<code>CMakeLists.txt</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> src</span><br><span class=\"line\">nvim CMakeLists.txt</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//\tsrc/CMakeLists.txt</span></span><br><span class=\"line\"><span class=\"built_in\">ADD_EXECUTABLE</span>(hello main.cpp)</span><br></pre></td></tr></table></figure>\n<p>去到<code>build</code>文件下(空)</p>\n<p>执行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">cmake ..</span><br></pre></td></tr></table></figure>\n<p>可以看到产生了</p>\n<blockquote>\n<p>. .. CMakeCache.txt CMakeFiles Makefile bin cmake_install.cmake</p>\n</blockquote>\n<p>再执行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">make</span><br></pre></td></tr></table></figure>\n<p>生成</p>\n<blockquote>\n<p>. .. CMakeCache.txt CMakeFiles Makefile bin cmake_install.cmake</p>\n</blockquote>\n<p>去到<code>bin</code>文件下</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> bin</span><br><span class=\"line\"><span class=\"built_in\">ls</span> -a</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>. .. CMakeFiles Makefile cmake_install.cmake hello</p>\n</blockquote>\n<p>可以看到已经产生了我们的可执行文件<code>hello</code></p>\n<h4 id=\"总结\">总结</h4>\n<p>结构为：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── build</span><br><span class=\"line\">├── CMakeLists.txt</span><br><span class=\"line\">└── src</span><br><span class=\"line\">    ├── CMakeLists.txt</span><br><span class=\"line\">    └── main.cpp</span><br></pre></td></tr></table></figure>\n<p>在外层的<code>CMakeLists.txt</code>中通过<code>ADD_SUBDIRECTORY</code>指明当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置</p>\n<p>在<code>src</code>中执行<code>ADD_EXECUTABLE(hello main.cpp)</code></p>\n<p>如果要更改二进制的保存路径</p>\n<p><code>SET</code>指令重新定义 <code>EXECUTABLE_OUTPUT_PATH</code> 和\n<code>LIBRARY_OUTPUT_PATH</code>变量 来指定最终的目标二进制的位置</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">SET</span>(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_BINARY_DIR&#125;/bin)</span><br><span class=\"line\"><span class=\"built_in\">SET</span>(LIBRARY_OUTPUT_PATH $&#123;PROJECT_BINARY_DIR&#125;/lib)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>ps:</p>\n<p>思考：加载哪个CMakeLists.txt当中</p>\n<p>哪里要改变目标存放路径，就在哪里加入上述的定义，所以应该在src下的CMakeLists.txt下写</p>\n</blockquote>\n<h1 id=\"安装\">7. 安装</h1>\n<p>使用<code>CMAKE</code>一个新的指令：<code>INSTALL</code></p>\n<p><code>INSTALL</code>的安装可以包括：二进制、动态库、静态库以及文件、目录、脚本等</p>\n<p>使用<code>CMAKE</code>一个新的变量：<code>CMAKE_INSTALL_PREFIX</code></p>\n<h2 id=\"创建实例\">7.1 创建实例</h2>\n<p>我们创建<code>cmake02</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── cmake01</span><br><span class=\"line\">├── cmake02</span><br></pre></td></tr></table></figure>\n<p>然后把<code>cmake01</code>的内容复制到<code>cmake02</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cp</span> cmake01/* cmake02</span><br></pre></td></tr></table></figure>\n<p>此时<code>cmake02</code>到的结构为</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">lab/cmakeLearn/cmake02</span><br><span class=\"line\">➜ tree</span><br><span class=\"line\">.</span><br><span class=\"line\">├── CMakeLists.txt</span><br><span class=\"line\">├── build</span><br><span class=\"line\">└── src</span><br><span class=\"line\">    ├── CMakeLists.txt</span><br><span class=\"line\">    └── main.cpp</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>安装以下目录树构建完整。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 目录树结构</span></span><br><span class=\"line\"><span class=\"comment\">//lab/cmakeLearn/cmake02</span></span><br><span class=\"line\">➜ tree</span><br><span class=\"line\">.</span><br><span class=\"line\">├── CMakeLists.txt</span><br><span class=\"line\">├── COPYRIGHT</span><br><span class=\"line\">├── README</span><br><span class=\"line\">├── build</span><br><span class=\"line\">├── doc</span><br><span class=\"line\">│   └── hello.txt</span><br><span class=\"line\">├── runhello.sh</span><br><span class=\"line\">└── src</span><br><span class=\"line\">    ├── CMakeLists.txt</span><br><span class=\"line\">    └── main.cpp</span><br></pre></td></tr></table></figure>\n<h3 id=\"安装文件copyright和readme\">7.2 安装文件COPYRIGHT和README</h3>\n<h4 id=\"安装文件copyright\">7.2.1 安装文件COPYRIGHT</h4>\n<p>打开最外层的<code>CMakeLists.txt</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">nvim CMakeLists.txt</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// CMakeLists.txt</span></span><br><span class=\"line\"><span class=\"built_in\">PROJECT</span>(HELLO)</span><br><span class=\"line\"><span class=\"built_in\">ADD_SUBDIRECTORY</span>(src bin)</span><br><span class=\"line\"><span class=\"built_in\">INSTALL</span>(FILES COPYRIGHT README DESTINATION share/doc/cmake/)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>INSTALL(FILES COPYRIGHT README DESTINATION share/doc/cmake/)</code></p>\n<p><code>FILES</code>：文件</p>\n<p><code>DESTINATION</code>：</p>\n<p>1、写绝对路径</p>\n<p>2、可以写相对路径，相对路径实际路径是：<code>$&#123;CMAKE_INSTALL_PREFIX&#125;/&lt;DESTINATION 定义的路径&gt;</code></p>\n<p><code>CMAKE_INSTALL_PREFIX</code> 默认是在\n<code>/usr/local/</code></p>\n<p><code>cmake -DCMAKE_INSTALL_PREFIX=/usr</code>\n在<code>cmake</code>的时候指定<code>CMAKE_INSTALL_PREFIX</code>变量的路径</p>\n</blockquote>\n<h4 id=\"安装脚本runhello.sh\">7.2.2 安装脚本<code>runhello.sh</code></h4>\n<p>继续在我们的<code>CMakeLists.txt</code>中添加</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">INSTALL</span>(PROGRAMS runhello.sh DESTINATION bin)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>PROGRAMS：非目标文件的可执行程序安装(比如脚本之类)</p>\n<p><code>INSTALL(PROGRAMS runhello.sh DESTINATION bin)</code></p>\n<p>说明：实际安装到的是 /usr/bin</p>\n</blockquote>\n<h4 id=\"安装-doc中的-hello.txt\">7.2.3 安装 <code>doc</code>中的\n<code>hello.txt</code></h4>\n<ul>\n<li><p>一、是通过在 doc 目录建立CMakeLists.txt\n，通过install下的file</p></li>\n<li><p>二、是直接在工程目录通过</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">INSTALL</span>(DIRECTORY doc/ DESTINATION share/doc/cmake)</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><code>DIRECTORY</code>后面连接的是所在<code>Source</code>\n目录的相对路径</p>\n<p>注意：<code>abc</code>和 <code>abc/</code>有很大的区别</p>\n<p>目录名不以<code>/</code>结尾：这个目录将被安装为目标路径下的</p>\n<p>目录名以<code>/</code>结尾：将这个目录中的内容安装到目标路径</p>\n<h4 id=\"安装-1\">7.2.4 安装</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> build</span><br><span class=\"line\">cmake ..</span><br></pre></td></tr></table></figure>\n<p><img src=\"cMake学习之路/7.2.4.jpg\" /></p>\n<p>可以看到已经生成了<code>Makefile</code>文件，代表没有出错</p>\n<p>执行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">make</span><br></pre></td></tr></table></figure>\n<p><img src=\"cMake学习之路/7.2.5.jpg\" /></p>\n<p>已经在<code>bin</code>中成功生成<code>hello</code>可执行文件</p>\n<p>执行</p>\n<blockquote>\n<p>make install</p>\n</blockquote>\n<p><img src=\"cMake学习之路/7.2.6.jpg\" /></p>\n<p>可以看到我们的<code>COPYRIGHT</code>和<code>README</code>已经成功安装。</p>\n<h2 id=\"静态库和动态库的构建\">8. 静态库和动态库的构建</h2>\n<p>任务：</p>\n<p>１，建立一个静态库和动态库，提供\n<code>HelloFunc</code>函数供其他程序编程使用，<code>HelloFunc</code>\n向终端输出<code>Hello World</code> 字符串。</p>\n<p>２，安装头文件与共享库。</p>\n<p>静态库和动态库的区别</p>\n<ul>\n<li>静态库的扩展名一般为<code>.a</code>或<code>.lib</code>；动态库的扩展名一般为<code>.so</code>或<code>.dll</code>。</li>\n<li>静态库在编译时会直接整合到目标程序中，编译成功的可执行文件可独立运行</li>\n<li>动态库在编译时不会放到连接的目标程序中，即可执行文件无法单独运行。</li>\n</ul>\n<h3 id=\"创建实例-1\">8.1 创建实例</h3>\n<p>我们创建<code>cmake03</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── cmake01</span><br><span class=\"line\">├── cmake02</span><br><span class=\"line\">├── cmake03</span><br></pre></td></tr></table></figure>\n<p><code>cmake03</code>结构为</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//目录树结构</span></span><br><span class=\"line\">.</span><br><span class=\"line\">├── build</span><br><span class=\"line\">├── CMakeLists.txt</span><br><span class=\"line\">└── lib</span><br><span class=\"line\">    ├── CMakeLists.txt</span><br><span class=\"line\">    ├── hello.cpp</span><br><span class=\"line\">    └── hello.h</span><br></pre></td></tr></table></figure>\n<p><code>hello.h</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// hello.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> HELLO_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> HELLO_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">HelloFunc</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<p><code>hello.cpp</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// hello.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;hello.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">HelloFunc</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tstd::cout &lt;&lt; <span class=\"string\">&quot;hello world&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>写项目外层的<code>CMakeLists.txt</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">PROJECT</span>(HELLO)</span><br><span class=\"line\"><span class=\"built_in\">ADD_SUBDIRECTORY</span>(lib bin)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>第二句为我们在<code>lib</code>中生成一个共享库<code>bin</code></p>\n</blockquote>\n<p><code>lib</code>中<code>CMakeLists.txt</code>中的内容</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// lib/CMakeLists.txt</span></span><br><span class=\"line\"><span class=\"built_in\">SET</span>(LIBHELLO_SRC hello.cpp)</span><br><span class=\"line\"><span class=\"built_in\">ADD_LIBRARY</span>(hello SHARED $&#123;LIBHELLO_SRC&#125;)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>LIBHELLO_SRC 为我们定义的一个变量</p>\n<p>在这个变量上放入了 hello.cpp</p>\n</blockquote>\n<p><code>ADD_LIBRARY</code></p>\n<p><code>ADD_LIBRARY(hello SHARED $&#123;LIBHELLO_SRC&#125;)</code></p>\n<ul>\n<li><code>hello</code>：就是正常的库名，生成的名字前面会加上<code>lib</code>，最终产生的文件是<code>libhello.so</code>\n或者<code>libhello.dylib</code>(<code>mac</code>中的共享库)</li>\n<li><code>SHARED</code>，动态库 <code>STATIC</code>，静态库</li>\n<li><code>$&#123;LIBHELLO_SRC&#125;</code>：源文件</li>\n</ul>\n<p>我们来到<code>build</code>，执行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">cmake ..</span><br><span class=\"line\">make</span><br></pre></td></tr></table></figure>\n<p>可以看到<code>bin</code>中生成了动态共享库<code>libhello.dylib</code></p>\n<blockquote>\n<p>drwxr-xr-x 5 SJCHEN staff 160B 5 15 22:41 CMakeFiles -rw-r--r-- 1\nSJCHEN staff 5.8K 5 15 22:41 Makefile -rw-r--r-- 1 SJCHEN staff 1.1K 5\n15 22:41 cmake_install.cmake -rwxr-xr-x 1 SJCHEN staff 55K 5 15 22:41\nlibhello.dylib</p>\n</blockquote>\n<h3 id=\"同时构建静态和动态库\">8.2 同时构建静态和动态库</h3>\n<p>我们来到<code>lib</code>中的<code>CMakeLists.txt</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">SET</span>(LIBHELLO_SRC hello.cpp)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">ADD_LIBRARY</span>(hello_static STATIC $&#123;LIBHELLO_SRC&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">SET_TARGET_PROPERTIES</span>(hello_static PROPERTIES  OUTPUT_NAME <span class=\"string\">&quot;hello&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">SET_TARGET_PROPERTIES</span>(hello_static PROPERTIES CLEAN_DIRECT_OUTPUT <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">ADD_LIBRARY</span>(hello SHARED $&#123;LIBHELLO_SRC&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">SET_TARGET_PROPERTIES</span>(hello PROPERTIES  OUTPUT_NAME <span class=\"string\">&quot;hello&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">SET_TARGET_PROPERTIES</span>(hello PROPERTIES CLEAN_DIRECT_OUTPUT <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n<p><code>SET_TARGET_PROPERTIES</code></p>\n<p>这条指令可以用来设置输出的名称，对于动态库，还可以用来指定动态库版本和\nAPI 版本</p>\n<p>来到<code>build</code></p>\n<p>先把<code>build</code>中的数据删空</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">rm</span> -rf *</span><br></pre></td></tr></table></figure>\n<p>执行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">cmake ..</span><br><span class=\"line\">make</span><br></pre></td></tr></table></figure>\n<p>输出结果；</p>\n<blockquote>\n<p>[ 25%] Building CXX object bin/CMakeFiles/hello_static.dir/hello.o [\n50%] Linking CXX static library libhello.a [ 50%] Built target\nhello_static [ 75%] Building CXX object bin/CMakeFiles/hello.dir/hello.o\n[100%] Linking CXX shared library libhello.dylib</p>\n</blockquote>\n<p>可以看到我们同时输出了静态库<code>libhello.a</code>和动态共享库<code>libhello.dylib</code></p>\n<h3 id=\"安装共享库和头文件\">8.3 安装共享库和头文件</h3>\n<p>来到<code>lib</code>中的<code>CMakeLists.txt</code></p>\n<p>插入</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">INSTALL</span>(FILES hello.h DESTINATION include/hello)</span><br><span class=\"line\"><span class=\"built_in\">INSTALL</span>(TARGETS hello hello_static LIBRARY DESTINATION lib ARCHIVE DESTINATION lib)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>//二进制，静态库，动态库安装都用TARGETS //ARCHIVE 特指静态库，LIBRARY\n特指动态库，RUNTIME 特指可执行目标二进制。</p>\n</blockquote>\n<p>此时<code>CMakeLists.txt</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">SET</span>(LIBHELLO_SRC hello.cpp)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">ADD_LIBRARY</span>(hello_static STATIC $&#123;LIBHELLO_SRC&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">SET_TARGET_PROPERTIES</span>(hello_static PROPERTIES  OUTPUT_NAME <span class=\"string\">&quot;hello&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">SET_TARGET_PROPERTIES</span>(hello_static PROPERTIES CLEAN_DIRECT_OUTPUT <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">ADD_LIBRARY</span>(hello SHARED $&#123;LIBHELLO_SRC&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">SET_TARGET_PROPERTIES</span>(hello PROPERTIES  OUTPUT_NAME <span class=\"string\">&quot;hello&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">SET_TARGET_PROPERTIES</span>(hello PROPERTIES CLEAN_DIRECT_OUTPUT <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">INSTALL</span>(FILES hello.h DESTINATION include/hello)</span><br><span class=\"line\"><span class=\"built_in\">INSTALL</span>(TARGETS hello hello_static LIBRARY DESTINATION lib ARCHIVE DESTINATION lib)</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>ps:</p>\n<p>注意：</p>\n<p>安装的时候，指定一下路径，放到系统下</p>\n<p>cmake -DCMAKE_INSTALL_PREFIX=/usr ..</p>\n</blockquote>\n<p>来到<code>build</code>，清空</p>\n<p>执行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">cmake -DCMAKE_INSTALL_PREFIX=/usr ..</span><br><span class=\"line\">make</span><br></pre></td></tr></table></figure>\n<p>安装</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">make install</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用外部共享库和头文件\">8.4 使用外部共享库和头文件</h3>\n<p>准备工作，新建一个目录来使用外部共享库和头文件</p>\n<p>我们创建<code>cmake04</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//目录树结构</span></span><br><span class=\"line\">.</span><br><span class=\"line\">├── build</span><br><span class=\"line\">├── CMakeLists.txt</span><br><span class=\"line\">└── src</span><br><span class=\"line\">    ├── CMakeLists.txt</span><br><span class=\"line\">    └── main.cpp</span><br></pre></td></tr></table></figure>\n","categories":["cMake"],"tags":["cMake"]},{"title":"cMake官方文档学习","url":"/2022/05/17/cMake%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0/","content":"<p><code>cmake 3.23.1</code><a\nhref=\"https://cmake.org/cmake/help/v3.23/guide/tutorial/A%20Basic%20Starting%20Point.html\">官方文档学习</a></p>\n<span id=\"more\"></span>\n<h1 id=\"step1-a-basic-starting-point\">Step1: A Basic Starting Point</h1>\n<p>我们在<code>CMake01</code>的文件下建立一个<code>hello.cpp</code>用于输出<code>hello world</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  std::cout&lt;&lt; <span class=\"string\">&quot;hello world&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>并建立<code>CMakeLists.txt</code></p>\n<p>写入</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cmake_minimum_required</span>(VERSION <span class=\"number\">3.10</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"># set the project name</span></span><br><span class=\"line\"><span class=\"built_in\">project</span>(Hello)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"># add the executeable</span></span><br><span class=\"line\"><span class=\"built_in\">add_executable</span>(hello hello.cpp)</span><br></pre></td></tr></table></figure>\n<p><code>CMake</code>支持大写和小写</p>\n<p><code>cmake_minimum_required(VERSION 3.10)</code>:指明我们的最低<code>cmake</code>版本号</p>\n<p><code>project(Hello)</code>:指定了工程的名字，并且支持所有语言</p>\n<p>也可以写成<code>project(Hello cpp)</code>,这指定了工程名字和支持的语言<code>c++</code></p>\n<p><code>add_executable(hello hello.cpp)</code></p>\n<p>生成可执行文件的名称为<code>hello</code>,读取的源文件为<code>hello.cpp</code></p>\n<h2 id=\"编译和运行\">编译和运行</h2>\n<p>现在我们可以开始进行编译运行，不过编译可能会产生需要我们不需要的文件，这让我们的项目不好管理，我们建立一个文件夹<code>Step1_build</code>用来存放编译信息。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">mkdir</span> Step1_build</span><br><span class=\"line\"><span class=\"built_in\">cd</span> Step1_build</span><br></pre></td></tr></table></figure>\n<p>执行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">cmake ..</span><br></pre></td></tr></table></figure>\n<p>当然<code>..</code>表示上一级目录，你也可以写<code>CMakeLists.txt</code>所在的绝对路径，这里我用的是相对路径，生产的文件都在<code>Step1_build</code>目录下了</p>\n<p>现在我们开始链接</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">cmake --build .</span><br></pre></td></tr></table></figure>\n<p>可以看到以下信息，代表我们链接成功</p>\n<blockquote>\n<p>[ 50%] Building CXX object CMakeFiles/hello.dir/hello.cpp.o [100%]\nLinking CXX executable hello [100%] Built target hello</p>\n</blockquote>\n<p>输入</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ll</span><br></pre></td></tr></table></figure>\n<p>看到我们的可执行文件<code>hello</code>已经生成</p>\n<blockquote>\n<p>-rw-r--r-- 1 SJCHEN staff 14K 5 17 01:51 CMakeCache.txt drwxr-xr-x 13\nSJCHEN staff 416B 5 17 01:54 CMakeFiles -rw-r--r-- 1 SJCHEN staff 5.2K 5\n17 01:51 Makefile -rw-r--r-- 1 SJCHEN staff 1.5K 5 17 01:51\ncmake_install.cmake -rwxr-xr-x 1 SJCHEN staff 55K 5 17 01:54\n<code>hello</code></p>\n</blockquote>\n<p>执行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">./hello</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<blockquote>\n<p>hello world</p>\n</blockquote>\n<p>至此我们已经编译运行成功。</p>\n<h2 id=\"cmake-编译工程\">CMake 编译工程</h2>\n<p>我们新建<code>CMake02</code>，并根据目录树结构创建对应的文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── CMakeLists.txt</span><br><span class=\"line\">├── build</span><br><span class=\"line\">├── main.cpp</span><br><span class=\"line\">├── include</span><br><span class=\"line\">│   └── hello.h</span><br><span class=\"line\">└── src</span><br><span class=\"line\">    └── hello.cpp</span><br></pre></td></tr></table></figure>\n<p><code>hello.h</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// hello.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> HELLO_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> HELLO_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SayHello</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<p><code>hello.cpp</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;hello.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">SayHello</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;hello world&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>main.cpp</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;hello.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">SayHello</span>();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>CMakeLists.txt</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cmake_minimum_required</span>(VERSION <span class=\"number\">3.0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">project</span>(HELLO)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">include_directories</span>(include)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">add_executable</span>(hello main.cpp src/hello.cpp)</span><br></pre></td></tr></table></figure>\n<p><code>include_directories(include)</code>向工程添加多个特定的库文件搜索路径，相当于指定g++编译器的<strong>-L</strong>参数</p>\n<p><code>add_executable</code>：生成可执行文件</p>\n<ul>\n<li>语法：<code>add_executable(exe文件名 source1 source2 .. sourceN)</code></li>\n</ul>\n<p><strong>外部构建编译执行</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> build</span><br><span class=\"line\">cmake ..</span><br><span class=\"line\">cmake --build .</span><br></pre></td></tr></table></figure>\n<h2 id=\"重要指令常用变量\"><strong>重要指令&amp;常用变量</strong></h2>\n<h3 id=\"重要指令\">1. 重要指令</h3>\n<ul>\n<li><p><code>cmake_minimum_required</code></p>\n<p>：指定CMake的最小版本要求</p>\n<ul>\n<li>语法：<code>cmake_minimum_required(VERSION 版本号 [FATAL_ERROR])</code></li>\n</ul></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// CMake最小版本要求为2.8.3</span></span><br><span class=\"line\"><span class=\"built_in\">cmake_minimum_required</span>(VERSION <span class=\"number\">2.8</span><span class=\"number\">.3</span>)</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p><strong><code>project</code></strong></p>\n<p>：定义工程名称，并可指定工程支持的语言</p>\n<ul>\n<li>语法：<code>project(工程名称 [CXX] [C] [java])</code></li>\n</ul></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 指定工程名为HELLOWORLD</span></span><br><span class=\"line\"><span class=\"built_in\">project</span>(HELLOWORLD)</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p><strong><code>set</code></strong></p>\n<p>：显式的定义变量</p>\n<ul>\n<li>语法：<code>set(变量名 [变量值] [CACHE TYPE DOCSTRING [FORCE]])</code></li>\n</ul></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义SRC变量，其值为main.cpp hello.cpp</span></span><br><span class=\"line\"><span class=\"built_in\">set</span>(SRC sayhello.cpp hello.cpp)</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p><strong><code>include_directories</code></strong></p>\n<p>：向工程添加多个特定的头文件搜索路径，相当于指定g++编译器的</p>\n<p>-I</p>\n<p>参数</p>\n<ul>\n<li>语法：<code>include_directories([AFTER|BEFORE][SYSTEM] dir1 dir2 ...)</code></li>\n</ul></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将/usr/include/myincludefolder 和 ./include 添加到头文件搜索路径</span></span><br><span class=\"line\"><span class=\"built_in\">include_directories</span>(/usr/include/myincludefolder ./include)</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p><strong>link_directories</strong></p>\n<p>：向工程添加多个特定的库文件搜索路径，相当于指定g++编译器的</p>\n<p>-L</p>\n<p>参数</p>\n<ul>\n<li>语法：<code>link_directories(dir1 dir2 ...)</code></li>\n</ul></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将/usr/lib/mylibfolder 和 ./lib 添加到库文件搜索路径</span></span><br><span class=\"line\"><span class=\"built_in\">link_directories</span>(/usr/lib/mylibfolder ./lib)</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p><strong><code>add_library</code></strong></p>\n<p>：生成库文件</p>\n<ul>\n<li>语法：<code>add_library(库名 [SHARED|STATIC|MODULE] [EXCLUDE_FROM_ALL] source1 source2 .. sourceN)</code></li>\n</ul></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过变量 SRC 生成 libhello.so 共享库</span></span><br><span class=\"line\"><span class=\"comment\">// SHARED代表动态库，STATIC代表静态库</span></span><br><span class=\"line\"><span class=\"built_in\">add_library</span>(hello SHARED $&#123;SRC&#125;)</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p><strong><code>add_compile_options</code></strong></p>\n<p>：添加编译参数</p>\n<ul>\n<li>语法：<code>add_compile_options(编译参数)</code></li>\n</ul></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 添加编译参数 -wall -std=c++11</span></span><br><span class=\"line\"><span class=\"built_in\">add_compile_options</span>(-wall -std=c++<span class=\"number\">11</span> -o2)</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p><strong><code>add_executable</code></strong></p>\n<p>：生成可执行文件</p>\n<ul>\n<li>语法：<code>add_executable(exe文件名 source1 source2 .. sourceN)</code></li>\n</ul></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 编译main.cpp生成可执行文件main</span></span><br><span class=\"line\"><span class=\"built_in\">add_executable</span>(main main.cpp)</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p><strong>target_link_libraries</strong></p>\n<p>：为target添加需要链接的共享库，相当于指定g++编译器-l参数</p>\n<ul>\n<li>语法：<code>target_link_libraries(target library1&lt;debug|optimized&gt; library2...)</code></li>\n</ul></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将hello动态库文件链接到可执行文件main</span></span><br><span class=\"line\"><span class=\"built_in\">target_link_libraries</span>(main hello)</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p><strong><code>add_subdirectory</code></strong></p>\n<p>：向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置</p>\n<ul>\n<li>语法：<code>add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</code></li>\n</ul></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 添加src子目录，src中需要有一个CMakeLists.txt</span></span><br><span class=\"line\"><span class=\"built_in\">add_subdirectory</span>(src)</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p><strong><code>aux_source_directory</code></strong></p>\n<p>：发现一个目录下所有的源代码文件并将列表存储在一个变量中，这个指令临时被用来自动构建源文件列表</p>\n<ul>\n<li>语法：<code>aux_source_directory(文件夹路径 变量名)</code></li>\n</ul></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义SRC变量，其值为当前目录下所有的源代码文件</span></span><br><span class=\"line\"><span class=\"built_in\">aux_source_directory</span>(. SRC)</span><br><span class=\"line\"><span class=\"comment\">// 编译SRC变量所代表的源代码文件，生成main可执行文件</span></span><br><span class=\"line\"><span class=\"built_in\">add_executable</span>(main $&#123;SRC&#125;)</span><br></pre></td></tr></table></figure>\n<hr />\n<h3 id=\"常用变量\">2. 常用变量</h3>\n<ul>\n<li><strong>CMAKE_C_FLAGS</strong>：gcc编译选项</li>\n<li><strong>CMAKE_CXX_FLAGS</strong>：g++编译选项</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在CMAKE_CXX_FLAGS编译选项后追加-std=c++11</span></span><br><span class=\"line\"><span class=\"built_in\">set</span>(CMAKE_CXX_FLAGS <span class=\"string\">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++11&quot;</span>)</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p><strong>CMAKE_BUILD_TYPE</strong>：编译类型(Debug, Release)</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 设定编译类型为debug，因为在调试时需要选择debug</span></span><br><span class=\"line\"><span class=\"built_in\">set</span>(CMAKE_BUILD_TYPE Debug)</span><br><span class=\"line\"><span class=\"comment\">// 设定编译类型为release，因为在发布时需要选择release</span></span><br><span class=\"line\"><span class=\"built_in\">set</span>(CMAKE_BUILD_TYPE release)</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>EXECUTABLE_OUTPUT_PATH</strong>：可执行文件输出的存放路径</p></li>\n<li><p><strong>LIBRARY_OUTPUT_PATH</strong>：库文件输出的存放路径</p></li>\n</ul>\n","categories":["cMake"],"tags":["cMake"]},{"title":"const","url":"/2022/04/18/const/","content":"<h1 id=\"const-含义\">1. const 含义</h1>\n<p>常类型是指使用类型修饰符<strong>const</strong>说明的类型，常类型的变量或对象的值是不能被更新的。</p>\n<span id=\"more\"></span>\n<h1 id=\"const-作用\">2. const 作用</h1>\n<ul>\n<li>可以定义常量</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> a = <span class=\"number\">100</span>;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>类型检查</p>\n<ul>\n<li><p>const常量与<code>#define</code>宏定义常量的区别：</p>\n<blockquote>\n<p>const 常量具有类型，编译器可以进行安全检查；</p>\n<p><code>#define</code>宏定义没有数据类型，只是简单的字符串替换，不能进行安全检查</p>\n</blockquote></li>\n<li><p>const\n定义的变量只有类型为整数或枚举，且以常量表达式初始化时才能作为常量表达式。</p></li>\n<li><p>其他情况下它只是一个 <code>const</code>\n限定的变量，不要将与常量混淆。</p></li>\n</ul></li>\n<li><p>防止修改，起保护作用。</p></li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">int</span> i)</span></span>&#123;</span><br><span class=\"line\">  i++;\t<span class=\"comment\">//error</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>可以节省空间，避免不必要的内存分配\n<ul>\n<li>const\n定义常量从汇编的角度看，只是给出了对应的内存地址，而不是<code>#define</code>一样给出的是立即数。</li>\n<li>const\n定义的常量在程序运行过程中只有一份拷贝。而<code>#define</code>定义的常量在内存中有若干个拷贝。</li>\n</ul></li>\n</ul>\n<h1 id=\"const-对象默认为文件局部变量\">3. const\n对象默认为文件局部变量</h1>\n<p>注意：非const变量默认为extern。要使const变量能够在其他文件中访问，必须在文件中显式地指定它为extern。</p>\n<blockquote>\n<p>未被const修饰的变量在不同文件的访问</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// file1.cpp</span></span><br><span class=\"line\"><span class=\"type\">int</span> ext;</span><br><span class=\"line\"><span class=\"comment\">// file2.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">int</span> ext;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    std::cout&lt;&lt;(ext+<span class=\"number\">10</span>)&lt;&lt;std::endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>const常量在不同文件的访问</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//extern_file1.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">const</span> <span class=\"type\">int</span> ext=<span class=\"number\">12</span>;</span><br><span class=\"line\"><span class=\"comment\">//extern_file2.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">const</span> <span class=\"type\">int</span> ext;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    std::cout&lt;&lt;ext&lt;&lt;std::endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>小结：\n可以发现未被const修饰的变量不需要extern显式声明！而const常量需要显式声明extern，并且需要做初始化！因为常量在定义后就不能被修改，所以定义时必须初始化。</p>\n</blockquote>\n<h1 id=\"定义常量\">4. 定义常量</h1>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\">b = <span class=\"number\">0</span>; <span class=\"comment\">// error: assignment of read-only variable ‘b’</span></span><br><span class=\"line\"><span class=\"type\">const</span> string s = <span class=\"string\">&quot;helloworld&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> i,j=<span class=\"number\">0</span> <span class=\"comment\">// error: uninitialized const ‘i’</span></span><br></pre></td></tr></table></figure>\n<p>上述有两个错误：</p>\n<blockquote>\n<ul>\n<li>b 为常量，不可更改！</li>\n<li>i\n为常量，必须进行初始化！(因为常量在定义后就不能被修改，所以定义时必须初始化。)</li>\n</ul>\n</blockquote>\n<p>小结：</p>\n<blockquote>\n<p>const 定义常量时，不可以进行更改，并且必须初始化。</p>\n</blockquote>\n<h1 id=\"指针与const\">5. 指针与const</h1>\n<p>与指针相关的const有四种：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">char</span> * a; <span class=\"comment\">//指向const对象的指针或者说指向常量的指针。</span></span><br><span class=\"line\"><span class=\"type\">char</span> <span class=\"type\">const</span> * a; <span class=\"comment\">//同上</span></span><br><span class=\"line\"><span class=\"type\">char</span> * <span class=\"type\">const</span> a; <span class=\"comment\">//指向类型对象的const指针。或者说常指针、const指针。</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">char</span> * <span class=\"type\">const</span> a; <span class=\"comment\">//指向const对象的const指针。</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>小结：</strong>\n如果<em>const</em>位于<code>*</code>的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；\n如果const位于<code>*</code>的右侧，<em>const</em>就是修饰指针本身，即指针本身是常量。</p>\n</blockquote>\n","categories":["C++"],"tags":["C++","CPlusPlusThings"]},{"title":"first","url":"/2019/04/03/first/","content":"<p>第一次使用</p>\n"},{"title":"g++和clang++支持c++11","url":"/2022/08/05/g++%E5%92%8Cclang++%E6%94%AF%E6%8C%81c++11/","content":"<p>在<code>mac</code>上用<code>clang++</code>或者<code>g++</code>编译<code>c++11</code>的文件时，老是报错或警告.</p>\n<p>test.cpp <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::vector&lt;<span class=\"type\">int</span>&gt; nums&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> num : nums) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; num &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>例如我们编译test.cpp这个文件时</p>\n<p>使用<code>clang++</code>编译，</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">clang++ test.cpp</span><br></pre></td></tr></table></figure>\n<p>我们会发现编译错误，因为默认的不支持<code>c++11</code>这样进行列表初始化。</p>\n<p>如果我们想成功编译需要这样</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">clang++ -std=c++11 test.cpp</span><br></pre></td></tr></table></figure>\n<p>g++也是一样</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">g++ -std=c++11 test.cpp -o test</span><br></pre></td></tr></table></figure>\n<p>每次都写<code>-std=c++11</code>比较麻烦,我们可以考虑使用别名。\n如果你终端使用的是<code>bash</code>,你需要在<code>.bashrc</code>中添加</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">alias clang++=&#x27;clang++ -std=c++11&#x27;</span><br><span class=\"line\">alias g++=&#x27;g++ -std=c++11&#x27;</span><br></pre></td></tr></table></figure>\n<p>最后 <figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">source ~/.bashrc</span><br></pre></td></tr></table></figure></p>\n<p>在<code>zsh</code>中同理在<code>.zshrc</code>中添加以上两句，在<code>source</code>即可。</p>\n","categories":["c++"],"tags":["c++"]},{"title":"hexo 更新","url":"/2022/05/14/hexo-%E6%9B%B4%E6%96%B0/","content":"<p>因为<code>hexo</code>版本太低，更新了<code>node</code>之后，不能发布博客了。</p>\n<p>我们去到我们博客所在的地址。</p>\n<span id=\"more\"></span>\n<p>如果没有<code>npm</code>的话，先安装。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">brew install npm</span><br></pre></td></tr></table></figure>\n<p>然后输入</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">nuc -u</span><br></pre></td></tr></table></figure>\n<p>找不到就</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install npm-check-updates -g</span><br></pre></td></tr></table></figure>\n<p>再次运行<code>ncu -u</code></p>\n<p><img src=\"hexo-更新/1.jpg\" /></p>\n<p>然后运行</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n<p>即可解决。</p>\n","categories":["hexo"],"tags":["hexo"]},{"title":"hexo常用技巧","url":"/2019/04/04/hexo%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/","content":"<h1 id=\"一些常用的hexo方法\">一些常用的hexo方法</h1>\n<h2 id=\"创建一个.md文件\">创建一个.md文件</h2>\n<p>可以执行：</p>\n<blockquote>\n<p>$ hexo new \"文件名\"</p>\n</blockquote>\n<h2 id=\"插入图片\">插入图片</h2>\n<ul>\n<li>首先把blog（hexo）目录下的_config.yml里的psot_asset_folder:设置为true</li>\n<li>在blog（hexo）目录下执行:</li>\n</ul>\n<blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>\n</blockquote>\n<ul>\n<li>在blog（hexo）目录下Git Bash Here，运行hexo n\n\"博客名\"来生成md博客时，会在_post目录下看到一个与博客同名的文件夹。</li>\n<li>将想要上传的图片先扔到文件夹下，然后在博客中使用markdown的格式引入图片：</li>\n</ul>\n<blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">![你想要输入的替代文字](xxxx/图片名.jpg)</span><br></pre></td></tr></table></figure>\n</blockquote>\n<figure>\n<img src=\"/hexo常用技巧/test.png\" alt=\"插入图片\" />\n<figcaption aria-hidden=\"true\">插入图片</figcaption>\n</figure>\n","categories":["hexo教程"],"tags":["随笔"]},{"title":"hexo搭建个人博客(一)","url":"/2019/04/04/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","content":"<h1 id=\"前言\">前言</h1>\n<p>打算搭建个博客用来记录自己学习的过程，这里就简单介绍下如何搭建一个个人博客。有讲得不好的请大家轻喷。</p>\n<span id=\"more\"></span>\n<h2 id=\"安装hexo\">安装Hexo</h2>\n<p>安装hexo只需几分钟，但是在安装之前请先安装一些东西.</p>\n<ul>\n<li><p><a href=\"https://nodejs.org\">node.js</a></p></li>\n<li><p><a href=\"https://git-scm.com\">Git</a></p>\n<p>安装完成之后，就只需要用npm安装Hexo:</p>\n<p>先选好自己要安装的目录</p>\n<blockquote>\n<p>cd <文件名></p>\n</blockquote>\n<p>然后再安装：</p>\n<blockquote>\n<p>$ npm install -g hexo-cli</p>\n</blockquote></li>\n</ul>\n<p>到这里我们已经安装好了Hexo。</p>\n<h3\nid=\"利用hexo初始化我们的站点和目录\">2，利用Hexo初始化我们的站点和目录</h3>\n<p>新建一个文件</p>\n<blockquote>\n<p>$ hexo init <文件夹></p>\n<p>$ cd <文件夹></p>\n<p>$ npm install</p>\n</blockquote>\n<p>到这步我们的基本框架就完成了</p>\n<p>进入你建的目录,然后输入:</p>\n<blockquote>\n<p>$ hexo g</p>\n<p>$ hexo s</p>\n</blockquote>\n<p>然后它会给你发个网址，也就是http://localhost:4000，</p>\n<p>在你的浏览器打开就可以看到你的框架了。</p>\n<p>到这里你的博客就已经基本搭建好了，但是这只是基于你的本地，</p>\n<p>后面我会给大家分享如何更换主题，标签，还有一些markdown的使用技巧。</p>\n<p>大家可以看下这里：<a\nhref=\"https://www.jianshu.com/p/043a4ae7684d\">详情</a></p>\n<p>感谢各位大佬能够看完。</p>\n","categories":["hexo教程"],"tags":["随笔"]},{"title":"lua","url":"/2022/07/25/lua/","content":"<p>[[toc]]</p>\n<p>Getting started with lua.</p>\n<p><a href=\"https://www.lua.org/manual/5.4/\">Lua 5.4 Reference\nManual</a></p>\n<span id=\"more\"></span>\n<h1 id=\"comment\">comment</h1>\n<p>The line comments and block comments.</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(a = <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\">--Line comments</span></span><br><span class=\"line\"><span class=\"comment\">--[[</span></span><br><span class=\"line\"><span class=\"comment\">block comments</span></span><br><span class=\"line\"><span class=\"comment\">]]</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"variables\">Variables</h1>\n<p>It is okay to have a semicoion at the end.</p>\n<p>the declaration variable defaults to global.</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">1</span>;</span><br><span class=\"line\">b = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br></pre></td></tr></table></figure>\n<p>Output:</p>\n<blockquote>\n<p>1</p>\n</blockquote>\n<p>local variable <figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> a = <span class=\"number\">1</span></span><br></pre></td></tr></table></figure></p>\n<p>Variables that have not been declared in lua are <code>nil</code>,\nSimilar to <code>nullptr</code> in C++.</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(c)</span><br></pre></td></tr></table></figure>\n<p>Output</p>\n<blockquote>\n<p>nil</p>\n</blockquote>\n<p><strong>Multiple assignment</strong></p>\n<p>The default value without assignment is <code>nil</code></p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">a, b, c = <span class=\"number\">1</span>, <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(a, b, c)</span><br></pre></td></tr></table></figure>\n<p>Output:</p>\n<blockquote>\n<p>1 2 nil</p>\n</blockquote>\n<h1 id=\"number\">Number</h1>\n<p>In the C language,there are multiple types of number values,such as\n<code>int</code>,<code>char</code>,<code>long</code>,etc.,but in lua\nthey are collectively called <code>number</code>.</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">1</span></span><br><span class=\"line\">b = <span class=\"number\">2e10</span></span><br><span class=\"line\">c = <span class=\"number\">0x11</span></span><br><span class=\"line\"><span class=\"comment\">--Hexadecimal</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"operator\">Operator</h1>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">1</span></span><br><span class=\"line\">b = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(a + b)</span><br></pre></td></tr></table></figure>\n<p>Output:</p>\n<blockquote>\n<p>3</p>\n</blockquote>\n<h1 id=\"string\">string</h1>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"string\">&quot;I am string type\\n&quot;</span></span><br><span class=\"line\">b = <span class=\"string\">&#x27;I am also a string type\\n&#x27;</span></span><br><span class=\"line\">c = <span class=\"string\">[[</span></span><br><span class=\"line\"><span class=\"string\">The contents of the remain unchanged.\\n</span></span><br><span class=\"line\"><span class=\"string\">]]</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(a, b, c)</span><br></pre></td></tr></table></figure>\n<p>Output:</p>\n<blockquote>\n<p>I am string type<br> I am alse a string type<br> The contents of the\nremain unchanged.</p>\n</blockquote>\n<p>We found that the content in <code>[[]]</code> remained the same,and\nthe transliteration characters did not change.</p>\n<p>In lua the string concatenation is not a <code>+</code>,but\n<code>..</code>.</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"string\">&#x27;the &#x27;</span></span><br><span class=\"line\">b = <span class=\"string\">&#x27;lua&#x27;</span></span><br><span class=\"line\">c = a..b</span><br><span class=\"line\"><span class=\"built_in\">print</span>(c)</span><br></pre></td></tr></table></figure>\n<p>Output:</p>\n<blockquote>\n<p>the lua</p>\n</blockquote>\n<p>String and numbers can alse be converted to each other. the return\nvalue of <code>tonumber()</code> conversion failure is\n<code>nil</code>.</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"built_in\">tostring</span>(<span class=\"number\">10</span>)</span><br><span class=\"line\">b = <span class=\"built_in\">tonumber</span>(<span class=\"string\">&#x27;10&#x27;</span>)</span><br><span class=\"line\">c = <span class=\"built_in\">tonumber</span>(<span class=\"string\">&quot;abc&quot;</span>)</span><br></pre></td></tr></table></figure>\n<p>Output:</p>\n<blockquote>\n<p>10 10 nil</p>\n</blockquote>\n<p>Get the string length by <code>#</code></p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"string\">&quot;hello world&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(#a)</span><br></pre></td></tr></table></figure>\n<p>Output:</p>\n<blockquote>\n<p>11</p>\n</blockquote>\n<h1 id=\"function\">Function</h1>\n<p><strong>declared function</strong></p>\n<p>The following function declares an equivalence, <code>...</code> is\nthe function argument.</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">function_name1</span><span class=\"params\">(...)</span></span></span><br><span class=\"line\">    <span class=\"comment\">-- body</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">function_name2 = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(...)</span></span></span><br><span class=\"line\">    <span class=\"comment\">-- body</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">function_name3</span><span class=\"params\">(...)</span></span></span><br><span class=\"line\">    <span class=\"comment\">-- body</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>such as:</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span><span class=\"params\">(a, b)</span></span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(a, b)</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">f(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n<p>Output:</p>\n<blockquote>\n<p>1 2</p>\n</blockquote>\n<p>The default return value of the function is alse\n<code>nil</code>.</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span><span class=\"params\">(a, b)</span></span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a, b</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(f(<span class=\"number\">1</span>, <span class=\"number\">2</span>))</span><br></pre></td></tr></table></figure>\n<p>Output:</p>\n<blockquote>\n<p>1 2</p>\n</blockquote>\n<h1 id=\"table\">table</h1>\n<h2 id=\"digital-subscript\"><strong>digital subscript:</strong></h2>\n<p>Can store numbers or strings,and even other tables,function,That is\nto say,anything can be stored in it.</p>\n<p>It should be noted that the first subscript of the table is\n<code>1</code>, you can also get the length of the table by\n<code>#</code>.</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = &#123;<span class=\"number\">1</span>, <span class=\"string\">&quot;abc&quot;</span>, &#123;&#125;, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span> <span class=\"keyword\">end</span>&#125;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a[<span class=\"number\">1</span>])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(#a)</span><br></pre></td></tr></table></figure>\n<p>Output:</p>\n<blockquote>\n<p>1 4</p>\n</blockquote>\n<h3 id=\"table.insert\">table.insert()</h3>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = &#123;<span class=\"number\">1</span>, <span class=\"string\">&quot;ac&quot;</span>, &#123;&#125;, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span> <span class=\"keyword\">end</span>&#125;</span><br><span class=\"line\">a[<span class=\"number\">5</span>] = <span class=\"number\">123</span></span><br><span class=\"line\"><span class=\"built_in\">table</span>.<span class=\"built_in\">insert</span>(a, <span class=\"string\">&quot;d&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">-- insert at the end</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(#a)</span><br></pre></td></tr></table></figure>\n<p>Output:</p>\n<blockquote>\n<p>6</p>\n</blockquote>\n<p>Insert a value at the specified position and move the following\nelements backward.</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = &#123;<span class=\"number\">1</span>, <span class=\"string\">&quot;ac&quot;</span>, &#123;&#125;, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span> <span class=\"keyword\">end</span>&#125;</span><br><span class=\"line\">a[<span class=\"number\">5</span>] = <span class=\"number\">123</span></span><br><span class=\"line\"><span class=\"built_in\">table</span>.<span class=\"built_in\">insert</span>(a, <span class=\"number\">2</span>, <span class=\"string\">&quot;d&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a[<span class=\"number\">2</span>])</span><br></pre></td></tr></table></figure>\n<p>Output:</p>\n<blockquote>\n<p>d</p>\n</blockquote>\n<h3 id=\"table.remove\">table.remove()</h3>\n<p>remove an element from an array</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = &#123;<span class=\"number\">1</span>, <span class=\"string\">&quot;ac&quot;</span>, &#123;&#125;, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span> <span class=\"keyword\">end</span>&#125;</span><br><span class=\"line\">a[<span class=\"number\">5</span>] = <span class=\"number\">123</span></span><br><span class=\"line\"><span class=\"built_in\">table</span>.<span class=\"built_in\">insert</span>(a, <span class=\"number\">2</span>, <span class=\"string\">&quot;d&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">local</span> s = <span class=\"built_in\">table</span>.<span class=\"built_in\">remove</span>(a, <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a[<span class=\"number\">2</span>])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(s)</span><br></pre></td></tr></table></figure>\n<p>Output:</p>\n<blockquote>\n<p>ac d</p>\n</blockquote>\n<h2 id=\"string-subscript\"><strong>string subscript:</strong></h2>\n<p>It should be noted that each end must be followed by\n<code>,</code></p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = &#123;</span><br><span class=\"line\">    a = <span class=\"number\">1</span>,</span><br><span class=\"line\">    b = <span class=\"string\">&quot;1234&quot;</span>,</span><br><span class=\"line\">    c = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">end</span>,</span><br><span class=\"line\">    d = <span class=\"number\">123</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(a[<span class=\"string\">&quot;a&quot;</span>])</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a.a)</span><br></pre></td></tr></table></figure>\n<p>Output:</p>\n<blockquote>\n<p>1 1</p>\n</blockquote>\n<h1 id=\"g\">_G</h1>\n<p>global table</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">_G</span>)</span><br></pre></td></tr></table></figure>\n<p>Output:</p>\n<blockquote>\n<p>table: 0x3</p>\n</blockquote>\n<p>As long as the declared global variables will appear in\n<code>_G</code>.</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">_G</span>[<span class=\"string\">&quot;a&quot;</span>])</span><br></pre></td></tr></table></figure>\n<p>Output:</p>\n<blockquote>\n<p>1</p>\n</blockquote>\n<h1 id=\"boolean\">boolean</h1>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"literal\">true</span></span><br><span class=\"line\">b = <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"number\">1</span> ~= <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"comment\">-- not equal to(1 != 2)</span></span><br></pre></td></tr></table></figure>\n<p><strong>and, or, not</strong></p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"literal\">true</span></span><br><span class=\"line\">b = <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(a <span class=\"keyword\">and</span> b)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a <span class=\"keyword\">or</span> b)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"keyword\">not</span> a)</span><br></pre></td></tr></table></figure>\n<p>Output:</p>\n<blockquote>\n<p>false true false</p>\n</blockquote>\n<p>In lua,only <code>false</code> and <code>nil</code> represent\n<code>false</code>,all other are <code>true</code></p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"literal\">nil</span> <span class=\"comment\">--false</span></span><br><span class=\"line\">b = <span class=\"number\">0</span> <span class=\"comment\">-- true</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(a <span class=\"keyword\">and</span> b)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a <span class=\"keyword\">or</span> b)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"keyword\">not</span> a)</span><br></pre></td></tr></table></figure>\n<p>Output:</p>\n<blockquote>\n<p>nil 0 true</p>\n</blockquote>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(a &gt; <span class=\"number\">10</span> <span class=\"keyword\">and</span> <span class=\"string\">&quot;yes&quot;</span> <span class=\"keyword\">or</span> <span class=\"string\">&quot;no&quot;</span>)</span><br></pre></td></tr></table></figure>\n<p>Output:</p>\n<blockquote>\n<p>no</p>\n</blockquote>\n<p>similar to c++</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> a = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(a &gt; <span class=\"number\">10</span>)</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;yes&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;no&quot;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"branch-statement\">branch statement</h2>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"number\">1</span>&gt;<span class=\"number\">10</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;1&gt;10&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">elseif</span> <span class=\"number\">1</span> &lt; <span class=\"number\">10</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;1 &lt; 10&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;no&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>Output:</p>\n<blockquote>\n<p>1 &lt; 10</p>\n</blockquote>\n<p><strong>0 is the true</strong></p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"number\">0</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;0 is true!&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>Output:</p>\n<blockquote>\n<p>0 is true!</p>\n</blockquote>\n<h1 id=\"loop-statement\">loop statement</h1>\n<h2 id=\"for\">for</h2>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i = <span class=\"number\">1</span>, <span class=\"number\">10</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(i)</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>Output:</p>\n<blockquote>\n<p>1 2 3 4 5 6 7 8 9 10</p>\n</blockquote>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i = <span class=\"number\">1</span>, <span class=\"number\">10</span>, <span class=\"number\">2</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(i)</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>Output:</p>\n<blockquote>\n<p>1 3 5 7 9</p>\n</blockquote>\n<p>2 is the step size.</p>\n<p>The for loop variable can not be modified in the middle.</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i = <span class=\"number\">10</span>, <span class=\"number\">1</span>, <span class=\"number\">-1</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(i)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> i == <span class=\"number\">5</span> <span class=\"keyword\">then</span> <span class=\"keyword\">break</span> <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>Output:</p>\n<blockquote>\n<p>10 9 8 7 6 5</p>\n</blockquote>\n<h2 id=\"while\">while</h2>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">local</span> n = <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> n &gt; <span class=\"number\">1</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(n)</span><br><span class=\"line\">    n = n - <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>Output:</p>\n<blockquote>\n<p>10 9 8 7 6 5 4 3 2</p>\n</blockquote>\n<p>Decrement is not supported in lua, such as</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">local n = 10</span><br><span class=\"line\">n--</span><br><span class=\"line\">n -= 1</span><br></pre></td></tr></table></figure>\n<h1 id=\"string-1\">string</h1>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">s = <span class=\"built_in\">string</span>.<span class=\"built_in\">char</span>(<span class=\"number\">0x30</span>,<span class=\"number\">0x31</span>,<span class=\"number\">0x32</span>,<span class=\"number\">0x33</span>) <span class=\"comment\">--ascii</span></span><br><span class=\"line\">n = <span class=\"built_in\">string</span>.<span class=\"built_in\">byte</span>(s, <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(s)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(n)</span><br></pre></td></tr></table></figure>\n<p>Output:</p>\n<blockquote>\n<p>0123 49</p>\n</blockquote>\n","categories":["lua"],"tags":["lua"]},{"title":"nSum问题","url":"/2022/04/15/nSum/","content":"<h1 id=\"两数之和\"><a href=\"https://leetcode-cn.com/problems/two-sum/\">1.\n两数之和</a></h1>\n<p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出\n和为目标值 target 的那 两个 整数，并返回它们的数组下标。</p>\n<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>\n<p>你可以按任意顺序返回答案。</p>\n<h2 id=\"示例\">示例：</h2>\n<blockquote>\n<p>输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] +\nnums[1] == 9 ，返回 [0, 1] 。</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"思路\">思路：</h3>\n<p>暴力解法是双重循环暴力枚举，我们发现可以在第二层循环时，通过哈希表在<code>O(1)</code>的时间内找到<code>target - nums[i]</code>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">twoSum</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        unordered_map&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt; mp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); i++)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> tmp = target - nums[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(mp.<span class=\"built_in\">count</span>(tmp))&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> &#123;mp[tmp], i&#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            mp[nums[i]] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>时间空间复杂度为<code>O(N)</code>。</p>\n<p><strong>在讲三数之和，我们先改动一下两数之和</strong>，假设我们现在要求返回的不是下标，而是数字。我们就可以先通过排序，然后二分查找。可以假设只有且仅有一对儿元素可以凑出\n<code>target</code>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">twoSum</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//排序</span></span><br><span class=\"line\">      <span class=\"built_in\">sort</span>(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">      <span class=\"comment\">//左右指针</span></span><br><span class=\"line\">      <span class=\"type\">int</span> lo = <span class=\"number\">0</span>, hi = nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"keyword\">while</span>(lo &lt; hi)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sum = nums[lo] + nums[hi];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sum &lt; target)&#123;</span><br><span class=\"line\">          lo++;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(sum &gt; target)&#123;</span><br><span class=\"line\">          hi--;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> &#123;nums[lo], nums[hi]&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这样就可以解决这个问题，不过我们要继续魔改题目，把这个题目变得更泛化，更困难一点：</p>\n<p><strong><code>nums</code> 中可能有多对儿元素之和都等于\n<code>target</code>，请你的算法返回所有和为 <code>target</code>\n的元素对儿，其中不能出现重复</strong>。</p>\n<p>函数签名如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">twoSumTarget</span>(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target);</span><br></pre></td></tr></table></figure>\n<p>比如说输入为\n<code>nums = [1,3,1,2,2,3], target = 4</code>，那么算法返回的结果就是：<code>[[1,3],[2,2]]</code>。</p>\n<p>对于修改后的问题，关键难点是现在可能有多个和为 <code>target</code>\n的数对儿，还不能重复，比如上述例子中 <code>[1,3]</code> 和\n<code>[3,1]</code> 就算重复，只能算一次。</p>\n<p>首先，基本思路肯定还是排序加双指针：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">twoSumTarget</span>(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 先对数组排序</span></span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; res;</span><br><span class=\"line\">    <span class=\"type\">int</span> lo = <span class=\"number\">0</span>, hi = nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (lo &lt; hi) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sum = nums[lo] + nums[hi];</span><br><span class=\"line\">        <span class=\"comment\">// 根据 sum 和 target 的比较，移动左右指针</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>      (sum &lt; target) lo++;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sum &gt; target) hi--;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            res.<span class=\"built_in\">push_back</span>(&#123;lo, hi&#125;);</span><br><span class=\"line\">            lo++; hi--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是，这样实现会造成重复的结果，比如说\n<code>nums = [1,1,1,2,2,3,3], target = 4</code>，得到的结果中\n<code>[1,3]</code> 肯定会重复。</p>\n<p>出问题的地方在于 <code>sum == target</code> 条件的 if 分支，当给\n<code>res</code> 加入一次结果后，<code>lo</code> 和 <code>hi</code>\n不应该改变 1 的同时，还应该跳过所有重复的元素：</p>\n<p>所以代码如下；</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">twoSumTarget</span>(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// nums 数组必须有序</span></span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    <span class=\"type\">int</span> lo = <span class=\"number\">0</span>, hi = nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; res;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (lo &lt; hi) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sum = nums[lo] + nums[hi];</span><br><span class=\"line\">        <span class=\"type\">int</span> left = nums[lo], right = nums[hi];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sum &lt; target) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sum &gt; target) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (lo &lt; hi &amp;&amp; nums[hi] == right) hi--;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            res.<span class=\"built_in\">push_back</span>(&#123;left, right&#125;);</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (lo &lt; hi &amp;&amp; nums[hi] == right) hi--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样，一个通用化的 <code>twoSum</code>\n函数就写出来了，请确保你理解了该算法的逻辑，我们后面解决\n<code>3Sum</code> 和 <code>4Sum</code> 的时候会复用这个函数。</p>\n<p>这个函数的时间复杂度非常容易看出来，双指针操作的部分虽然有那么多\nwhile 循环，但是时间复杂度还是 <code>O(N)</code>，而排序的时间复杂度是\n<code>O(NlogN)</code>，所以这个函数的时间复杂度是\n<code>O(NlogN)</code>。</p>\n<h1 id=\"三数之和\"><a href=\"https://leetcode-cn.com/problems/3sum/\">15.\n三数之和</a></h1>\n<p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素\na，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p>\n<p>注意：答案中不可以包含重复的三元组。</p>\n<p>##示例：</p>\n<blockquote>\n<p>输入：nums = [-1,0,1,2,-1,-4] 输出：[[-1,-1,2],[-1,0,1]]</p>\n</blockquote>\n<h3 id=\"思路-1\">思路：</h3>\n<p>这样，我们再泛化一下题目，不要光和为 0 的三元组了，计算和为\n<code>target</code> 的三元组吧，同上面的 <code>twoSum</code>\n一样，也不允许重复的结果：</p>\n<p>这里就相当于<code>target = 0</code></p>\n<p>这个问题怎么解决呢？<strong>很简单，穷举呗</strong>。现在我们想找和为\n<code>target</code>\n的三个数字，那么对于第一个数字，可能是什么？<code>nums</code>\n中的每一个元素 <code>nums[i]</code> 都有可能！</p>\n<p>那么，确定了第一个数字之后，剩下的两个数字可以是什么呢？其实就是和为\n<code>target - nums[i]</code> 的两个数字呗，那不就是 <code>twoSum</code>\n函数解决的问题。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">threeSum</span>(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//排序</span></span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; res;</span><br><span class=\"line\">      \t<span class=\"type\">int</span> target = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//穷举第一个数</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//对 target - nums[i] 计算 twoSum</span></span><br><span class=\"line\">            vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; tuples = <span class=\"built_in\">twoSumTarget</span>(nums, i + <span class=\"number\">1</span>, target - nums[i]);</span><br><span class=\"line\">            <span class=\"comment\">//如果存在满足条件的二元组，再加上 nums[i] 就是结果三元组</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(vector&lt;<span class=\"type\">int</span>&gt;&amp; tuple : tuples)&#123;</span><br><span class=\"line\">                tuple.<span class=\"built_in\">push_back</span>(nums[i]);</span><br><span class=\"line\">                res.<span class=\"built_in\">push_back</span>(tuple);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//跳过第一个数字重复的情况</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(i &lt; n - <span class=\"number\">1</span> &amp;&amp; nums[i] == nums[i+<span class=\"number\">1</span>]) i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; <span class=\"built_in\">twoSumTarget</span>(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> start, <span class=\"type\">int</span> target)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> lo = start, hi = nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(lo &lt; hi)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> sum = nums[lo] + nums[hi];</span><br><span class=\"line\">            <span class=\"type\">int</span> left = nums[lo], right = nums[hi];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sum &lt; target)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span>(lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(sum &gt; target)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span>(lo &lt; hi &amp;&amp; nums[hi] == right) hi--;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                res.<span class=\"built_in\">push_back</span>(&#123;left, right&#125;);</span><br><span class=\"line\">                <span class=\"keyword\">while</span>(lo &lt; hi &amp;&amp; nums[lo] == left) lo++;</span><br><span class=\"line\">                <span class=\"keyword\">while</span>(lo &lt; hi &amp;&amp; nums[hi] == right) hi--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["双指针"],"tags":["双指针"]},{"title":"nvim-lua 常用键位","url":"/2022/07/26/nvim-lua-%E5%B8%B8%E7%94%A8%E9%94%AE%E4%BD%8D/","content":"<p><code>nvim</code>常用快捷键</p>\n<span id=\"more\"></span>\n<h4 id=\"基本快捷键\">1. 基本快捷键</h4>\n<table>\n<thead>\n<tr class=\"header\">\n<th>快捷键</th>\n<th>操作</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>i</code></td>\n<td>在光标之前插入</td>\n</tr>\n<tr class=\"even\">\n<td><code>a</code></td>\n<td>在光标之后插入</td>\n</tr>\n<tr class=\"odd\">\n<td><code>esc</code></td>\n<td>普通模式</td>\n</tr>\n<tr class=\"even\">\n<td><code>v</code></td>\n<td>可视模式</td>\n</tr>\n<tr class=\"odd\">\n<td><code>w</code></td>\n<td>移动到下一个单词</td>\n</tr>\n<tr class=\"even\">\n<td><code>b</code></td>\n<td>移动到上一个单词</td>\n</tr>\n<tr class=\"odd\">\n<td><code>dd</code></td>\n<td>删除整行（剪切整行）</td>\n</tr>\n<tr class=\"even\">\n<td><code>ddp</code></td>\n<td>交换上下行</td>\n</tr>\n<tr class=\"odd\">\n<td><code>p</code></td>\n<td>粘贴</td>\n</tr>\n<tr class=\"even\">\n<td><code>y</code></td>\n<td>复制</td>\n</tr>\n<tr class=\"odd\">\n<td><code>yy</code></td>\n<td>复制整行</td>\n</tr>\n<tr class=\"even\">\n<td><code>u</code></td>\n<td>撤销操作（重做）</td>\n</tr>\n<tr class=\"odd\">\n<td><code>m</code> +</td>\n<td>标签</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"保存文本\">2. 保存文本</h4>\n<table>\n<thead>\n<tr class=\"header\">\n<th>快捷键</th>\n<th>操作</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>:w name</code></td>\n<td>将文件另存为其他文件名</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"删除文本\">3. 删除文本</h4>\n<table>\n<thead>\n<tr class=\"header\">\n<th>快捷键</th>\n<th>操作</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>x</code></td>\n<td>删除当前字符</td>\n</tr>\n<tr class=\"even\">\n<td><code>X</code></td>\n<td>删除前一个字符</td>\n</tr>\n<tr class=\"odd\">\n<td><code>dw</code></td>\n<td>删除一个单词</td>\n</tr>\n<tr class=\"even\">\n<td><code>D</code></td>\n<td>删除至行尾</td>\n</tr>\n<tr class=\"odd\">\n<td><code>d^</code></td>\n<td>删除至行首</td>\n</tr>\n<tr class=\"even\">\n<td><code>dG</code></td>\n<td>删除到文档末尾</td>\n</tr>\n<tr class=\"odd\">\n<td><code>d1G</code></td>\n<td>删除至文档首部</td>\n</tr>\n<tr class=\"even\">\n<td><code>ndd</code></td>\n<td>删除n行</td>\n</tr>\n<tr class=\"odd\">\n<td><code>nx</code></td>\n<td>删除n个连续字符</td>\n</tr>\n<tr class=\"even\">\n<td><code>dnw</code></td>\n<td>删除n个单词</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"插入模式\">4. 插入模式</h4>\n<p>在普通模式下使用下面的键将进入插入模式，并可以从相应的位置开始输入</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>快捷键</th>\n<th>操作</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>I</code></td>\n<td>在行首插入</td>\n</tr>\n<tr class=\"even\">\n<td><code>A</code></td>\n<td>在行末插入</td>\n</tr>\n<tr class=\"odd\">\n<td><code>a</code></td>\n<td>在光标后插入编辑</td>\n</tr>\n<tr class=\"even\">\n<td><code>o</code></td>\n<td>在当前行后插入一个新行</td>\n</tr>\n<tr class=\"odd\">\n<td><code>O</code></td>\n<td>在当前行前插入一个新行</td>\n</tr>\n<tr class=\"even\">\n<td><code>cw</code></td>\n<td>删除当前光标之后的单词</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"行间跳转\">5. 行间跳转</h4>\n<table>\n<thead>\n<tr class=\"header\">\n<th>快捷键</th>\n<th>操作</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>nG</code></td>\n<td>移动游标到第n行</td>\n</tr>\n<tr class=\"even\">\n<td><code>gg</code></td>\n<td>移动游标到第一行</td>\n</tr>\n<tr class=\"odd\">\n<td><code>G</code></td>\n<td>移动游标到最后一行</td>\n</tr>\n<tr class=\"even\">\n<td><code>Ctrl+o</code></td>\n<td>快速回到上一次光标所在位置</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"行内跳转\">6. 行内跳转</h4>\n<table>\n<colgroup>\n<col style=\"width: 13%\" />\n<col style=\"width: 86%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>快捷键</th>\n<th>操作</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>w</code></td>\n<td>到下一个单词的开头</td>\n</tr>\n<tr class=\"even\">\n<td><code>e</code></td>\n<td>到当前单词的结尾</td>\n</tr>\n<tr class=\"odd\">\n<td><code>b</code></td>\n<td>到前一个单词的开头</td>\n</tr>\n<tr class=\"even\">\n<td><code>^或0</code></td>\n<td>0是到行首，<code>^</code>是到第一个字符</td>\n</tr>\n<tr class=\"odd\">\n<td><code>ge</code></td>\n<td>到前一个单词的结尾</td>\n</tr>\n<tr class=\"even\">\n<td><code>$</code></td>\n<td>到行尾</td>\n</tr>\n<tr class=\"odd\">\n<td><code>f&lt;字母&gt;</code></td>\n<td>向后搜索<字母>并跳转到第一个匹配的位置，再按<code>;</code>重复此命令</td>\n</tr>\n<tr class=\"even\">\n<td><code>F&lt;字母&gt;</code></td>\n<td>向前搜索<字母>并跳转到第一个匹配的位置</td>\n</tr>\n<tr class=\"odd\">\n<td><code>%</code></td>\n<td>跳到结束的括号处</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"大小写\">7. 大小写</h4>\n<table>\n<thead>\n<tr class=\"header\">\n<th>快捷键</th>\n<th>操作</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>~</code></td>\n<td>将游标所在位置字母变成大写或小写</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"comment-注释\">8. Comment 注释</h4>\n<table>\n<thead>\n<tr class=\"header\">\n<th>快捷键</th>\n<th>操作</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>gcc</code></td>\n<td>单行注释</td>\n</tr>\n<tr class=\"even\">\n<td><code>gc</code></td>\n<td>用单行注释多行</td>\n</tr>\n<tr class=\"odd\">\n<td><code>gbc</code></td>\n<td>多行注释</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"分屏\">9. 分屏</h4>\n<table>\n<thead>\n<tr class=\"header\">\n<th>快捷键</th>\n<th>操作</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>sl</code></td>\n<td>左右分屏，光标在右边</td>\n</tr>\n<tr class=\"even\">\n<td><code>sh</code></td>\n<td>左右分屏，光标在左</td>\n</tr>\n<tr class=\"odd\">\n<td><code>sk</code></td>\n<td>上下分屏，光标在上</td>\n</tr>\n<tr class=\"even\">\n<td><code>sj</code></td>\n<td>上下分屏，光标在下</td>\n</tr>\n<tr class=\"odd\">\n<td><code>sc</code></td>\n<td>只剩原来的窗口</td>\n</tr>\n<tr class=\"even\">\n<td><code>so</code></td>\n<td>关闭其他窗口</td>\n</tr>\n<tr class=\"odd\">\n<td><code>&lt;LEADER&gt;hjkl</code></td>\n<td>选择左下上右窗口</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"telescope-快速模糊查找\">10. telescope 快速模糊查找</h4>\n<p>按下空格键提示</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>快捷键</th>\n<th>操作</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>&lt;LEADER&gt;f</code></td>\n<td>查找文件</td>\n</tr>\n<tr class=\"even\">\n<td><code>&lt;LEADER&gt;t</code></td>\n<td>查找单词</td>\n</tr>\n<tr class=\"odd\">\n<td><code>&lt;LEADER&gt;b</code></td>\n<td>查找<code>buffer</code></td>\n</tr>\n<tr class=\"even\">\n<td><code>&lt;LEADER&gt;h</code></td>\n<td>查找<code>help_tags</code></td>\n</tr>\n<tr class=\"odd\">\n<td><code>&lt;LEADER&gt;m</code></td>\n<td>查找图片等媒体文件</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"搜索\">11. 搜索</h4>\n<table>\n<thead>\n<tr class=\"header\">\n<th>快捷键</th>\n<th>操作</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>/</code></td>\n<td>搜索单词</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"which-key\">12. which-key</h4>\n<table>\n<thead>\n<tr class=\"header\">\n<th>快捷键</th>\n<th>操作</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>&lt;space&gt;</code></td>\n<td>弹出选择框</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"surround快速增加或删除括号等\">13\nsurround快速增加或删除括号等</h4>\n<p>和<code>i</code>在光标之前插入，<code>a</code>在光标之后插入，<code>w</code>跳转到下一个单词结合起来使用</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>快捷键</th>\n<th>操作</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>ys</code></td>\n<td>加</td>\n</tr>\n<tr class=\"even\">\n<td><code>ds</code></td>\n<td>减</td>\n</tr>\n<tr class=\"odd\">\n<td><code>cs</code></td>\n<td>改变</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"hop快速移动\">14. hop快速移动</h4>\n<table>\n<thead>\n<tr class=\"header\">\n<th>快捷键</th>\n<th>操作</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>f</code>+想要移动到的字母</td>\n<td>移动到当前行字母后面的你想要字母</td>\n</tr>\n<tr class=\"even\">\n<td><code>F</code>+想要移动的字母</td>\n<td>移动到当前行字母前面的你想去的字母</td>\n</tr>\n<tr class=\"odd\">\n<td><code>&lt;LEADER&gt;</code>+w</td>\n<td>移动到你想去的单词</td>\n</tr>\n<tr class=\"even\">\n<td><code>&lt;LEADER&gt;</code>+j</td>\n<td>移动到你想去的行号</td>\n</tr>\n</tbody>\n</table>\n","categories":["nvim"],"tags":["nvim"]},{"title":"next_permutation和prev_permutation","url":"/2019/04/17/next-permutation%E5%92%8Cprev-permutation/","content":"<p>上一个排列和下一个排列</p>\n<span id=\"more\"></span>\n<h3 id=\"next_permutation\">next_permutation</h3>\n<hr />\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">组合数学中经常用到排列，这里介绍一个计算序列全排列的函数：next_permutation（start,end），和prev_permutation（start,end）。这两个函数作用是一样的，区别就在于前者求的是当前排列的下一个排列，后一个求的是当前排列的上一个排列。至于这里的“前一个”和“后一个”，我们可以把它理解为序列的字典序的前后，严格来讲，就是对于当前序列pn，他的下一个序列pn+<span class=\"number\">1</span>满足：不存在另外的序列pm，使pn&lt;pm&lt;pn+<span class=\"number\">1.</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;set&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> a[<span class=\"number\">3</span>]=&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(a,a+<span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">3</span>;i++)</span><br><span class=\"line\">            cout&lt;&lt;a[i]&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">        cout&lt;&lt;endl;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span>(<span class=\"built_in\">next_permutation</span>(a,a+<span class=\"number\">3</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"结果为\">结果为</h4>\n<blockquote>\n<p>1 3 2 2 1 3 2 3 1 3 1 2 3 2 1</p>\n</blockquote>\n<h3 id=\"prev_permutation\">prev_permutation</h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;set&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> a[<span class=\"number\">3</span>]=&#123;<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">3</span>;i++)</span><br><span class=\"line\">            cout&lt;&lt;a[i]&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">        cout&lt;&lt;endl;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span>(<span class=\"built_in\">prev_permutation</span>(a,a+<span class=\"number\">3</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"结果为-1\">结果为</h4>\n<blockquote>\n<p>3 2 1 3 1 2 2 3 1 2 1 3 1 3 2 1 2 3</p>\n</blockquote>\n","categories":["C++常用STL"],"tags":["next_permutation","prev_permutation"]},{"title":"python实现词云","url":"/2019/06/08/python%E5%AE%9E%E7%8E%B0%E8%AF%8D%E4%BA%91/","content":"<p>首先我们先配置下环境： 打开命令行，输入以下命令，回车:</p>\n<blockquote>\n<p>pip3 install numpy matplotlib pillow wordcloud imageio jieba snownlp\nitchat -i https://pypi.tuna.tsinghua.edu.cn/simple</p>\n</blockquote>\n<p>如果遇上权限问题的话: 在前面加上sudo 如果你遇到python\npip更新问题:</p>\n<span id=\"more\"></span>\n<p>输入以下命令:</p>\n<blockquote>\n<p>sudo pip3 --upgrade pip</p>\n</blockquote>\n<p>下面开始正式的词云学习:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 导入第三方库</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> wordcloud</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#创建词云对象</span></span><br><span class=\"line\">w=wordcloud.WordCloud()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#调用词云对象的generate方法，将文本传入</span></span><br><span class=\"line\">w.generate(<span class=\"string\">&#x27;and that government of the people,by the people,for the people,shall not perish from the earth.&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#将生成的词云保存到当前文件夹下</span></span><br><span class=\"line\">w.to_file(<span class=\"string\">&#x27;example1.png&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<p>效果如下： <img src=\"python实现词云/example1.png\" /></p>\n<p>这只是简单的制作，我们还可以美化它:\n我们可以在WordCloud()里面加入各种参数，控制词云的字体，字号，字色，背景颜色等等。\nwordcloud库会非常智能地按空格进行分词及词频统计，出现次数多的词就大。</p>\n<h4 id=\"美化词云\">美化词云</h4>\n<p>注意字体</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> wordcloud</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 构建词云对象w，设置词云图片宽、高、字体、背景颜色等参数</span></span><br><span class=\"line\">w = wordcloud.WordCloud(width=<span class=\"number\">1000</span>,height=<span class=\"number\">700</span>,background_color=<span class=\"string\">&#x27;white&#x27;</span>,font_path=<span class=\"string\">&#x27;Songti.ttc&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 调用词云对象的generate方法，将文本传入</span></span><br><span class=\"line\">w.generate(<span class=\"string\">&#x27;从明天起，做一个幸福的人。喂马、劈柴，周游世界。从明天起，关心粮食和蔬菜。我有一所房子，面朝大海，春暖花开&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将生成的词云保存为output2-poem.png图片文件，保存到当前文件夹中</span></span><br><span class=\"line\">w.to_file(<span class=\"string\">&#x27;example2.png&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<p><img src=\"python实现词云/example2.png\" /></p>\n<h4 id=\"常用参数\">常用参数</h4>\n<ul>\n<li>width 词云图片宽度，默认400像素</li>\n<li>height 词云图片高度 默认200像素</li>\n<li>background_color 词云图片的背景颜色，默认为黑色</li>\n</ul>\n<blockquote>\n<p>background_color='white'</p>\n</blockquote>\n<ul>\n<li>font_step 字号增大的步进间隔 默认1号</li>\n</ul>\n<p>font_path 指定字体路径 默认None，对于中文可用font_path='msyh.ttc'</p>\n<ul>\n<li>mini_font_size 最小字号 默认4号</li>\n<li>max_font_size 最大字号 根据高度自动调节</li>\n<li>max_words 最大词数 默认200</li>\n<li>stop_words 不显示的单词 stop_words={\"python\",\"java\"}</li>\n<li>Scale 默认值1。值越大，图像密度越大越清晰</li>\n<li>prefer_horizontal：默认值0.90，浮点数类型。表示在水平如果不合适，就旋转为垂直方向，水平放置的词数占0.9？</li>\n<li>relative_scaling：默认值0.5，浮点型。设定按词频倒序排列，上一个词相对下一位词的大小倍数。有如下取值：“0”表示大小标准只参考频率排名，“1”如果词频是2倍，大小也是2倍</li>\n<li>mask 指定词云形状图片，默认为矩形</li>\n</ul>\n<p>通过以下代码读入外部词云形状图片（需要先pip install\nimageio安装imageio）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">w=wordcloud.WordCloud(</span><br><span class=\"line\">  width=<span class=\"number\">400</span>,</span><br><span class=\"line\">  height=<span class=\"number\">200</span>,</span><br><span class=\"line\">  background_color=<span class=\"string\">&#x27;black&#x27;</span>,</span><br><span class=\"line\">  font_path=<span class=\"literal\">None</span>,</span><br><span class=\"line\">  font_step=<span class=\"number\">1</span>,</span><br><span class=\"line\">  min_font_size=<span class=\"number\">4</span>,</span><br><span class=\"line\">  max_font_size=<span class=\"literal\">None</span>,</span><br><span class=\"line\">  max_words=<span class=\"number\">200</span>,</span><br><span class=\"line\">  stoppwords=&#123;&#125;,</span><br><span class=\"line\">  scale=<span class=\"number\">1</span>,</span><br><span class=\"line\">  prefer_horizontal=<span class=\"number\">0.9</span>,</span><br><span class=\"line\">  relative_scaling=<span class=\"number\">0.5</span>,</span><br><span class=\"line\">  mask=<span class=\"literal\">None</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h4 id=\"从外部文件读入文本\">从外部文件读入文本</h4>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> wordcloud</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从外部.txt文件中读取大段文本，存入变量txt中</span></span><br><span class=\"line\">f=<span class=\"built_in\">open</span>(<span class=\"string\">&#x27;/Users/SJCHEN/Downloads/zihaowordcloud-master/code/关于实施乡村振兴战略的意见.txt&#x27;</span>,encoding=<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\">txt=f.read()</span><br><span class=\"line\"></span><br><span class=\"line\">w=wordcloud.WordCloud(</span><br><span class=\"line\">  width=<span class=\"number\">1000</span>,</span><br><span class=\"line\">  height=<span class=\"number\">700</span>,</span><br><span class=\"line\">  background_color=<span class=\"string\">&#x27;white&#x27;</span>,</span><br><span class=\"line\">  font_path=<span class=\"string\">&#x27;Songti.ttc&#x27;</span>)</span><br><span class=\"line\">w.generate(txt)</span><br><span class=\"line\">w.to_file(<span class=\"string\">&#x27;example3.png&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<p><img src=\"python实现词云/example3.png\" /></p>\n","categories":["python","wordcloud"],"tags":["python"]},{"title":"nvim 常用键位","url":"/2022/05/12/nvim-%E5%B8%B8%E7%94%A8%E9%94%AE%E4%BD%8D/","content":"<p><code>nvim</code>常用快捷键</p>\n<span id=\"more\"></span>\n<h4 id=\"基本快捷键\">1. 基本快捷键</h4>\n<table>\n<thead>\n<tr class=\"header\">\n<th>快捷键</th>\n<th>操作</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>i</code></td>\n<td>插入模式</td>\n</tr>\n<tr class=\"even\">\n<td><code>esc</code></td>\n<td>普通模式</td>\n</tr>\n<tr class=\"odd\">\n<td><code>v</code></td>\n<td>可视模式</td>\n</tr>\n<tr class=\"even\">\n<td><code>w</code></td>\n<td>移动到下一个单词</td>\n</tr>\n<tr class=\"odd\">\n<td><code>b</code></td>\n<td>移动到上一个单词</td>\n</tr>\n<tr class=\"even\">\n<td><code>dd</code></td>\n<td>删除整行（剪切整行）</td>\n</tr>\n<tr class=\"odd\">\n<td><code>ddp</code></td>\n<td>交换上下行</td>\n</tr>\n<tr class=\"even\">\n<td><code>p</code></td>\n<td>粘贴</td>\n</tr>\n<tr class=\"odd\">\n<td><code>y</code></td>\n<td>复制</td>\n</tr>\n<tr class=\"even\">\n<td><code>yy</code></td>\n<td>复制整行</td>\n</tr>\n<tr class=\"odd\">\n<td><code>u</code></td>\n<td>撤销操作（重做）</td>\n</tr>\n<tr class=\"even\">\n<td><code>m</code> +</td>\n<td>标签</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"保存文本\">2. 保存文本</h4>\n<table>\n<thead>\n<tr class=\"header\">\n<th>快捷键</th>\n<th>操作</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>:w name</code></td>\n<td>将文件另存为其他文件名</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"删除文本\">3. 删除文本</h4>\n<table>\n<thead>\n<tr class=\"header\">\n<th>快捷键</th>\n<th>操作</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>x</code></td>\n<td>删除当前字符</td>\n</tr>\n<tr class=\"even\">\n<td><code>X</code></td>\n<td>删除前一个字符</td>\n</tr>\n<tr class=\"odd\">\n<td><code>dw</code></td>\n<td>删除一个单词</td>\n</tr>\n<tr class=\"even\">\n<td><code>D</code></td>\n<td>删除至行尾</td>\n</tr>\n<tr class=\"odd\">\n<td><code>d^</code></td>\n<td>删除至行首</td>\n</tr>\n<tr class=\"even\">\n<td><code>dG</code></td>\n<td>删除到文档末尾</td>\n</tr>\n<tr class=\"odd\">\n<td><code>d1G</code></td>\n<td>删除至文档首部</td>\n</tr>\n<tr class=\"even\">\n<td><code>ndd</code></td>\n<td>删除n行</td>\n</tr>\n<tr class=\"odd\">\n<td><code>nx</code></td>\n<td>删除n个连续字符</td>\n</tr>\n<tr class=\"even\">\n<td><code>dnw</code></td>\n<td>删除n个单词</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"插入模式\">4. 插入模式</h4>\n<p>在普通模式下使用下面的键将进入插入模式，并可以从相应的位置开始输入</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>快捷键</th>\n<th>操作</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>I</code></td>\n<td>在行首插入</td>\n</tr>\n<tr class=\"even\">\n<td><code>A</code></td>\n<td>在行末插入</td>\n</tr>\n<tr class=\"odd\">\n<td><code>a</code></td>\n<td>在光标后插入编辑</td>\n</tr>\n<tr class=\"even\">\n<td><code>o</code></td>\n<td>在当前行后插入一个新行</td>\n</tr>\n<tr class=\"odd\">\n<td><code>O</code></td>\n<td>在当前行前插入一个新行</td>\n</tr>\n<tr class=\"even\">\n<td><code>cw</code></td>\n<td>删除当前光标之后的单词</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"行间跳转\">5. 行间跳转</h4>\n<table>\n<thead>\n<tr class=\"header\">\n<th>快捷键</th>\n<th>操作</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>nG</code></td>\n<td>移动游标到第n行</td>\n</tr>\n<tr class=\"even\">\n<td><code>gg</code></td>\n<td>移动游标到第一行</td>\n</tr>\n<tr class=\"odd\">\n<td><code>G</code></td>\n<td>移动游标到最后一行</td>\n</tr>\n<tr class=\"even\">\n<td><code>Ctrl+o</code></td>\n<td>快速回到上一次光标所在位置</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"行内跳转\">6. 行内跳转</h4>\n<table>\n<colgroup>\n<col style=\"width: 13%\" />\n<col style=\"width: 86%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>快捷键</th>\n<th>操作</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>w</code></td>\n<td>到下一个单词的开头</td>\n</tr>\n<tr class=\"even\">\n<td><code>e</code></td>\n<td>到当前单词的结尾</td>\n</tr>\n<tr class=\"odd\">\n<td><code>b</code></td>\n<td>到前一个单词的开头</td>\n</tr>\n<tr class=\"even\">\n<td><code>^或0</code></td>\n<td>0是到行首，<code>^</code>是到第一个字符</td>\n</tr>\n<tr class=\"odd\">\n<td><code>ge</code></td>\n<td>到前一个单词的结尾</td>\n</tr>\n<tr class=\"even\">\n<td><code>$</code></td>\n<td>到行尾</td>\n</tr>\n<tr class=\"odd\">\n<td><code>f&lt;字母&gt;</code></td>\n<td>向后搜索<字母>并跳转到第一个匹配的位置，再按<code>;</code>重复此命令</td>\n</tr>\n<tr class=\"even\">\n<td><code>F&lt;字母&gt;</code></td>\n<td>向前搜索<字母>并跳转到第一个匹配的位置</td>\n</tr>\n<tr class=\"odd\">\n<td><code>%</code></td>\n<td>跳到结束的括号处</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"大小写\">7. 大小写</h4>\n<table>\n<thead>\n<tr class=\"header\">\n<th>快捷键</th>\n<th>操作</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>~</code></td>\n<td>将游标所在位置字母变成大写或小写</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"分屏\">8. 分屏</h4>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"> noremap sl :set splitright&lt;CR&gt;:vsplit&lt;CR&gt;</span><br><span class=\"line\"> noremap sh :set nosplitright&lt;CR&gt;:vsplit&lt;CR&gt;</span><br><span class=\"line\"> noremap sk :set nosplitbelow&lt;CR&gt;:split&lt;CR&gt;</span><br><span class=\"line\"> noremap sj :set splitbelow&lt;CR&gt;:split&lt;CR&gt;</span><br><span class=\"line\">   </span><br><span class=\"line\">noremap &lt;LEADER&gt;h &lt;C-w&gt;h</span><br><span class=\"line\">noremap &lt;LEADER&gt;j &lt;C-w&gt;j</span><br><span class=\"line\">noremap &lt;LEADER&gt;k &lt;C-w&gt;k</span><br><span class=\"line\">noremap &lt;LEADER&gt;l &lt;C-w&gt;l</span><br><span class=\"line\">   </span><br><span class=\"line\">noremap &lt;LEADER&gt;&lt;up&gt; :res +<span class=\"number\">5</span>&lt;CR&gt;</span><br><span class=\"line\">noremap &lt;LEADER&gt;&lt;down&gt; :res <span class=\"number\">-5</span>&lt;CR&gt;</span><br><span class=\"line\">noremap &lt;LEADER&gt;&lt;left&gt; :vertical resize<span class=\"number\">-5</span>&lt;CR&gt;</span><br><span class=\"line\">noremap &lt;LEADER&gt;&lt;right&gt; :vertical resize+<span class=\"number\">5</span>&lt;CR&gt;</span><br><span class=\"line\">  </span><br><span class=\"line\">noremap sv &lt;C-w&gt;t&lt;C-w&gt;H</span><br><span class=\"line\">noremap sh &lt;C-w&gt;t&lt;C-w&gt;K</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr class=\"header\">\n<th>快捷键</th>\n<th>操作</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>sl</code></td>\n<td>向右分屏，光标在右</td>\n</tr>\n<tr class=\"even\">\n<td><code>sh</code></td>\n<td>向左分屏，光标在左</td>\n</tr>\n<tr class=\"odd\">\n<td><code>sk</code></td>\n<td>向上分屏，光标在上</td>\n</tr>\n<tr class=\"even\">\n<td><code>sj</code></td>\n<td>向下分屏，光标在下</td>\n</tr>\n<tr class=\"odd\">\n<td><code>:q</code></td>\n<td>退出</td>\n</tr>\n<tr class=\"even\">\n<td><code>&lt;LEADER&gt;h</code></td>\n<td>光标向左移动</td>\n</tr>\n<tr class=\"odd\">\n<td><code>&lt;LEADER&gt;j</code></td>\n<td>光标向下移动</td>\n</tr>\n<tr class=\"even\">\n<td><code>&lt;LEADER&gt;k</code></td>\n<td>光标向上移动</td>\n</tr>\n<tr class=\"odd\">\n<td><code>&lt;LEADER&gt;l</code></td>\n<td>光标向右移动</td>\n</tr>\n<tr class=\"even\">\n<td><code>&lt;LEADER&gt;</code> + 上下左右</td>\n<td>控制分屏大小</td>\n</tr>\n<tr class=\"odd\">\n<td><code>sv</code></td>\n<td>改变为左右分屏模式</td>\n</tr>\n<tr class=\"even\">\n<td><code>sh</code></td>\n<td>改变为上下分屏模式</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"标签页\">9. 标签页</h4>\n<table>\n<thead>\n<tr class=\"header\">\n<th>快捷键</th>\n<th>操作</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>tn</code></td>\n<td>新建标签页</td>\n</tr>\n<tr class=\"even\">\n<td><code>th</code></td>\n<td>去到左边一个标签页</td>\n</tr>\n<tr class=\"odd\">\n<td><code>tl</code></td>\n<td>去到右边一个标签页</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"neadtree\">10. <code>neadTree</code></h4>\n<table>\n<thead>\n<tr class=\"header\">\n<th>快捷键</th>\n<th>操作</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>tt</code></td>\n<td>打开目录树</td>\n</tr>\n<tr class=\"even\">\n<td><code>ma</code></td>\n<td>新建文件</td>\n</tr>\n<tr class=\"odd\">\n<td><code>mm</code></td>\n<td>修改文件名</td>\n</tr>\n<tr class=\"even\">\n<td><code>md</code></td>\n<td>删除文件</td>\n</tr>\n<tr class=\"odd\">\n<td><code>m</code> + 文件名 + <code>/</code></td>\n<td>创建文件夹</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"undotree\">11. <code>UndoTree</code></h4>\n<table>\n<thead>\n<tr class=\"header\">\n<th>快捷键</th>\n<th>操作</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>UT</code></td>\n<td>打开</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"coc\">12. <code>coc</code></h4>\n<table>\n<thead>\n<tr class=\"header\">\n<th>快捷键</th>\n<th>操作</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>g + d</code></td>\n<td>到定义的位置</td>\n</tr>\n<tr class=\"even\">\n<td><code>g + r</code></td>\n<td>到引用的地方</td>\n</tr>\n<tr class=\"odd\">\n<td><code>K</code></td>\n<td>显示文档</td>\n</tr>\n<tr class=\"even\">\n<td><code>&lt;LEADER&gt; + rn</code></td>\n<td>重命名</td>\n</tr>\n<tr class=\"odd\">\n<td><code>&lt;LEADER&gt; + qf</code></td>\n<td>快速修复错误</td>\n</tr>\n<tr class=\"even\">\n<td><code>&lt;Ctrl&gt; + p</code></td>\n<td>选择提示的内容</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"fzf\">13. fzf</h4>\n<table>\n<thead>\n<tr class=\"header\">\n<th>快捷键</th>\n<th>操作</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>&lt;LEADER&gt; + ff</code></td>\n<td>搜索文件</td>\n</tr>\n<tr class=\"even\">\n<td><code>&lt;LEADER&gt; + hh</code></td>\n<td>搜索历史</td>\n</tr>\n<tr class=\"odd\">\n<td><code>&lt;LEADER&gt; + hc</code></td>\n<td>搜索命令行</td>\n</tr>\n<tr class=\"even\">\n<td><code>&lt;LEADER&gt; + ma</code></td>\n<td>键值对</td>\n</tr>\n<tr class=\"odd\">\n<td><code>Ctrl + d</code></td>\n<td>删除<code>buffers</code></td>\n</tr>\n<tr class=\"even\">\n<td><code>&lt;LEADER&gt; + mk</code></td>\n<td>打开所有标签</td>\n</tr>\n<tr class=\"odd\">\n<td><code>&lt;LEADER&gt; + tw</code></td>\n<td>打开所有窗口</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"nerdcommenter\">14 nerdcommenter</h4>\n<table>\n<thead>\n<tr class=\"header\">\n<th>快捷键</th>\n<th>操作</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>&lt;LEADER&gt; cc</code></td>\n<td>注释</td>\n</tr>\n<tr class=\"even\">\n<td><code>&lt;LEADER&gt;cu</code></td>\n<td>取消注释</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"修改函数参数\">15 修改函数参数</h4>\n<table>\n<thead>\n<tr class=\"header\">\n<th>快捷键</th>\n<th>操作</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>f(lct,</code></td>\n<td>修改第一个函数参数</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"vimspector代码调试\">16 vimspector代码调试</h4>\n<table>\n<thead>\n<tr class=\"header\">\n<th>快捷键</th>\n<th>操作</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>&lt;LEADER&gt;vs</code></td>\n<td>生成<code>vimspector.json</code>文件</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"buffer切换\">17 buffer切换</h4>\n<table>\n<thead>\n<tr class=\"header\">\n<th>快捷键</th>\n<th>操作</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>&lt;LEADER&gt; + 1</code></td>\n<td>去到上个<code>buffer</code></td>\n</tr>\n<tr class=\"even\">\n<td><code>&lt;LEADER&gt; + 2</code></td>\n<td>去到下个<code>buffer</code></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"markdowm-preview\">18 markdowm-preview</h4>\n<table>\n<thead>\n<tr class=\"header\">\n<th>快捷键</th>\n<th>操作</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>&lt;LEADER&gt; + mp</code></td>\n<td>预览markdowm</td>\n</tr>\n<tr class=\"even\">\n<td><code>&lt;LEADER&gt; + ms</code></td>\n<td>停止预览markdowm</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"vimwikimarkdowm文件管理\">19 vimwiki（markdowm文件管理）</h4>\n<table>\n<thead>\n<tr class=\"header\">\n<th>快捷键</th>\n<th>操作</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>&lt;LEADER&gt; + ww</code></td>\n<td>打开默认的wiki目录文件</td>\n</tr>\n<tr class=\"even\">\n<td><code>&lt;LEADER&gt; + wt</code></td>\n<td>在新tab中打开wiki目录文件</td>\n</tr>\n<tr class=\"odd\">\n<td><code>&lt;LEADER&gt; + wd</code></td>\n<td>删除当前wiki文件</td>\n</tr>\n<tr class=\"even\">\n<td><code>Enter</code></td>\n<td>创建或打开wiki文件</td>\n</tr>\n<tr class=\"odd\">\n<td><code>&lt;Shift-Enter&gt;</code></td>\n<td>先上下分屏再打开 wiki 链接（若非链接则先创建）</td>\n</tr>\n<tr class=\"even\">\n<td><code>&lt;Ctrl-Enter&gt;</code></td>\n<td>先左右分屏再打开 wiki 链接（若非链接则先创建）</td>\n</tr>\n<tr class=\"odd\">\n<td><code>&lt;Backspace&gt;</code></td>\n<td>返回之前浏览的 wiki 文件</td>\n</tr>\n<tr class=\"even\">\n<td><code>&lt;Tab&gt;</code></td>\n<td>跳到本文件中下一个 wiki 链接</td>\n</tr>\n<tr class=\"odd\">\n<td><code>&lt;Shift-Tab&gt;</code></td>\n<td>跳到本文件中上一个 wiki 链接</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"改变了的光标移动方式\">改变了的光标移动方式</h4>\n<table>\n<thead>\n<tr class=\"header\">\n<th>快捷键</th>\n<th>操作</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>Ctro + o</code></td>\n<td>回到上一个位置</td>\n</tr>\n<tr class=\"even\">\n<td><code>&lt;LEADER&gt; + e</code></td>\n<td>打开<code>nerdTree</code></td>\n</tr>\n<tr class=\"odd\">\n<td><code>shift + a</code></td>\n<td>去到行尾，并进入写入模式</td>\n</tr>\n<tr class=\"even\">\n<td><code>shift + i</code></td>\n<td>去到行首，并进入写入模式</td>\n</tr>\n<tr class=\"odd\">\n<td><code>0</code></td>\n<td>将光标移至当前行的第一个字符</td>\n</tr>\n<tr class=\"even\">\n<td><code>$</code></td>\n<td>将光标移至当前行的最后一个字符</td>\n</tr>\n<tr class=\"odd\">\n<td><code>Ctrl + u</code></td>\n<td>将视角向上移动五行而不移动光标</td>\n</tr>\n<tr class=\"even\">\n<td><code>Ctrl + e</code></td>\n<td>将视角向下移动五行而不移动光标</td>\n</tr>\n<tr class=\"odd\">\n<td><code>W</code></td>\n<td>将光标移至五个词后的末尾</td>\n</tr>\n<tr class=\"even\">\n<td><code>B</code></td>\n<td>将光标移至五个词前的开头</td>\n</tr>\n</tbody>\n</table>\n","categories":["nvim"],"tags":["nvim"]},{"title":"static","url":"/2022/04/18/static/","content":"<p>#static</p>\n<p>当与不同类型一起使用时，Static关键字具有不同的含义。我们可以使用static关键字：</p>\n<p><strong>静态变量：</strong> 函数中的变量，类中的变量</p>\n<p><strong>静态类的成员：</strong> 类对象和类中的函数</p>\n<p>现在让我们详细看一下静态的这些用法：</p>\n<span id=\"more\"></span>\n<h2 id=\"静态变量\">静态变量：</h2>\n<ul>\n<li><strong>函数中的静态变量：</strong></li>\n</ul>\n<p>当变量声明为static时，空间<strong>将在程序的生命周期内分配</strong>。即使多次调用该函数，静态变量的空间也<strong>只分配一次</strong>，前一次调用中的变量值通过下一次函数调用传递。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span> </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span> </span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">demo</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; </span><br><span class=\"line\">\t<span class=\"comment\">// static variable </span></span><br><span class=\"line\">\t<span class=\"type\">static</span> <span class=\"type\">int</span> count = <span class=\"number\">0</span>; </span><br><span class=\"line\">\tcout &lt;&lt; count &lt;&lt; <span class=\"string\">&quot; &quot;</span>; </span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// value is updated and </span></span><br><span class=\"line\">\t<span class=\"comment\">// will be carried to next </span></span><br><span class=\"line\">\t<span class=\"comment\">// function calls </span></span><br><span class=\"line\">\tcount++; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; </span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">5</span>; i++)\t </span><br><span class=\"line\">\t\t<span class=\"built_in\">demo</span>(); </span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>; </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<blockquote>\n<p>0 1 2 3 4</p>\n</blockquote>\n<ul>\n<li>类中的静态变量</li>\n</ul>\n<p>由于声明为static的变量只被初始化一次，因为它们在单独的静态存储中分配了空间，因此类中的静态变量<strong>由对象共享。</strong>对于不同的对象，不能有相同静态变量的多个副本。也是因为这个原因，<strong>静态变量不能使用构造函数初始化。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span> </span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Apple</span> </span><br><span class=\"line\">&#123; </span><br><span class=\"line\"><span class=\"keyword\">public</span>: </span><br><span class=\"line\">\t<span class=\"type\">static</span> <span class=\"type\">int</span> i; </span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">Apple</span>() </span><br><span class=\"line\">\t&#123; </span><br><span class=\"line\">\t\t<span class=\"comment\">// Do nothing </span></span><br><span class=\"line\">\t&#125;; </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; </span><br><span class=\"line\">Apple obj1; </span><br><span class=\"line\">Apple obj2; </span><br><span class=\"line\">obj1.i =<span class=\"number\">2</span>; </span><br><span class=\"line\">obj2.i = <span class=\"number\">3</span>; </span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"comment\">// prints value of i </span></span><br><span class=\"line\">cout &lt;&lt; obj1.i&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;obj2.i; </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p>您可以在上面的程序中看到我们已经尝试为多个对象创建静态变量i的多个副本。但这并没有发生。因此，<strong>类中的静态变量应由用户使用类外的类名和范围解析运算符显式初始化</strong>，如下所示：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span> </span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Apple</span> </span><br><span class=\"line\">&#123; </span><br><span class=\"line\"><span class=\"keyword\">public</span>: </span><br><span class=\"line\">\t<span class=\"type\">static</span> <span class=\"type\">int</span> i; </span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">Apple</span>() </span><br><span class=\"line\">\t&#123; </span><br><span class=\"line\">\t\t<span class=\"comment\">// Do nothing </span></span><br><span class=\"line\">\t&#125;; </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> Apple::i = <span class=\"number\">1</span>; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; </span><br><span class=\"line\">\tApple obj; </span><br><span class=\"line\">\t<span class=\"comment\">// prints value of i </span></span><br><span class=\"line\">\tcout &lt;&lt; obj.i; </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<blockquote>\n<p>1</p>\n</blockquote>\n<h2 id=\"静态成员\">静态成员</h2>\n<ul>\n<li><strong>类对象为静态</strong></li>\n</ul>\n<p>就像变量一样，对象也在声明为static时具有范围，直到程序的生命周期。</p>\n<p>考虑以下程序，其中对象是非静态的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span> </span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Apple</span> </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">\t<span class=\"type\">int</span> i; </span><br><span class=\"line\">\t<span class=\"keyword\">public</span>: </span><br><span class=\"line\">\t\t<span class=\"built_in\">Apple</span>() </span><br><span class=\"line\">\t\t&#123; </span><br><span class=\"line\">\t\t\ti = <span class=\"number\">0</span>; </span><br><span class=\"line\">\t\t\tcout &lt;&lt; <span class=\"string\">&quot;Inside Constructor\\n&quot;</span>; </span><br><span class=\"line\">\t\t&#125; </span><br><span class=\"line\">\t\t~<span class=\"built_in\">Apple</span>() </span><br><span class=\"line\">\t\t&#123; </span><br><span class=\"line\">\t\t\tcout &lt;&lt; <span class=\"string\">&quot;Inside Destructor\\n&quot;</span>; </span><br><span class=\"line\">\t\t&#125; </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; </span><br><span class=\"line\">\t<span class=\"type\">int</span> x = <span class=\"number\">0</span>; </span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (x==<span class=\"number\">0</span>) </span><br><span class=\"line\">\t&#123; </span><br><span class=\"line\">\t\tApple obj; </span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;End of main\\n&quot;</span>; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<blockquote>\n<p>Inside Constructor Inside Destructor End of main</p>\n</blockquote>\n<p>在上面的程序中，对象在if块内声明为非静态。因此，变量的范围仅在if块内。因此，当创建对象时，将调用构造函数，并且在if块的控制权越过析构函数的同时调用，因为对象的范围仅在声明它的if块内。\n如果我们将对象声明为静态，现在让我们看看输出的变化。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span> </span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Apple</span> </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">\t<span class=\"type\">int</span> i; </span><br><span class=\"line\">\t<span class=\"keyword\">public</span>: </span><br><span class=\"line\">\t\t<span class=\"built_in\">Apple</span>() </span><br><span class=\"line\">\t\t&#123; </span><br><span class=\"line\">\t\t\ti = <span class=\"number\">0</span>; </span><br><span class=\"line\">\t\t\tcout &lt;&lt; <span class=\"string\">&quot;Inside Constructor\\n&quot;</span>; </span><br><span class=\"line\">\t\t&#125; </span><br><span class=\"line\">\t\t~<span class=\"built_in\">Apple</span>() </span><br><span class=\"line\">\t\t&#123; </span><br><span class=\"line\">\t\t\tcout &lt;&lt; <span class=\"string\">&quot;Inside Destructor\\n&quot;</span>; </span><br><span class=\"line\">\t\t&#125; </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; </span><br><span class=\"line\">\t<span class=\"type\">int</span> x = <span class=\"number\">0</span>; </span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (x==<span class=\"number\">0</span>) </span><br><span class=\"line\">\t&#123; </span><br><span class=\"line\">\t\t<span class=\"type\">static</span> Apple obj; </span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">\tcout &lt;&lt; <span class=\"string\">&quot;End of main\\n&quot;</span>; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<blockquote>\n<p>Inside Constructor End of main Inside Destructor</p>\n</blockquote>\n<p>您可以清楚地看到输出的变化。现在，在main结束后调用析构函数。这是因为静态对象的范围是贯穿程序的生命周期。</p>\n<ul>\n<li><strong>类中的静态函数</strong></li>\n</ul>\n<p>就像类中的静态数据成员或静态变量一样，静态成员函数也不依赖于类的对象。我们被允许使用对象和'.'来调用静态成员函数。但建议使用类名和范围解析运算符调用静态成员。</p>\n<p>允许静态成员函数仅访问静态数据成员或其他静态成员函数，它们无法访问类的非静态数据成员或成员函数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span> </span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Apple</span> </span><br><span class=\"line\">&#123; </span><br><span class=\"line\">    <span class=\"keyword\">public</span>: </span><br><span class=\"line\">        <span class=\"comment\">// static member function </span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">printMsg</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\">        </span>&#123;</span><br><span class=\"line\">            cout&lt;&lt;<span class=\"string\">&quot;Welcome to Apple!&quot;</span>; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// main function </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">// invoking a static member function </span></span><br><span class=\"line\">    Apple::<span class=\"built_in\">printMsg</span>(); </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<blockquote>\n<p>Welcome to Apple!</p>\n</blockquote>\n<p><strong>限定访问范围</strong>\nstatic还有限定访问范围的作用（类似于匿名名字空间）。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// source1.cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"type\">void</span> <span class=\"title\">sayHello</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">char</span>* msg = <span class=\"string\">&quot;Hello World!\\n&quot;</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">sayHello</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// source2.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">char</span>* msg;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">sayHello</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s&quot;</span>, msg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>g++对于上面两个代码文件是可以正常编译并且打印Hello\nWorld!，但如果给source1.cpp中的msg加上static，则会导致undefined\nreference to 'msg'的编译错误：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// source1.cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"type\">void</span> <span class=\"title\">sayHello</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">char</span>* msg = <span class=\"string\">&quot;Hello World!\\n&quot;</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">sayHello</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["C++"],"tags":["C++","CPlusPlusThings"]},{"title":"p1141 01迷宫","url":"/2019/06/11/p1141-01%E8%BF%B7%E5%AE%AB/","content":"<p><a\nhref=\"https://www.luogu.org/problemnew/show/P1141\">题目链接</a></p>\n<h2 id=\"题目描述\">题目描述</h2>\n<p>有一个仅由数字0与1组成的n×n格迷宫。若你位于一格0上，那么你可以移动到相邻44格中的某一格1上，同样若你位于一格1上，那么你可以移动到相邻44格中的某一格0上。</p>\n<p>你的任务是：对于给定的迷宫，询问从某一格开始能移动到多少个格子（包含自身）。</p>\n<h2 id=\"输入输出格式\">输入输出格式</h2>\n<p>输入格式：</p>\n<p>第1行为两个正整数n,m。</p>\n<p>下面n行，每行n个字符，字符只可能是0或者1，字符之间没有空格。</p>\n<p>接下来m行，每行2个用空格分隔的正整数i,j，对应了迷宫中第i行第j列的一个格子，询问从这一格开始能移动到多少格。</p>\n<p>输出格式：</p>\n<p>m<em>m</em>行，对于每个询问输出相应答案。</p>\n<span id=\"more\"></span>\n<h2 id=\"输入输出样例\">输入输出样例</h2>\n<p>输入样例#1:</p>\n<blockquote>\n<p>2 2</p>\n<p>01</p>\n<p>10</p>\n<p>1 1</p>\n<p>2 2</p>\n</blockquote>\n<p>输出样例#1:</p>\n<blockquote>\n<p>4</p>\n<p>4</p>\n</blockquote>\n<h2 id=\"解题思路\">解题思路</h2>\n<p>一开始我直接就dfs直接搜了，但是TLE了3个数据。</p>\n<p>代码如下:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> maxn=<span class=\"number\">1010</span>;</span><br><span class=\"line\"><span class=\"type\">char</span> a[maxn][maxn];</span><br><span class=\"line\"><span class=\"type\">int</span> dir[][<span class=\"number\">2</span>]=&#123;&#123;<span class=\"number\">-1</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">1</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">0</span>,<span class=\"number\">-1</span>&#125;,&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>&#125;&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> vis[maxn][maxn];</span><br><span class=\"line\"><span class=\"type\">int</span> n,m;</span><br><span class=\"line\"><span class=\"type\">int</span> ans;</span><br><span class=\"line\"><span class=\"type\">int</span> max_ans;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y,<span class=\"type\">char</span> temp)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    vis[x][y]=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x&lt;<span class=\"number\">1</span>||x&gt;n||y&lt;<span class=\"number\">1</span>||y&gt;n) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> dx=x+dir[i][<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"type\">int</span> dy=y+dir[i][<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dx&gt;<span class=\"number\">0</span>&amp;&amp;dx&lt;=n&amp;&amp;dy&gt;<span class=\"number\">0</span>&amp;&amp;dy&lt;=n&amp;&amp;vis[dx][dy]==<span class=\"number\">0</span>&amp;&amp;a[dx][dy]!=temp)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(vis[dx][dy]==<span class=\"number\">0</span>) ans++;</span><br><span class=\"line\">                vis[dx][dy]++;</span><br><span class=\"line\">                temp=a[dx][dy];</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(ans&gt;max_ans) max_ans=ans;</span><br><span class=\"line\">                <span class=\"built_in\">dfs</span>(dx,dy,temp);</span><br><span class=\"line\">                temp=a[x][y];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> start,end;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)</span><br><span class=\"line\">            cin&gt;&gt;a[i][j];</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(m--)&#123;</span><br><span class=\"line\">        cin&gt;&gt;start&gt;&gt;end;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(vis,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(vis));</span><br><span class=\"line\">        ans=<span class=\"number\">1</span>;max_ans=<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(start,end,a[start][end]);</span><br><span class=\"line\">        cout&lt;&lt;max_ans&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>听大佬说可以用并查集可以直接写，但是不会（无奈）</p>\n<p>想了许久，发现如果每次查询一个就重新查会TLE,那么是不是只要我们查过了的我们就标志下，下次就不用再查了.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bit/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> maxn=<span class=\"number\">1000010</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> x,y,f[<span class=\"number\">1010</span>][<span class=\"number\">1010</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,ans[maxn];</span><br><span class=\"line\"><span class=\"type\">char</span> s[<span class=\"number\">1010</span>][<span class=\"number\">1010</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> r,<span class=\"type\">int</span> c,<span class=\"type\">int</span> z,<span class=\"type\">int</span> l)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(r&lt;<span class=\"number\">0</span>||r&gt;=n||c&lt;<span class=\"number\">0</span>||c&gt;=n||f[r][c]!=<span class=\"number\">-1</span>||s[r][c]-<span class=\"string\">&#x27;0&#x27;</span>!=z) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    f[r][c]=l;ans[l]++;<span class=\"comment\">//记录个数</span></span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(r<span class=\"number\">-1</span>,c,!z,l);</span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(r+<span class=\"number\">1</span>,c,!z,l);</span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(r,c<span class=\"number\">-1</span>,!z,l);</span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(r,c+<span class=\"number\">1</span>,!z,l);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;n;j++)</span><br><span class=\"line\">            cin&gt;&gt;s[i][j];</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(f,<span class=\"number\">-1</span>,<span class=\"built_in\">sizeof</span>(f));</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;m;i++)&#123;</span><br><span class=\"line\">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">        x--;y--;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(f[x][y]==<span class=\"number\">-1</span>) <span class=\"built_in\">dfs</span>(x,y,s[x][y]-<span class=\"string\">&#x27;0&#x27;</span>,i);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> ans[i]=ans[f[x][y]];<span class=\"comment\">//已经找过了</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;m;i++)</span><br><span class=\"line\">        cout&lt;&lt;ans[i]&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","categories":["dfs"],"tags":["dfs(优化)"]},{"title":"stringstream读取字符串","url":"/2022/04/09/stringstream%E8%AF%BB%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2/","content":"<h1 id=\"stringstream-流\">stringstream 流</h1>\n<p>首先引入头文件</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sstream&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p>然后定义一个stringstream对象，用来输入输出，这个对象既可以把数字变成字符串，也可以把字符串变成数字，甚至可以分割被空格、制表符等符号分割的字符串（简单来说就是去空格和换行）</p>\n<span id=\"more\"></span>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">字符串转数字：</span><br><span class=\"line\">stringstream stream;</span><br><span class=\"line\">string result=<span class=\"string\">&quot;10000&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n=<span class=\"number\">0</span>;</span><br><span class=\"line\">stream&lt;&lt;result;</span><br><span class=\"line\">stream&gt;&gt;n;<span class=\"comment\">//n等于10000</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">数字转字符串：</span><br><span class=\"line\">stringstream stream;</span><br><span class=\"line\">string result;</span><br><span class=\"line\"><span class=\"type\">int</span> i = <span class=\"number\">1000</span>;</span><br><span class=\"line\">stream &lt;&lt; i;  <span class=\"comment\">// 将int输入流</span></span><br><span class=\"line\">stream &gt;&gt; result;  <span class=\"comment\">// 从stream中抽取前面插入的int值</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">stringstream构造函数用法：</span><br><span class=\"line\">string result=<span class=\"string\">&quot;10000&quot;</span>;</span><br><span class=\"line\">stringstream stream（result）;（可以是字符串也可以是数字，总之后面直接输入到目标变量里面）</span><br><span class=\"line\"><span class=\"type\">int</span> n=<span class=\"number\">0</span>;</span><br><span class=\"line\">stream&gt;&gt;n;<span class=\"comment\">//n等于10000</span></span><br></pre></td></tr></table></figure>\n<p>这里我们重点讲下分割,去空格和换行（<strong>因为stringstream是通过空格判断一个字符串的结束</strong>）：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">string str=<span class=\"string\">&quot;i am a boy&quot;</span>;  </span><br><span class=\"line\"><span class=\"function\">stringstream <span class=\"title\">stream</span><span class=\"params\">(str)</span></span>;  </span><br><span class=\"line\">string s;  <span class=\"comment\">//存储不含空格和换行的字符串</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(stream&gt;&gt;s)  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">     cout&lt;&lt;s&lt;&lt;endl;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">输出结果：</span><br><span class=\"line\">i</span><br><span class=\"line\">am</span><br><span class=\"line\">a</span><br><span class=\"line\">boy</span><br></pre></td></tr></table></figure>\n<p>这里补充一点小知识，我们在使用<code>getline(cin,str)</code>之前，如果前面使用了<code>cin &gt;&gt; s</code>,那么我们必须<code>xin.ignore()</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">string s;</span><br><span class=\"line\">cin &gt;&gt; s;</span><br><span class=\"line\">cin.<span class=\"built_in\">ignore</span>(); <span class=\"comment\">// 必须使用，要不然getline读不到东西</span></span><br><span class=\"line\">string str;</span><br><span class=\"line\"><span class=\"built_in\">getline</span>(cin, str);</span><br></pre></td></tr></table></figure>\n","categories":["字符串","stringstream"],"tags":["字符串","stringstream"]},{"title":"Mac上sublime Text配置万能头文件","url":"/2019/05/04/sublime-Text%E9%85%8D%E7%BD%AE%E4%B8%87%E8%83%BD%E5%A4%B4%E6%96%87%E4%BB%B6/","content":"<p>首先我们要看下头文件所在位置，在访达中按组合键\n<code>shift + commond + G</code>访问隐藏的文件，在弹出的框中输入<code>/usr/local</code></p>\n<span id=\"more\"></span>\n<p><img src=\"sublime-Text配置万能头文件/1.png\" /></p>\n<p>然后找到<code>include</code>这个文件夹，查看它的属性（显示简介）</p>\n<p><img src=\"sublime-Text配置万能头文件/2.png\" /></p>\n<p>权限大概像我这样就可以了，没问题之后，进入<code>include</code>这个文件夹，并且在里面建立一个<code>bits</code>文件夹，在文件夹里建一个<code>stdc++.h</code>的头文件，<code>stdc++.h</code>内容如下:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// C++ includes used for precompiling -*- C++ -*-</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Copyright (C) 2003-2014 Free Software Foundation, Inc.</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// This file is part of the GNU ISO C++ Library.  This library is free</span></span><br><span class=\"line\"><span class=\"comment\">// software; you can redistribute it and/or modify it under the</span></span><br><span class=\"line\"><span class=\"comment\">// terms of the GNU General Public License as published by the</span></span><br><span class=\"line\"><span class=\"comment\">// Free Software Foundation; either version 3, or (at your option)</span></span><br><span class=\"line\"><span class=\"comment\">// any later version.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// This library is distributed in the hope that it will be useful,</span></span><br><span class=\"line\"><span class=\"comment\">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span></span><br><span class=\"line\"><span class=\"comment\">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span></span><br><span class=\"line\"><span class=\"comment\">// GNU General Public License for more details.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Under Section 7 of GPL version 3, you are granted additional</span></span><br><span class=\"line\"><span class=\"comment\">// permissions described in the GCC Runtime Library Exception, version</span></span><br><span class=\"line\"><span class=\"comment\">// 3.1, as published by the Free Software Foundation.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// You should have received a copy of the GNU General Public License and</span></span><br><span class=\"line\"><span class=\"comment\">// a copy of the GCC Runtime Library Exception along with this program;</span></span><br><span class=\"line\"><span class=\"comment\">// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see</span></span><br><span class=\"line\"><span class=\"comment\">// &lt;http://www.gnu.org/licenses/&gt;.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** @file stdc++.h</span></span><br><span class=\"line\"><span class=\"comment\"> *  This is an implementation file for a precompiled header.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 17.4.1.2 Headers</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// C</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> _GLIBCXX_NO_ASSERT</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cassert&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cctype&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cerrno&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cfloat&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;ciso646&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;climits&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;clocale&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;csetjmp&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;csignal&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdarg&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstddef&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdlib&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;ctime&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> __cplusplus &gt;= 201103L</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;ccomplex&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cfenv&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cinttypes&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdbool&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdint&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;ctgmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cwchar&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cwctype&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// C++</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bitset&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;complex&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;deque&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;exception&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fstream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iomanip&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;ios&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iosfwd&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;istream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iterator&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;limits&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;list&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;locale&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;memory&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;new&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;numeric&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;ostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;set&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sstream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdexcept&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;streambuf&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;typeinfo&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;utility&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;valarray&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> __cplusplus &gt;= 201103L</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;array&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;atomic&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;chrono&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;condition_variable&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;forward_list&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;future&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;initializer_list&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;mutex&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;random&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;ratio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;regex&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;scoped_allocator&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;system_error&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;tuple&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;typeindex&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;type_traits&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unordered_map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unordered_set&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这样我们就成功了。</p>\n","tags":["bits/stdc++/.h"]},{"title":"“中文分词jieba”","url":"/2019/06/09/%E2%80%9C%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8Djieba%E2%80%9D/","content":"<p>first：安装中文分词库, 在命令行中输入</p>\n<blockquote>\n<p>pip3 install jieba</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> jieba</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>textlist=jieba.lcut(<span class=\"string\">&#x27;动力学和电磁学&#x27;</span>)</span><br><span class=\"line\">[<span class=\"string\">&#x27;动力学&#x27;</span>,<span class=\"string\">&#x27;和&#x27;</span>,<span class=\"string\">&#x27;电磁学&#x27;</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>string = <span class=\"string\">&quot; &quot;</span>.join(textlist)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>string</span><br><span class=\"line\">‘动力学 和 电磁学’</span><br></pre></td></tr></table></figure>\n<p>以上代码将一句完整的中文字符串转换成了以空格分隔的词组成的字符串，而后者是绘制词云时generate()方法要求传入的参数。</p>\n<span id=\"more\"></span>\n<h4 id=\"中文分词库jieba的常用方法\">中文分词库jieba的常用方法</h4>\n<p>精确模式（最常用，只会这个就行）：每个字只用一遍，不存在冗余词汇。jieba.lcut('动力学和电磁学')</p>\n<p>全模式：把每个字可能形成的词汇都提取出来，存在冗余。jieba.lcut('动力学和电磁学',cut_all=True)</p>\n<p>搜索引擎模式：将全模式分词的结果从短到长排列好。jieba.lcut_for_search('动力学和电磁学')</p>\n<p>以下命令演示了三种分词模式及结果，精确模式是最常用的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> jieba</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>textlist1 = jieba.lcut(<span class=\"string\">&#x27;动力学和电磁学&#x27;</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>textlist1</span><br><span class=\"line\">[<span class=\"string\">&#x27;动力学&#x27;</span>, <span class=\"string\">&#x27;和&#x27;</span>, <span class=\"string\">&#x27;电磁学&#x27;</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>textlist2 = jieba.lcut(<span class=\"string\">&#x27;动力学和电磁学&#x27;</span>,cut_all=<span class=\"literal\">True</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>textlist2</span><br><span class=\"line\">[<span class=\"string\">&#x27;动力&#x27;</span>, <span class=\"string\">&#x27;动力学&#x27;</span>, <span class=\"string\">&#x27;力学&#x27;</span>, <span class=\"string\">&#x27;和&#x27;</span>, <span class=\"string\">&#x27;电磁&#x27;</span>, <span class=\"string\">&#x27;电磁学&#x27;</span>, <span class=\"string\">&#x27;磁学&#x27;</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>textlist3 = jieba.lcut_for_search(<span class=\"string\">&#x27;动力学和电磁学&#x27;</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>textlist3</span><br><span class=\"line\">[<span class=\"string\">&#x27;动力&#x27;</span>, <span class=\"string\">&#x27;力学&#x27;</span>, <span class=\"string\">&#x27;动力学&#x27;</span>, <span class=\"string\">&#x27;和&#x27;</span>, <span class=\"string\">&#x27;电磁&#x27;</span>, <span class=\"string\">&#x27;磁学&#x27;</span>, <span class=\"string\">&#x27;电磁学&#x27;</span>]</span><br></pre></td></tr></table></figure>\n<h4 id=\"学校介绍词云\">学校介绍词云</h4>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> jieba</span><br><span class=\"line\"><span class=\"keyword\">import</span> wordcloud</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#构建词云对象</span></span><br><span class=\"line\">w=wordcloud.WordCloud(width=<span class=\"number\">1000</span>,</span><br><span class=\"line\">                      height=<span class=\"number\">700</span>,</span><br><span class=\"line\">                      background_color=<span class=\"string\">&#x27;white&#x27;</span>,</span><br><span class=\"line\">                      font_path=<span class=\"string\">&#x27;Songti.ttc&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">#调用jieba的lcut()方法对原始文本进行中文分词，得到string</span></span><br><span class=\"line\">txt=<span class=\"string\">&#x27;河南理工大学（Henan Polytechnic University）位于河南省焦作市，是中国第一所矿业高等学府、河南省建立最早的高等学校，为河南省与应急管理部共建高校、河南省属重点大学。&#x27;</span></span><br><span class=\"line\">textlist=jieba.lcut(txt)</span><br><span class=\"line\">string=<span class=\"string\">&quot; &quot;</span>.join(textlist)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#将string变量传入到w的generate()方法，给词云输入文字</span></span><br><span class=\"line\">w.generate(string)</span><br><span class=\"line\"><span class=\"comment\">#将词云图片导出到当前文件夹</span></span><br><span class=\"line\">w.to_file(<span class=\"string\">&#x27;example4.png&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<p><img src=\"“中文分词jieba”/example4.png\" /></p>\n<h4 id=\"读取文本\">读取文本</h4>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> jieba</span><br><span class=\"line\"><span class=\"keyword\">import</span> wordcloud</span><br><span class=\"line\"></span><br><span class=\"line\">w=wordcloud.WordCloud(width=<span class=\"number\">1000</span>,</span><br><span class=\"line\">                      height=<span class=\"number\">700</span>,</span><br><span class=\"line\">                      background_color=<span class=\"string\">&#x27;white&#x27;</span>,</span><br><span class=\"line\">                      font_path=<span class=\"string\">&#x27;Songti.ttc&#x27;</span>)</span><br><span class=\"line\">f=<span class=\"built_in\">open</span>(<span class=\"string\">&#x27;/Users/SJCHEN/Downloads/zihaowordcloud-master/code/关于实施乡村振兴战略的意见.txt&#x27;</span>,encoding=<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\">txt=f.read()</span><br><span class=\"line\">textlist=jieba.lcut(txt)</span><br><span class=\"line\">string=<span class=\"string\">&quot; &quot;</span>.join(textlist)</span><br><span class=\"line\"></span><br><span class=\"line\">w.generate(string)</span><br><span class=\"line\">w.to_file(<span class=\"string\">&#x27;example5.png&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<p><img src=\"“中文分词jieba”/example5.png\" /></p>\n","categories":["python","词云"],"tags":["python","词云","jieba"]},{"title":"下一个排列","url":"/2022/04/18/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/","content":"<h1 id=\"下一个排列\"><a\nhref=\"https://leetcode-cn.com/problems/next-permutation/\">31.\n下一个排列</a></h1>\n<p>整数数组的一个 排列 就是将其所有成员以序列或线性顺序排列。</p>\n<p>例如，<code>arr = [1,2,3]</code>，以下这些都可以视作 arr\n的排列：<code>[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1]</code>。 整数数组的\n下一个排列\n是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的\n下一个排列\n就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>\n<p>例如，<code>arr = [1,2,3]</code>的下一个排列是 <code>[1,3,2]</code>。\n类似地，<code>arr = [2,3,1]</code>的下一个排列是 <code>[3,1,2]</code>。\n而 <code>arr = [3,2,1]</code> 的下一个排列是 <code>[1,2,3]</code> ，因为\n<code>[3,2,1]</code>不存在一个字典序更大的排列。 给你一个整数数组\n<code>nums</code> ，找出 <code>nums</code>的下一个排列。</p>\n<p>必须 原地 修改，只允许使用额外常数空间。</p>\n<h2 id=\"示例\">示例：</h2>\n<blockquote>\n<p>输入：nums = [1,2,3] 输出：[1,3,2]</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"思路\">思路：</h3>\n<p>这里考察我们对<code>next_permutation</code>函数的实现。我们直接调用这个函数就可以解决，但是我们还是希望可以自己手写一下这个函数。</p>\n<p>“下一个排列”的定义是：给定数字序列的字典序中下一个更大的排列。如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>\n<p>我们以<code>1,2,3</code>为例，我们借用<code>next_permutation</code>函数输出全部排列。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ll;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">double</span> ld;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; pii;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> vector&lt;<span class=\"type\">int</span>&gt; vi;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">nextPermutation</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); i++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(i == nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                    cout &lt;&lt; nums[i] &lt;&lt; endl;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> cout &lt;&lt; nums[i] &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">while</span>(<span class=\"built_in\">next_permutation</span>(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> arr[<span class=\"number\">3</span>] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">nums</span><span class=\"params\">(arr, arr + <span class=\"number\">3</span>)</span></span>;</span><br><span class=\"line\">    Solution a;</span><br><span class=\"line\">    a.<span class=\"built_in\">nextPermutation</span>(nums);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); i++)&#123;</span><br><span class=\"line\">        cout &lt;&lt; nums[i] &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果为：</p>\n<blockquote>\n<p>1 2 3 1 3 2 2 1 3 2 3 1 3 1 2 3 2 1 1 2 3</p>\n</blockquote>\n<h4 id=\"算法推导\">算法推导:</h4>\n<p>可以把它抽象成一个整数，比如123下一个比它大的最小数就是132，我们为了得到这个数，肯定是考虑从后面开始遍历。</p>\n<p>1、先找出最大的索引 k 满足 nums[k] &lt;\nnums[k+1]，如果不存在，就翻转整个数组，结束。</p>\n<p>2、再找出另一个最大索引 l 满足 nums[l] &gt; nums[k]；</p>\n<p>3、交换 nums[l] 和 nums[k]；</p>\n<p>4、最后翻转 nums[k+1:]</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">nextPermutation</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums.<span class=\"built_in\">size</span>() &lt;= <span class=\"number\">1</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> k = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>, j = i - <span class=\"number\">1</span>; j &gt;= <span class=\"number\">0</span>; i--, j--)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[j] &lt; nums[i])&#123;</span><br><span class=\"line\">                k = j;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(k == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">reverse</span>(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[i] &gt; nums[k])&#123;</span><br><span class=\"line\">                <span class=\"built_in\">swap</span>(nums[k], nums[i]);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">reverse</span>(nums.<span class=\"built_in\">begin</span>() + k + <span class=\"number\">1</span>, nums.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["数组","双指针"],"tags":["数组","双指针"]},{"title":"152 乘积最大子数组","url":"/2022/04/08/%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/","content":"<p>#<a\nhref=\"https://leetcode-cn.com/problems/maximum-product-subarray/\">152.\n乘积最大子数组</a></p>\n<p>给你一个整数数组 nums\n，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>\n<p>测试用例的答案是一个 32-位 整数。</p>\n<p>子数组 是数组的连续子序列。</p>\n<h2 id=\"示例\">示例</h2>\n<blockquote>\n<p>输入: nums = [2,3,-2,4] 输出: 6 解释: 子数组 [2,3] 有最大乘积 6。</p>\n</blockquote>\n<h3 id=\"思路\">思路：</h3>\n<p>乘积无非三种组合</p>\n<ul>\n<li>全是正的</li>\n<li>全是负的</li>\n<li>有正有负</li>\n</ul>\n<p>其实我们只需要考虑第三种情况就可以了，我们发现如果，出现负数，我们之前的最大值就会变成最小值，最小值变为最大值。</p>\n<p>所以我们不关要维护最大值，还需要维护个最小值。</p>\n<span id=\"more\"></span>\n<p><img src=\"乘积最大子数组/1.jpg\" /></p>\n<p><img src=\"乘积最大子数组/2.jpg\" /></p>\n<p><img src=\"乘积最大子数组/3.jpg\" /></p>\n<p><img src=\"乘积最大子数组/4.jpg\" /></p>\n<p><img src=\"乘积最大子数组/5.jpg\" /></p>\n<p><img src=\"乘积最大子数组/6.jpg\" /></p>\n<p>综上，我们可以写出如下代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maxProduct</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> res_max = INT_MIN, imax = <span class=\"number\">1</span>, imin = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[i] &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">swap</span>(imax, imin);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            imax = <span class=\"built_in\">max</span>(imax * nums[i], nums[i]);</span><br><span class=\"line\">            imin = <span class=\"built_in\">min</span>(imin * nums[i], nums[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">            res_max = <span class=\"built_in\">max</span>(res_max, imax);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res_max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["动态规划"],"tags":["动态规划","leetcode"]},{"title":"不同路径","url":"/2022/07/31/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/","content":"<h1 id=\"不同路径\"><a\nhref=\"https://leetcode.cn/problems/unique-paths/\">62. 不同路径</a></h1>\n<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start”\n）。</p>\n<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为\n“Finish” ）。</p>\n<p>问总共有多少条不同的路径？</p>\n<h2 id=\"示例\">示例：</h2>\n<p><img\nsrc=\"https://sjchen404.oss-cn-shenzhen.aliyuncs.com/img/2.png\" /></p>\n<blockquote>\n<p>输入：m = 3, n = 7 输出：28</p>\n</blockquote>\n<blockquote>\n<p>输入：m = 3, n = 2 输出：3 解释： 从左上角开始，总共有 3\n条路径可以到达右下角。 1. 向右 -&gt; 向下 -&gt; 向下 2. 向下 -&gt; 向下\n-&gt; 向右 3. 向下 -&gt; 向右 -&gt; 向下</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"思路\">思路：</h3>\n<h4 id=\"方法一备忘录\">方法一：备忘录</h4>\n<p>我们知道最右下角一定是由它的左边或者上边来的。</p>\n<p>所以状态转移方程为：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">dp[x][y] = dp[x - <span class=\"number\">1</span>][y] + dp[x][y - <span class=\"number\">1</span>];</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; memo;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uniquePaths</span><span class=\"params\">(<span class=\"type\">int</span> m, <span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        memo.<span class=\"built_in\">resize</span>(m, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(n, <span class=\"number\">0</span>));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">dp</span>(m - <span class=\"number\">1</span>, n - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dp</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//base case</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x == <span class=\"number\">0</span> &amp;&amp; y == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x &lt; <span class=\"number\">0</span> || y &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(memo[x][y] != <span class=\"number\">0</span>) <span class=\"keyword\">return</span> memo[x][y];</span><br><span class=\"line\"></span><br><span class=\"line\">        memo[x][y] = <span class=\"built_in\">dp</span>(x - <span class=\"number\">1</span>, y) + <span class=\"built_in\">dp</span>(x, y - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> memo[x][y];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二迭代\">方法二：迭代</h4>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">迭代</span></span><br><span class=\"line\"><span class=\"comment\">对于第一行 dp[0][j]，或者第一列 dp[i][0]，由于都是在边界，所以只能为 1</span></span><br><span class=\"line\"><span class=\"comment\">dp[m][n] : 从[0,0] 到 [m,n] 有dp[m][n]条路径</span></span><br><span class=\"line\"><span class=\"comment\">时间复杂度：O(mn)</span></span><br><span class=\"line\"><span class=\"comment\">空间复杂度：O(mn)</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution1</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uniquePaths</span><span class=\"params\">(<span class=\"type\">int</span> m, <span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; <span class=\"built_in\">dp</span>(m, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(n , <span class=\"number\">0</span>));</span><br><span class=\"line\">        <span class=\"comment\">//左边</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++)&#123;</span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//上边</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            dp[<span class=\"number\">0</span>][i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; m; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt; n; j++)&#123;</span><br><span class=\"line\">                dp[i][j] = dp[i - <span class=\"number\">1</span>][j] + dp[i][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m - <span class=\"number\">1</span>][n - <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"不同路径-ii\"><a\nhref=\"https://leetcode.cn/problems/unique-paths-ii/\">63. 不同路径\nII</a></h1>\n<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start”\n）。</p>\n<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为\n“Finish”）。</p>\n<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>\n<p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p>\n<h2 id=\"示例-1\">示例：</h2>\n<p><img\nsrc=\"https://sjchen404.oss-cn-shenzhen.aliyuncs.com/img/2.jpg\" /></p>\n<blockquote>\n<p>输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]] 输出：2 解释：3x3\n网格的正中间有一个障碍物。 从左上角到右下角一共有 2 条不同的路径： 1.\n向右 -&gt; 向右 -&gt; 向下 -&gt; 向下 2. 向下 -&gt; 向下 -&gt; 向右\n-&gt; 向右</p>\n</blockquote>\n<h3 id=\"思路-1\">思路：</h3>\n<p>和上一题的思路一样，只是我们在处理第0行或者第0列时，如果碰到障碍物需要退出，并且在其他位置时需要跳过障碍物，即：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(obstacleGrid[i][j] != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      dp[i][j] = dp[i - <span class=\"number\">1</span>][j] + dp[i][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">uniquePathsWithObstacles</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> m = obstacleGrid.<span class=\"built_in\">size</span>(), n = obstacleGrid[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">dp</span>(m, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(n, <span class=\"number\">0</span>));</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 左边</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(obstacleGrid[i][<span class=\"number\">0</span>] == <span class=\"number\">1</span>)</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 上边</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(obstacleGrid[<span class=\"number\">0</span>][i] == <span class=\"number\">1</span>)</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            dp[<span class=\"number\">0</span>][i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(obstacleGrid[i][j] != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    dp[i][j] = dp[i - <span class=\"number\">1</span>][j] + dp[i][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m - <span class=\"number\">1</span>][n - <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["动态规划"],"tags":["动态规划"]},{"title":"二分查找","url":"/2022/03/06/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","content":"<p>对于寻找左右边界的二分搜索，常见的手法是使用左闭右开的搜索区间，但是为了方便记忆，全部统一为两端都闭。</p>\n<span id=\"more\"></span>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">binary_search</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> left = <span class=\"number\">0</span>, right = nums.length - <span class=\"number\">1</span>; </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(left &lt;= right) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> mid = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[mid] &lt; target) &#123;</span><br><span class=\"line\">            left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &gt; target) &#123;</span><br><span class=\"line\">            right = mid - <span class=\"number\">1</span>; </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[mid] == target) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 直接返回</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//左边界</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">left_bound</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> left = <span class=\"number\">0</span>, right = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left &lt;= right) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> mid = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[mid] &lt; target) &#123;</span><br><span class=\"line\">            left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &gt; target) &#123;</span><br><span class=\"line\">            right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] == target) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 别返回，锁定左侧边界</span></span><br><span class=\"line\">            right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 最后要检查 left 越界的情况</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left &gt;= nums.length || nums[left] != target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//右边界</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">right_bound</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> left = <span class=\"number\">0</span>, right = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left &lt;= right) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> mid = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[mid] &lt; target) &#123;</span><br><span class=\"line\">            left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &gt; target) &#123;</span><br><span class=\"line\">            right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] == target) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 别返回，锁定右侧边界</span></span><br><span class=\"line\">            left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 最后要检查 right 越界的情况</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (right &lt; <span class=\"number\">0</span> || nums[right] != target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> right;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"在排序数组中查找元素的第一个和最后一个位置\"><a\nhref=\"https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/\">34.\n在排序数组中查找元素的第一个和最后一个位置</a></h1>\n<p>给定一个按照升序排列的整数数组 nums，和一个目标值\ntarget。找出给定目标值在数组中的开始位置和结束位置。</p>\n<p>如果数组中不存在目标值 target，返回 [-1, -1]。</p>\n<p>进阶：</p>\n<p>你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？</p>\n<h2 id=\"示例\">示例：</h2>\n<blockquote>\n<p>输入：nums = [5,7,7,8,8,10], target = 8 输出：[3,4]</p>\n</blockquote>\n<h3 id=\"思路\">思路：</h3>\n<p>二分查找的时间复杂度为<code>O(logN)</code>，我们只需要调用两次，分别查找左边界和右边界。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">searchRange</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;<span class=\"built_in\">left_bound</span>(nums, target), <span class=\"built_in\">right_bound</span>(nums, target)&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">left_bound</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">0</span>, right = nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left &lt;= right)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> mid = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[mid] &lt; target)&#123;</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[mid] &gt; target)&#123;</span><br><span class=\"line\">                right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">              \t<span class=\"comment\">//收缩右边界</span></span><br><span class=\"line\">                right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//检查出界情况</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(left &gt;= nums.<span class=\"built_in\">size</span>() || nums[left] != target)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">right_bound</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">0</span>, right = nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left &lt;= right)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> mid = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[mid] &lt; target)&#123;</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[mid] &gt; target)&#123;</span><br><span class=\"line\">                right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">              \t<span class=\"comment\">//收缩左边界</span></span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//检查出界情况</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(right &lt; <span class=\"number\">0</span> || nums[right] != target)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"搜索插入位置\"><a\nhref=\"https://leetcode-cn.com/problems/search-insert-position/\">35.\n搜索插入位置</a></h1>\n<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>\n<p>请必须使用时间复杂度为 O(log n) 的算法。</p>\n<h2 id=\"示例-1\">示例：</h2>\n<blockquote>\n<p>输入: nums = [1,3,5,6], target = 5 输出: 2</p>\n</blockquote>\n<blockquote>\n<p>输入: nums = [1,3,5,6], target = 2 输出: 1</p>\n</blockquote>\n<h3 id=\"思路-1\">思路：</h3>\n<p>前面我们讲过了数组中寻在目标元素重复的情况，现在是目标元素不存在的情况。</p>\n<p><strong>当目标元素<code>target</code>不存在数组<code>nums</code>中时，搜索左侧边界的二分搜索的返回值可以做以下几种解读：</strong></p>\n<ul>\n<li>返回的这个值是 nums 中⼤于等于 target 的最⼩元素索引。</li>\n<li>返回的这个值是 target 应该插⼊在 nums 中的索引位置。</li>\n<li>返回的这个值是 nums 中⼩于 target 的元素个数。</li>\n</ul>\n<p>⽐如在有序数组 nums = [2,3,5,7] 中搜索 target =\n4，搜索左边界的⼆分算法会返回 2，你带⼊上⾯ 的说法，都是对的。</p>\n<p>我们现在需要的正是第二种</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">searchInsert</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">left_bound</span>(nums, target);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">left_bound</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">0</span>, right = nums.<span class=\"built_in\">size</span>();<span class=\"comment\">//需要注意</span></span><br><span class=\"line\">        <span class=\"comment\">//需要注意不能等于</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left &lt; right)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> mid = left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[mid] &lt; target)&#123;</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[mid] &gt; target)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//这里也需要注意</span></span><br><span class=\"line\">                right = mid;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                right = mid;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>以上几点需要注意，因为我们需要的是要插入的位置。</p>\n","categories":["二分查找"],"tags":["二分查找"]},{"title":"买卖股票问题","url":"/2022/04/09/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/","content":"<p>我们以下面这道题来了解下股票问题这个框架。</p>\n<p>具体可参考<a\nhref=\"https://mp.weixin.qq.com/s/4nqJMIyCKQD7IJ-HI6S3Vg\">labuladong</a></p>\n<p>每天都有三种「选择」：买入，卖出，无操作，我们用\n<code>buy</code>,<code>sell</code>,<code>rest</code>表示三种选择。</p>\n<p>但问题是，并不是每天都可以任意选择这三种选择，因为<code>sell</code>必须在<code>buy</code>之后，<code>buy</code>又必须在<code>sell</code>之后。那么<code>rest</code>操作之后还应该分两种状态：一种是<code>buy</code>之后的<code>rest</code>（持有了股票），一种是<code>sell</code>之后的<code>rest</code>（没有持有股票）。而且别忘了，我们还有交易次数<code>k</code>的限制，就是说你<code>buy</code>还只能在<code>k &gt; 0</code>的前提下操作。</p>\n<p><strong>这个问题的「状态」有三个</strong>，第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态（即之前说的<code>rest</code>的状态，我们不妨用\n1 表示持有，0\n表示没有持有）。然后我们用一个三维数组就可以装下这几种状态的全部组合：</p>\n<span id=\"more\"></span>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">dp[i][k][<span class=\"number\">0</span> <span class=\"keyword\">or</span> <span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"number\">0</span> &lt;= i &lt;= n - <span class=\"number\">1</span>, <span class=\"number\">1</span> &lt;= k &lt;= K</span><br><span class=\"line\">n 为天数，大 K 为交易数的上限，<span class=\"number\">0</span> 和 <span class=\"number\">1</span> 代表是否持有股票。</span><br><span class=\"line\">此问题共 n × K × <span class=\"number\">2</span> 种状态，全部穷举就能搞定。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"number\">0</span> &lt;= i &lt; n:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"number\">1</span> &lt;= k &lt;= K:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> s in &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>&#125;:</span><br><span class=\"line\">            dp[i][k][s] = <span class=\"built_in\">max</span>(buy, sell, rest)</span><br></pre></td></tr></table></figure>\n<p>而且我们可以用自然语言描述出每一个状态的含义，比如说<code>dp[3][2][1]</code>的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行\n2\n次交易。再比如<code>dp[2][3][0]</code>的含义：今天是第二天，我现在手上没有持有股票，至今最多进行\n3 次交易。很容易理解，对吧？</p>\n<p>我们想求的最终答案是<code>dp[n - 1][K][0]</code>，即最后一天，最多允许<code>K</code>次交易，最多获得多少利润。</p>\n<p>读者可能问为什么不是<code>dp[n - 1][K][1]</code>？因为<code>dp[n - 1][K][1]</code>代表到最后一天手上还持有股票，<code>dp[n - 1][K][0]</code>表示最后一天手上的股票已经卖出去了，很显然后者得到的利润一定大于前者。</p>\n<p>记住如何解释「状态」，一旦你觉得哪里不好理解，把它翻译成自然语言就容易理解了。</p>\n<p>现在，我们完成了「状态」的穷举，我们开始思考每种「状态」有哪些「选择」，应该如何更新「状态」。</p>\n<p>只看「持有状态」，可以画个状态转移图：</p>\n<p><img src=\"买卖股票问题/1.png\" /></p>\n<p>通过这个图可以很清楚地看到，每种状态（0 和\n1）是如何转移而来的。根据这个图，我们来写一下状态转移方程：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">dp[i][k][<span class=\"number\">0</span>] = <span class=\"built_in\">max</span>(dp[i<span class=\"number\">-1</span>][k][<span class=\"number\">0</span>], dp[i<span class=\"number\">-1</span>][k][<span class=\"number\">1</span>] + prices[i])</span><br><span class=\"line\">              <span class=\"built_in\">max</span>( 今天选择 rest,        今天选择 sell       )</span><br></pre></td></tr></table></figure>\n<p>解释：今天我没有持有股票，有两种可能，我从这两种可能中求最大利润：</p>\n<p>1、我昨天就没有持有，且截至昨天最大交易次数限制为<code>k</code>；然后我今天选择<code>rest</code>，所以我今天还是没有持有，最大交易次数限制依然为<code>k</code>。</p>\n<p>2、我昨天持有股票，且截至昨天最大交易次数限制为<code>k</code>；但是今天我<code>sell</code>了，所以我今天没有持有股票了，最大交易次数限制依然为<code>k</code>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">dp[i][k][<span class=\"number\">1</span>] = <span class=\"built_in\">max</span>(dp[i<span class=\"number\">-1</span>][k][<span class=\"number\">1</span>], dp[i<span class=\"number\">-1</span>][k<span class=\"number\">-1</span>][<span class=\"number\">0</span>] - prices[i])</span><br><span class=\"line\">              <span class=\"built_in\">max</span>( 今天选择 rest,         今天选择 buy         )</span><br></pre></td></tr></table></figure>\n<p>解释：今天我持有着股票，最大交易次数限制为<code>k</code>，那么对于昨天来说，有两种可能，我从这两种可能中求最大利润：</p>\n<p>1、我昨天就持有着股票，且截至昨天最大交易次数限制为<code>k</code>；然后今天选择<code>rest</code>，所以我今天还持有着股票，最大交易次数限制依然为<code>k</code>。</p>\n<p>2、我昨天本没有持有，且截至昨天最大交易次数限制为<code>k - 1</code>；但今天我选择<code>buy</code>，所以今天我就持有股票了，最大交易次数限制为<code>k</code>。</p>\n<blockquote>\n<p>ps:这里着重提醒一下，时刻牢记「状态」的定义，<code>k</code>的定义并不是「已进行的交易次数」，而是「最大交易次数的上限限制」。如果确定今天进行一次交易，且要保证截至今天最大交易次数上限为<code>k</code>，那么昨天的最大交易次数上限必须是<code>k - 1</code>。</p>\n</blockquote>\n<p>这个解释应该很清楚了，如果<code>buy</code>，就要从利润中减去<code>prices[i]</code>，如果<code>sell</code>，就要给利润增加<code>prices[i]</code>。今天的最大利润就是这两种可能选择中较大的那个。</p>\n<p>注意<code>k</code>的限制，在选择<code>buy</code>的时候相当于开启了一次交易，那么对于昨天来说，交易次数的上限<code>k</code>应该减小\n1。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">dp[<span class=\"number\">-1</span>][...][<span class=\"number\">0</span>] = <span class=\"number\">0</span></span><br><span class=\"line\">解释：因为 i 是从 <span class=\"number\">0</span> 开始的，所以 i = <span class=\"number\">-1</span> 意味着还没有开始，这时候的利润当然是 <span class=\"number\">0</span>。</span><br><span class=\"line\"></span><br><span class=\"line\">dp[<span class=\"number\">-1</span>][...][<span class=\"number\">1</span>] = -infinity</span><br><span class=\"line\">解释：还没开始的时候，是不可能持有股票的。</span><br><span class=\"line\">因为我们的算法要求一个最大值，所以初始值设为一个最小值，方便取最大值。</span><br><span class=\"line\"></span><br><span class=\"line\">dp[...][<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">0</span></span><br><span class=\"line\">解释：因为 k 是从 <span class=\"number\">1</span> 开始的，所以 k = <span class=\"number\">0</span> 意味着根本不允许交易，这时候利润当然是 <span class=\"number\">0</span>。</span><br><span class=\"line\"></span><br><span class=\"line\">dp[...][<span class=\"number\">0</span>][<span class=\"number\">1</span>] = -infinity</span><br><span class=\"line\">解释：不允许交易的情况下，是不可能持有股票的。</span><br><span class=\"line\">因为我们的算法要求一个最大值，所以初始值设为一个最小值，方便取最大值。</span><br></pre></td></tr></table></figure>\n<p>把上面的状态转移方程总结一下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">base <span class=\"keyword\">case</span>：</span><br><span class=\"line\">dp[<span class=\"number\">-1</span>][...][<span class=\"number\">0</span>] = dp[...][<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">0</span></span><br><span class=\"line\">dp[<span class=\"number\">-1</span>][...][<span class=\"number\">1</span>] = dp[...][<span class=\"number\">0</span>][<span class=\"number\">1</span>] = -infinity</span><br><span class=\"line\"></span><br><span class=\"line\">状态转移方程：</span><br><span class=\"line\">dp[i][k][<span class=\"number\">0</span>] = <span class=\"built_in\">max</span>(dp[i<span class=\"number\">-1</span>][k][<span class=\"number\">0</span>], dp[i<span class=\"number\">-1</span>][k][<span class=\"number\">1</span>] + prices[i])</span><br><span class=\"line\">dp[i][k][<span class=\"number\">1</span>] = <span class=\"built_in\">max</span>(dp[i<span class=\"number\">-1</span>][k][<span class=\"number\">1</span>], dp[i<span class=\"number\">-1</span>][k<span class=\"number\">-1</span>][<span class=\"number\">0</span>] - prices[i])</span><br></pre></td></tr></table></figure>\n<p>#<a\nhref=\"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/\">121.\n买卖股票的最佳时机</a></p>\n<p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i\n天的价格。</p>\n<p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子\n卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>\n<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0\n。</p>\n<h2 id=\"示例\">示例</h2>\n<blockquote>\n<p>输入：[7,1,5,3,6,4] 输出：5 解释：在第 2 天（股票价格 =\n1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5\n。 注意利润不能是 7-1 = 6,\n因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</p>\n</blockquote>\n<h3 id=\"思路\">思路：</h3>\n<p>相当于 <code>k = 1</code>我们直接套模版，</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">dp[i][<span class=\"number\">1</span>][<span class=\"number\">0</span>] = <span class=\"built_in\">max</span>(dp[i<span class=\"number\">-1</span>][<span class=\"number\">1</span>][<span class=\"number\">0</span>], dp[i<span class=\"number\">-1</span>][<span class=\"number\">1</span>][<span class=\"number\">1</span>] + prices[i])</span><br><span class=\"line\">dp[i][<span class=\"number\">1</span>][<span class=\"number\">1</span>] = <span class=\"built_in\">max</span>(dp[i<span class=\"number\">-1</span>][<span class=\"number\">1</span>][<span class=\"number\">1</span>], dp[i<span class=\"number\">-1</span>][<span class=\"number\">0</span>][<span class=\"number\">0</span>] - prices[i]) </span><br><span class=\"line\">            = <span class=\"built_in\">max</span>(dp[i<span class=\"number\">-1</span>][<span class=\"number\">1</span>][<span class=\"number\">1</span>], -prices[i])</span><br><span class=\"line\">解释：k = <span class=\"number\">0</span> 的 base <span class=\"keyword\">case</span>，所以 dp[i<span class=\"number\">-1</span>][<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">0</span>。</span><br><span class=\"line\"></span><br><span class=\"line\">现在发现 k 都是 <span class=\"number\">1</span>，不会改变，即 k 对状态转移已经没有影响了。</span><br><span class=\"line\">可以进行进一步化简去掉所有 k：</span><br><span class=\"line\">dp[i][<span class=\"number\">0</span>] = <span class=\"built_in\">max</span>(dp[i<span class=\"number\">-1</span>][<span class=\"number\">0</span>], dp[i<span class=\"number\">-1</span>][<span class=\"number\">1</span>] + prices[i])</span><br><span class=\"line\">dp[i][<span class=\"number\">1</span>] = <span class=\"built_in\">max</span>(dp[i<span class=\"number\">-1</span>][<span class=\"number\">1</span>], -prices[i])</span><br></pre></td></tr></table></figure>\n<p>写出如下代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> n = prices.length;</span><br><span class=\"line\"><span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"type\">int</span>[n][<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">    dp[i][<span class=\"number\">0</span>] = <span class=\"built_in\">max</span>(dp[i<span class=\"number\">-1</span>][<span class=\"number\">0</span>], dp[i<span class=\"number\">-1</span>][<span class=\"number\">1</span>] + prices[i]);</span><br><span class=\"line\">    dp[i][<span class=\"number\">1</span>] = <span class=\"built_in\">max</span>(dp[i<span class=\"number\">-1</span>][<span class=\"number\">1</span>], -prices[i]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> dp[n - <span class=\"number\">1</span>][<span class=\"number\">0</span>];</span><br></pre></td></tr></table></figure>\n<p>显然<code>i = 0</code>时<code>i - 1</code>是不合法的索引，这是因为我们没有对<code>i</code>的\nbase case 进行处理，可以这样给一个特化处理：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (i - <span class=\"number\">1</span> == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">    dp[i][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 根据状态转移方程可得：</span></span><br><span class=\"line\">    <span class=\"comment\">//   dp[i][0] </span></span><br><span class=\"line\">    <span class=\"comment\">// = max(dp[-1][0], dp[-1][1] + prices[i])</span></span><br><span class=\"line\">    <span class=\"comment\">// = max(0, -infinity + prices[i]) = 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    dp[i][<span class=\"number\">1</span>] = -prices[i];</span><br><span class=\"line\">    <span class=\"comment\">// 根据状态转移方程可得：</span></span><br><span class=\"line\">    <span class=\"comment\">//   dp[i][1] </span></span><br><span class=\"line\">    <span class=\"comment\">// = max(dp[-1][1], dp[-1][0] - prices[i])</span></span><br><span class=\"line\">    <span class=\"comment\">// = max(-infinity, 0 - prices[i]) </span></span><br><span class=\"line\">    <span class=\"comment\">// = -prices[i]</span></span><br><span class=\"line\">    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maxProfit</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = prices.<span class=\"built_in\">size</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; <span class=\"built_in\">dp</span>(n, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(<span class=\"number\">2</span>,<span class=\"number\">0</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i - <span class=\"number\">1</span> == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">                dp[i][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                dp[i][<span class=\"number\">1</span>] = -prices[i];</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>] = <span class=\"built_in\">max</span>(dp[i - <span class=\"number\">1</span>][<span class=\"number\">0</span>], dp[i - <span class=\"number\">1</span>][<span class=\"number\">1</span>] + prices[i]);</span><br><span class=\"line\">            dp[i][<span class=\"number\">1</span>] = <span class=\"built_in\">max</span>(dp[i - <span class=\"number\">1</span>][<span class=\"number\">1</span>],  -prices[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n - <span class=\"number\">1</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>注意一下状态转移方程，新状态只和相邻的一个状态有关，其实不用整个<code>dp</code>数组，只需要一个变量储存相邻的那个状态就足够了，这样可以把空间复杂度降到\nO(1)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maxProfit</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = prices.<span class=\"built_in\">size</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> dp_i_0 = <span class=\"number\">0</span>, dp_i_1 = INT_MIN;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            dp_i_0 = <span class=\"built_in\">max</span>(dp_i_0, dp_i_1 + prices[i]);</span><br><span class=\"line\">            dp_i_1 = <span class=\"built_in\">max</span>(dp_i_1, -prices[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp_i_0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"买卖股票的最佳时机-ii\"><a\nhref=\"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/\">122.\n买卖股票的最佳时机 II</a></h1>\n<p>给定一个数组 prices ，其中 prices[i] 表示股票第 i 天的价格。</p>\n<p>在每一天，你可能会决定购买和/或出售股票。你在任何时候 最多 只能持有\n一股 股票。你也可以购买它，然后在 同一天 出售。 返回 你能获得的 最大\n利润 。</p>\n<h2 id=\"示例-1\">示例：</h2>\n<blockquote>\n<p>输入: prices = [7,1,5,3,6,4] 输出: 7 解释: 在第 2 天（股票价格 =\n1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润\n= 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5\n天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p>\n</blockquote>\n<h3 id=\"思路-1\">思路：</h3>\n<p>相当于<code>k = +infinity</code>，那么我们可以认为<code>k</code>和<code>k-1</code>是一样的，可以这样改写框架：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">dp[i][k][<span class=\"number\">0</span>] = <span class=\"built_in\">max</span>(dp[i<span class=\"number\">-1</span>][k][<span class=\"number\">0</span>], dp[i<span class=\"number\">-1</span>][k][<span class=\"number\">1</span>] + prices[i]);</span><br><span class=\"line\">dp[i][k][<span class=\"number\">1</span>] = <span class=\"built_in\">max</span>(dp[i<span class=\"number\">-1</span>][k<span class=\"number\">-1</span>][<span class=\"number\">1</span>], dp[i<span class=\"number\">-1</span>][k<span class=\"number\">-1</span>][<span class=\"number\">0</span>] - prices[i]);</span><br><span class=\"line\">\t\t\t\t\t\t= <span class=\"built_in\">max</span>(dp[i<span class=\"number\">-1</span>][k][<span class=\"number\">1</span>], dp[i<span class=\"number\">-1</span>][k][<span class=\"number\">0</span>] - prices[i]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//我们可以看到数组中 k 已经不会发生改变，也就是说不需要再记录 k</span></span><br><span class=\"line\">dp[i][<span class=\"number\">0</span>] = <span class=\"built_in\">max</span>(dp[i<span class=\"number\">-1</span>][<span class=\"number\">0</span>], dp[i<span class=\"number\">-1</span>][<span class=\"number\">1</span>] + prices[i]);</span><br><span class=\"line\">dp[i][<span class=\"number\">1</span>] = <span class=\"built_in\">max</span>(dp[i<span class=\"number\">-1</span>][<span class=\"number\">1</span>], dp[i<span class=\"number\">-1</span>][<span class=\"number\">0</span>] - prices[i]);</span><br></pre></td></tr></table></figure>\n<p>所以可以写出：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maxProfit</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = prices.<span class=\"built_in\">size</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; <span class=\"built_in\">dp</span>(n, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(<span class=\"number\">2</span>,<span class=\"number\">0</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i - <span class=\"number\">1</span> == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">                dp[i][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                dp[i][<span class=\"number\">1</span>] = -prices[i];</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>] = <span class=\"built_in\">max</span>(dp[i<span class=\"number\">-1</span>][<span class=\"number\">0</span>], dp[i<span class=\"number\">-1</span>][<span class=\"number\">1</span>] + prices[i]);</span><br><span class=\"line\">            dp[i][<span class=\"number\">1</span>] = <span class=\"built_in\">max</span>(dp[i<span class=\"number\">-1</span>][<span class=\"number\">1</span>], dp[i<span class=\"number\">-1</span>][<span class=\"number\">0</span>] - prices[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n - <span class=\"number\">1</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>状态压缩成<code>O(1)</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maxProfit</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = prices.<span class=\"built_in\">size</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> dp_i_0 = <span class=\"number\">0</span>, dp_i_1 = INT_MIN;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            dp_i_0 = <span class=\"built_in\">max</span>(dp_i_0, dp_i_1 + prices[i]);</span><br><span class=\"line\">            dp_i_1 = <span class=\"built_in\">max</span>(dp_i_1, dp_i_0 - prices[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp_i_0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"最佳买卖股票时机含冷冻期\"><a\nhref=\"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/\">309.\n最佳买卖股票时机含冷冻期</a></h1>\n<p>给定一个整数数组prices，其中第 prices[i] 表示第 i 天的股票价格 。</p>\n<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>\n<p>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。\n注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>\n<h2 id=\"示例-2\">示例：</h2>\n<blockquote>\n<p>输入: prices = [1,2,3,0,2] 输出: 3 解释: 对应的交易状态为: [买入,\n卖出, 冷冻期, 买入, 卖出]</p>\n</blockquote>\n<h3 id=\"思路-2\">思路：</h3>\n<p>相当于<code>k = infinity +cooldowm</code></p>\n<p>每次<code>sell</code>之后要等一天才能继续交易。只要把这个特点融入上一题的状态转移方程即可：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">dp[i][<span class=\"number\">0</span>] = <span class=\"built_in\">max</span>(dp[i<span class=\"number\">-1</span>][<span class=\"number\">0</span>], dp[i<span class=\"number\">-1</span>][<span class=\"number\">1</span>] + prices[i]);</span><br><span class=\"line\">dp[i][<span class=\"number\">1</span>] = <span class=\"built_in\">max</span>(dp[i<span class=\"number\">-1</span>][<span class=\"number\">1</span>], dp[i<span class=\"number\">-2</span>][<span class=\"number\">0</span>] - prices[i]);</span><br></pre></td></tr></table></figure>\n<p>所以最终可以写成：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maxProfit</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = prices.<span class=\"built_in\">size</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; <span class=\"built_in\">dp</span>(n, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(<span class=\"number\">2</span>,<span class=\"number\">0</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i - <span class=\"number\">1</span> == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">                dp[i][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                dp[i][<span class=\"number\">1</span>] = -prices[i];</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i - <span class=\"number\">2</span> == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">                dp[i][<span class=\"number\">0</span>] = <span class=\"built_in\">max</span>(dp[i - <span class=\"number\">1</span>][<span class=\"number\">0</span>], dp[i - <span class=\"number\">1</span>][<span class=\"number\">1</span>] + prices[i]);</span><br><span class=\"line\">                dp[i][<span class=\"number\">1</span>] = <span class=\"built_in\">max</span>(dp[i - <span class=\"number\">1</span>][<span class=\"number\">1</span>],  -prices[i]);</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>] = <span class=\"built_in\">max</span>(dp[i - <span class=\"number\">1</span>][<span class=\"number\">0</span>], dp[i - <span class=\"number\">1</span>][<span class=\"number\">1</span>] + prices[i]);</span><br><span class=\"line\">            dp[i][<span class=\"number\">1</span>] = <span class=\"built_in\">max</span>(dp[i - <span class=\"number\">1</span>][<span class=\"number\">1</span>], dp[i - <span class=\"number\">2</span>][<span class=\"number\">0</span>] - prices[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n - <span class=\"number\">1</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>状态压缩：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maxProfit</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = prices.<span class=\"built_in\">size</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> dp_i_0 = <span class=\"number\">0</span>, dp_i_1 = INT_MIN;</span><br><span class=\"line\">        <span class=\"type\">int</span> dp_pre_0 = <span class=\"number\">0</span>;<span class=\"comment\">//代表dp[i - 2][0]</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> temp = dp_i_0;</span><br><span class=\"line\">            dp_i_0 = <span class=\"built_in\">max</span>(dp_i_0, dp_i_1 + prices[i]);</span><br><span class=\"line\">            dp_i_1 = <span class=\"built_in\">max</span>(dp_i_1, dp_pre_0 - prices[i]);</span><br><span class=\"line\">            dp_pre_0 = temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp_i_0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"买卖股票的最佳时机含手续费\"><a\nhref=\"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/\">714.\n买卖股票的最佳时机含手续费</a></h1>\n<p>给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数\nfee 代表了交易股票的手续费用。</p>\n<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>\n<p>返回获得利润的最大值。</p>\n<p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p>\n<h2 id=\"示例-3\">示例：</h2>\n<blockquote>\n<p>输入：prices = [1, 3, 2, 8, 4, 9], fee = 2 输出：8\n解释：能够达到的最大利润:<br />\n在此处买入 prices[0] = 1 在此处卖出 prices[3] = 8 在此处买入 prices[4] =\n4 在此处卖出 prices[5] = 9 总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8</p>\n</blockquote>\n<h3 id=\"思路-3\">思路：</h3>\n<p>相当于<code>k = infinity + fee</code></p>\n<p>改写方程：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">dp[i][<span class=\"number\">0</span>] = <span class=\"built_in\">max</span>(dp[i<span class=\"number\">-1</span>][<span class=\"number\">0</span>], dp[i<span class=\"number\">-1</span>][<span class=\"number\">1</span>] + prices[i]);</span><br><span class=\"line\">dp[i][<span class=\"number\">1</span>] = <span class=\"built_in\">max</span>(dp[i<span class=\"number\">-1</span>][<span class=\"number\">1</span>], dp[i<span class=\"number\">-1</span>][<span class=\"number\">0</span>] - prices[i] - fee);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果直接把<code>fee</code>放在第一个式子里减，会有测试用例无法通过，错误原因是整型溢出而不是思路问题。一种解决方案是把代码中的<code>int</code>类型都改成<code>long</code>类型，避免<code>int</code>的整型溢出。</p>\n</blockquote>\n<p>所以最终代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maxProfit</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; prices, <span class=\"type\">int</span> fee)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = prices.<span class=\"built_in\">size</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; <span class=\"built_in\">dp</span>(n, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(<span class=\"number\">2</span>,<span class=\"number\">0</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i - <span class=\"number\">1</span> == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">                dp[i][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                dp[i][<span class=\"number\">1</span>] = -prices[i] - fee;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>] = <span class=\"built_in\">max</span>(dp[i - <span class=\"number\">1</span>][<span class=\"number\">0</span>], dp[i - <span class=\"number\">1</span>][<span class=\"number\">1</span>] + prices[i]);</span><br><span class=\"line\">            dp[i][<span class=\"number\">1</span>] = <span class=\"built_in\">max</span>(dp[i - <span class=\"number\">1</span>][<span class=\"number\">1</span>], dp[i - <span class=\"number\">1</span>][<span class=\"number\">0</span>] - prices[i] - fee);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n - <span class=\"number\">1</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>状态压缩如下</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maxProfit</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; prices, <span class=\"type\">int</span> fee)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = prices.<span class=\"built_in\">size</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> dp_i_0 = <span class=\"number\">0</span>, dp_i_1 = INT_MIN;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            dp_i_0 = <span class=\"built_in\">max</span>(dp_i_0, dp_i_1 + prices[i]);</span><br><span class=\"line\">            dp_i_1 = <span class=\"built_in\">max</span>(dp_i_1, dp_i_0 - prices[i] - fee);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp_i_0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"买卖股票的最佳时机-iii\"><a\nhref=\"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/\">123.\n买卖股票的最佳时机 III</a></h1>\n<p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p>\n<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔\n交易。</p>\n<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>\n<h2 id=\"示例-4\">示例：</h2>\n<blockquote>\n<p>输入：prices = [3,3,5,0,0,3,1,4] 输出：6 解释：在第 4 天（股票价格 =\n0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润\n= 3-0 = 3 。 随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天\n（股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</p>\n</blockquote>\n<h3 id=\"思路-4\">思路：</h3>\n<p>前面的和<code>k</code>都没关系，现在 <code>k = 2</code></p>\n<p>我们先分析下状态转移方程：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">dp[i][k][<span class=\"number\">0</span>] = <span class=\"built_in\">max</span>(dp[i<span class=\"number\">-1</span>][k][<span class=\"number\">0</span>], dp[i<span class=\"number\">-1</span>][k][<span class=\"number\">1</span>] + prices[i]);</span><br><span class=\"line\">dp[i][k][<span class=\"number\">1</span>] = <span class=\"built_in\">max</span>(dp[i<span class=\"number\">-1</span>][k][<span class=\"number\">1</span>], dp[i<span class=\"number\">-1</span>][k<span class=\"number\">-1</span>][<span class=\"number\">0</span>] - prices[i]);</span><br></pre></td></tr></table></figure>\n<p>发现没有可以化简的地方：</p>\n<p>按照之前的代码，我们可能想当然这样写代码（错误的）：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> k = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"type\">int</span>[][][] dp = <span class=\"keyword\">new</span> <span class=\"type\">int</span>[n][k + <span class=\"number\">1</span>][<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i - <span class=\"number\">1</span> == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 处理 base case</span></span><br><span class=\"line\">        dp[i][k][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        dp[i][k][<span class=\"number\">1</span>] = -prices[i];</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dp[i][k][<span class=\"number\">0</span>] = Math.<span class=\"built_in\">max</span>(dp[i<span class=\"number\">-1</span>][k][<span class=\"number\">0</span>], dp[i<span class=\"number\">-1</span>][k][<span class=\"number\">1</span>] + prices[i]);</span><br><span class=\"line\">    dp[i][k][<span class=\"number\">1</span>] = Math.<span class=\"built_in\">max</span>(dp[i<span class=\"number\">-1</span>][k][<span class=\"number\">1</span>], dp[i<span class=\"number\">-1</span>][k<span class=\"number\">-1</span>][<span class=\"number\">0</span>] - prices[i]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> dp[n - <span class=\"number\">1</span>][k][<span class=\"number\">0</span>];</span><br></pre></td></tr></table></figure>\n<p>为什么错误？我这不是照着状态转移方程写的吗？</p>\n<p>还记得前面总结的「穷举框架」吗？就是说我们必须穷举所有状态。其实我们之前的解法，都在穷举所有状态，只是之前的题目中<code>k</code>都被化简掉了。</p>\n<p>但当<code>k = 2</code>时，由于没有消掉<code>k</code>的影响，所以必须要对<code>k</code>进行穷举：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maxProfit</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = prices.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> max_k = <span class=\"number\">2</span>;</span><br><span class=\"line\">        vector&lt;vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; &gt; <span class=\"built_in\">dp</span>(n, vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; (max_k + <span class=\"number\">1</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(<span class=\"number\">2</span>, <span class=\"number\">0</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k = max_k; k &gt;= <span class=\"number\">1</span>; k--)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(i - <span class=\"number\">1</span> == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">                    dp[i][k][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                    dp[i][k][<span class=\"number\">1</span>] = -prices[i];</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//k表示最大交易次数</span></span><br><span class=\"line\">                dp[i][k][<span class=\"number\">0</span>] = <span class=\"built_in\">max</span>(dp[i - <span class=\"number\">1</span>][k][<span class=\"number\">0</span>], dp[i - <span class=\"number\">1</span>][k][<span class=\"number\">1</span>] + prices[i]);<span class=\"comment\">//2，我昨天持有股票，且截至昨天最大交易次数限制为 k；但是今天我 sell 了，所以我今天没有持有股票了，最大交易次数限制依然为 k。</span></span><br><span class=\"line\">                dp[i][k][<span class=\"number\">1</span>] = <span class=\"built_in\">max</span>(dp[i - <span class=\"number\">1</span>][k][<span class=\"number\">1</span>], dp[i - <span class=\"number\">1</span>][k - <span class=\"number\">1</span>][<span class=\"number\">0</span>] - prices[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n - <span class=\"number\">1</span>][max_k][<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>状态压缩：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maxProfit</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// base case</span></span><br><span class=\"line\">        <span class=\"type\">int</span> dp_i10 = <span class=\"number\">0</span>, dp_i11 = INT_MIN;</span><br><span class=\"line\">        <span class=\"type\">int</span> dp_i20 = <span class=\"number\">0</span>, dp_i21 = INT_MIN;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> price : prices) &#123;</span><br><span class=\"line\">            dp_i20 = <span class=\"built_in\">max</span>(dp_i20, dp_i21 + price);</span><br><span class=\"line\">            dp_i21 = <span class=\"built_in\">max</span>(dp_i21, dp_i10 - price);</span><br><span class=\"line\">            dp_i10 = <span class=\"built_in\">max</span>(dp_i10, dp_i11 + price);</span><br><span class=\"line\">            dp_i11 = <span class=\"built_in\">max</span>(dp_i11, -price);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp_i20;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"买卖股票的最佳时机-iv\"><a\nhref=\"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/\">188.\n买卖股票的最佳时机 IV</a></h1>\n<p>给定一个整数数组 prices ，它的第 i 个元素 prices[i]\n是一支给定的股票在第 i 天的价格。</p>\n<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p>\n<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>\n<h2 id=\"示例-5\">示例：</h2>\n<blockquote>\n<p>输入：k = 2, prices = [2,4,1] 输出：2 解释：在第 1 天 (股票价格 = 2)\n的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 =\n4-2 = 2 。</p>\n</blockquote>\n<h3 id=\"思路-5\">思路：</h3>\n<p><code>k = nay interger</code></p>\n<p>有了上一题<code>k = 2</code>的铺垫，这题应该和上一题的第一个解法没啥区别。但是出现了一个超内存的错误，原来是传入的<code>k</code>值会非常大，<code>dp</code>数组太大了。现在想想，交易次数<code>k</code>最多有多大呢？</p>\n<p>一次交易由买入和卖出构成，至少需要两天。所以说有效的限制<code>k</code>应该不超过<code>n/2</code>，如果超过，就没有约束作用了，相当于<code>k = +infinity</code>。这种情况是之前解决过的。</p>\n<p>所以代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span> k, vector&lt;<span class=\"type\">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = prices.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n &lt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k &gt; n / <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 复用之前交易次数 k 没有限制的情况</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">maxProfit2</span>(prices);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        vector&lt;vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; &gt; <span class=\"built_in\">dp</span>(n, vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; (k + <span class=\"number\">1</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(<span class=\"number\">2</span>, <span class=\"number\">0</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>][<span class=\"number\">1</span>] = INT_MIN;</span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> p = k; p &gt;= <span class=\"number\">1</span>; p--)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(i - <span class=\"number\">1</span> == <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">                    dp[i][p][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                    dp[i][p][<span class=\"number\">1</span>] = -prices[i];</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                dp[i][p][<span class=\"number\">0</span>] = <span class=\"built_in\">max</span>(dp[i - <span class=\"number\">1</span>][p][<span class=\"number\">0</span>], dp[i - <span class=\"number\">1</span>][p][<span class=\"number\">1</span>] + prices[i]);</span><br><span class=\"line\">                dp[i][p][<span class=\"number\">1</span>] = <span class=\"built_in\">max</span>(dp[i - <span class=\"number\">1</span>][p][<span class=\"number\">1</span>], dp[i - <span class=\"number\">1</span>][p - <span class=\"number\">1</span>][<span class=\"number\">0</span>] - prices[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n - <span class=\"number\">1</span>][k][<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maxProfit2</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// base case</span></span><br><span class=\"line\">        <span class=\"type\">int</span> dp_i10 = <span class=\"number\">0</span>, dp_i11 = INT_MIN;</span><br><span class=\"line\">        <span class=\"type\">int</span> dp_i20 = <span class=\"number\">0</span>, dp_i21 = INT_MIN;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> price : prices) &#123;</span><br><span class=\"line\">            dp_i20 = <span class=\"built_in\">max</span>(dp_i20, dp_i21 + price);</span><br><span class=\"line\">            dp_i21 = <span class=\"built_in\">max</span>(dp_i21, dp_i10 - price);</span><br><span class=\"line\">            dp_i10 = <span class=\"built_in\">max</span>(dp_i10, dp_i11 + price);</span><br><span class=\"line\">            dp_i11 = <span class=\"built_in\">max</span>(dp_i11, -price);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp_i20;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["动态规划"],"tags":["动态规划","leetcode"]},{"title":"二叉树","url":"/2022/03/07/%E4%BA%8C%E5%8F%89%E6%A0%91/","content":"<p>二叉树常用算法</p>\n<span id=\"more\"></span>\n<h4 id=\"翻转二叉树\"><a\nhref=\"https://leetcode-cn.com/problems/invert-binary-tree/\">226.\n翻转二叉树</a></h4>\n<p>给你一棵二叉树的根节点 <code>root</code>\n，翻转这棵二叉树，并返回其根节点。</p>\n<h5 id=\"示例\">示例：</h5>\n<p><img src=\"二叉树/invert1-tree.jpg\" /></p>\n<blockquote>\n<p>root = [4,2,7,1,3,6,9] 输出：[4,7,2,9,6,3,1]</p>\n</blockquote>\n<h5 id=\"思路\">思路：</h5>\n<p>我们可以发现只需要翻转每个节点的左右子节点。就可以得到翻转后的二叉树了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">invertTree</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//交换root节点的左右子节点</span></span><br><span class=\"line\">        TreeNode* tmp = root-&gt;left;</span><br><span class=\"line\">        root-&gt;left = root-&gt;right;</span><br><span class=\"line\">        root-&gt;right = tmp;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//让左右子节点继续翻转他们的子节点</span></span><br><span class=\"line\">        <span class=\"built_in\">invertTree</span>(root-&gt;left);</span><br><span class=\"line\">        <span class=\"built_in\">invertTree</span>(root-&gt;right);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"填充每个节点的下一个右侧节点指针\"><a\nhref=\"https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/\">116.填充每个节点的下一个右侧节点指针</a></h4>\n<p>给定一个 <strong>完美二叉树</strong>\n，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>\n<blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> val;</span><br><span class=\"line\">  Node *left;</span><br><span class=\"line\">  Node *right;</span><br><span class=\"line\">  Node *next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>填充它的每个 next\n指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将\nnext 指针设置为 NULL。</p>\n<p>初始状态下，所有 next 指针都被设置为 NULL。</p>\n<h5 id=\"示例-1\">示例：</h5>\n<p><img src=\"二叉树/116_sample.png\" /></p>\n<blockquote>\n<p>输入：root = [1,2,3,4,5,6,7] 输出：[1,#,2,3,#,4,5,6,7,#]\n解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next\n指针，以指向其下一个右侧节点，如图 B\n所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#'\n标志着每一层的结束。</p>\n</blockquote>\n<h5 id=\"思路-1\">思路：</h5>\n<p>我们可以很轻松的用递归实现左子节点指向右子节点，可是面临一个难题，那就是不同子树的节点，</p>\n<p>我们应该如何连接呢？</p>\n<p>二叉树的问题难点在于，如何把题目要求细化成每个节点需要做的事。</p>\n<p>如果只依赖一个节点的话，我们肯定没有办法连接跨父节点的两个相邻节点，那么我们的做法就是增加函数参数，</p>\n<p>使用两个节点。</p>\n<p>例如：题中的5和6如何相连，我们只需要递归实现<code>connectTowNode(2-&gt;right,3-&gt;left)</code>即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">Node* <span class=\"title\">connect</span><span class=\"params\">(Node* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"built_in\">connectTwoNode</span>(root-&gt;left, root-&gt;right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">connectTwoNode</span><span class=\"params\">(Node* node1, Node* node2)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(node1 == <span class=\"literal\">nullptr</span> || node2 == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">      \t<span class=\"comment\">//前序位置</span></span><br><span class=\"line\">        <span class=\"comment\">//将传入的节点连接</span></span><br><span class=\"line\">        node1-&gt;next = node2;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//连接相同父节点的两个节点</span></span><br><span class=\"line\">        <span class=\"built_in\">connectTwoNode</span>(node1-&gt;left, node1-&gt;right);</span><br><span class=\"line\">        <span class=\"built_in\">connectTwoNode</span>(node2-&gt;left, node2-&gt;right);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//连接跨父节点的两个节点</span></span><br><span class=\"line\">        <span class=\"built_in\">connectTwoNode</span>(node1-&gt;right, node2-&gt;left);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"二叉树展开为链表\"><a\nhref=\"https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/\">114.\n二叉树展开为链表</a></h4>\n<p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p>\n<ul>\n<li>展开后的单链表应该同样使用 TreeNode ，其中 right\n子指针指向链表中下一个结点，而左子指针始终为 null 。</li>\n<li>展开后的单链表应该与二叉树 先序遍历 顺序相同。</li>\n</ul>\n<h5 id=\"示例-2\">示例：</h5>\n<p><img src=\"二叉树/flaten.jpg\" /></p>\n<blockquote>\n<p>输入：root = [1,2,5,3,4,null,6]\n输出：[1,null,2,null,3,null,4,null,5,null,6]</p>\n</blockquote>\n<h5 id=\"思路-2\">思路：</h5>\n<p>1，将root的左右子树拉平。</p>\n<p>2，将root的左子树作为右子树</p>\n<p>3，将右子树接到左子树下方</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">flatten</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">flatten</span>(root-&gt;left);</span><br><span class=\"line\">        <span class=\"built_in\">flatten</span>(root-&gt;right);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//后续遍历位置，因为我们需要拉平才能操作</span></span><br><span class=\"line\">        <span class=\"comment\">//1，左右子树已经拉平成一条链表</span></span><br><span class=\"line\">        TreeNode* left = root-&gt;left;</span><br><span class=\"line\">        TreeNode* right = root-&gt;right;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//2，将左子树作为右子树</span></span><br><span class=\"line\">        root-&gt;right = left;</span><br><span class=\"line\">        root-&gt;left = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//3，将右子树接到左子树下方</span></span><br><span class=\"line\">        TreeNode* p = root;</span><br><span class=\"line\">        <span class=\"comment\">//让p指针指向最末端</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p-&gt;right != <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            p = p-&gt;right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//指向原来的右子树</span></span><br><span class=\"line\">        p-&gt;right = right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"最大二叉树\"><a\nhref=\"https://leetcode-cn.com/problems/maximum-binary-tree/\">654.\n最大二叉树</a></h4>\n<p>给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums\n递归地构建:</p>\n<p>​ 1，创建一个根节点，其值为 nums 中的最大值。 ​ 2，递归地在最大值 左边\n的 子数组前缀上 构建左子树。 ​ 3，递归地在最大值 右边 的 子数组后缀上\n构建右子树。 返回 nums 构建的 最大二叉树 。</p>\n<h5 id=\"示例-3\">示例：</h5>\n<p><img src=\"二叉树/tree1.jpg\" /></p>\n<blockquote>\n<p>输入：nums = [3,2,1,6,0,5] 输出：[6,3,5,null,2,0,null,null,1]\n解释：递归调用如下所示： - [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是\n[3,2,1] ，右边部分是 [0,5] 。 - [3,2,1] 中的最大值是 3 ，左边部分是 []\n，右边部分是 [2,1] 。 - 空数组，无子节点。 - [2,1] 中的最大值是 2\n，左边部分是 [] ，右边部分是 [1] 。 - 空数组，无子节点。 -\n只有一个元素，所以子节点是一个值为 1 的节点。 - [0,5] 中的最大值是 5\n，左边部分是 [0] ，右边部分是 [] 。 - 只有一个元素，所以子节点是一个值为\n0 的节点。 - 空数组，无子节点。</p>\n</blockquote>\n<h5 id=\"思路-3\">思路：</h5>\n<p>我们首先要明确每个节点应该做什么？很显然每个节点要做的就是把自己构造出来</p>\n<pre><code>1，递归终止条件lo &gt; hi</code></pre>\n<p>​ 2，遍历找出最大值maxVal</p>\n<pre><code>3，递归左右两边作为左右子树。</code></pre>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">constructMaximumBinaryTree</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums.<span class=\"built_in\">empty</span>()) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">build</span>(nums, <span class=\"number\">0</span>, nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">build</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> lo, <span class=\"type\">int</span> hi)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//递归终止条件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(lo &gt; hi) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//找到数组中最大值和对应的索引</span></span><br><span class=\"line\">        <span class=\"type\">int</span> index = <span class=\"number\">-1</span>, maxVal = INT_MIN;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = lo; i &lt;= hi; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(maxVal &lt; nums[i])&#123;</span><br><span class=\"line\">                index = i;</span><br><span class=\"line\">                maxVal = nums[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//构建自己的节点</span></span><br><span class=\"line\">        TreeNode* root = <span class=\"keyword\">new</span> <span class=\"built_in\">TreeNode</span>(maxVal);</span><br><span class=\"line\">        <span class=\"comment\">//递归构建自己节点的左右子树</span></span><br><span class=\"line\">        root-&gt;left = <span class=\"built_in\">build</span>(nums, lo, index<span class=\"number\">-1</span>);</span><br><span class=\"line\">        root-&gt;right = <span class=\"built_in\">build</span>(nums, index + <span class=\"number\">1</span>, hi);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"从前序与中序遍历序列构造二叉树\"><a\nhref=\"https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/\">105.\n从前序与中序遍历序列构造二叉树</a></h4>\n<p>给定两个整数数组 preorder 和 inorder ，其中 preorder\n是二叉树的先序遍历， inorder\n是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p>\n<h5 id=\"示例-4\">示例：</h5>\n<p><img src=\"二叉树/tree.jpg\" /></p>\n<blockquote>\n<p>输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7] 输出:\n[3,9,20,null,null,15,7]</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">TreeNode</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> val;</span><br><span class=\"line\">    TreeNode *left;</span><br><span class=\"line\">    TreeNode *right;</span><br><span class=\"line\">    <span class=\"built_in\">TreeNode</span>() : <span class=\"built_in\">val</span>(<span class=\"number\">0</span>), <span class=\"built_in\">left</span>(<span class=\"literal\">nullptr</span>), <span class=\"built_in\">right</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">TreeNode</span>(<span class=\"type\">int</span> x) : <span class=\"built_in\">val</span>(x), <span class=\"built_in\">left</span>(<span class=\"literal\">nullptr</span>), <span class=\"built_in\">right</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">TreeNode</span>(<span class=\"type\">int</span> x, TreeNode *left, TreeNode *right) : <span class=\"built_in\">val</span>(x), <span class=\"built_in\">left</span>(left), <span class=\"built_in\">right</span>(right) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"思路-4\">思路：</h5>\n<p>我们主要的就是把根节点做出来，然后递归构造左右子树即可。</p>\n<p>前序遍历可以把数组分成<code>[根，左，   右]</code>三部分，而中序遍历可以把数组分为<code>[左，根，   右]</code>三部分</p>\n<p>我们知道前序遍历的第一个值就是根节点的值，关键在于如何通过根节点的值。将<code>preorder</code>和<code>inorder</code>分为两半，构建根节点的左右子树</p>\n<p><img src=\"https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e7%b3%bb%e5%88%972/4.jpeg\" alt=\"img\" style=\"zoom:67%;\" /></p>\n<p>这样就可以分为：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> leftSize = index - inStart;</span><br><span class=\"line\">root-&gt;left = <span class=\"built_in\">build</span>(preorder, preStart + <span class=\"number\">1</span>, preStart + leftSize, inorder, inStart, index - <span class=\"number\">1</span>);</span><br><span class=\"line\">root-&gt;right = <span class=\"built_in\">build</span>(preorder, preStart + leftSize + <span class=\"number\">1</span>, preEnd, inorder, index + <span class=\"number\">1</span>, inEnd);</span><br></pre></td></tr></table></figure>\n<p>综上：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">buildTree</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; preorder, vector&lt;<span class=\"type\">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//前序，前序起点，前序终点，中序，中序起点，中序终点</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">build</span>(preorder, <span class=\"number\">0</span>, preorder.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>, inorder, <span class=\"number\">0</span>, inorder.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">build</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; preorder, <span class=\"type\">int</span> preStart, <span class=\"type\">int</span> preEnd, vector&lt;<span class=\"type\">int</span>&gt;&amp; inorder, <span class=\"type\">int</span> inStart, <span class=\"type\">int</span> inEnd)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//递归终止条件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(preStart &gt; preEnd) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"comment\">//root 节点就是前序遍历的第一个节点</span></span><br><span class=\"line\">        <span class=\"type\">int</span> rootVal = preorder[preStart];</span><br><span class=\"line\">        <span class=\"comment\">//rootVal 在中序遍历中的索引</span></span><br><span class=\"line\">        <span class=\"type\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = inStart; i &lt;= inEnd; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(inorder[i] == rootVal)&#123;</span><br><span class=\"line\">                index = i;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//左子树长度</span></span><br><span class=\"line\">        <span class=\"type\">int</span> leftSize = index - inStart;</span><br><span class=\"line\">        <span class=\"comment\">//构建根节点</span></span><br><span class=\"line\">        TreeNode* root = <span class=\"keyword\">new</span> <span class=\"built_in\">TreeNode</span>(rootVal);</span><br><span class=\"line\">        <span class=\"comment\">//递归构建左右子树</span></span><br><span class=\"line\">        root-&gt;left = <span class=\"built_in\">build</span>(preorder, preStart + <span class=\"number\">1</span>, preStart + leftSize, inorder, inStart, index - <span class=\"number\">1</span>);</span><br><span class=\"line\">        root-&gt;right = <span class=\"built_in\">build</span>(preorder, preStart + leftSize + <span class=\"number\">1</span>, preEnd, inorder, index + <span class=\"number\">1</span>, inEnd);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"从中序与后序遍历序列构造二叉树\"><a\nhref=\"https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/\">106.\n从中序与后序遍历序列构造二叉树</a></h4>\n<p>给定两个整数数组 inorder 和 postorder ，其中 inorder\n是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗\n二叉树 。</p>\n<h5 id=\"示例-5\">示例：</h5>\n<p><img src=\"二叉树/tree.jpg\" /></p>\n<blockquote>\n<p>输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]\n输出：[3,9,20,null,null,15,7]</p>\n</blockquote>\n<h5 id=\"思路-5\">思路：</h5>\n<p>和上题一样，我们只需要知道后序遍历为<code>[左   右   根]</code>根节点为最后一个元素。</p>\n<p><img src=\"二叉树/6.jpg\" /></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">TreeNode</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> val;</span><br><span class=\"line\">    TreeNode *left;</span><br><span class=\"line\">    TreeNode *right;</span><br><span class=\"line\">    <span class=\"built_in\">TreeNode</span>() : <span class=\"built_in\">val</span>(<span class=\"number\">0</span>), <span class=\"built_in\">left</span>(<span class=\"literal\">nullptr</span>), <span class=\"built_in\">right</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">TreeNode</span>(<span class=\"type\">int</span> x) : <span class=\"built_in\">val</span>(x), <span class=\"built_in\">left</span>(<span class=\"literal\">nullptr</span>), <span class=\"built_in\">right</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">TreeNode</span>(<span class=\"type\">int</span> x, TreeNode *left, TreeNode *right) : <span class=\"built_in\">val</span>(x), <span class=\"built_in\">left</span>(left), <span class=\"built_in\">right</span>(right) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">buildTree</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; inorder, vector&lt;<span class=\"type\">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">build</span>(inorder, <span class=\"number\">0</span>, inorder.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>, postorder, <span class=\"number\">0</span>, postorder.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">build</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; inorder, <span class=\"type\">int</span> inStart, <span class=\"type\">int</span> inEnd, vector&lt;<span class=\"type\">int</span>&gt;&amp; postorder, <span class=\"type\">int</span> postStart, <span class=\"type\">int</span> postEnd)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//递归终止条件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(inStart &gt; inEnd) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"comment\">//root 为后序遍历postorder的最后一个节点</span></span><br><span class=\"line\">        <span class=\"type\">int</span> rootVal = postorder[postEnd];</span><br><span class=\"line\">        <span class=\"comment\">//rootVal 在中序遍历中的索引</span></span><br><span class=\"line\">        <span class=\"type\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = inStart; i &lt;= inEnd; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(inorder[i] == rootVal)&#123;</span><br><span class=\"line\">                index = i;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//计算左子树长度</span></span><br><span class=\"line\">        <span class=\"type\">int</span> leftSize = index - inStart;</span><br><span class=\"line\">        <span class=\"comment\">//构建根节点</span></span><br><span class=\"line\">        TreeNode* root = <span class=\"keyword\">new</span> <span class=\"built_in\">TreeNode</span>(rootVal);</span><br><span class=\"line\">        <span class=\"comment\">//递归构建左右子树</span></span><br><span class=\"line\">        root-&gt;left = <span class=\"built_in\">build</span>(inorder, inStart, index - <span class=\"number\">1</span>, postorder, postStart, postStart + leftSize - <span class=\"number\">1</span>);</span><br><span class=\"line\">        root-&gt;right = <span class=\"built_in\">build</span>(inorder, index + <span class=\"number\">1</span>, inEnd, postorder, postStart + leftSize, postEnd - <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"根据前序和后序遍历构造二叉树\"><a\nhref=\"https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/\">889.\n根据前序和后序遍历构造二叉树</a></h4>\n<p>给定两个整数数组，preorder 和 postorder ，其中 preorder 是一个具有\n无重复 值的二叉树的前序遍历，postorder\n是同一棵树的后序遍历，重构并返回二叉树。</p>\n<p>如果存在多个答案，您可以返回其中 任何 一个。</p>\n<h5 id=\"示例-6\">示例：</h5>\n<p><img src=\"二叉树/lc-prepost.jpg\" /></p>\n<blockquote>\n<p>输入：preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]\n输出：[1,2,3,4,5,6,7]</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">TreeNode</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> val;</span><br><span class=\"line\">    TreeNode *left;</span><br><span class=\"line\">    TreeNode *right;</span><br><span class=\"line\">    <span class=\"built_in\">TreeNode</span>() : <span class=\"built_in\">val</span>(<span class=\"number\">0</span>), <span class=\"built_in\">left</span>(<span class=\"literal\">nullptr</span>), <span class=\"built_in\">right</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">TreeNode</span>(<span class=\"type\">int</span> x) : <span class=\"built_in\">val</span>(x), <span class=\"built_in\">left</span>(<span class=\"literal\">nullptr</span>), <span class=\"built_in\">right</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">TreeNode</span>(<span class=\"type\">int</span> x, TreeNode *left, TreeNode *right) : <span class=\"built_in\">val</span>(x), <span class=\"built_in\">left</span>(left), <span class=\"built_in\">right</span>(right) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h5 id=\"思路-6\">思路：</h5>\n<p>通过前序中序，或者后序中序遍历可以确定一棵原始二叉树，但是通过前序后序结果无法确定原始二叉树。</p>\n<p>1，首先把前序遍历的第一个节点或者后序遍历的最后一个元素作为根节点的值</p>\n<p>2，然后把前序遍历结果的第二个元素作为左子树的根节点的值</p>\n<p>3，在后序遍历结果中寻找左子树根节点的值，从而确定了左子树的索引边界，进而确定右子树的索引边界，递归构造左右子树即可</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">constructFromPrePost</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; preorder, vector&lt;<span class=\"type\">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">build</span>(preorder, <span class=\"number\">0</span>, preorder.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>, postorder, <span class=\"number\">0</span>, postorder.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">build</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; preorder, <span class=\"type\">int</span> preStart, <span class=\"type\">int</span> preEnd, vector&lt;<span class=\"type\">int</span>&gt;&amp; postorder, <span class=\"type\">int</span> postStart, <span class=\"type\">int</span> postEnd)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//递归终止条件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(preStart &gt; preEnd) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"comment\">//只剩一个节点了，直接构建为新节点即可</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(preStart == preEnd) <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TreeNode</span>(preorder[preStart]);</span><br><span class=\"line\">        <span class=\"comment\">//root 为前序遍历的第一个元素</span></span><br><span class=\"line\">        <span class=\"type\">int</span> rootVal = preorder[preStart];</span><br><span class=\"line\">        <span class=\"comment\">//leftRoot 为前序遍历的第二个元素</span></span><br><span class=\"line\">        <span class=\"comment\">//通过前序和后序遍历构造二叉树的关键在于通过左子树</span></span><br><span class=\"line\">        <span class=\"comment\">//确定preorder 和 postorder 中左右子树的元素区间</span></span><br><span class=\"line\">        <span class=\"type\">int</span> leftRootVal = preorder[preStart + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"comment\">//leftRootVal 在后序遍历数组中的索引</span></span><br><span class=\"line\">        <span class=\"type\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//这里不能等于，因为相等时,就没有leftRootVal了</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = postStart; i &lt; postEnd; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(postorder[i] == leftRootVal)&#123;</span><br><span class=\"line\">                index = i;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 左子树长度，记得加一，因为 index 也属于左子树</span></span><br><span class=\"line\">        <span class=\"type\">int</span> leftSize = index - postStart + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//先构建出当前根节点</span></span><br><span class=\"line\">        TreeNode* root = <span class=\"keyword\">new</span> <span class=\"built_in\">TreeNode</span>(rootVal);</span><br><span class=\"line\">        <span class=\"comment\">//递归构建左右子树</span></span><br><span class=\"line\">        root-&gt;left = <span class=\"built_in\">build</span>(preorder, preStart + <span class=\"number\">1</span>, preStart + leftSize, postorder, postStart, index);</span><br><span class=\"line\">        root-&gt;right = <span class=\"built_in\">build</span>(preorder, preStart + leftSize + <span class=\"number\">1</span>, preEnd, postorder, index + <span class=\"number\">1</span>, postEnd - <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"寻找重复的子树\"><a\nhref=\"https://leetcode-cn.com/problems/find-duplicate-subtrees/\">652.\n寻找重复的子树</a></h4>\n<p>给定一棵二叉树 root，返回所有重复的子树。</p>\n<p>对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。</p>\n<p>如果两棵树具有相同的结构和相同的结点值，则它们是重复的。</p>\n<h5 id=\"示例-7\">示例：</h5>\n<p><img src=\"二叉树/e1.jpg\" /></p>\n<blockquote>\n<p>输入：root = [1,2,3,4,null,2,4,null,null,4] 输出：[[2,4],[4]]</p>\n</blockquote>\n<h5 id=\"思路-7\">思路：</h5>\n<p><a\nhref=\"https://mp.weixin.qq.com/s/LJbpo49qppIeRs-FbgjsSQ\">具体请点击</a></p>\n<p>对于某一点，它应该做什么？</p>\n<p>1，以我为根的这颗二叉树长什么样？</p>\n<p>2，以其他节点为根的子树都长什么样？</p>\n<p>可以看出我们可以选择「后序遍历」框架来解决：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">traverse</span><span class=\"params\">(TreeNode* root)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">traverse</span>(root-&gt;left);</span><br><span class=\"line\">\t<span class=\"built_in\">traverse</span>(root-&gt;right);</span><br><span class=\"line\">\t<span class=\"comment\">/*解法代码位置*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为我要知道以自己为根的子树长什么样，是不是得先知道我的左右子树长什么样，再加上自己，就构成了整颗子树的样子。</p>\n<p>那么接下来我们应该怎么描述一棵二叉树的模样呢？</p>\n<p>通过二叉树序列化：通过拼接字符串的方式。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">string <span class=\"title\">traverse</span><span class=\"params\">(TreeNode* root)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//对于空节点，可以用一个特殊字符表示</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(root == null) <span class=\"keyword\">return</span> <span class=\"string\">&#x27;#&#x27;</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//将左右子树序列化成字符串</span></span><br><span class=\"line\">\tstring left = <span class=\"built_in\">traverse</span>(root-&gt;left);</span><br><span class=\"line\">\tstring right = <span class=\"built_in\">traverse</span>(root-&gt;right);</span><br><span class=\"line\">\t<span class=\"comment\">/*后序遍历位置*/</span></span><br><span class=\"line\">\t<span class=\"comment\">//左右子树加上自己，就是以自己为根的二叉树序列化结果</span></span><br><span class=\"line\">\tstring subTree = left + <span class=\"string\">&quot;,&quot;</span> + right + <span class=\"string\">&quot;,&quot;</span> + <span class=\"built_in\">to_string</span>(root-&gt;val);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> subTree;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样我们解决了第一个问题，知道了自己长什么样，现在解决第二个问题，怎么知道别人长什么样？这样我才能知道有没有其他子树根我重复。</p>\n<p>我们只需要借助<code>unordered_map</code>，让每个节点把自己子树的序列化结果存进去，这样，对于每个节点，不就知道有没有其他节点的子树和自己重复了。</p>\n<p>完整代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 记录所有子树以及出现的次数</span></span><br><span class=\"line\">    unordered_map&lt;string, <span class=\"type\">int</span>&gt; mp;</span><br><span class=\"line\">    vector&lt;TreeNode*&gt; res;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;TreeNode*&gt; <span class=\"title\">findDuplicateSubtrees</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">traverse</span>(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">traverse</span><span class=\"params\">(TreeNode* root)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//递归终止条件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;#&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//二叉树序列化</span></span><br><span class=\"line\">        string left = <span class=\"built_in\">traverse</span>(root-&gt;left);</span><br><span class=\"line\">        string right = <span class=\"built_in\">traverse</span>(root-&gt;right);</span><br><span class=\"line\">        string subTree = left + <span class=\"string\">&quot;,&quot;</span> + right + <span class=\"string\">&quot;,&quot;</span> + <span class=\"built_in\">to_string</span>(root-&gt;val);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(mp[subTree] == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            res.<span class=\"built_in\">push_back</span>(root);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//给子树对应的出现次数加一</span></span><br><span class=\"line\">        mp[subTree]++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> subTree;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"二叉树的序列化与反序列化\"><a\nhref=\"https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/\">297.\n二叉树的序列化与反序列化</a></h4>\n<p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>\n<p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 /\n反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>\n<p>提示: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode\n序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p>\n<h5 id=\"示例-8\">示例:</h5>\n<p><img src=\"二叉树/serdeser.jpg\" /></p>\n<blockquote>\n<p>输入：root = [1,2,3,null,null,4,5] 输出：[1,2,3,null,null,4,5]</p>\n</blockquote>\n<h5 id=\"思路-8\">思路：</h5>\n<p><strong>先序实现</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Codec</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将二叉树转化为字符串</span></span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">serialize</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        string res;</span><br><span class=\"line\">        <span class=\"built_in\">mySerialize</span>(root,res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 辅助函数，将二叉树存入 str</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">mySerialize</span><span class=\"params\">(TreeNode* root, string&amp; str)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            str += <span class=\"string\">&quot;#,&quot;</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//前序遍历</span></span><br><span class=\"line\">            str += <span class=\"built_in\">to_string</span>(root-&gt;val) + <span class=\"string\">&quot;,&quot;</span>;</span><br><span class=\"line\">            <span class=\"built_in\">mySerialize</span>(root-&gt;left, str);</span><br><span class=\"line\">            <span class=\"built_in\">mySerialize</span>(root-&gt;right, str);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将字符串反序列化为二叉树结构</span></span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">deserialize</span><span class=\"params\">(string data)</span> </span>&#123;</span><br><span class=\"line\">        string str;</span><br><span class=\"line\">        <span class=\"comment\">//将字符串反序列化为列表</span></span><br><span class=\"line\">        list&lt;string&gt; datalist;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span>&amp; ch : data)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>( ch == <span class=\"string\">&#x27;,&#x27;</span>)&#123;</span><br><span class=\"line\">                datalist.<span class=\"built_in\">push_back</span>(str);</span><br><span class=\"line\">                <span class=\"comment\">//删除容器存储的所有元素</span></span><br><span class=\"line\">                str.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                str.<span class=\"built_in\">push_back</span>(ch);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!str.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">            datalist.<span class=\"built_in\">push_back</span>(str);</span><br><span class=\"line\">            str.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">myDeserialize</span>(datalist);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//辅助函数，通过 nodes 列表构造二叉树</span></span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">myDeserialize</span><span class=\"params\">(list&lt;string&gt;&amp; datalist)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(datalist.<span class=\"built_in\">front</span>() == <span class=\"string\">&quot;#&quot;</span>)&#123;</span><br><span class=\"line\">            datalist.<span class=\"built_in\">erase</span>(datalist.<span class=\"built_in\">begin</span>());</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 列表最左侧就是根节点</span></span><br><span class=\"line\">        TreeNode* root = <span class=\"keyword\">new</span> <span class=\"built_in\">TreeNode</span>(<span class=\"built_in\">stoi</span>(datalist.<span class=\"built_in\">front</span>()));</span><br><span class=\"line\">        datalist.<span class=\"built_in\">erase</span>(datalist.<span class=\"built_in\">begin</span>());</span><br><span class=\"line\">        root-&gt;left = <span class=\"built_in\">myDeserialize</span>(datalist);</span><br><span class=\"line\">        root-&gt;right = <span class=\"built_in\">myDeserialize</span>(datalist);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"二叉搜索子树的最大键值和\"><a\nhref=\"https://leetcode-cn.com/problems/maximum-sum-bst-in-binary-tree/\">1373.\n二叉搜索子树的最大键值和</a></h4>\n<p>给你一棵以 root 为根的 二叉树 ，请你返回 任意\n二叉搜索子树的最大键值和。</p>\n<p>二叉搜索树的定义如下：</p>\n<ul>\n<li><p>任意节点的左子树中的键值都 小于 此节点的键值。</p></li>\n<li><p>任意节点的右子树中的键值都 大于 此节点的键值。</p></li>\n<li><p>任意节点的左子树和右子树都是二叉搜索树。</p></li>\n</ul>\n<h5 id=\"示例-9\">示例：</h5>\n<p><img src=\"二叉树/sample_1_1709.png\" /></p>\n<blockquote>\n<p>输入：root = [1,4,3,2,4,2,5,null,null,null,null,null,null,4,6]\n输出：20 解释：键值为 3 的子树是和最大的二叉搜索树。</p>\n</blockquote>\n<h5 id=\"思路-9\">思路：</h5>\n<p>1，左右子树是不是BST</p>\n<p>2，左子树的最大值和右子树的最小值</p>\n<p>3，左右子树的节点值之和</p>\n<p>traverse(root)返回一个大小为4的int数组res</p>\n<p>res[0] 记录以 root\n为根的二叉树是否是BST，若为1则说明是BST，否则不是</p>\n<p>res[1] 记录以 root 为根的二叉树所有节点中的最小值；</p>\n<p>res[2] 记录以 root 为根的二叉树所有节点中的最大值；</p>\n<p>res[3] 记录以 root 为根的二叉树所有节点值之和；</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> maxSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maxSumBST</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">traverse</span>(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxSum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">traverse</span><span class=\"params\">(TreeNode* root)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//递归终止条件</span></span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; tmp = &#123;<span class=\"number\">1</span>,INT_MAX,INT_MIN,<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> tmp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 递归计算左右子树</span></span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">left</span><span class=\"params\">(<span class=\"number\">4</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">right</span><span class=\"params\">(<span class=\"number\">4</span>)</span></span>;</span><br><span class=\"line\">        left = <span class=\"built_in\">traverse</span>(root-&gt;left);</span><br><span class=\"line\">        right = <span class=\"built_in\">traverse</span>(root-&gt;right);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//后序遍历位置</span></span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">res</span><span class=\"params\">(<span class=\"number\">4</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"comment\">// if 判断以 root 为根的二叉树是不是BST</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(left[<span class=\"number\">0</span>] == <span class=\"number\">1</span> &amp;&amp; right[<span class=\"number\">0</span>] == <span class=\"number\">1</span> &amp;&amp; root-&gt;val &gt; left[<span class=\"number\">2</span>] &amp;&amp; root-&gt;val &lt; right[<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">            res[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"comment\">//计算以 root 为根的这颗 BST 的最小值</span></span><br><span class=\"line\">            res[<span class=\"number\">1</span>] = <span class=\"built_in\">min</span>(left[<span class=\"number\">1</span>],root-&gt;val);</span><br><span class=\"line\">            <span class=\"comment\">//计算以 root 为根的这颗 BST 的最大值</span></span><br><span class=\"line\">            res[<span class=\"number\">2</span>] = <span class=\"built_in\">max</span>(right[<span class=\"number\">2</span>],root-&gt;val);</span><br><span class=\"line\">            <span class=\"comment\">//计算以 root 为根的这颗 BST 所有节点之和</span></span><br><span class=\"line\">            res[<span class=\"number\">3</span>] = left[<span class=\"number\">3</span>] + right[<span class=\"number\">3</span>] + root-&gt;val;</span><br><span class=\"line\">            <span class=\"comment\">//更新全局变量</span></span><br><span class=\"line\">            maxSum = <span class=\"built_in\">max</span>(maxSum, res[<span class=\"number\">3</span>]);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//以 root 为根的二叉树不是 BST</span></span><br><span class=\"line\">            res[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"comment\">//其他值就不需要计算了</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["二叉树","leetcode"],"tags":["二叉树"]},{"title":"二叉搜索树BST","url":"/2022/04/23/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91BST/","content":"<p>前面我们讲了<a\nhref=\"https://sjchen404.github.io/2022/03/07/二叉树/#more\">二叉树</a>，二叉搜索树(<code>BST</code>)就是特殊的二叉树而已。</p>\n<p>首先，<code>BST</code>性质：</p>\n<ul>\n<li>对于<code>BST</code>的每个节点<code>node</code>，左子树节点的值都比<code>node</code>的值小，右子树节点的值都比<code>node</code>的值大。</li>\n<li>对于<code>BST</code>的每一个节点<code>node</code>，它的左子树和右子树都是<code>BST</code></li>\n<li><code>BST</code>的<strong>中序遍历是升序</strong>。</li>\n</ul>\n<p>二叉搜索树并不算难，但是基于<code>BST</code>的数据结构有二叉平衡树(<code>AVL</code>)，红黑树等等，还有<code>B+</code>树，线段树等结构都是基于<code>BST</code>的思想来设计的。</p>\n<p>二叉搜索树上的基本操作所花费的时间与这棵树的高度成正比。基本操作的运行时间为<code>O(lgN)</code></p>\n<p>对于特性三，我们输入一颗<code>BST</code>树，可以通过中序遍历把<code>BST</code>中每个节点的值升序打印出来。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">traverse</span><span class=\"params\">(TreeNode *root)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"built_in\">traverse</span>(root-&gt;left);</span><br><span class=\"line\">    <span class=\"comment\">//中序遍历位置</span></span><br><span class=\"line\">    cout &lt;&lt; root-&gt;val;</span><br><span class=\"line\">    <span class=\"built_in\">traverse</span>(root-&gt;right);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<span id=\"more\"></span>\n<p>#1. 寻找第K大的元素</p>\n<h2 id=\"二叉搜索树中第k小的元素\"><a\nhref=\"https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/\">230.\n二叉搜索树中第K小的元素</a></h2>\n<p>给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数\n<code>k</code> ，请你设计一个算法查找其中第 <code>k</code>\n个最小元素（从 1 开始计数）。</p>\n<h3 id=\"示例\">示例：</h3>\n<p><img src=\"二叉搜索树BST/kthtree1.jpg\" /></p>\n<blockquote>\n<p>输入：root = [3,1,4,null,2], k = 1 输出：1</p>\n</blockquote>\n<h4 id=\"结构\">结构：</h4>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">TreeNode</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> val;</span><br><span class=\"line\">    TreeNode *left;</span><br><span class=\"line\">    TreeNode *right;</span><br><span class=\"line\">    <span class=\"built_in\">TreeNode</span>() : <span class=\"built_in\">val</span>(<span class=\"number\">0</span>), <span class=\"built_in\">left</span>(<span class=\"literal\">nullptr</span>), <span class=\"built_in\">right</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">TreeNode</span>(<span class=\"type\">int</span> x) : <span class=\"built_in\">val</span>(x), <span class=\"built_in\">left</span>(<span class=\"literal\">nullptr</span>), <span class=\"built_in\">right</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">TreeNode</span>(<span class=\"type\">int</span> x, TreeNode *left, TreeNode *right) : <span class=\"built_in\">val</span>(x), <span class=\"built_in\">left</span>(left), <span class=\"built_in\">right</span>(right) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"思路\">思路：</h4>\n<p>中序遍历，我们先遍历左子树，通过一个计数器<code>cnt</code>来计算是第几小的数，当<code>cnt == k</code>时结束</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;<span class=\"comment\">//记录当前排名</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">kthSmallest</span><span class=\"params\">(TreeNode* root, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//BST 中序遍历是升序</span></span><br><span class=\"line\">        <span class=\"built_in\">inorder</span>(root, k);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">inorder</span><span class=\"params\">(TreeNode* root, <span class=\"type\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">inorder</span>(root-&gt;left, k);</span><br><span class=\"line\">        cnt++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cnt == k)&#123;</span><br><span class=\"line\">            res = root-&gt;val;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">inorder</span>(root-&gt;right, k);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>##<a\nhref=\"https://leetcode-cn.com/problems/convert-bst-to-greater-tree/\">538.\n把二叉搜索树转换为累加树</a></p>\n<p>给出二叉 搜索\n树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum\nTree），使每个节点 <code>node</code>的新值等于原树中大于或等于\n<code>node.val</code>的值之和。</p>\n<p>提醒一下，二叉搜索树满足下列约束条件：</p>\n<p>节点的左子树仅包含键 小于 节点键的节点。 节点的右子树仅包含键 大于\n节点键的节点。 左右子树也必须是二叉搜索树。</p>\n<h3 id=\"示例-1\">示例：</h3>\n<p><img src=\"二叉搜索树BST/tree.png\" /></p>\n<h4 id=\"思路-1\">思路：</h4>\n<p>先遍历右子树，然后值相加。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">convertBST</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//BST 中序遍历是升序,反过来先遍历右子树再遍历左子树就是降序</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"built_in\">convertBST</span>(root-&gt;right);</span><br><span class=\"line\">        root-&gt;val = root-&gt;val + sum;</span><br><span class=\"line\">        sum = root-&gt;val;</span><br><span class=\"line\">        <span class=\"built_in\">convertBST</span>(root-&gt;left);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>#2. 二叉搜索树的搜索，插入，删除</p>\n<p>一般操作</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">BST</span><span class=\"params\">(TreeNode *root, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;val == target)</span><br><span class=\"line\">    <span class=\"comment\">//找到⽬标，做点什么</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root-&gt;val &gt; target)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">BST</span>(root-&gt;left, target)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root-&gt;val &lt; target)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">BST</span>(root-&gt;right, target)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二叉搜索树中的搜索\"><a\nhref=\"https://leetcode-cn.com/problems/search-in-a-binary-search-tree/\">700.\n二叉搜索树中的搜索</a></h2>\n<p>给定二叉搜索树（<code>BST</code>）的根节点\n<code>root</code>和一个整数值 <code>val</code>。</p>\n<p>你需要在 <code>BST</code>中找到节点值等于 <code>val</code>的节点。\n返回以该节点为根的子树。 如果节点不存在，则返回 <code>null</code>。</p>\n<h3 id=\"示例-2\">示例：</h3>\n<p><img src=\"二叉搜索树BST/tree1.jpg\" /></p>\n<blockquote>\n<p>输入：root = [4,2,7,1,3], val = 2 输出：[2,1,3]</p>\n</blockquote>\n<h4 id=\"思路-2\">思路：</h4>\n<p>用<code>BST</code>的第一个特性，节点比左子树大，比右子树小。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">searchBST</span><span class=\"params\">(TreeNode* root, <span class=\"type\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//base case</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//  去左边找</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root-&gt;val &gt; val)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">searchBST</span>(root-&gt;left, val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//去右边找</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root-&gt;val &lt; val)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">searchBST</span>(root-&gt;right, val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二叉搜索树中的插入操作\"><a\nhref=\"https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/\">701.\n二叉搜索树中的插入操作</a></h2>\n<p>给定二叉搜索树（<code>BST</code>）的根节点 root 和要插入树中的值\n<code>value</code>，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。\n输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。</p>\n<p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。\n你可以返回 <strong>任意有效的结果 。</strong></p>\n<h3 id=\"示例-3\">示例：</h3>\n<p><img src=\"二叉搜索树BST/insertbst.jpg\" /></p>\n<blockquote>\n<p>输入：root = [4,2,7,1,3], val = 5 输出：[4,2,7,1,3,5]\n解释：另一个满足题目要求可以通过的树是：</p>\n<p><img src=\"二叉搜索树BST/bst.jpg\" /></p>\n</blockquote>\n<h4 id=\"思路-3\">思路：</h4>\n<p>插入有多种情况，最简单的就是在叶子节点插入，总可以找到这样一个节点。另一种需要我们重构二叉搜索树。</p>\n<p>我们先采用简单的方法。</p>\n<p>找到要插入的最后一个节点，构造新节点，判断要插入节点和当前节点的大小关系，如果比当前节点大，就插到右孩子处，反之，左孩子。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">insertIntoBST</span><span class=\"params\">(TreeNode* root, <span class=\"type\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TreeNode</span>(val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root-&gt;val &gt; val)&#123;</span><br><span class=\"line\">            root-&gt;left = <span class=\"built_in\">insertIntoBST</span>(root-&gt;left, val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root-&gt;val &lt; val)&#123;</span><br><span class=\"line\">            root-&gt;right = <span class=\"built_in\">insertIntoBST</span>(root-&gt;right, val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>在讲删除之前，我们首先需要了解下如何判断二叉树是不是二叉搜索树。</strong></p>\n<p>定义：</p>\n<ul>\n<li><code>BST</code>中任意一个节点的左子树所有节点的值都小于该节点的值，右子树所有节点的值都大于该节点的值。</li>\n<li><code>BST</code>中任意一个节点的左右子树都是<code>BST</code>。</li>\n</ul>\n<p>第二点是我们经常忽略的。我们需要找出左子树的最大的元素值，还有右子树的最小元素值去和当前节点比较，当前节点大于左子树的最大元素，小于右子树的最小元素，这才是合法的二叉搜索树。</p>\n<h2 id=\"验证二叉搜索树\"><a\nhref=\"https://leetcode-cn.com/problems/validate-binary-search-tree/\">98.\n验证二叉搜索树</a></h2>\n<p>给你一个二叉树的根节点\n<code>root</code>，判断其是否是一个有效的二叉搜索树。</p>\n<p>有效 二叉搜索树定义如下：</p>\n<p>节点的左子树只包含 小于 当前节点的数。 节点的右子树只包含 大于\n当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。</p>\n<p>###示例：</p>\n<p><img src=\"二叉搜索树BST/tree1-1.jpg\" /></p>\n<blockquote>\n<p>输入：root = [2,1,3] 输出：true</p>\n</blockquote>\n<h4 id=\"思路-4\">思路：</h4>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isValidBST</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">isValidBST</span>(root, <span class=\"literal\">nullptr</span>, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isValidBST</span><span class=\"params\">(TreeNode* root, TreeNode* min, TreeNode* max)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//base case</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">//若root-&gt;val 不符合 max 和 min 的限制，说明不是合法的 BST</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(min != <span class=\"literal\">nullptr</span> &amp;&amp; root-&gt;val &lt;= min-&gt;val) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(max != <span class=\"literal\">nullptr</span> &amp;&amp; root-&gt;val &gt;= max-&gt;val) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">//限定左子树的最大值为 root-&gt;val 右子树的最小值为 root-&gt;val</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">isValidBST</span>(root-&gt;left, min, root) </span><br><span class=\"line\">            &amp;&amp; <span class=\"built_in\">isValidBST</span>(root-&gt;right, root, max);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"删除二叉搜索树中的节点\"><a\nhref=\"https://leetcode-cn.com/problems/delete-node-in-a-bst/\">450.\n删除二叉搜索树中的节点</a></h2>\n<p>给定一个二叉搜索树的根节点 <code>root</code>和一个值\n<code>key</code>，删除二叉搜索树中的\n<code>key</code>对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>\n<p>一般来说，删除节点可分为两个步骤：</p>\n<p>首先找到需要删除的节点； 如果找到了，删除它。</p>\n<h3 id=\"示例-4\">示例：</h3>\n<p><img src=\"二叉搜索树BST/del_node_1.jpg\" /></p>\n<h4 id=\"思路-5\">思路：</h4>\n<p>我们首先先找到这个节点，然后再去修改。</p>\n<p>查找的话和我们前面的搜索一样</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">BST</span><span class=\"params\">(TreeNode *root, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root-&gt;val == target)</span><br><span class=\"line\">    <span class=\"comment\">//找到⽬标</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root-&gt;val &gt; target)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">BST</span>(root-&gt;left, target)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(root-&gt;val &lt; target)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">BST</span>(root-&gt;right, target)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>找到目标节点后，比如说节点<code>A</code>，如何删除这个节点呢？因为删除节点的同时不能破坏<code>BST</code>的性质。一共有<code>3</code>种情况：</p>\n<p><strong>情况一：<code>A</code>恰好是末端叶子节点。两个子节点都为空，那么我们可以直接删除</strong></p>\n<p><img src=\"二叉搜索树BST/bst_deletion_case_1.png\" /></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(root-&gt;left == <span class=\"literal\">nullptr</span> &amp;&amp; root-&gt;right == <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>情况二：<code>A</code>只有一个非空字节点，那么它要让这个孩子接替自己的位置</strong></p>\n<p><img src=\"二叉搜索树BST/bst_deletion_case_2.png\" /></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(root-&gt;left == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> root-&gt;right;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(root-&gt;right == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> root-&gt;left;</span><br></pre></td></tr></table></figure>\n<p><strong>情况三：</strong><code>A</code>有两个子节点，为了不破坏<code>BST</code>的性质，<code>A</code>必须找到左子树中最大的那个节点或者右子树中最小的那个节点来接替自己。这里我们选择第二种。</p>\n<p><img src=\"二叉搜索树BST/bst_deletion_case_3.png\" /></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(root-&gt;left != <span class=\"literal\">nullptr</span> &amp;&amp; root-&gt;right != <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">  <span class=\"comment\">//找到右子树的最小节点</span></span><br><span class=\"line\">  TreeNode *minNode = <span class=\"built_in\">getMin</span>(root-&gt;right);</span><br><span class=\"line\">  <span class=\"comment\">//把 root 改成 minNode</span></span><br><span class=\"line\">  root-&gt;val = minNode-&gt;val;</span><br><span class=\"line\">  <span class=\"comment\">//删除 minNode</span></span><br><span class=\"line\">  root-&gt;right = <span class=\"built_in\">deleteNode</span>(root-&gt;right, minNode-&gt;val);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>完整代码如下:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">deleteNode</span><span class=\"params\">(TreeNode* root, <span class=\"type\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// base case</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//和root节点比较,如果key比根节点大，我们就去右边寻找，否则左边</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root-&gt;val == key)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//1,左右孩子都为空，或者一边为空</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(root-&gt;left == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> root-&gt;right;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(root-&gt;right == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> root-&gt;left;</span><br><span class=\"line\">            <span class=\"comment\">//2,两边都不为空，我们可以直接把右孩子的最小节点代替父亲节点</span></span><br><span class=\"line\">            <span class=\"comment\">//获得右子树的最小节点</span></span><br><span class=\"line\">            TreeNode* minNode = <span class=\"built_in\">getMin</span>(root-&gt;right);</span><br><span class=\"line\">            <span class=\"comment\">//删除右子树大最小节点</span></span><br><span class=\"line\">            root-&gt;right = <span class=\"built_in\">deleteNode</span>(root-&gt;right, minNode-&gt;val);</span><br><span class=\"line\">            <span class=\"comment\">//用右子树最小的节点替换 root 节点</span></span><br><span class=\"line\">            minNode-&gt;left = root-&gt;left;</span><br><span class=\"line\">            minNode-&gt;right = root-&gt;right;</span><br><span class=\"line\">            root = minNode;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(root-&gt;val &gt; key)&#123;<span class=\"comment\">//去左边找</span></span><br><span class=\"line\">            root-&gt;left = <span class=\"built_in\">deleteNode</span>(root-&gt;left, key);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(root-&gt;val &lt; key)&#123;<span class=\"comment\">//去右边找</span></span><br><span class=\"line\">            root-&gt;right = <span class=\"built_in\">deleteNode</span>(root-&gt;right, key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">getMin</span><span class=\"params\">(TreeNode* node)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//bst 最左边的就是最小的节点</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(node-&gt;left != <span class=\"literal\">nullptr</span>) node = node-&gt;left;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"构造篇\">3. 构造篇</h1>\n<h2 id=\"不同的二叉搜索树\"><a\nhref=\"https://leetcode-cn.com/problems/unique-binary-search-trees/\">96.\n不同的二叉搜索树</a></h2>\n<p>给你一个整数 <code>n</code> ，求恰由 <code>n</code>\n个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的\n<strong>二叉搜索树</strong>\n有多少种？返回满足题意的二叉搜索树的种数。</p>\n<h3 id=\"示例-5\">示例：</h3>\n<p><img src=\"二叉搜索树BST/uniquebstn3.jpg\" /></p>\n<blockquote>\n<p>输入：n = 3 输出：5</p>\n</blockquote>\n<h4 id=\"思路-6\">思路：</h4>\n<p>例如我们输入：<code>n = 5</code>，也就是说用<code>&#123;1,2,3,4,5&#125;</code>这些数字去构造<code>BST</code>。</p>\n<p>首先，根节点有<code>5</code>种情况，因为每个数字都可以作为根节点。</p>\n<p>比如我们固定<code>3</code>作为根节点，这个前提下能有几种不同的<code>BST</code>呢？</p>\n<p>根据 BST\n的特性，根节点的左子树都比根节点的值小，右子树的值都比根节点的值大。</p>\n<p>所以如果固定<code>3</code>作为根节点，左子树节点就是<code>&#123;1,2&#125;</code>的组合，右子树就是<code>&#123;4,5&#125;</code>的组合。</p>\n<p><strong>左子树的组合数和右子树的组合数乘积</strong>就是<code>3</code>作为根节点时的\nBST 个数。</p>\n<p><img src=\"二叉搜索树BST/bst_3.jpg\" /></p>\n<p>一共有<code>2*2 = 4种</code>,组合问题。</p>\n<p>我们这是说了<code>3</code>为根节点这一种特殊情况，其实其他的节点也是一样的。</p>\n<p>那你可能会问，我们可以一眼看出<code>&#123;1,2&#125;</code>和<code>&#123;4,5&#125;</code>有几种组合，但是怎么让算法进行计算呢？</p>\n<p>我们只需要递归就可以了，我们可以写这样一个函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; memo;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">numTrees</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        memo.<span class=\"built_in\">resize</span>(n + <span class=\"number\">1</span>,<span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(n + <span class=\"number\">1</span>,<span class=\"number\">-1</span>));</span><br><span class=\"line\">        <span class=\"comment\">//计算闭区间 [1,n] 组成的 BST 个数</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">count</span>(<span class=\"number\">1</span>,n);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">////计算闭区间 [1,n] 组成的 BST 个数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">count</span><span class=\"params\">(<span class=\"type\">int</span> lo, <span class=\"type\">int</span> hi)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//base case</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(lo &gt; hi) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">//避免重复计算</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(memo[lo][hi] != <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> memo[lo][hi];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = lo; i &lt;= hi; i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// i 的值作为根节点 root</span></span><br><span class=\"line\">            <span class=\"type\">int</span> left = <span class=\"built_in\">count</span>(lo, i - <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"type\">int</span> right = <span class=\"built_in\">count</span>(i + <span class=\"number\">1</span>, hi);</span><br><span class=\"line\">            <span class=\"comment\">// 左右子树的组合数乘积是 BST 的总数</span></span><br><span class=\"line\">            res += left * right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        memo[lo][hi] = res;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>注意 base\ncase，显然当<code>lo &gt; hi</code>闭区间<code>[lo, hi]</code>肯定是个空区间，也就对应着空节点\n<code>nullptr</code>，虽然是空节点，但是也是一种情况，所以要返回\n<code>1</code>而不能返回 <code>0</code>。</p>\n<h5 id=\"方法二卡特兰数\">方法二：卡特兰数</h5>\n<p>令<code>h(0)=1,h(1)=1</code>，catalan数满足递推式。<strong>h(n)=\nh(0)*h(n-1)+h(1)*h(n-2) + ... + h(n-1)h(0)\n(n&gt;=2)。</strong>也就是说，如果能把公式化成上面这种形式的数，就是卡特兰数<strong>。</strong></p>\n<p><strong>通项公式:</strong> <span class=\"math display\">\\[\nC_n = \\frac{1}{n + 1}C^{n}_{2n} = C^{n}_{2n} - C^{n-1}_{2n}\n\\]</span> 假设\n<code>n</code>个节点存在二叉排序树的个数是<code>G (n)</code>，令<code>f(i)</code>为以<code>i</code>\n为根的二叉搜索树的个数，则 <span class=\"math display\">\\[\nG(n) = f(1) + f(2) + f(3) + ... + f(n)\n\\]</span>\n当<code>i</code>为根节点的时候，其左子树个数为<code>i-1</code>个，右子树为<code>n - i</code>则：\n<span class=\"math display\">\\[\nf(i) = G(i-1)*G(n-i)\n\\]</span> 综上可以得到卡特兰数： <span class=\"math display\">\\[\nG(n) = G(0) * G(n-1) + G(1) * G(n-2) + ... + G(n-1)*G(0)\n\\]</span> 代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">numTrees</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">G</span><span class=\"params\">(n + <span class=\"number\">1</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        G[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        G[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">2</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= i; j++)&#123;</span><br><span class=\"line\">                G[i] += G[j - <span class=\"number\">1</span>] * G[i - j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> G[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"不同的二叉搜索树-ii\"><a\nhref=\"https://leetcode-cn.com/problems/unique-binary-search-trees-ii/\">95.\n不同的二叉搜索树 II</a></h2>\n<p>给你一个整数 <code>n</code> ，请你生成并返回所有由 <code>n</code>\n个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的不同\n<strong>二叉搜索树</strong> 。可以按 <strong>任意顺序</strong>\n返回答案。</p>\n<h3 id=\"示例-6\">示例：</h3>\n<p><img src=\"二叉搜索树BST/uniquebstn3.jpg\" /></p>\n<blockquote>\n<p>输入：n = 3\n输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]</p>\n</blockquote>\n<h4 id=\"思路-7\">思路：</h4>\n<p><strong>明白了上道题构造合法 BST\n的方法，这道题的思路也是一样的</strong>：</p>\n<p>1、穷举<code>root</code>节点的所有可能。</p>\n<p>2、递归构造出左右子树的所有合法 BST。</p>\n<p>3、给<code>root</code>节点穷举所有左右子树的组合。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;TreeNode*&gt; <span class=\"title\">generateTrees</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">        <span class=\"comment\">//构造闭区间为 [1,n] 组成的BST</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">build</span>(<span class=\"number\">1</span>,n);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;TreeNode*&gt; <span class=\"title\">build</span><span class=\"params\">(<span class=\"type\">int</span> lo, <span class=\"type\">int</span> hi)</span></span>&#123;</span><br><span class=\"line\">        vector&lt;TreeNode*&gt; res;</span><br><span class=\"line\">        <span class=\"comment\">//base case</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(lo &gt; hi)&#123;</span><br><span class=\"line\">            res.<span class=\"built_in\">push_back</span>(<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 1,穷举 root 节点的所有可能</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = lo; i &lt;= hi; i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 2,递归构造出左右子树的所有合法 BST</span></span><br><span class=\"line\">            vector&lt;TreeNode*&gt; leftTree = <span class=\"built_in\">build</span>(lo, i - <span class=\"number\">1</span>);</span><br><span class=\"line\">            vector&lt;TreeNode*&gt; rightTree = <span class=\"built_in\">build</span>(i + <span class=\"number\">1</span>, hi);</span><br><span class=\"line\">            <span class=\"comment\">// 3,给 root 节点穷举所有左右子树的组合</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(TreeNode* left : leftTree)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(TreeNode* right : rightTree)&#123;</span><br><span class=\"line\">                    <span class=\"comment\">// i 作为根节点 root 的值</span></span><br><span class=\"line\">                    TreeNode* root = <span class=\"keyword\">new</span> <span class=\"built_in\">TreeNode</span>(i);</span><br><span class=\"line\">                    root-&gt;left = left;</span><br><span class=\"line\">                    root-&gt;right = right;</span><br><span class=\"line\">                    res.<span class=\"built_in\">push_back</span>(root);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["二叉树","二叉搜索树"],"tags":["二叉搜索树","二叉树"]},{"title":"八皇后","url":"/2019/04/09/%E5%85%AB%E7%9A%87%E5%90%8E/","content":"<p><a\nhref=\"https://www.luogu.org/problemnew/show/P1219\">题目链接</a></p>\n<h1 id=\"题目描述\">题目描述</h1>\n<p>检查一个如下的6 x\n6的跳棋棋盘，有六个棋子被放置在棋盘上，使得每行、每列有且只有一个，每条对角线(包括两条主对角线的所有平行线)上至多有一个棋子。</p>\n<figure>\n<img src=\"八皇后/60.png\" alt=\"img\" />\n<figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<p>上面的布局可以用序列2 4 6 1 3\n5来描述，第i个数字表示在第i行的相应位置有一个棋子，如下：</p>\n<p>行号 1 2 3 4 5 6</p>\n<p>列号 2 4 6 1 3 5</p>\n<p>这只是跳棋放置的一个解。请编一个程序找出所有跳棋放置的解。并把它们以上面的序列方法输出。解按字典顺序排列。请输出前3个解。最后一行是解的总个数。</p>\n<p>//以下的话来自usaco官方，不代表洛谷观点</p>\n<p>特别注意: 对于更大的N(棋盘大小N x\nN)你的程序应当改进得更有效。不要事先计算出所有解然后只输出(或是找到一个关于它的公式），这是作弊。如果你坚持作弊，那么你登陆USACO\nTraining的帐号删除并且不能参加USACO的任何竞赛。我警告过你了！</p>\n<span id=\"more\"></span>\n<h2 id=\"输入输出格式\">输入输出格式</h2>\n<p>输入格式：</p>\n<p>一个数字N (6 &lt;= N &lt;= 13) 表示棋盘是N x N大小的。</p>\n<p>输出格式：</p>\n<p>前三行为前三个解，每个解的两个数字之间用一个空格隔开。第四行只有一个数字，表示解的总数。</p>\n<h3 id=\"输入样例\">输入样例：</h3>\n<blockquote>\n<p>6</p>\n</blockquote>\n<h3 id=\"输出样例\">输出样例：</h3>\n<blockquote>\n<p>2 4 6 1 3 5</p>\n<p>3 6 2 5 1 4</p>\n<p>4 1 5 2 6 3</p>\n<p>4</p>\n</blockquote>\n<h4 id=\"解题思路\">解题思路：</h4>\n<p>dfs模版题</p>\n<p>我们可以注意到从左下角到右上角的对角线上各个元素的（行+列）都相等</p>\n<p>从右下角到左上角的各个元素的\n(行-列)都相等，为了避免出现负数。我们用(行-列+n)来表示。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">int</span> n,sum;</span><br><span class=\"line\"><span class=\"type\">int</span> ans[<span class=\"number\">14</span>],check[<span class=\"number\">3</span>][<span class=\"number\">50</span>]=&#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    sum++;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(sum&lt;=<span class=\"number\">3</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">            cout&lt;&lt;ans[i]&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> line)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(check[<span class=\"number\">0</span>][i]==<span class=\"number\">0</span>&amp;&amp;check[<span class=\"number\">1</span>][line+i]==<span class=\"number\">0</span>&amp;&amp;check[<span class=\"number\">2</span>][line-i+n]==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            ans[line]=i;<span class=\"comment\">//第line行第j个</span></span><br><span class=\"line\">            check[<span class=\"number\">0</span>][i]=<span class=\"number\">1</span>;<span class=\"comment\">//占列</span></span><br><span class=\"line\">            check[<span class=\"number\">1</span>][line+i]=<span class=\"number\">1</span>;<span class=\"comment\">//占左下角到右上角的对角线</span></span><br><span class=\"line\">            check[<span class=\"number\">2</span>][line-i+n]=<span class=\"number\">1</span>;<span class=\"comment\">//占右下到左上的对角线</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(line==n)<span class=\"built_in\">print</span>();</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"built_in\">dfs</span>(line+<span class=\"number\">1</span>);</span><br><span class=\"line\">            check[<span class=\"number\">0</span>][i]=<span class=\"number\">0</span>;check[<span class=\"number\">1</span>][line+i]=<span class=\"number\">0</span>;check[<span class=\"number\">2</span>][line-i+n]=<span class=\"number\">0</span>;<span class=\"comment\">//回溯</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","categories":["dfs"],"tags":["dfs"]},{"title":"分割字符串","url":"/2022/04/10/%E5%88%86%E5%89%B2%E5%AD%97%E7%AC%A6%E4%B8%B2/","content":"<p>我们经常遇到要分割字符串例如</p>\n<blockquote>\n<p>20-21,15,18,30,5-10</p>\n</blockquote>\n<p>以<code>,</code>来分割</p>\n<span id=\"more\"></span>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Stringsplit</span><span class=\"params\">(string str, <span class=\"type\">const</span> <span class=\"type\">char</span> split,vector&lt;string&gt;&amp; res)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">istringstream <span class=\"title\">iss</span><span class=\"params\">(str)</span></span>;\t<span class=\"comment\">// 输入流</span></span><br><span class=\"line\">\tstring token;\t\t\t<span class=\"comment\">// 接收缓冲区</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (<span class=\"built_in\">getline</span>(iss, token, split))\t<span class=\"comment\">// 以split为分隔符</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tres.<span class=\"built_in\">push_back</span>(token);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们只需要调用</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">string str;</span><br><span class=\"line\">vector&lt;string&gt; res;</span><br><span class=\"line\"><span class=\"built_in\">Stringsplit</span>(str, <span class=\"string\">&#x27;,&#x27;</span>, res);</span><br></pre></td></tr></table></figure>\n","categories":["字符串","stringstream"],"tags":["字符串","stringstream"]},{"title":"分苹果","url":"/2022/04/03/%E5%88%86%E8%8B%B9%E6%9E%9C/","content":"<p>#分苹果</p>\n<p>有A，B两个同学想要分苹果。A的想法是使用二进制进行，1 +\n1相加不进一位，如（9 + 5 = 1001 +101 =\n12）。B同学的想法是使用十进制进行，并且进一位。\n会输入两组数据，一组是苹果总数，一组分别是每个苹果的重量。如果让B同学在满足A同学的情况下获取到苹果的总重量且返回，如果不能则返回-1。</p>\n<p>输入</p>\n<blockquote>\n<p>3</p>\n<p>3 5 6</p>\n</blockquote>\n<p>返回</p>\n<blockquote>\n<p>11</p>\n</blockquote>\n<p>备注：按照A同学的想法 5 + 6 = 3 （101 + 110 = 010）</p>\n<span id=\"more\"></span>\n<h2 id=\"思路\">思路：</h2>\n<p>对于 a 来说是平分</p>\n<p>5 + 6 = (101 + 110 = 010) = 3</p>\n<p>对于 b 来说 5 + 6 = (101 + 110) = 1011 = 11</p>\n<p>1，如果最终有解，那么所有数字的异或结果为0（两个相同数字异或是0），最终答案就是\n所有数字的十进制和，减去这些数字里的最小值就是了。</p>\n<p>2，如果无解，那么所有数字的异或结果非零，直接返回-1</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"type\">int</span> minApple = INT_MAX;</span><br><span class=\"line\">    <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> apple;</span><br><span class=\"line\">        cin &gt;&gt; apple;</span><br><span class=\"line\">        sum += apple;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(apple &lt; minApple)&#123;</span><br><span class=\"line\">            minApple = apple;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//全部数求异或(相同为0，不同为1)</span></span><br><span class=\"line\">        res = res ^ apple;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//代表符合 a 的情况</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(res == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        cout &lt;&lt; sum - minApple &lt;&lt; endl;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"number\">-1</span> &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["异或","华为"],"tags":["异或"]},{"title":"俄罗斯套娃信封问题","url":"/2022/04/13/%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98/","content":"<h1 id=\"俄罗斯套娃信封问题\"><a\nhref=\"https://leetcode-cn.com/problems/russian-doll-envelopes/\">354.\n俄罗斯套娃信封问题</a></h1>\n<p>给你一个二维整数数组 envelopes ，其中 envelopes[i] = [wi, hi]\n，表示第 i 个信封的宽度和高度。</p>\n<p>当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。</p>\n<p>请计算 最多能有多少个\n信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。</p>\n<p>注意：不允许旋转信封。</p>\n<h2 id=\"示例\">示例：</h2>\n<blockquote>\n<p>输入：envelopes = [[5,4],[6,4],[6,7],[2,3]] 输出：3\n解释：最多信封的个数为 3, 组合为: [2,3] =&gt; [5,4] =&gt; [6,7]。</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"思路\">思路：</h3>\n<p>我们首先想到的肯定是排序，假设信封是有由<code>(w,h)</code>这样的二维数对组成。</p>\n<p>我们先按照宽度<code>w</code>进行升序排序，如果遇到<code>w</code>相同的情况，则按照高度<code>h</code>降序排序。最后把所有的<code>h</code>组成一个新的数组，进行<a\nhref=\"https://sjchen404.github.io/2022/04/11/最长递增子序列/#more\">最长递增子序列</a>。就是最后的答案。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maxEnvelopes</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt;&amp; envelopes)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = envelopes.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"comment\">//按宽度升序排列，如果宽度一样，则按照高度降序排列</span></span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(envelopes.<span class=\"built_in\">begin</span>(), envelopes.<span class=\"built_in\">end</span>(), [](<span class=\"type\">const</span> vector&lt;<span class=\"type\">int</span>&gt;&amp; e1, <span class=\"type\">const</span> vector&lt;<span class=\"type\">int</span>&gt;&amp; e2)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(e1[<span class=\"number\">0</span>] == e2[<span class=\"number\">0</span>]) <span class=\"keyword\">return</span> e1[<span class=\"number\">1</span>] &gt; e2[<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">return</span> e1[<span class=\"number\">0</span>] &lt; e2[<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"comment\">//对高度数组寻找 LIS</span></span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">height</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            height[i] = envelopes[i][<span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">lengthOfLIS</span>(height);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  \t<span class=\"comment\">//最长递增子序列</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">lengthOfLIS</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">top</span><span class=\"params\">(nums.size(), <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"comment\">// 牌堆数初始化为0</span></span><br><span class=\"line\">        <span class=\"type\">int</span> piles = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 想要处理的扑克牌</span></span><br><span class=\"line\">            <span class=\"type\">int</span> poker = nums[i];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 搜索左侧边界的二分查找</span></span><br><span class=\"line\">            <span class=\"type\">int</span> left = <span class=\"number\">0</span>, right = piles;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(left &lt; right)&#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> mid = (left + right) / <span class=\"number\">2</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(top[mid] &gt; poker)&#123;</span><br><span class=\"line\">                    right = mid;</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(top[mid] &lt; poker)&#123;</span><br><span class=\"line\">                    left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    right = mid;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 没找到合适的牌堆，新建一堆</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(left == piles) piles++;</span><br><span class=\"line\">            <span class=\"comment\">// 把这张牌放到牌堆顶</span></span><br><span class=\"line\">            top[left] = poker;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> piles;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["二分查找"],"tags":["二分查找"]},{"title":"前缀和数组","url":"/2022/03/24/%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84/","content":"<p>前缀和技巧适用于快速、频繁地计算一个索引区间内的元素之和。</p>\n<h1 id=\"区域和检索---数组不可变\"><a\nhref=\"https://leetcode-cn.com/problems/range-sum-query-immutable/\">303.\n区域和检索 - 数组不可变</a></h1>\n<p>给定一个整数数组 <code>nums</code>，处理以下类型的多个查询:</p>\n<p>计算索引 <code>left</code>和<code>right</code> （包含 left 和\nright）之间的 nums 元素的和 ，其中 left &lt;= right 实现 NumArray\n类：</p>\n<ul>\n<li>NumArray(int[] nums) 使用数组 nums 初始化对象</li>\n<li>int sumRange(int i, int j) 返回数组 nums 中索引 left 和 right\n之间的元素的总和 ，包含 left 和 right 两点（也就是\n<code>nums[left] + nums[left + 1] + ... + nums[right] )</code></li>\n</ul>\n<h2 id=\"示例\">示例：</h2>\n<blockquote>\n<p>输入： [\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"] [[[-2, 0, 3,\n-5, 2, -1]], [0, 2], [2, 5], [0, 5]] 输出： [null, 1, -1, -3]</p>\n<p>解释： NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);\nnumArray.sumRange(0, 2); // return 1 ((-2) + 0 + 3) numArray.sumRange(2,\n5); // return -1 (3 + (-5) + 2 + (-1)) numArray.sumRange(0, 5); //\nreturn -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"思路\">思路：</h3>\n<p>我们如果没有学过前缀和，可以这样写出。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">NumArray</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; myNums;</span><br><span class=\"line\">    <span class=\"built_in\">NumArray</span>(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">        myNums = nums;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">sumRange</span><span class=\"params\">(<span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = left; i &lt;= right; i++)&#123;</span><br><span class=\"line\">            res += myNums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这样，可以达到效果，但是效率很差，因为 <code>sumRange</code>\n方法会被频繁调用，而它的时间复杂度是 <code>O(N)</code>，其中\n<code>N</code> 代表 <code>nums</code> 数组的长度。</p>\n<p>这道题的最优解法是使用前缀和技巧，将 <code>sumRange</code>\n函数的时间复杂度降为 <code>O(1)</code>，说白了就是不要在\n<code>sumRange</code> 里面用 for 循环，咋整？</p>\n<p>核心思路是我们 new 一个新的数组 <code>preSum</code>\n出来，<code>preSum[i]</code> 记录 <code>nums[0..i-1]</code>\n的累加和，看图 10 = 3 + 5 + 2：</p>\n<p><img src=\"前缀和数组/1.jpg\" style=\"zoom:67%;\" /></p>\n<p>看这个 <code>preSum</code> 数组，如果我想求索引区间\n<code>[1, 4]</code> 内的所有元素之和，就可以通过\n<code>preSum[5] - preSum[1]</code> 得出。</p>\n<p>这样，<code>sumRange</code>\n函数仅仅需要做一次减法运算，避免了每次进行 for\n循环调用，最坏时间复杂度为常数 <code>O(1)</code>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">NumArray</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; preSum;</span><br><span class=\"line\">    <span class=\"built_in\">NumArray</span>(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// preSum[0] = 0, 便于计算累加和</span></span><br><span class=\"line\">        preSum.<span class=\"built_in\">resize</span>(nums.<span class=\"built_in\">size</span>() + <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"comment\">//计算 nums 的累加和</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; preSum.<span class=\"built_in\">size</span>(); i++)&#123;</span><br><span class=\"line\">            preSum[i] = preSum[i - <span class=\"number\">1</span>] + nums[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">sumRange</span><span class=\"params\">(<span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> preSum[right + <span class=\"number\">1</span>] - preSum[left];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"二维区域和检索---矩阵不可变\"><a\nhref=\"https://leetcode-cn.com/problems/range-sum-query-2d-immutable/\">304.\n二维区域和检索 - 矩阵不可变</a></h1>\n<p>给定一个二维矩阵 matrix，以下类型的多个请求：</p>\n<p>计算其子矩形范围内元素的总和，该子矩阵的 左上角 为 (row1, col1)\n，右下角 为 (row2, col2) 。 实现 NumMatrix 类：</p>\n<p>NumMatrix(int[][] matrix) 给定整数矩阵 matrix 进行初始化 int\nsumRegion(int row1, int col1, int row2, int col2) 返回 左上角 (row1,\ncol1) 、右下角 (row2, col2) 所描述的子矩阵的元素总和</p>\n<h2 id=\"示例-1\">示例：</h2>\n<p><img src=\"前缀和数组/2.jpg\" style=\"zoom:67%;\" /></p>\n<blockquote>\n<p>输入: [\"NumMatrix\",\"sumRegion\",\"sumRegion\",\"sumRegion\"]\n[[[[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]],[2,1,4,3],[1,1,2,2],[1,2,2,4]]\n输出: [null, 8, 11, 12]</p>\n<p>解释: NumMatrix numMatrix = new\nNumMatrix([[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]);\nnumMatrix.sumRegion(2, 1, 4, 3); // return 8 (红色矩形框的元素总和)\nnumMatrix.sumRegion(1, 1, 2, 2); // return 11 (绿色矩形框的元素总和)\nnumMatrix.sumRegion(1, 2, 2, 4); // return 12 (蓝色矩形框的元素总和)</p>\n</blockquote>\n<h3 id=\"思路-1\">思路：</h3>\n<p><img src=\"前缀和数组/3.png\" style=\"zoom:67%;\" /></p>\n<p>如果我想计算红色的这个子矩阵的元素之和，可以用绿色矩阵减去蓝色矩阵减去橙色矩阵最后加上粉色矩阵，而绿蓝橙粉这四个矩阵有一个共同的特点，就是左上角就是\n<code>(0, 0)</code> 原点。</p>\n<p>那么我们可以维护一个二维 <code>preSum</code>\n数组，专门记录以原点为顶点的矩阵的元素之和，就可以用几次加减运算算出任何一个子矩阵的元素和：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">NumMatrix</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; preSum;</span><br><span class=\"line\">    <span class=\"built_in\">NumMatrix</span>(vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt;&amp; matrix) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> m = matrix.<span class=\"built_in\">size</span>(), n = matrix[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(m == <span class=\"number\">0</span> || n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"comment\">//构造前缀和矩阵</span></span><br><span class=\"line\">        preSum.<span class=\"built_in\">resize</span>(m + <span class=\"number\">1</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(n + <span class=\"number\">1</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//计算每个矩阵[0, 0, i, j] 的元素和</span></span><br><span class=\"line\">                preSum[i][j] = preSum[i - <span class=\"number\">1</span>][j] + preSum[i][j - <span class=\"number\">1</span>] + matrix[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>] - preSum[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">sumRegion</span><span class=\"params\">(<span class=\"type\">int</span> row1, <span class=\"type\">int</span> col1, <span class=\"type\">int</span> row2, <span class=\"type\">int</span> col2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> preSum[row2 + <span class=\"number\">1</span>][col2 + <span class=\"number\">1</span>] - preSum[row1][col2 + <span class=\"number\">1</span>] - preSum[row2 + <span class=\"number\">1</span>][col1] + preSum[row1][col1];   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"和为-k-的子数组\"><a\nhref=\"https://leetcode-cn.com/problems/subarray-sum-equals-k/\">560. 和为\nK 的子数组</a></h1>\n<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code>\n，请你统计并返回 <em>该数组中和为 <code>k</code> 的子数组的个数</em>\n。</p>\n<h2 id=\"示例-2\">示例：</h2>\n<blockquote>\n<p>输入：nums = [1,1,1], k = 2 输出：2</p>\n<p>输入：nums = [1,2,3], k = 3 输出：2</p>\n</blockquote>\n<h3 id=\"思路-2\">思路：</h3>\n<h4 id=\"方法一暴力\">方法一：暴力</h4>\n<p>时机复杂度为<code>O(N^2)</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">subarraySum</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 构造前缀和</span></span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">preSum</span><span class=\"params\">(n + <span class=\"number\">1</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        preSum[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            preSum[i + <span class=\"number\">1</span>] = preSum[i] + nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 穷举所有子数组</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; i; j++)&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 子数组 nums[j..i-1] 的元素和</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(preSum[i] - preSum[j] == k)&#123;</span><br><span class=\"line\">                    res++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二前缀和加哈希表优化\">方法二：前缀和加哈希表优化</h4>\n<p>我们针对上一个方法中的穷举所有子数组进行优化</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; i; j++)&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 子数组 nums[j..i-1] 的元素和</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(preSum[i] - preSum[j] == k)&#123;</span><br><span class=\"line\">          res++;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第二层 for 循环在干嘛呢？翻译一下就是，<strong>在计算，有几个\n<code>j</code> 能够使得 <code>preSum[i]</code> 和 <code>preSum[j]</code>\n的差为 <code>k</code></strong>。毎找到一个这样的\n<code>j</code>，就把结果加一。</p>\n<p>优化的思路是：<strong>我直接记录下有几个 <code>preSum[j]</code> 和\n<code>preSum[i] - k</code> 相等，直接更新结果，就避免了内层的 for\n循环</strong>。我们可以用哈希表，在记录前缀和的同时记录该前缀和出现的次数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">subarraySum</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// map：前缀和 -&gt; 该前缀和出现的次数</span></span><br><span class=\"line\">        unordered_map&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; preSum;</span><br><span class=\"line\">        preSum[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>, pre = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> x : nums)&#123;</span><br><span class=\"line\">            pre += x;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(preSum.<span class=\"built_in\">count</span>(pre - k))&#123;</span><br><span class=\"line\">                res += preSum[pre - k];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            preSum[pre]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>注意这里我们 <code>preSum</code>\n记录的是前缀和到该前缀和出现的次数的映射</strong>。</p>\n<p>这样，就把时间复杂度降到了 <code>O(N)</code>，是最优解法了。</p>\n","categories":["前缀和","数组","leetcode"],"tags":["数组","前缀和"]},{"title":"华为机试","url":"/2022/02/24/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95/","content":"<p>华为机试</p>\n<span id=\"more\"></span>\n<p>####HJ1 字符串最后一个单词的长度</p>\n<p><strong>计算字符串最后一个单词的长度，单词以空格隔开，字符串长度小于5000。（注：字符串末尾不以空格为结尾）</strong></p>\n<p><strong>示例：</strong></p>\n<blockquote>\n<p>输入 hello world</p>\n<p>输出 8</p>\n</blockquote>\n<p><strong>思路：</strong></p>\n<p>从后往前开始计算，碰到第一个空格时，长度为字符串长度-当前所在的位置-1；</p>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    string s1=<span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">getline</span>(cin,s1);</span><br><span class=\"line\">    <span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = s1.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>; i &gt;= <span class=\"number\">0</span>; --i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s1[i] == <span class=\"string\">&#x27; &#x27;</span>)&#123;</span><br><span class=\"line\">            ans = s1.<span class=\"built_in\">size</span>() - i - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(i==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            ans = s1.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>####<strong>HJ2</strong> <strong>计算某字符出现次数</strong></p>\n<p><strong>写出一个程序，接受一个由字母、数字和空格组成的字符串，和一个字符，然后输出输入字符串中该字符的出现次数。（不区分大小写字母）</strong></p>\n<blockquote>\n<p>ABCabc</p>\n<p>A</p>\n<p>输出：2</p>\n</blockquote>\n<p><strong>思路：</strong></p>\n<p>由于不区分大小写，所以将大写转化为小写，统计输出次数。</p>\n<p>tolower函数把小写字母转换为小写，非字母字符不做出处理</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    string s1;</span><br><span class=\"line\">    <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">getline</span>(cin,s1))&#123;</span><br><span class=\"line\">        <span class=\"type\">char</span> input;</span><br><span class=\"line\">        cin &gt;&gt; input;</span><br><span class=\"line\">        cin.<span class=\"built_in\">ignore</span>();</span><br><span class=\"line\">        input= <span class=\"built_in\">tolower</span>(input);<span class=\"comment\">//转化为小写</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;s1.<span class=\"built_in\">size</span>();++i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s1[i]==input|| s1[i]==input<span class=\"number\">-32</span>)&#123;</span><br><span class=\"line\">                res++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"hj3-明明的随机数\"><strong>HJ3</strong>\n<strong>明明的随机数</strong></h4>\n<p>明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了\nN 个 1 到 1000 之间的随机整数（ N≤1000\n），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。现在明明把他已经用计算机生成好的\nN\n个随机数按照下面的输入描述的格式交给你，请你协助明明完成“去重”与“排序”的工作(同一个测试用例里可能会有多组数据(用于不同的调查)，希望大家能正确处理)。</p>\n<p>注：测试用例保证输入参数的正确性，答题者无需验证。测试用例不止一组。</p>\n<p>当没有新的输入时，说明输入结束。</p>\n<p>数据范围： 1≤n≤1000 1≤<em>n</em>≤1000 ，输入的数字大小满足 1≤val≤500\n1≤<em>v<strong>a</strong>l</em>≤500</p>\n<blockquote>\n<p>3 2 2 1 11 10 20 40 32 67 40 20 89 300 400 15</p>\n<p>输出：</p>\n<p>1 2 10 15 20 32 40 67 89 300 400</p>\n<p>说明：</p>\n<p>示例1包含了两个小样例！！<br />\n输入解释：\n第一个数字是3，也即这个小样例的N=3，说明用计算机生成了3个1到1000之间的随机整数，接下来每行一个随机数字，共3行，也即这3个随机数字为：\n2 2 1 所以第一个小样例的输出为： 1 2\n第二个小样例的第一个数字为11，也即...(类似上面的解释)...\n所以第二个小样例的输出为： 10 15 20 32 40 67 89 300 400</p>\n</blockquote>\n<p><strong>思路：</strong></p>\n<p>类似于map,统计，最后遍历一遍输出即可</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> number,n;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cin&gt;&gt;number)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> a[<span class=\"number\">1001</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(number--)&#123;</span><br><span class=\"line\">            cin&gt;&gt;n;</span><br><span class=\"line\">            a[n]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>;i&lt;<span class=\"number\">1001</span>;++i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a[i])&#123;</span><br><span class=\"line\">                cout&lt;&lt;i&lt;&lt;endl;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"hj4-字符串分隔\"><strong>HJ4</strong>\n<strong>字符串分隔</strong></h4>\n<p>•连续输入字符串，请按长度为8拆分每个输入字符串并进行输出；</p>\n<p>•长度不是8整数倍的字符串请在后面补数字0，空字符串不处理。</p>\n<p>（注：本题有多组输入）</p>\n<p><strong>示例：</strong></p>\n<blockquote>\n<p>输入：</p>\n<p>abc 123456789</p>\n<p>输出：</p>\n<p>abc00000 12345678 90000000</p>\n</blockquote>\n<p><strong>思路：</strong></p>\n<p>我们在读取的字符串后面增加7个零，这样我们就可以保证后面的0；在通过substr函数进行提取，这里需要简单介绍下substr函数。</p>\n<p>s.substr(pos,len)，返回值是string,包含s中从pos开始的len个字符的拷贝。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    string s1;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cin&gt;&gt;s1)&#123;</span><br><span class=\"line\">        s1 = s1 + <span class=\"string\">&quot;0000000&quot;</span>;    <span class=\"comment\">//增加7个0，然后substr函数截取前8个</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(s1.<span class=\"built_in\">size</span>()&gt;=<span class=\"number\">8</span>)&#123;</span><br><span class=\"line\">            cout&lt;&lt;s1.<span class=\"built_in\">substr</span>(<span class=\"number\">0</span>,<span class=\"number\">8</span>)&lt;&lt;endl;</span><br><span class=\"line\">            s1 = s1.<span class=\"built_in\">substr</span>(<span class=\"number\">8</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"hj5-进制转换\"><strong>HJ5</strong>\n<strong>进制转换</strong></h4>\n<p>写出一个程序，接受一个十六进制的数，输出该数值的十进制表示。</p>\n<p>数据范围：保证结果在 1≤n≤231−1 1≤<em>n</em>≤231−1</p>\n<p>注意本题有多组输入</p>\n<p><strong>示例：</strong></p>\n<blockquote>\n<p>输入：</p>\n<p>0xA 0xAA</p>\n<p>输出：</p>\n<p>10 170</p>\n</blockquote>\n<p><strong>思路：</strong></p>\n<p>方法一：</p>\n<p>直接用流类格式化输入输出</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> a;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(cin&gt;&gt;hex&gt;&gt;a)</span><br><span class=\"line\">\tcout&lt;&lt;dec&lt;&lt;a&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>方法二：</p>\n<p>主要就是十进制和十六进制的转换关系。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    string s;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cin&gt;&gt;s)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> bit=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i =s.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;i&gt;<span class=\"number\">1</span>;--i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[i]&gt;=<span class=\"string\">&#x27;0&#x27;</span>&amp;&amp;s[i]&lt;=<span class=\"string\">&#x27;9&#x27;</span>)&#123;</span><br><span class=\"line\">                ans+=(s[i]-<span class=\"string\">&#x27;0&#x27;</span>)*<span class=\"built_in\">pow</span>(<span class=\"number\">16</span>,bit++);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(s[i]&gt;=<span class=\"string\">&#x27;A&#x27;</span>&amp;&amp;s[i]&lt;=<span class=\"string\">&#x27;F&#x27;</span>)&#123;</span><br><span class=\"line\">                ans+=(s[i]-<span class=\"string\">&#x27;A&#x27;</span>+<span class=\"number\">10</span>)*<span class=\"built_in\">pow</span>(<span class=\"number\">16</span>,bit++);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>####HJ6 质数因子</p>\n<p>功能:输入一个正整数，按照从小到大的顺序输出它的所有质因子（重复的也要列举）（如180的质因子为2\n2 3 3 5 ）</p>\n<p>数据范围： 1≤n≤2×109+14 1≤<em>n</em>≤2×109+14</p>\n<p><strong>输入描述：</strong></p>\n<p>输入一个整数</p>\n<p><strong>输出描述：</strong></p>\n<p>按照从小到大的顺序输出它的所有质数的因子，以空格隔开。最后一个数后面也要有空格。</p>\n<p><strong>示例：</strong></p>\n<blockquote>\n<p>输入：180</p>\n<p>输出：2 2 3 3 5</p>\n</blockquote>\n<p><strong>思路：</strong></p>\n<p>输出所有质数的因子，那么这个因子最大也就是这个数值开根号，比如25，质数因子就是\n5、5；除数从2开始，进行除法计算，除不尽就用3，以此类推，直到除数增加到该数的开根号。</p>\n<p>有除数能除的最后数值一定是1，如果不是1，那就是这个数本身就是质因子，只有1和本身可以整数，直接输出即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> res;</span><br><span class=\"line\">    <span class=\"type\">long</span> i = <span class=\"number\">2</span>;</span><br><span class=\"line\">    cin &gt;&gt; res;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i;i&lt;=<span class=\"built_in\">sqrt</span>(res);i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(res%i==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            cout&lt;&lt;i&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">            res /= i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(res&gt;<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        cout&lt;&lt;res&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"hj7-取近似值\"><strong>HJ7</strong>\n<strong>取近似值</strong></h4>\n<p>写出一个程序，接受一个正浮点数值，输出该数值的近似整数值。如果小数点后数值大于等于\n0.5 ,向上取整；小于 0.5 ，则向下取整。</p>\n<p>数据范围：保证输入的数字在 32 位浮点数范围内</p>\n<p><strong>示例：</strong></p>\n<blockquote>\n<p>输入：5.5</p>\n<p>输出：6</p>\n<p>输入：2.499</p>\n<p>输出：2</p>\n</blockquote>\n<p><strong>思路：</strong></p>\n<p>直接在输入的数上+0.5，然后通过int取整就可以了</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> input;</span><br><span class=\"line\">    cin&gt;&gt;input;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"built_in\">int</span>(input+<span class=\"number\">0.5</span>)&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>####<strong>HJ8</strong> <strong>合并表记录</strong></p>\n<p>数据表记录包含表索引和数值（int范围的正整数），请对表索引相同的记录进行合并，即将相同索引的数值进行求和运算，输出按照key值升序进行输出。</p>\n<p>提示:</p>\n<p>0 &lt;= index &lt;= 11111111</p>\n<p>1 &lt;= value &lt;= 100000</p>\n<p><strong>输入描述:</strong></p>\n<p>先输入键值对的个数n（1 &lt;= n &lt;= 500）\n然后输入成对的index和value值，以空格隔开</p>\n<p><strong>输出描述：</strong></p>\n<p>输出合并后的键值对（多行）</p>\n<p><strong>示例：</strong></p>\n<blockquote>\n<p>输入：</p>\n<p>4 0 1 0 2 1 2 3 4</p>\n<p>输出：</p>\n<p>0 3 1 2 3 4</p>\n</blockquote>\n<p><strong>解题思路：</strong></p>\n<p>方法一：</p>\n<p>我们用一个数组来存储，对相同索引的数值求和，最后遍历输出数值大与0的即可。（不能完全AC）</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> num;</span><br><span class=\"line\">    cin&gt;&gt;num;</span><br><span class=\"line\">    <span class=\"type\">int</span> sum[<span class=\"number\">1000</span>]=&#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"type\">int</span> index,value;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;num;i++)&#123;</span><br><span class=\"line\">        cin&gt;&gt;index&gt;&gt;value;</span><br><span class=\"line\">        sum[index]+=value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">1000</span>;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sum[i]!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            cout&lt;&lt;i&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;sum[i]&lt;&lt;endl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>方法二：</p>\n<p>利用C++的map实现</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    map&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt;sum;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"type\">int</span> index,value;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n--)&#123;</span><br><span class=\"line\">        cin&gt;&gt;index&gt;&gt;value;</span><br><span class=\"line\">        sum[index]+=value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> c:sum)&#123;</span><br><span class=\"line\">        cout&lt;&lt;c.first&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;c.second&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"hj9-提取不重复的整数\"><strong>HJ9</strong>\n<strong>提取不重复的整数</strong></h4>\n<p>输入一个 int\n型整数，按照从右向左的阅读顺序，返回一个不含重复数字的新的整数。</p>\n<p>保证输入的整数最后一位不是 0 。</p>\n<p>数据范围： 1≤n≤108 1≤<em>n</em>≤108</p>\n<p><strong>示例：</strong></p>\n<blockquote>\n<p>输入：9876673</p>\n<p>输出：37689</p>\n</blockquote>\n<p><strong>解题思路：</strong></p>\n<p>转化为字符串的方法来解决，这里了解一下string::npos</p>\n<p>find函数在找不到指定值得情况下会返回string::npos。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    string str;</span><br><span class=\"line\">    string str1=<span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    cin&gt;&gt;str;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=str.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;i&gt;=<span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str1.<span class=\"built_in\">find</span>(str[i])==string::npos)</span><br><span class=\"line\">            str1+=str[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;str1&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>方法二：</strong></p>\n<p>使用数组a[10]来更新，每次把a[n%10]来判断是否出现过</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    <span class=\"type\">int</span> a[<span class=\"number\">10</span>]=&#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"type\">int</span> num=<span class=\"number\">0</span>;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a[n%<span class=\"number\">10</span>]==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            a[n%<span class=\"number\">10</span>]++;<span class=\"comment\">//这一步更新，遇到相同的数会跳过</span></span><br><span class=\"line\">            num = num*<span class=\"number\">10</span>+n%<span class=\"number\">10</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        n/=<span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;num&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>####<strong>HJ10</strong> <strong>字符个数统计</strong></p>\n<p>编写一个函数，计算字符串中含有的不同字符的个数。字符在 ASCII\n码范围内( 0~127 ，包括 0 和 127\n)，换行表示结束符，不算在字符里。不在范围内的不作统计。多个相同的字符只计算一次</p>\n<p>例如，对于字符串 abaca 而言，有 a、b、c 三种不同的字符，因此输出 3\n。</p>\n<p>数据范围： 1≤n≤500 1≤<em>n</em>≤500</p>\n<h5 id=\"示例\">示例：</h5>\n<blockquote>\n<p>输入：abc</p>\n<p>输出：3</p>\n</blockquote>\n<p>#####思路：</p>\n<p>set就是关键字的简单集合。当只是想知道一个值是否存在时，set是最有用的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    string str;</span><br><span class=\"line\">    set&lt;<span class=\"type\">char</span>&gt;s;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">getline</span>(cin,str))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;str.<span class=\"built_in\">size</span>();i++)&#123;</span><br><span class=\"line\">            s.<span class=\"built_in\">insert</span>(str[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;s.<span class=\"built_in\">size</span>()&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"hj11-数字颠倒\"><strong>HJ11</strong>\n<strong>数字颠倒</strong></h4>\n<p>输入一个整数，将这个整数以字符串的形式逆序输出</p>\n<p>程序不考虑负数的情况，若数字含有0，则逆序形式也含有0，如输入为100，则输出为001</p>\n<p>数据范围： 0≤n≤230−1 0≤<em>n</em>≤230−1</p>\n<h5 id=\"示例-1\">示例：</h5>\n<blockquote>\n<p>输入：1516000</p>\n<p>输出：0006151</p>\n</blockquote>\n<h5 id=\"思路\">思路：</h5>\n<p>转化为string,然后翻转</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> input;</span><br><span class=\"line\">    cin&gt;&gt;input;</span><br><span class=\"line\">    string res = <span class=\"built_in\">to_string</span>(input);</span><br><span class=\"line\">    <span class=\"built_in\">reverse</span>(res.<span class=\"built_in\">begin</span>(), res.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    cout&lt;&lt;res;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"hj12-字符串反转\"><strong>HJ12</strong>\n<strong>字符串反转</strong></h4>\n<p>接受一个只包含小写字母的字符串，然后输出该字符串反转后的字符串。（字符串长度不超过1000）</p>\n<h5 id=\"示例-2\">示例：</h5>\n<blockquote>\n<p>输入：abcd</p>\n<p>输出：dcba</p>\n</blockquote>\n<h5 id=\"思路-1\">思路：</h5>\n<p>直接reverse()</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    string str;</span><br><span class=\"line\">    cin&gt;&gt;str;</span><br><span class=\"line\">    <span class=\"built_in\">reverse</span>(str.<span class=\"built_in\">begin</span>(),str.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    cout&lt;&lt;str;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"hj13-句子逆序\"><strong>HJ13</strong>\n<strong>句子逆序</strong></h4>\n<p>将一个英文语句以单词为单位逆序排放。例如“I am a\nboy”，逆序排放后为“boy a am I”</p>\n<p>所有单词之间用一个空格隔开，语句中除了英文字母外，不再包含其他字符</p>\n<p>数据范围：输入的字符串长度满足 1≤n≤1000 1≤<em>n</em>≤1000</p>\n<p>注意本题有多组输入</p>\n<h4 id=\"示例-3\">示例：</h4>\n<blockquote>\n<p>输入：I am a boy</p>\n<p>输出：boy a am I</p>\n</blockquote>\n<h5 id=\"思路-2\">思路：</h5>\n<p>我们定义一个string数组，顺序输入，倒序输出即可</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    string str;</span><br><span class=\"line\">    vector&lt;string&gt; tmp;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cin&gt;&gt;str)&#123;</span><br><span class=\"line\">        tmp.<span class=\"built_in\">push_back</span>(str);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=tmp.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;i&gt;<span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">        cout&lt;&lt;tmp[i]&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;tmp[<span class=\"number\">0</span>]&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"hj14-字符串排序\"><strong>HJ14</strong>\n<strong>字符串排序</strong></h4>\n<h5 id=\"描述\">描述</h5>\n<p>给定 n 个字符串，请对 n 个字符串按照字典序排列。</p>\n<p>数据范围： 1≤n≤1000 1≤<em>n</em>≤1000 ，字符串长度满足 1≤len≤100\n1≤<em>l<strong>e</strong>n</em>≤100</p>\n<h5 id=\"输入描述\">输入描述：</h5>\n<p>输入第一行为一个正整数n(1≤n≤1000),下面n行为n个字符串(字符串长度≤100),字符串中只含有大小写字母。</p>\n<h5 id=\"输出描述\">输出描述：</h5>\n<p>数据输出n行，输出结果为按照字典序排列的字符串。</p>\n<h5 id=\"示例-4\">示例：</h5>\n<blockquote>\n<p>输入：</p>\n<p>9 cap to cat card two too up boat boot</p>\n<p>输出：</p>\n<p>boat boot cap card cat to too two up</p>\n</blockquote>\n<h5 id=\"思路-3\">思路：</h5>\n<p>直接排序</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    vector&lt;string&gt; res;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n--)&#123;</span><br><span class=\"line\">        string tmp;</span><br><span class=\"line\">        cin&gt;&gt;tmp;</span><br><span class=\"line\">        res.<span class=\"built_in\">push_back</span>(tmp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(res.<span class=\"built_in\">begin</span>(),res.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;res.<span class=\"built_in\">size</span>();i++)&#123;</span><br><span class=\"line\">        cout&lt;&lt;res[i]&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>####HJ15 求int型正整数在内存中存储时1的个数</p>\n<p>#####描述</p>\n<p>输入一个 int 型的正整数，计算出该 int 型数据在内存中存储时 1\n的个数。</p>\n<p>数据范围：保证在 32 位整型数字范围内</p>\n<h5 id=\"输入描述-1\">输入描述：</h5>\n<p>输入一个整数（int类型）</p>\n<h5 id=\"输出描述-1\">输出描述：</h5>\n<p>这个数转换成2进制后，输出1的个数</p>\n<h5 id=\"示例-5\">示例：</h5>\n<blockquote>\n<p>输入：5</p>\n<p>输出：2</p>\n</blockquote>\n<h5 id=\"思路-4\">思路：</h5>\n<p>n&amp;(n-1) 即（0111）&amp;（0110）== 0110 就是 n去除了最后一个1\n；</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cin&gt;&gt;n)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(n)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//判断二进制有多少个1</span></span><br><span class=\"line\">            n &amp;= n<span class=\"number\">-1</span>;</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout&lt;&lt;count&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["华为"],"tags":["华为"]},{"title":"区间问题","url":"/2022/04/07/%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/","content":"<p>区间问题就是线段问题，让你合并所有线段，找出线段的交集等。主要有两个技巧：</p>\n<p>1，<strong>排序：</strong>\n常见的排序方法就是按照区间起点排序，或者先按照起点升序排序，若起点相同，则按照终点降序排列。</p>\n<p>2，<strong>画图：</strong>画图可以更直观的看出两个区间的相对位置到底有几种可能，不同的相对位置，我们应该如何去解决。</p>\n<span id=\"more\"></span>\n<h1 id=\"删除被覆盖区间\"><a\nhref=\"https://leetcode-cn.com/problems/remove-covered-intervals/\">1288.\n删除被覆盖区间</a></h1>\n<p>给你一个区间列表，请你删除列表中被其他区间所覆盖的区间。</p>\n<p>只有当 c &lt;= a 且 b &lt;= d 时，我们才认为区间 [a,b) 被区间 [c,d)\n覆盖。</p>\n<p>在完成所有删除操作后，请你返回列表中剩余区间的数目。</p>\n<h2 id=\"示例\">示例：</h2>\n<blockquote>\n<p>输入：intervals = [[1,4],[3,6],[2,8]] 输出：2 解释：区间 [3,6] 被区间\n[2,8] 覆盖，所以它被删除了。</p>\n</blockquote>\n<h3 id=\"思路\">思路：</h3>\n<p>我们可以先算出被覆盖的区间有几个，最后再用总数减去即可。</p>\n<p>第一步，我们先排序：</p>\n<p><img src=\"区间问题/1.jpeg\" /></p>\n<p>排序之后，两个相邻区间可能有如下三种相对位置：</p>\n<p><img src=\"区间问题/2.jpeg\" /></p>\n<p>对于这三种情况，我们应该这样处理：</p>\n<p>对于情况一，找到了覆盖区间。</p>\n<p>对于情况二，两个区间可以合并，成一个大区间。</p>\n<p>对于情况三，两个区间完全不相交。</p>\n<p>所以代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">removeCoveredIntervals</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt;&amp; intervals)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//按照起点升序排列，起点相同时降序排列</span></span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(intervals.<span class=\"built_in\">begin</span>(), intervals.<span class=\"built_in\">end</span>(), [](<span class=\"type\">const</span> vector&lt;<span class=\"type\">int</span>&gt;&amp; a, <span class=\"type\">const</span> vector&lt;<span class=\"type\">int</span>&gt;&amp; b)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a[<span class=\"number\">0</span>] == b[<span class=\"number\">0</span>])&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> a[<span class=\"number\">1</span>] &gt; b[<span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> a[<span class=\"number\">0</span>] &lt; b[<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//记录合并区间的起点和终点</span></span><br><span class=\"line\">        <span class=\"type\">int</span> left = intervals[<span class=\"number\">0</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span> right = intervals[<span class=\"number\">0</span>][<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; intervals.<span class=\"built_in\">size</span>(); i++)&#123;</span><br><span class=\"line\">            vector&lt;<span class=\"type\">int</span>&gt; intv = intervals[i];</span><br><span class=\"line\">            <span class=\"comment\">//情况一，找到覆盖区间</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(left &lt;= intv[<span class=\"number\">0</span>] &amp;&amp; right &gt;= intv[<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                res++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//情况二，找到相交区间，合并</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(right &gt;= intv[<span class=\"number\">0</span>] &amp;&amp; right &lt;= intv[<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                right = intv[<span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//情况三，完全不相交</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(right &lt; intv[<span class=\"number\">0</span>])&#123;</span><br><span class=\"line\">                left = intv[<span class=\"number\">0</span>];</span><br><span class=\"line\">                right = intv[<span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> intervals.<span class=\"built_in\">size</span>() - res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"合并区间\"><a\nhref=\"https://leetcode-cn.com/problems/merge-intervals/\">56.\n合并区间</a></h1>\n<p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] =\n[starti, endi] 。请你合并所有重叠的区间，并返回\n一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p>\n<h2 id=\"示例-1\">示例：</h2>\n<blockquote>\n<p>输入：intervals = [[1,3],[2,6],[8,10],[15,18]]\n输出：[[1,6],[8,10],[15,18]] 解释：区间 [1,3] 和 [2,6] 重叠,\n将它们合并为 [1,6].</p>\n</blockquote>\n<h3 id=\"思路-1\">思路：</h3>\n<p>我们解决区间问题一般是先排序，然后画图。我们按照起点升序排序，得到以下图形。</p>\n<p><img src=\"区间问题/3.jpeg\" /></p>\n<p>显然，对于相交的线段，最小的起点就是<code>start</code>最小的，<code>end</code>为其中结尾最大的。那问题就转化为找到相交中起点最小的和终点最大的，</p>\n<p>由于我们已经按照起点排序了，那么第一位就是我们的<code>start</code>,那么<code>end</code>应该如何确定呢，我们只需要判断下一个要来的起点是否小于当前的终点，如果小于，那么终点就是这两个结尾的最大值。</p>\n<p>例如[1,3]和[2,6]，2 &lt; 3 所以必相交，终点就更新为max(3, 6) =\n6；</p>\n<p>代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; <span class=\"built_in\">merge</span>(vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt;&amp; intervals) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(intervals.<span class=\"built_in\">begin</span>(), intervals.<span class=\"built_in\">end</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; res;</span><br><span class=\"line\">        res.<span class=\"built_in\">push_back</span>(intervals[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; intervals.<span class=\"built_in\">size</span>(); i++)&#123;</span><br><span class=\"line\">            vector&lt;<span class=\"type\">int</span>&gt; curr = intervals[i];</span><br><span class=\"line\">            <span class=\"comment\">// res 中最后一个元素的引用</span></span><br><span class=\"line\">            vector&lt;<span class=\"type\">int</span>&gt; last = res.<span class=\"built_in\">back</span>();</span><br><span class=\"line\">            <span class=\"comment\">//后一个开始节点小于前一个的终点，所以相交或覆盖，取两条线段尾部最大的</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(curr[<span class=\"number\">0</span>] &lt;= last[<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                last[<span class=\"number\">1</span>] = <span class=\"built_in\">max</span>(last[<span class=\"number\">1</span>], curr[<span class=\"number\">1</span>]);</span><br><span class=\"line\">              \t<span class=\"comment\">//更新终点</span></span><br><span class=\"line\">                res.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">                res.<span class=\"built_in\">push_back</span>(last);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">//处理下一个待合并的区间</span></span><br><span class=\"line\">                res.<span class=\"built_in\">push_back</span>(curr);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"区间列表的交集\"><a\nhref=\"https://leetcode-cn.com/problems/interval-list-intersections/\">986.\n区间列表的交集</a></h1>\n<p>给定两个由一些 闭区间 组成的列表，firstList 和 secondList ，其中\nfirstList[i] = [starti, endi] 而 secondList[j] = [startj, endj]\n。每个区间列表都是成对 不相交 的，并且 已经排序 。</p>\n<p>返回这 两个区间列表的交集 。</p>\n<p>形式上，闭区间 [a, b]（其中 a &lt;= b）表示实数 x 的集合，而 a &lt;=\nx &lt;= b 。</p>\n<p>两个闭区间的 交集 是一组实数，要么为空集，要么为闭区间。例如，[1, 3]\n和 [2, 4] 的交集为 [2, 3] 。</p>\n<h2 id=\"示例-2\">示例：</h2>\n<p><img src=\"区间问题/4.jpeg\" /></p>\n<blockquote>\n<p>输入：firstList = [[0,2],[5,10],[13,23],[24,25]], secondList =\n[[1,5],[8,12],[15,24],[25,26]]\n输出：[[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]</p>\n</blockquote>\n<h3 id=\"思路-2\">思路：</h3>\n<p><strong>第一步，排序</strong>，已经排过序了，那我们使用双指针。</p>\n<p>我们分析下各种情况：</p>\n<ul>\n<li>对于两个区间，我们用<code>[a1,a2]</code>和<code>[b1,b2]</code>表示在A\n和 B中的两个区间，那么什么时候没有交集呢？</li>\n</ul>\n<p><img src=\"区间问题/5.jpg\" /></p>\n<p>只有这两种情况：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(b2 &lt; a1 || a2 &lt; b1)&#123;</span><br><span class=\"line\">\t[a1,a2]和[b1,b2]无交集</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么什么时候存在交集呢？根据命题的否定</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(b2 &gt;= a1 &amp;&amp; a2 &gt;= b1)&#123;</span><br><span class=\"line\">\t存在交集</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>穷举出来如下：</p>\n<p><img src=\"区间问题/6.jpg\" /></p>\n<p>这很简单吧，就这四种情况而已。那么接下来思考，这几种情况下，交集是否有什么共同点呢？</p>\n<p><img src=\"区间问题/7.jpg\" /></p>\n<p>我们惊奇地发现，交集区间是有规律的！如果交集区间是<code>[c1,c2]</code>，那么<code>c1=max(a1,b1)</code>，<code>c2=min(a2,b2)</code>！这一点就是寻找交集的核心，我们把代码更进一步：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> i &lt; <span class=\"built_in\">len</span>(A) <span class=\"keyword\">and</span> j &lt; <span class=\"built_in\">len</span>(B):</span><br><span class=\"line\">    a1, a2 = A[i][<span class=\"number\">0</span>], A[i][<span class=\"number\">1</span>]</span><br><span class=\"line\">    b1, b2 = B[j][<span class=\"number\">0</span>], B[j][<span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> b2 &gt;= a1 <span class=\"keyword\">and</span> a2 &gt;= b1:</span><br><span class=\"line\">        res.<span class=\"built_in\">append</span>([<span class=\"built_in\">max</span>(a1, b1), <span class=\"built_in\">min</span>(a2, b2)])</span><br><span class=\"line\">    # ...</span><br></pre></td></tr></table></figure>\n<p>最后一步，我们的指针 <code>i</code>和<code>j</code>什么时候前进？</p>\n<p>我们发现当 b2 &lt;\na2时，我们的<code>j</code>会往前，因为此时这个线段的最长已经在A的里面了。</p>\n<p>同理当 b2 &gt;= a2 时， <code>i++</code>;</p>\n<p>所以，完整代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; <span class=\"built_in\">intervalIntersection</span>(vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt;&amp; firstList, vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt;&amp; secondList) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(firstList.<span class=\"built_in\">size</span>() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(secondList.<span class=\"built_in\">size</span>() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> i  = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i &lt; firstList.<span class=\"built_in\">size</span>() &amp;&amp; j &lt; secondList.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> a1 = firstList[i][<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"type\">int</span> a2 = firstList[i][<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">int</span> b1 = secondList[j][<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"type\">int</span> b2 = secondList[j][<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//两个区间存在交集</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(b2 &gt;= a1 &amp;&amp; a2 &gt;= b1)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//计算出交集，加入res</span></span><br><span class=\"line\">                res.<span class=\"built_in\">push_back</span>(&#123;<span class=\"built_in\">max</span>(a1,b1), <span class=\"built_in\">min</span>(a2,b2)&#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//指针前进</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(b2 &lt; a2) j += <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> i += <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["排序","区间"],"tags":["leetcode","区间","排序"]},{"title":"单词方阵","url":"/2019/04/11/%E5%8D%95%E8%AF%8D%E6%96%B9%E9%98%B5/","content":"<p><a\nhref=\"https://www.luogu.org/problemnew/show/P1101\">题目链接</a></p>\n<h1 id=\"题目描述\">题目描述</h1>\n<p>给一n×n的字母方阵，内可能蕴含多个“<code>yizhong</code>”单词。单词在方阵中是沿着同一方向连续摆放的。摆放可沿着\n8个方向的任一方向，同一单词摆放时不再改变方向，单词与单词之间可以交叉,因此有可能共用字母。输出时，将不是单词的字母用<code>*</code>代替，以突出显示单词。例如:</p>\n<span id=\"more\"></span>\n<figure>\n<img src=\"单词方阵/1.jpg\" alt=\"img\" />\n<figcaption aria-hidden=\"true\">img</figcaption>\n</figure>\n<h2 id=\"输入输出格式\">输入输出格式</h2>\n<p>输入格式：</p>\n<p>第一行输入一个数<code>n</code>。<code>(7≤n≤100)</code>。</p>\n<p>第二行开始输入<code>n×n</code>的字母矩阵。</p>\n<p>输出格式：</p>\n<p>突出显示单词的<code>n×n</code>矩阵</p>\n<h3 id=\"解题思路\">解题思路：</h3>\n<p>也是dfs,(dfs大法好)，我们只要找到开头的y，然后dfs查找八个方向中下一个字母为i的方向(dfs的方向不变)，一直到终点即可。</p>\n<p>这题关键还是我们要记录路径，也就是要记录我们走过的点。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">char</span> str[<span class=\"number\">100</span>][<span class=\"number\">100</span>];</span><br><span class=\"line\"><span class=\"type\">char</span> s[<span class=\"number\">9</span>]=&#123;<span class=\"string\">&quot;yizhong&quot;</span>&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> dir[][<span class=\"number\">2</span>]=&#123;&#123;<span class=\"number\">-1</span>,<span class=\"number\">-1</span>&#125;,&#123;<span class=\"number\">-1</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">-1</span>,<span class=\"number\">1</span>&#125;,&#123;<span class=\"number\">0</span>,<span class=\"number\">-1</span>&#125;,&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>&#125;,&#123;<span class=\"number\">1</span>,<span class=\"number\">-1</span>&#125;,&#123;<span class=\"number\">1</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">1</span>,<span class=\"number\">1</span>&#125;&#125;;<span class=\"comment\">//八个方向</span></span><br><span class=\"line\"><span class=\"type\">int</span> vis[<span class=\"number\">100</span>][<span class=\"number\">100</span>];<span class=\"comment\">//标记路径</span></span><br><span class=\"line\"><span class=\"type\">int</span> n;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">node</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x,y;</span><br><span class=\"line\">&#125;c[<span class=\"number\">100</span>];<span class=\"comment\">//储存路径</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y,node c[],<span class=\"type\">int</span> k,<span class=\"type\">int</span> cur)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(cur==<span class=\"number\">7</span>)&#123;<span class=\"comment\">//找到完整的路径，标记</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">7</span>;i++)&#123;</span><br><span class=\"line\">            vis[c[i].x][c[i].y]=<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> dx=x+dir[k][<span class=\"number\">0</span>];<span class=\"comment\">//根据前一个的方向继续寻找</span></span><br><span class=\"line\">        <span class=\"type\">int</span> dy=y+dir[k][<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cur==<span class=\"number\">6</span>||str[dx][dy]==s[cur+<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">            c[cur].x=x;<span class=\"comment\">//存储前一个路径</span></span><br><span class=\"line\">            c[cur].y=y;</span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(dx,dy,c,k,cur+<span class=\"number\">1</span>);<span class=\"comment\">//dfs下一个字母</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;n;j++)</span><br><span class=\"line\">            cin&gt;&gt;str[i][j];</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(vis,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(vis));</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;n;j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(str[i][j]==<span class=\"string\">&#x27;y&#x27;</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k=<span class=\"number\">0</span>;k&lt;<span class=\"number\">8</span>;k++)&#123;</span><br><span class=\"line\">                    <span class=\"type\">int</span> x=i+dir[k][<span class=\"number\">0</span>];<span class=\"comment\">//沿着正确方向走</span></span><br><span class=\"line\">                    <span class=\"type\">int</span> y=j+dir[k][<span class=\"number\">1</span>];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(str[x][y]==<span class=\"string\">&#x27;i&#x27;</span>)&#123;</span><br><span class=\"line\">                        <span class=\"built_in\">dfs</span>(i,j,c,k,<span class=\"number\">0</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;n;j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(vis[i][j]) <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c&quot;</span>,str[i][j]);<span class=\"comment\">//代表我们走过的路径</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;*&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","categories":["dfs"],"tags":["dfs"]},{"title":"单词拆分","url":"/2022/05/08/%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/","content":"<h1 id=\"单词拆分\"><a\nhref=\"https://leetcode-cn.com/problems/word-break/\">139.\n单词拆分</a></h1>\n<p>给你一个字符串 <code>s</code>和一个字符串列表\n<code>wordDict</code>作为字典。请你判断是否可以利用字典中出现的单词拼接出\ns 。</p>\n<p>注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p>\n<h2 id=\"示例\">示例：</h2>\n<blockquote>\n<p>输入: s = \"leetcode\", wordDict = [\"leet\", \"code\"] 输出: true 解释:\n返回 true 因为 \"leetcode\" 可以由 \"leet\" 和 \"code\" 拼接成。</p>\n<p>输入: s = \"applepenapple\", wordDict = [\"apple\", \"pen\"] 输出: true\n解释: 返回 true 因为 \"applepenapple\" 可以由 \"apple\" \"pen\" \"apple\"\n拼接成。 注意，你可以重复使用字典中的单词。</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"思路\">思路：</h3>\n<p>让你判断 <code>s</code> 是否能被分解成 <code>wordDict</code>\n中的单词，反过来想就是判断 <code>wordDict</code> 中的单词是否能拼出\n<code>s</code></p>\n<p><code>dp(s,0,wordDict)</code>表示当前位置为<code>0</code>，\n<code>wordDict</code> 中的单词是否能拼出\n<code>s</code>，我们每次取<code>wordDict</code>中的单词<code>word</code>，然后从<code>s</code>中分割出<code>s[i,i + word.size()]</code>然后和<code>word</code>比较是否相等，如果相等我们继续，不相等我们就换个<code>word</code>。最后加上备忘录优化子问题。</p>\n<p>#####方法一：递归</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; memo;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">wordBreak</span><span class=\"params\">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class=\"line\">        memo.<span class=\"built_in\">resize</span>(s.<span class=\"built_in\">size</span>(), <span class=\"number\">-1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">dp</span>(s, <span class=\"number\">0</span>, wordDict);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">dp</span><span class=\"params\">(string s, <span class=\"type\">int</span> i, vector&lt;string&gt; wordDict)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//base case</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i == s.<span class=\"built_in\">size</span>()) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(memo[i] != <span class=\"number\">-1</span>) <span class=\"keyword\">return</span> memo[i] == <span class=\"number\">1</span> ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//遍历所有单词，尝试匹配 s[i...] 的前缀</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(string word : wordDict)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> len = word.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i + len &gt; s.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            string subStr = s.<span class=\"built_in\">substr</span>(i, len);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(subStr != word)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//s[i...] 的前缀已经匹配，去尝试匹配 s[i + len..]</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"built_in\">dp</span>(s, i + len, wordDict))&#123;</span><br><span class=\"line\">                <span class=\"comment\">//s[i...] 可以被拼出， 将结果计入备忘录</span></span><br><span class=\"line\">                memo[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//不能拼出 s[i...]</span></span><br><span class=\"line\">        memo[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"方法二迭代\">方法二：迭代</h5>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">wordBreak</span><span class=\"params\">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">bool</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(s.size() + <span class=\"number\">1</span>, <span class=\"literal\">false</span>)</span></span>;</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; s.<span class=\"built_in\">size</span>(); i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!dp[i])&#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span>&amp; word : wordDict)&#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> len = word.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(i + len &lt;= s.<span class=\"built_in\">size</span>() &amp;&amp; s.<span class=\"built_in\">substr</span>(i, len) == word)&#123;</span><br><span class=\"line\">                    dp[i + len] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[s.<span class=\"built_in\">size</span>()];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["动态规划"],"tags":["动态规划"]},{"title":"单调栈","url":"/2022/04/06/%E5%8D%95%E8%B0%83%E6%A0%88/","content":"<p>单调栈的用途不太广泛，只处理一种典型的问题，叫做 Next Greater\nElement。</p>\n<h1 id=\"单调栈模版\">单调栈模版</h1>\n<p>给你一个数组<code>nums</code>，请你返回一个等长的结果数组，结果数组中对应索引存储着下一个更大元素，如果没有更大元素，就存\n-1。</p>\n<p>例如：输入一个数组\n<code>nums = [2,1,2,4,3]</code>,你返回数组<code>[4,2,4,-1,-1]</code></p>\n<blockquote>\n<p>ps: 第⼀个 2 后⾯⽐ 2 ⼤的数是 4; 1 后⾯⽐ 1 ⼤的数是 2；第⼆个 2\n后⾯⽐ 2 ⼤的数是 4; 4 后⾯没有⽐ 4⼤的数，填 -1；3 后⾯没有⽐ 3\n⼤的数，填 -1。</p>\n</blockquote>\n<p>当然我们很轻松就可以想到暴力解法，就是对每个元素后面都进行遍历，找到第一个更大的元素就可以了，但是暴力解法的时间复杂度是<code>O(n^2)</code></p>\n<p>这个问题可以这样抽象思考：把数组的元素想象成并列站⽴的⼈，元素⼤⼩想象成⼈的身⾼。这些⼈⾯对你站成一列，如何求元素「2」的Next\nGreater Number呢？</p>\n<p>很简单我们只需要把它能看到的一个元素就是答案，因为矮的都被挡着看不到。</p>\n<p><img src=\"单调栈/1.jpg\" /></p>\n<p>我们从后面开始看，3 前面没人，所有输入 -1，4前面没有比它大的，并且3\n比它小，所以把 3 出栈，并输入 -1 ，2 前面有 4\n比它大，所以输入4，并且2入栈，1 前面第一个看到的是 2， 所以输入 2，\n并且进栈，2 前面看到的是 4 ，输入4 并且前面的1 和 2 都出栈。</p>\n<span id=\"more\"></span>\n<p>最后逆序输出即可，这就是为什么需要到栈，下面就是代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">nextGreaterElement</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">res</span><span class=\"params\">(nums.size())</span></span>;<span class=\"comment\">//存放答案的数组</span></span><br><span class=\"line\">  stack&lt;<span class=\"type\">int</span>&gt; s;</span><br><span class=\"line\">  <span class=\"comment\">//倒着进栈</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//判定个字高矮</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!s.<span class=\"built_in\">empty</span>() &amp;&amp; nums[i] &gt;= s.<span class=\"built_in\">top</span>())&#123;</span><br><span class=\"line\">      <span class=\"comment\">//矮个出栈</span></span><br><span class=\"line\">      s.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//next Greater Element</span></span><br><span class=\"line\">    res[i] = s.<span class=\"built_in\">empty</span>() ? <span class=\"number\">-1</span> : s.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">    s.<span class=\"built_in\">push</span>(nums[i]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度为<code>O(N)</code>，因为每个元素最多进栈一次。</p>\n<h1 id=\"下一个更大元素-i\"><a\nhref=\"https://leetcode-cn.com/problems/next-greater-element-i/\">496.\n下一个更大元素 I</a></h1>\n<p>nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的\n第一个 比 x 大的元素。</p>\n<p>给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0\n开始计数，其中nums1 是 nums2 的子集。</p>\n<p>对于每个 0 &lt;= i &lt; nums1.length ，找出满足 nums1[i] == nums2[j]\n的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素\n。如果不存在下一个更大元素，那么本次查询的答案是 -1 。</p>\n<p>返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i]\n是如上所述的 下一个更大元素 。</p>\n<h2 id=\"示例\">示例：</h2>\n<blockquote>\n<p>输入：nums1 = [4,1,2], nums2 = [1,3,4,2]. 输出：[-1,3,-1] 解释：nums1\n中每个值的下一个更大元素如下所述： - 4 ，用加粗斜体标识，nums2 =\n[1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。 - 1\n，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。 - 2\n，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1\n。</p>\n</blockquote>\n<h3 id=\"思路\">思路：</h3>\n<p>和前面我们介绍的模版一样，这里只是我们需要用到哈希表，先存储num2\n中的下一个更大元素，最后在根据哈希表查找num1中对应的值。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">nextGreaterElement</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums1, vector&lt;<span class=\"type\">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class=\"line\">        unordered_map&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt; hashmap;</span><br><span class=\"line\">        stack&lt;<span class=\"type\">int</span>&gt; st;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = nums2.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> num = nums2[i];</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!st.<span class=\"built_in\">empty</span>() &amp;&amp; num &gt;= st.<span class=\"built_in\">top</span>())&#123;</span><br><span class=\"line\">                st.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            hashmap[num] = st.<span class=\"built_in\">empty</span>() ? <span class=\"number\">-1</span> : st.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">            st.<span class=\"built_in\">push</span>(num);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">res</span><span class=\"params\">(nums1.size())</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; nums1.<span class=\"built_in\">size</span>(); i++)&#123;</span><br><span class=\"line\">            res[i] = hashmap[nums1[i]];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"每日温度\"><a\nhref=\"https://leetcode-cn.com/problems/daily-temperatures/\">739.\n每日温度</a></h1>\n<p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer\n，其中 answer[i] 是指在第 i\n天之后，才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0\n来代替。</p>\n<h2 id=\"示例-1\">示例：</h2>\n<blockquote>\n<p>输入: temperatures = [73,74,75,71,69,72,76,73] 输出:\n[1,1,4,2,1,1,0,0]</p>\n</blockquote>\n<h3 id=\"思路-1\">思路：</h3>\n<p>和前面不同的是，现在求的是下一个更大元素的距离，我们现在入栈的不能是元素的值，而是元素的下标。我们用栈顶元素的下标减去当前元素的下标，不就是要求的距离吗？</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dailyTemperatures</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">res</span><span class=\"params\">(temperatures.size())</span></span>;</span><br><span class=\"line\">        stack&lt;<span class=\"type\">int</span>&gt; s;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = temperatures.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> temp = temperatures[i];</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!s.<span class=\"built_in\">empty</span>() &amp;&amp; temp &gt;= temperatures[s.<span class=\"built_in\">top</span>()])&#123;</span><br><span class=\"line\">                s.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          \t<span class=\"comment\">//得到索引距离</span></span><br><span class=\"line\">            res[i] = s.<span class=\"built_in\">empty</span>() ? <span class=\"number\">0</span> : (s.<span class=\"built_in\">top</span>() - i);</span><br><span class=\"line\">          \t<span class=\"comment\">// 将索引入栈</span></span><br><span class=\"line\">            s.<span class=\"built_in\">push</span>(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"如何处理循环数组\">如何处理循环数组</h1>\n<p>比如输入一个循环数组<code>[2,1,2,4,3]</code>你返回<code>[4,2,4,-1,4]</code>，最后一个元素3绕了一圈后找到了比自己大的元素4.</p>\n<p>我们可以把原来的循环数组复制一份，变成<code>[2,1,2,4,3,2,1,2,4,3]</code>，这样我们就可以用前面说过的模版来解决了，当然我们也不是一定需要真的复制一份数组，可以采用<code>%</code>求模运算，来实现。</p>\n<h2 id=\"下一个更大元素-ii\"><a\nhref=\"https://leetcode-cn.com/problems/next-greater-element-ii/\">503.\n下一个更大元素 II</a></h2>\n<p>给定一个循环数组 nums （ nums[nums.length - 1] 的下一个元素是 nums[0]\n），返回 nums 中每个元素的 下一个更大元素 。</p>\n<p>数字 x 的 下一个更大的元素\n是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出\n-1 。</p>\n<h3 id=\"示例-2\">示例：</h3>\n<blockquote>\n<p>输入: nums = [1,2,1] 输出: [2,-1,2] 解释: 第一个 1 的下一个更大的数是\n2； 数字 2 找不到下一个更大的数； 第二个 1\n的下一个最大的数需要循环搜索，结果也是 2。</p>\n</blockquote>\n<h4 id=\"思路-2\">思路：</h4>\n<p>前面分析的一样，通过将数组翻倍来解决。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">nextGreaterElements</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">res</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">        stack&lt;<span class=\"type\">int</span>&gt; s;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//假装数组长度翻倍</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">2</span> * n - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//需要注意这里，我们不是真的翻倍，需要求模</span></span><br><span class=\"line\">            <span class=\"type\">int</span> num = nums[i % n];</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!s.<span class=\"built_in\">empty</span>() &amp;&amp; num &gt;= s.<span class=\"built_in\">top</span>())&#123;</span><br><span class=\"line\">                s.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res[i % n] = s.<span class=\"built_in\">empty</span>() ? <span class=\"number\">-1</span> : s.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">            s.<span class=\"built_in\">push</span>(num);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"数组去重\">数组去重</h1>\n<h2 id=\"去除重复字母\"><a\nhref=\"https://leetcode-cn.com/problems/remove-duplicate-letters/\">316.\n去除重复字母</a></h2>\n<p>给你一个字符串 <code>s</code>\n，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证\n<strong>返回结果的字典序最小</strong>（要求不能打乱其他字符的相对位置）。</p>\n<h3 id=\"示例-3\">示例：</h3>\n<blockquote>\n<p>输入：s = \"bcabc\" 输出：\"abc\"</p>\n</blockquote>\n<h4 id=\"思路-3\">思路：</h4>\n<p>对于一般的去重，我们只需要借助哈希表就可以解决了，但是现在却要我们保持字典序最小。</p>\n<p>题目要求：</p>\n<ul>\n<li>去重</li>\n<li>去重后不能打乱 s 中字符出现的相对顺序</li>\n<li>在所有符合上条的去重字符串中，字典序最小</li>\n</ul>\n<p>按理说，如果我们想要得出有序的结果，那必然要排序，可是排序后相对位置就不能保证，这似乎有点矛盾。</p>\n<p>我们可以借用前面讲的单调栈来实现。</p>\n<p>首先我们先不用考虑第三个条件，我们可以写出这样的代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">string <span class=\"title\">removeDuplicateLetters</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//存放去重结果</span></span><br><span class=\"line\">  stack&lt;<span class=\"type\">char</span>&gt; st;</span><br><span class=\"line\">  <span class=\"comment\">//因为是用ASCII,所以256就可以了</span></span><br><span class=\"line\">  <span class=\"function\">vector&lt;<span class=\"type\">bool</span>&gt; <span class=\"title\">inStack</span><span class=\"params\">(<span class=\"number\">256</span>)</span></span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"type\">char</span> c : s)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//如果字符 c 已经在栈中了，则直接跳过</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(inStack[c]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    <span class=\"comment\">//如果不在，则进栈，并标记已经在栈中</span></span><br><span class=\"line\">    st.<span class=\"built_in\">push</span>(c);</span><br><span class=\"line\">    inStack[c] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  string res;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(!st.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">    res += st.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">    st.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//栈中元素是反的，所以需要翻转</span></span><br><span class=\"line\">  <span class=\"built_in\">reverse</span>(res.<span class=\"built_in\">begin</span>(), res.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样，例如<code>s = \"babc\"</code>，我们就得到了<code>bac</code>,但是答案却是<code>abc</code>,因为它的字典序更小。如果我们要满足条件三，保证字典序，我们需要做什么呢？</p>\n<p>就比如到<code>a</code>的时候，我们发现栈中<code>b</code>的字典序比它小，并且后面还有出现，我们可以把<code>b</code>弹出。这关键是我们怎么知道后面<code>b</code>会不会出现呢，我们只需要前期用一个数组，统计<code>s</code>中每个字符出现的次数，当它是唯一一个时，就不在被弹出，否则弹出。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">removeDuplicateLetters</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        stack&lt;<span class=\"type\">char</span>&gt; st;</span><br><span class=\"line\">        <span class=\"comment\">//维护一个计数器记录字符串中字符的数量</span></span><br><span class=\"line\">        <span class=\"comment\">//因为输入为ASCII字符，大小256就够用了</span></span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">count</span><span class=\"params\">(<span class=\"number\">256</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; s.<span class=\"built_in\">size</span>(); i++)&#123;</span><br><span class=\"line\">            count[s[i]]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">bool</span>&gt; <span class=\"title\">inStack</span><span class=\"params\">(<span class=\"number\">256</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">char</span> c : s)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//每遍历过一个字符，都将对应的是计数减1</span></span><br><span class=\"line\">            count[c]--;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(inStack[c])</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"comment\">//把栈顶比当前字符大的元素出栈</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!st.<span class=\"built_in\">empty</span>() &amp;&amp; st.<span class=\"built_in\">top</span>() &gt; c)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//后面不在出现</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(count[st.<span class=\"built_in\">top</span>()] == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//若之后还有，则可以pop()</span></span><br><span class=\"line\">                inStack[st.<span class=\"built_in\">top</span>()] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                st.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            st.<span class=\"built_in\">push</span>(c);</span><br><span class=\"line\">            inStack[c] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        string res;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!st.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">            res += st.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">            st.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">reverse</span>(res.<span class=\"built_in\">begin</span>(), res.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["单调栈"],"tags":["leetcode","单调栈"]},{"title":"单链表的六大解题套路","url":"/2022/04/13/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%AD%E5%A4%A7%E8%A7%A3%E9%A2%98%E5%A5%97%E8%B7%AF/","content":"<p>单链表的基本技巧：</p>\n<p>1，合并两个有序链表</p>\n<p>2，合并 K 个有序链表</p>\n<p>3，寻找单链表的倒数第 K 个节点</p>\n<p>4，寻找单链表的中点</p>\n<p>5，判断单链表是否包含环并找出环起点</p>\n<p>6，判断两个单链表是否相交并找出交点</p>\n<span id=\"more\"></span>\n<p>#1，合并两个有序链表</p>\n<h2 id=\"合并两个有序链表\"><a\nhref=\"https://leetcode-cn.com/problems/merge-two-sorted-lists/\">21.\n合并两个有序链表</a></h2>\n<p>将两个升序链表合并为一个新的 <strong>升序</strong>\n链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>\n<h3 id=\"示例\">示例：</h3>\n<p><img src=\"单链表的六大解题套路/1.jpg\" /></p>\n<blockquote>\n<p>输入：l1 = [1,2,4], l2 = [1,3,4] 输出：[1,1,2,3,4,4]</p>\n</blockquote>\n<h4 id=\"思路\">思路：</h4>\n<p>对于两个升序的链表，我们首先想到的肯定是归并排序。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">mergeTwoLists</span><span class=\"params\">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建虚拟头节点</span></span><br><span class=\"line\">        ListNode* dummy = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">        ListNode* p = dummy;</span><br><span class=\"line\">        ListNode* p1 = list1;</span><br><span class=\"line\">        ListNode* p2 = list2;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p1 != <span class=\"literal\">nullptr</span> &amp;&amp; p2 != <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//比较 p1 和 p2 两个指针</span></span><br><span class=\"line\">            <span class=\"comment\">// 将值较小的节点接到 p 指针</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p1-&gt;val &gt; p2-&gt;val)&#123;</span><br><span class=\"line\">                p-&gt;next = p2;</span><br><span class=\"line\">                p2 = p2-&gt;next;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                p-&gt;next = p1;</span><br><span class=\"line\">                p1 = p1-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            p = p-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//判断是否有不空的队列</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p1 != <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            p-&gt;next = p1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p2 != <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            p-&gt;next = p2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dummy-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>#2，合并 K 个有序链表</p>\n<h2 id=\"合并k个升序链表\"><a\nhref=\"https://leetcode-cn.com/problems/merge-k-sorted-lists/\">合并K个升序链表</a></h2>\n<p>给你一个链表数组，每个链表都已经按升序排列。</p>\n<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>\n<h3 id=\"示例-1\">示例：</h3>\n<p>输入：lists = [[1,4,5],[1,3,4],[2,6]] 输出：[1,1,2,3,4,4,5,6]\n解释：链表数组如下： [ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]\n将它们合并到一个有序链表中得到。\n1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p>\n<h4 id=\"思路-1\">思路：</h4>\n<h5 id=\"方法一归并排序\">方法一：归并排序</h5>\n<p>我们是不是可以转化为前面我们说过的两个队列，然后依次合并即可。</p>\n<p>那么我们应该如何转化呢，可以定义一个空的链表，依次合并。</p>\n<p>时间复杂度为：<code>O(NlogN)</code>;</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">mergeKLists</span><span class=\"params\">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class=\"line\">        ListNode* dummy = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; lists.<span class=\"built_in\">size</span>(); i++)&#123;</span><br><span class=\"line\">            ListNode* t = <span class=\"built_in\">mergeTwoLists</span>(dummy, lists[i]);</span><br><span class=\"line\">            dummy = t;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dummy;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">mergeTwoLists</span><span class=\"params\">(ListNode* l1, ListNode* l2)</span></span>&#123;</span><br><span class=\"line\">        ListNode* node = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">        ListNode* cur = node;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l1 != <span class=\"literal\">nullptr</span> &amp;&amp; l2 != <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class=\"line\">                cur-&gt;next = l1;</span><br><span class=\"line\">                l1 = l1-&gt;next;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                cur-&gt;next = l2;</span><br><span class=\"line\">                l2 = l2-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cur = cur-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l1 != <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            cur-&gt;next = l1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l2 != <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            cur-&gt;next = l2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> node-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"方法二-优先队列二叉堆\">方法二： 优先队列（二叉堆）</h5>\n<p>把链表节点放入一个最小堆中，就可以每次获得 K 个节点中的最小节点。</p>\n<p>时间复杂度为:<code>O(NlogK)</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">bool</span> <span class=\"title\">myCmp</span><span class=\"params\">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> l1-&gt;val &gt;= l2-&gt;val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">mergeKLists</span><span class=\"params\">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(lists.<span class=\"built_in\">size</span>() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"comment\">//虚拟头节点</span></span><br><span class=\"line\">        ListNode* dummy = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">        ListNode* p = dummy;</span><br><span class=\"line\">        <span class=\"comment\">//优先队列(默认为最大堆)，最小堆</span></span><br><span class=\"line\">        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, function&lt;<span class=\"type\">bool</span>(ListNode*, ListNode*)&gt;&gt; <span class=\"built_in\">pq</span>(myCmp);</span><br><span class=\"line\">        <span class=\"comment\">// 将 k 个链表头节点加入最小堆</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(ListNode* head : lists)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(head != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">                pq.<span class=\"built_in\">push</span>(head);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!pq.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">            <span class=\"comment\">//获取最小节点，接到结果列表</span></span><br><span class=\"line\">            ListNode* node = pq.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">            pq.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            p-&gt;next = node;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(node-&gt;next != <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">                pq.<span class=\"built_in\">push</span>(node-&gt;next);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            p = p-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dummy-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>优先队列<code>pq</code>中的元素个数最多是<code>k</code>，所以一次<code>push</code>或者<code>pop</code>方法的时间复杂度是<code>O(logk)</code>；所有的链表节点都会被加入和弹出<code>pq</code>，<strong>所以算法整体的时间复杂度是<code>O(Nlogk)</code>，其中<code>k</code>是链表的条数，<code>N</code>是这些链表的节点总数</strong>。</p>\n<p>#3，寻找单链表的倒数第 K 个节点</p>\n<h2 id=\"删除链表的倒数第-n-个结点\"><a\nhref=\"https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/\">19.\n删除链表的倒数第 N 个结点</a></h2>\n<p>给你一个链表，删除链表的倒数第 <code>n</code>\n个结点，并且返回链表的头结点。</p>\n<h3 id=\"示例-2\">示例：</h3>\n<p><img src=\"单链表的六大解题套路/2.jpg\" /></p>\n<blockquote>\n<p>输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5]</p>\n</blockquote>\n<h4 id=\"思路-2\">思路：</h4>\n<p>我们要想删除单链表中的一个节点，我们需要知道这个节点的前一个节点。</p>\n<p>那么我们该如何找到这个节点呢？这就需要双指针，</p>\n<p>先设置<code>p1</code>先走<code>k+1</code>步，然后<code>p2</code>从头节点同时走，这样<code>p1</code>走到结尾，<code>p2</code>就是我们要找的节点。</p>\n<p>例如：</p>\n<blockquote>\n<p>1-&gt;2-&gt;3-&gt;4-&gt;5</p>\n<p>n = 2</p>\n</blockquote>\n<p>也就是要删除4,我们需要找到3，也就是倒数第<code>n+1</code>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(ListNode* head, <span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建虚拟头节点</span></span><br><span class=\"line\">        ListNode* dummy = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">        dummy-&gt;next = head;</span><br><span class=\"line\">        <span class=\"comment\">//删除倒数第 n 个，要先找到倒数第 n + 1 个节点</span></span><br><span class=\"line\">        ListNode* x = <span class=\"built_in\">findFromEnd</span>(dummy, n + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">//删除倒数第 n 个节点</span></span><br><span class=\"line\">        x-&gt;next = x-&gt;next-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dummy-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">findFromEnd</span><span class=\"params\">(ListNode* head, <span class=\"type\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">        ListNode* p1 = head;</span><br><span class=\"line\">        <span class=\"comment\">//p1 先走 k 步</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; k; i++)&#123;</span><br><span class=\"line\">            p1 = p1-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ListNode* p2 = head;</span><br><span class=\"line\">        <span class=\"comment\">//同时走</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p1 != <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            p2 = p2-&gt;next;</span><br><span class=\"line\">            p1 = p1-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>不过注意我们又使用了虚拟头结点的技巧，也是为了防止出现空指针的情况，比如说链表总共有\n5 个节点，题目就让你删除倒数第 5\n个节点，也就是第一个节点，那按照算法逻辑，应该首先找到倒数第 6\n个节点。但第一个节点前面已经没有节点了，这就会出错。</p>\n<p>但有了我们虚拟节点<code>dummy</code>的存在，就避免了这个问题，能够对这种情况进行正确的删除。</p>\n<p>#4，寻找单链表的中点</p>\n<h2 id=\"链表的中间结点\"><a\nhref=\"https://leetcode-cn.com/problems/middle-of-the-linked-list/\">876.\n链表的中间结点</a></h2>\n<p>给定一个头结点为 <code>head</code>\n的非空单链表，返回链表的中间结点。</p>\n<p>如果有两个中间结点，则返回第二个中间结点。</p>\n<h3 id=\"示例-3\">示例：</h3>\n<blockquote>\n<p>输入：[1,2,3,4,5] 输出：此列表中的结点 3 (序列化形式：[3,4,5])\n返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。\n注意，我们返回了一个 ListNode 类型的对象 ans，这样： ans.val = 3,\nans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next =\nNULL.</p>\n</blockquote>\n<h4 id=\"思路-3\">思路：</h4>\n<p>找中间节点，需要用到快慢指针，慢指针走一步，快指针走两步。</p>\n<p>最后返回慢指针即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">middleNode</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        ListNode *slow = head,*fast = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(fast != <span class=\"literal\">nullptr</span> &amp;&amp; fast-&gt;next != <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            slow = slow-&gt;next;</span><br><span class=\"line\">            fast = fast-&gt;next-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> slow;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，如果链表长度为偶数，也就是说中点有两个的时候，我们这个解法返回的节点是靠后的那个节点。</p>\n<p>#5， 判断是否有环以及环的起点</p>\n<h2 id=\"环形链表\"><a\nhref=\"https://leetcode-cn.com/problems/linked-list-cycle/\">141.\n环形链表</a></h2>\n<p>给你一个链表的头节点 head ，判断链表中是否有环。</p>\n<p>如果链表中有某个节点，可以通过连续跟踪 next\n指针再次到达，则链表中存在环。\n为了表示给定链表中的环，评测系统内部使用整数 pos\n来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos\n不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p>\n<p>如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p>\n<h3 id=\"示例-4\">示例：</h3>\n<p><img src=\"单链表的六大解题套路/3.png\" /></p>\n<blockquote>\n<p>输入：head = [3,2,0,-4], pos = 1 输出：true\n解释：链表中有一个环，其尾部连接到第二个节点。</p>\n</blockquote>\n<h4 id=\"思路-4\">思路：</h4>\n<p>判断单链表是否包含环属于经典问题了，解决方案也是用快慢指针：</p>\n<p>每当慢指针<code>slow</code>前进一步，快指针<code>fast</code>就前进两步。</p>\n<p>如果<code>fast</code>最终遇到空指针，说明链表中没有环；如果<code>fast</code>最终和<code>slow</code>相遇，那肯定是<code>fast</code>超过了<code>slow</code>一圈，说明链表中含有环。</p>\n<p>只需要把寻找链表中点的代码稍加修改就行了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">hasCycle</span><span class=\"params\">(ListNode *head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//快慢指针初始化指向 head</span></span><br><span class=\"line\">        ListNode *slow = head, *fast = head;</span><br><span class=\"line\">        <span class=\"comment\">// 快指针走到末尾停止</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(fast != <span class=\"literal\">nullptr</span> &amp;&amp; fast-&gt;next != <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//慢指针走一步，快指针走两步</span></span><br><span class=\"line\">            slow = slow-&gt;next;</span><br><span class=\"line\">            fast = fast-&gt;next-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 快慢指针相遇，说明有环</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(slow == fast)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//没有环</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>进阶的话就是问环的起点。</p>\n<h2 id=\"环形链表-ii\"><a\nhref=\"https://leetcode-cn.com/problems/linked-list-cycle-ii/\">142.\n环形链表 II</a></h2>\n<p>给定一个链表的头节点 head ，返回链表开始入环的第一个节点。\n如果链表无环，则返回 null。</p>\n<p>如果链表中有某个节点，可以通过连续跟踪 next\n指针再次到达，则链表中存在环。\n为了表示给定链表中的环，评测系统内部使用整数 pos\n来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是\n-1，则在该链表中没有环。注意：pos\n不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>\n<p>不允许修改 链表。</p>\n<p><img src=\"单链表的六大解题套路/3.png\" /></p>\n<h3 id=\"示例-5\">示例：</h3>\n<blockquote>\n<p>输入：head = [3,2,0,-4], pos = 1 输出：返回索引为 1 的链表节点\n解释：链表中有一个环，其尾部连接到第二个节点。</p>\n</blockquote>\n<h4 id=\"思路-5\">思路：</h4>\n<p>我们用前面的算法判断了是否有环。</p>\n<p>我们假设快慢指针相遇时，慢指针<code>slow</code>走了<code>k</code>步，那么快指针<code>fast</code>一定走了<code>2k</code>步：</p>\n<blockquote>\n<p>ps: 因为慢指针走一步，快指针走两步</p>\n</blockquote>\n<p><img src=\"单链表的六大解题套路/4.jpg\" /></p>\n<p><strong><code>fast</code>一定比<code>slow</code>多走了<code>k</code>步，这多走的<code>k</code>步其实就是<code>fast</code>指针在环里转圈圈，所以<code>k</code>的值就是环长度的「整数倍」</strong>。</p>\n<p>假设相遇点距环的起点的距离为<code>m</code>，那么结合上图的 slow\n指针，环的起点距头结点<code>head</code>的距离为<code>k - m</code>，也就是说如果从<code>head</code>前进<code>k - m</code>步就能到达环起点。</p>\n<p>巧的是，如果从相遇点继续前进<code>k - m</code>步，也恰好到达环起点。因为结合上图的\nfast\n指针，从相遇点开始走<code>k</code>步可以转回到相遇点，那走<code>k - m</code>步肯定就走到环起点了：</p>\n<p><img src=\"单链表的六大解题套路/5.jpg\" /></p>\n<p>所以，只要我们把快慢指针中的任一个重新指向<code>head</code>，然后两个指针同速前进，<code>k - m</code>步后一定会相遇，相遇之处就是环的起点了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode *<span class=\"title\">detectCycle</span><span class=\"params\">(ListNode *head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//快慢指针初始化指向 head</span></span><br><span class=\"line\">        ListNode *slow, *fast;</span><br><span class=\"line\">        slow = fast = head;</span><br><span class=\"line\">        <span class=\"comment\">// 快指针走到末尾停止</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(fast != <span class=\"literal\">nullptr</span> &amp;&amp; fast-&gt;next != <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//慢指针走一步，快指针走两步</span></span><br><span class=\"line\">            fast = fast-&gt;next-&gt;next;</span><br><span class=\"line\">            slow = slow-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 快慢指针相遇，说明有环</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(slow == fast) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(fast == <span class=\"literal\">nullptr</span> || fast-&gt;next == <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// fast 遇到空指针说明没有环</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//重新指向头节点</span></span><br><span class=\"line\">        slow = head;</span><br><span class=\"line\">        <span class=\"comment\">//快慢指针同步前进，相交点就是环起点</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(slow != fast)&#123;</span><br><span class=\"line\">            fast = fast-&gt;next;</span><br><span class=\"line\">            slow = slow-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> slow;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1\nid=\"判断两个单链表是否相交并找出交点\">6，判断两个单链表是否相交并找出交点</h1>\n<h2 id=\"相交链表\"><a\nhref=\"https://leetcode-cn.com/problems/intersection-of-two-linked-lists/\">160.\n相交链表</a></h2>\n<p>给你两个单链表的头节点 headA 和 headB\n，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回\nnull 。</p>\n<p>图示两个链表在节点 c1 开始相交：</p>\n<p><img src=\"单链表的六大解题套路/6.png\" /></p>\n<h3 id=\"示例-6\">示例：</h3>\n<p><img src=\"单链表的六大解题套路/7.png\" /></p>\n<blockquote>\n<p>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5],\nskipA = 2, skipB = 3 输出：Intersected at '8' 解释：相交节点的值为 8\n（注意，如果两个链表相交则不能为 0）。 从各自的表头开始算起，链表 A 为\n[4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。 在 A 中，相交节点前有 2\n个节点；在 B 中，相交节点前有 3 个节点。</p>\n</blockquote>\n<h4 id=\"思路-6\">思路：</h4>\n<h5 id=\"方法一\">方法一：</h5>\n<p>我们可以让两个链表同时到终点，也就是说如果我们知道<code>headA</code>和<code>headB</code>的长度，让长度长的走<code>lenA - lenB</code>（假设A的长度长）然后判断是否是同一个链表，如果是就返回，不是就同时前进。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode *<span class=\"title\">getIntersectionNode</span><span class=\"params\">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> lenA = <span class=\"number\">0</span>, lenB = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(ListNode* p1 = headA; p1 != <span class=\"literal\">nullptr</span>; p1 = p1-&gt;next)&#123;</span><br><span class=\"line\">            lenA++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(ListNode* p2 = headB; p2 != <span class=\"literal\">nullptr</span>; p2 = p2-&gt;next)&#123;</span><br><span class=\"line\">            lenB++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//让 p1 p2 达到尾部的时间一致</span></span><br><span class=\"line\">        ListNode* p1 = headA, *p2 = headB;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(lenA &gt; lenB)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; lenA - lenB; i++)&#123;</span><br><span class=\"line\">                p1 = p1-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; lenB - lenA; i++)&#123;</span><br><span class=\"line\">                p2 = p2-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p1 != p2)&#123;</span><br><span class=\"line\">            p1 = p1-&gt;next;</span><br><span class=\"line\">            p2 = p2-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"方法二\">方法二：</h5>\n<p>我们可以把<code>headA</code>的尾指针指向头节点，这样不就转化为前面所说过的求环的起点了吗？</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode *<span class=\"title\">getIntersectionNode</span><span class=\"params\">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class=\"line\">        ListNode *p1 = headA;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p1-&gt;next != <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            p1 = p1-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//指向头节点</span></span><br><span class=\"line\">        p1-&gt;next = headA;</span><br><span class=\"line\">        <span class=\"comment\">//判断 headB 环的起点</span></span><br><span class=\"line\">        ListNode *slow, *fast;</span><br><span class=\"line\">        slow = headB, fast = headB;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(fast != <span class=\"literal\">nullptr</span> &amp;&amp; fast-&gt;next != <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            slow = slow-&gt;next;</span><br><span class=\"line\">            fast = fast-&gt;next-&gt;next;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">//相遇，说明有环</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(slow == fast)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//不存在环</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(fast == <span class=\"literal\">nullptr</span> || fast-&gt;next == <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//重新指向头节点，然后同步走</span></span><br><span class=\"line\">        slow = headB;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(slow != fast)&#123;</span><br><span class=\"line\">            slow = slow-&gt;next;</span><br><span class=\"line\">            fast = fast-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> slow;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["链表"],"tags":["双指针","链表","二叉堆","归并排序"]},{"title":"反转单链表","url":"/2022/05/10/%E5%8F%8D%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8/","content":"<h1 id=\"反转链表\"><a\nhref=\"https://leetcode.cn/problems/reverse-linked-list/\">206.\n反转链表</a></h1>\n<p>给你单链表的头节点 <code>head</code>\n，请你反转链表，并返回反转后的链表。</p>\n<h2 id=\"示例\">示例：</h2>\n<p><img src=\"反转单链表/rev1ex1.jpg\" /></p>\n<blockquote>\n<p>输入：head = [1,2,3,4,5] 输出：[5,4,3,2,1]</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"思路\">思路：</h3>\n<h4 id=\"方法一-递归\">方法一： 递归</h4>\n<p><strong>对于递归算法，最重要的就是明确递归函数的定义，不要跳进具体的细节中。</strong></p>\n<p>比如对于这道题，递归函数<code>reverseList</code>的定义就是：</p>\n<p><strong>输入一个节点<code>head</code>，将以<code>head</code>为起点的链表反转，并返回反转后的头节点</strong>。</p>\n<p>比如我们反转</p>\n<p><img src=\"反转单链表/1.jpg\" /></p>\n<p>我们经过</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">ListNode *dummy = <span class=\"built_in\">reverseList</span>(head-&gt;next);</span><br></pre></td></tr></table></figure>\n<p>之后，整个链表就变为了：</p>\n<p><img src=\"反转单链表/2.jpg\" /></p>\n<p>此时我们只需要让<code>2</code>指向<code>1</code>，<code>1</code>指向<code>nullptr</code>，然后返回<code>dummy</code>即：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">head-&gt;next-&gt;next = head;</span><br><span class=\"line\">head-&gt;next = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"><span class=\"keyword\">return</span> dummy;</span><br></pre></td></tr></table></figure>\n<p>我们就得到了：</p>\n<p><img src=\"反转单链表/3.jpg\" /></p>\n<p>最后，递归函数需要有终止条件<code>base case</code>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(head == <span class=\"literal\">nullptr</span> || head-&gt;next == <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">  \t<span class=\"keyword\">return</span> head;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>综上，代码为：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">reverseList</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head == <span class=\"literal\">nullptr</span> || head-&gt;next == <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ListNode *dummy = <span class=\"built_in\">reverseList</span>(head-&gt;next);</span><br><span class=\"line\">        <span class=\"comment\">//使末尾指针指向当前节点</span></span><br><span class=\"line\">        head-&gt;next-&gt;next = head;</span><br><span class=\"line\">        <span class=\"comment\">//让新链表的尾节为空，避免成环</span></span><br><span class=\"line\">        head-&gt;next =  <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dummy;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"迭代\">迭代：</h4>\n<p>我们采用<strong>头插法</strong>来实现：</p>\n<p><img src=\"反转单链表/1_1.jpg\" /></p>\n<p><img src=\"反转单链表/1_2.jpg\" /></p>\n<p>直到<code>cur==nullptr</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">reverseList</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        ListNode *pre = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        ListNode *cur = head;</span><br><span class=\"line\">        <span class=\"comment\">//头插法</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur != <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            ListNode *t = cur-&gt;next;</span><br><span class=\"line\">            cur-&gt;next = pre;</span><br><span class=\"line\">            pre = cur;</span><br><span class=\"line\">            cur = t;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pre;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"反转链表-ii\"><a\nhref=\"https://leetcode.cn/problems/reverse-linked-list-ii/\">92. 反转链表\nII</a></h1>\n<p>给你单链表的头指针 <code>head</code>和两个整数 <code>left</code>和\n<code>right</code>，其中 <code>left &lt;= right</code>。请你反转从位置\n<code>left</code>到位置 <code>right</code>的链表节点，返回 反转后的链表\n。</p>\n<h2 id=\"示例-1\">示例：</h2>\n<p><img src=\"反转单链表/rev2ex2.jpg\" /></p>\n<blockquote>\n<p>输入：head = [1,2,3,4,5], left = 2, right = 4 输出：[1,4,3,2,5]</p>\n</blockquote>\n<h3 id=\"思路-1\">思路：</h3>\n<h4 id=\"方法一递归\">方法一：递归</h4>\n<p>在解决这道题之前。如果需要我们只反转开头的前<code>m</code>个元素，我们如何解决呢？</p>\n<p>例如：</p>\n<p><code>reverse(head, 3)</code></p>\n<p><img src=\"反转单链表/3_1.jpg\" /></p>\n<p>思路和我们前面一题反转全部链表差不多，我们只需要记录反转的节点个数即可</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">ListNode *succ = <span class=\"literal\">nullptr</span>;    <span class=\"comment\">//后驱节点</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//反转以 head 为起点的 n 个节点，返回新的头节点</span></span><br><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">reverseN</span><span class=\"params\">(ListNode *head, <span class=\"type\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//记录第 n + 1 个节点</span></span><br><span class=\"line\">        succ = head-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     <span class=\"comment\">// 以 head.next 为起点，需要反转前 n - 1 个节点</span></span><br><span class=\"line\">    ListNode *last = <span class=\"built_in\">reverseN</span>(head-&gt;next, n - <span class=\"number\">1</span>);</span><br><span class=\"line\">    head-&gt;next-&gt;next = head;</span><br><span class=\"line\">    <span class=\"comment\">// 让反转之后的 head 节点和后面的节点连起来</span></span><br><span class=\"line\">    head-&gt;next = succ;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> last;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"反转单链表/4_1.jpg\" /></p>\n<p>现在我们再来解决这道题，如果<code>left = 1</code>，也就是我们刚才实现的功能。</p>\n<p>如果 <code>left != 1</code> 怎么办？如果我们把 <code>head</code>\n的索引视为 1，那么我们是想从第 <code>left</code>\n个元素开始反转对吧；如果把 <code>head-&gt;next</code> 的索引视为 1\n呢？那么相对于 <code>head-&gt;next</code>，反转的区间应该是从第\n<code>left - 1</code> 个元素开始的；那么对于\n<code>head-&gt;next-&gt;next</code> 呢……</p>\n<p>区别于迭代思想，这就是递归思想，所以我们可以完成代码：</p>\n<p><img src=\"反转单链表/4_2.jpg\" /></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  \tListNode *succ = <span class=\"literal\">nullptr</span>;    <span class=\"comment\">//后驱节点</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//反转以 head 为起点的 n 个节点，返回新的头节点</span></span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">reverseN</span><span class=\"params\">(ListNode *head, <span class=\"type\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//记录第 n + 1 个节点</span></span><br><span class=\"line\">            succ = head-&gt;next;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">         <span class=\"comment\">// 以 head.next 为起点，需要反转前 n - 1 个节点</span></span><br><span class=\"line\">        ListNode *last = <span class=\"built_in\">reverseN</span>(head-&gt;next, n - <span class=\"number\">1</span>);</span><br><span class=\"line\">        head-&gt;next-&gt;next = head;</span><br><span class=\"line\">        <span class=\"comment\">// 让反转之后的 head 节点和后面的节点连起来</span></span><br><span class=\"line\">        head-&gt;next = succ;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">reverseBetween</span><span class=\"params\">(ListNode* head, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//base case</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(left == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">reverseN</span>(head, right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        head-&gt;next = <span class=\"built_in\">reverseBetween</span>(head-&gt;next, left - <span class=\"number\">1</span>, right - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二迭代\">方法二：迭代</h4>\n<p>同样采用头插法，先找到<code>left</code>节点的左边一个节点<code>pre</code></p>\n<p>将<code>left</code>所在的节点定义为<code>cur</code>，<code>cur</code>下一个节点为<code>next</code></p>\n<ul>\n<li>把<code>cur</code>的下一个节点指向<code>next</code>的下一个节点</li>\n<li>把<code>next</code>的下一个节点指向<code>pre</code>的下一个节点</li>\n<li>把<code>pre</code>的下一个节点指向<code>next</code></li>\n</ul>\n<p>即</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">next = cur-&gt;next;</span><br><span class=\"line\">cur-&gt;next = next-&gt;next;</span><br><span class=\"line\">next-&gt;next = pre-&gt;next;</span><br><span class=\"line\">pre-&gt;next = next;</span><br></pre></td></tr></table></figure>\n<p><img src=\"反转单链表/2_1.jpg\" /></p>\n<p><img src=\"反转单链表/2_2.jpg\" /></p>\n<p>以此类推<code>right - left</code>次：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">reverseBetween</span><span class=\"params\">(ListNode* head, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">        ListNode *dummy = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">        dummy-&gt;next = head;</span><br><span class=\"line\">        ListNode *pre = dummy;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; left - <span class=\"number\">1</span>; i++)&#123;</span><br><span class=\"line\">            pre = pre-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ListNode *cur = pre-&gt;next;</span><br><span class=\"line\">        ListNode *next;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; right - left; i++)&#123;</span><br><span class=\"line\">            next = cur-&gt;next;</span><br><span class=\"line\">            cur-&gt;next = next-&gt;next;</span><br><span class=\"line\">            next-&gt;next = pre-&gt;next;</span><br><span class=\"line\">            pre-&gt;next = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dummy-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["链表","单链表"],"tags":["链表"]},{"title":"回溯算法","url":"/2022/03/07/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/","content":"<p>我们先理解几个问题：</p>\n<p><a href=\"https://labuladong.gitee.io/algo/4/30/110/\">具体思想</a></p>\n<p><strong>1，回溯算法是什么？解决回溯算法相关的问题有什么技巧？如何学习回溯算法？回溯算法代码有什么规律？</strong></p>\n<p>回溯算法其实就是DFS算法，本质上就是一种暴力穷举算法。</p>\n<p>解决一个回溯问题，实际就是一个决策树的遍历过程。我们只需要考虑3个问题：</p>\n<p>（1）<strong>路径：</strong> 也就是已经做出的选择。</p>\n<p>（2）<strong>选择列表：</strong> 也就是你当前可以做的选择。</p>\n<p>（3）<strong>结束条件：</strong>\n也就是达到决策树底层，无法再做选择的条件。</p>\n<span id=\"more\"></span>\n<p><strong>回溯算法框架：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">result = []</span><br><span class=\"line\">def <span class=\"built_in\">backtrack</span>(路径，选择列表):</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> 满足结束条件:</span><br><span class=\"line\">\t\tresult.<span class=\"built_in\">add</span>(路径)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> 选择 in 选择列表:</span><br><span class=\"line\">\t\t做选择</span><br><span class=\"line\">\t\t<span class=\"built_in\">backtrack</span>(路径，选择列表)</span><br><span class=\"line\">\t\t撤销选择</span><br></pre></td></tr></table></figure>\n<p>其核心就是for循环里面的递归，在递归调用之前”做选择“，在递归调用之后”撤销选择“。</p>\n<h4 id=\"全排列\"><a\nhref=\"https://leetcode-cn.com/problems/permutations/\">46.\n全排列</a></h4>\n<p>给定一个不含重复数字的数组 <code>nums</code> ，返回其\n<em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong>\n返回答案。</p>\n<h5 id=\"示例\">示例：</h5>\n<blockquote>\n<p>输入：nums = [1,2,3]\n输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p>\n</blockquote>\n<h5 id=\"思路\">思路：</h5>\n<p><img src=\"回溯算法/1.jpg\" /></p>\n<p>我们把这棵树称为回溯算法的「决策树」。因为我们在每个节点上都是在做决策。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; res;</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; <span class=\"built_in\">permute</span>(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//记录路径</span></span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; track;</span><br><span class=\"line\">        <span class=\"comment\">//标记数组，避免重复使用</span></span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">bool</span>&gt; <span class=\"title\">used</span><span class=\"params\">(nums.size())</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">backtrack</span>(nums, track, used);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">backtrack</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, vector&lt;<span class=\"type\">int</span>&gt;&amp; track, vector&lt;<span class=\"type\">bool</span>&gt;&amp; used)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//结束条件：nums 中的元素全部在 track 中</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(track.<span class=\"built_in\">size</span>() == nums.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">            res.<span class=\"built_in\">push_back</span>(track);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//排除不合法的选择</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(used[i])&#123;</span><br><span class=\"line\">                <span class=\"comment\">//num[i] 已经在 track 中，跳过</span></span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//做选择</span></span><br><span class=\"line\">            track.<span class=\"built_in\">push_back</span>(nums[i]);</span><br><span class=\"line\">            used[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"comment\">//进入下一层决策树</span></span><br><span class=\"line\">            <span class=\"built_in\">backtrack</span>(nums, track, used);</span><br><span class=\"line\">            <span class=\"comment\">//取消选择</span></span><br><span class=\"line\">            track.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">            used[i] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"n-皇后\"><a href=\"https://leetcode-cn.com/problems/n-queens/\">51.\nN 皇后</a></h4>\n<p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n\n的棋盘上，并且使皇后彼此之间不能相互攻击。</p>\n<p>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p>\n<p>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和\n'.' 分别代表了皇后和空位。</p>\n<p>每一行每一列每一条直线只有一个皇后</p>\n<h5 id=\"示例-1\">示例：</h5>\n<p><img src=\"回溯算法/queens.jpg\" /></p>\n<blockquote>\n<p>输入：n = 4\n输出：[[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]\n解释：如上图所示，4 皇后问题存在两个不同的解法。</p>\n</blockquote>\n<h5 id=\"思路-1\">思路：</h5>\n<p>路径：board 中小于 row 的那些行都已经成功放置了皇后</p>\n<p>选择列表：第 row 行的所有列都是放置皇后的选择</p>\n<p>结束条件：row 超过 board 的最后一行</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;string&gt; &gt;res;</span><br><span class=\"line\">    vector&lt;vector&lt;string&gt; &gt; <span class=\"built_in\">solveNQueens</span>(<span class=\"type\">int</span> n) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//初识化棋盘：&#x27;.&#x27;表示空，&#x27;Q&#x27;表示皇后。</span></span><br><span class=\"line\">        <span class=\"function\">vector&lt;string&gt; <span class=\"title\">board</span><span class=\"params\">(n, string(n,<span class=\"string\">&#x27;.&#x27;</span>))</span></span>;</span><br><span class=\"line\">        <span class=\"built_in\">backstrack</span>(board, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//路径：board 中小于 row 的那些行都已经成功放置了皇后</span></span><br><span class=\"line\">    <span class=\"comment\">//选择列表：第 row 行的所有列都是放置皇后的选择</span></span><br><span class=\"line\">    <span class=\"comment\">//结束条件：row 超过 board 的最后一行</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">backstrack</span><span class=\"params\">(vector&lt;string&gt;&amp; board, <span class=\"type\">int</span> row)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//终止条件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(row == board.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">            res.<span class=\"built_in\">push_back</span>(board);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> n = board[row].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> col = <span class=\"number\">0</span>; col &lt; n; col++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//排除不合法的选择</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!<span class=\"built_in\">isValid</span>(board, row, col))&#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//做选择</span></span><br><span class=\"line\">            board[row][col] = <span class=\"string\">&#x27;Q&#x27;</span>;</span><br><span class=\"line\">            <span class=\"comment\">//进入下一行决策</span></span><br><span class=\"line\">            <span class=\"built_in\">backstrack</span>(board, row + <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"comment\">//撤销选择</span></span><br><span class=\"line\">            board[row][col] = <span class=\"string\">&#x27;.&#x27;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//是否可以在 board[row][col]放置皇后</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isValid</span><span class=\"params\">(vector&lt;string&gt;&amp; board, <span class=\"type\">int</span> row, <span class=\"type\">int</span> col)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = board.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"comment\">//检查列是否有皇后互相冲突</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(board[i][col] == <span class=\"string\">&#x27;Q&#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//检查右上方是否有皇后互相冲突</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = row - <span class=\"number\">1</span>, j = col + <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span> &amp;&amp; j &lt; n; i--,j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(board[i][j] == <span class=\"string\">&#x27;Q&#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//检查左上方是否有皇后互相冲突</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = row - <span class=\"number\">1</span>, j = col - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span> &amp;&amp; j &gt;= <span class=\"number\">0</span>; i--,j--)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(board[i][j] == <span class=\"string\">&#x27;Q&#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["回溯算法","DFS","leetcode"],"tags":["DFS","回溯算法"]},{"title":"图的总结","url":"/2022/06/08/%E5%9B%BE%E7%9A%84%E6%80%BB%E7%BB%93/","content":"<p>图主要考虑深度优先搜索和广度优先搜索。</p>\n<span id=\"more\"></span>\n<p><img src=\"图的总结/1.jpg\" /></p>\n<p>看着内容比较多，不过最主要的也就是图的遍历和图的应用。</p>\n<h1 id=\"图的基本概念\">1. 图的基本概念</h1>\n<p>图由顶点集<code>V</code>和边集<code>E</code>组成，记为<code>G=(V,E)</code>。</p>\n<p>图分为有向图和无向图。</p>\n","categories":["图"],"tags":["图"]},{"title":"图的遍历","url":"/2022/04/14/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/","content":"<p>图一般使用邻接表或者领接矩阵来实现。</p>\n<p><img src=\"图的遍历/1.jpg\" /></p>\n<p>⽤邻接表和邻接矩阵的存储⽅式如下：</p>\n<p><img src=\"图的遍历/2.jpg\" /></p>\n<p>邻接表很直观，我把每个节点 x 的邻居都存到⼀个列表⾥，然后把 x\n和这个列表关联起来，这样就可以通过 ⼀个节点 x 找到它的所有相邻节点。\n邻接矩阵则是⼀个⼆维布尔数组，我们权且称为 matrix，如果节点 x 和 y\n是相连的，那么就把 <span class=\"math inline\">\\(matrix[x][y]\\)</span>设为\n（上图中绿⾊的⽅格代表 ）。如果想找节点 的邻居，去扫⼀圈 $matrix[x][..]\n$就⾏ 了。</p>\n<p><strong>那么，为什么有这两种存储图的⽅式呢？肯定是因为他们各有优劣。\n</strong></p>\n<p>对于邻接表，好处是占⽤的空间少。</p>\n<p>你看邻接矩阵⾥⾯空着那么多位置，肯定需要更多的存储空间。</p>\n<p>但是，邻接表⽆法快速判断两个节点是否相邻。 ⽐如说我想判断节点 1\n是否和节点 3 相邻，我要去邻接表⾥ 1 对应的邻居列表⾥查找\n是否存在。但对于邻接矩阵来说，只要看看<code>matrix[1][3]</code>就知道了，效率比较高。</p>\n<span id=\"more\"></span>\n<h1 id=\"所有可能的路径\"><a\nhref=\"https://leetcode-cn.com/problems/all-paths-from-source-to-target/\">797.\n所有可能的路径</a></h1>\n<p>给你一个有 n 个节点的 有向无环图（DAG），请你找出所有从节点 0 到节点\nn-1 的路径并输出（不要求按特定顺序）</p>\n<p>graph[i] 是一个从节点 i 可以访问的所有节点的列表（即从节点 i 到节点\ngraph[i][j]存在一条有向边）。</p>\n<h2 id=\"示例\">示例：</h2>\n<p><img src=\"图的遍历/1.jpg\" /></p>\n<blockquote>\n<p>输入：graph = [[4,3,1],[3,2,4],[3],[4],[]]\n输出：[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]</p>\n</blockquote>\n<h3 id=\"思路\">思路：</h3>\n<p>我们可以发现输入的二维数组其实就是「邻接表」。</p>\n<p>我们只需要，<strong>以 0\n为起点遍历图，同时记录遍历过的路径，当遍历到终点时将路径记录下来即可。</strong></p>\n<p>既然输⼊的图是⽆环的，我们就不需要 visited\n数组辅助了，直接套⽤图的遍历框架：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; res;</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">allPathsSourceTarget</span>(vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; graph) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//维护递归过程中经过的路径</span></span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; path;</span><br><span class=\"line\">        <span class=\"built_in\">traverse</span>(graph, <span class=\"number\">0</span>, path);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">traverse</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt;&amp; graph, <span class=\"type\">int</span> s, vector&lt;<span class=\"type\">int</span>&gt;&amp; path)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//添加节点 s 到路径</span></span><br><span class=\"line\">        path.<span class=\"built_in\">push_back</span>(s);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> n = graph.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s == n - <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//到达终点</span></span><br><span class=\"line\">            res.<span class=\"built_in\">push_back</span>(path);</span><br><span class=\"line\">            path.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//递归每个相邻节点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> v : graph[s])&#123;</span><br><span class=\"line\">            <span class=\"built_in\">traverse</span>(graph, v, path);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        path.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["图"],"tags":["图"]},{"title":"图解HTTP 第三章 HTTP报文内的HTTP信息","url":"/2022/04/23/%E5%9B%BE%E8%A7%A3HTTP-%E7%AC%AC%E4%B8%89%E7%AB%A0-HTTP%E6%8A%A5%E6%96%87%E5%86%85%E7%9A%84HTTP%E4%BF%A1%E6%81%AF/","content":"<h1 id=\"第三章-http报文内的http信息\">第三章 HTTP报文内的HTTP信息</h1>\n<p>HTTP通信过程包括从客户端发往服务器端的请求及从服务器端返回客户端的响应。</p>\n<span id=\"more\"></span>\n<h2 id=\"http报文\">3.1 HTTP报文</h2>\n<p>用于HTTP协议交互的信息就称为HTTP报文。请求端（客户端）的 HTTP\n报文叫做请求报文，响应端（服务器端）的叫做响应报文。</p>\n<p>HTTP\n报文大致可分为报文首部和报文主体两块。两者由最初出现的空行(CR+LF)来划分。</p>\n<p><img src=\"图解HTTP/3.1.jpg\" /></p>\n<h2 id=\"请求报文及响应报文的结构\">3.2 请求报文及响应报文的结构</h2>\n<p><img src=\"图解HTTP/3.2.1.jpg\" /></p>\n<p><img src=\"图解HTTP/3.2.2.jpg\" /></p>\n<p><strong>请求行</strong></p>\n<p>包含用于请求的方法，请求URI 和 HTTP 版本。</p>\n<p><strong>状态行</strong></p>\n<p>包含表明响应结果的状态码，原因短语和HTTP版本。</p>\n<p><strong>首部字段</strong></p>\n<p>包含表示请求和响应的各种条件和属性的各种首部。</p>\n<p>一般有4种首部，分别是：通用首部，请求首部，响应首部和实体首部。</p>\n<p><strong>其他</strong></p>\n<p>可能包含 HTTP 的 RFC 里未定义的首部（Cookie 等）。</p>\n<h2 id=\"编码提升传输速率\">3.3 编码提升传输速率</h2>\n<p>HTTP\n在传输数据时可以按照数据原貌直接传输，但也可以在传输过程中通过编码提升传输速率。通过在传输时编码，能有效地处理大量的访问请求。</p>\n<h3 id=\"报文主体和实体主体的差异\">3.3.1 报文主体和实体主体的差异</h3>\n<ul>\n<li><p><strong>报文(message)</strong></p>\n<blockquote>\n<p>是HTTP 通信中的基本单位，由8位组字节流组成，通过HTTP通信传输。</p>\n</blockquote></li>\n<li><p><strong>实体(entity)</strong></p>\n<blockquote>\n<p>作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成</p>\n</blockquote></li>\n</ul>\n<p>HTTP 报文的主体用于传输请求或响应的实体主体。</p>\n<p>通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。</p>\n<h3 id=\"压缩传输的内容编码\">3.3.2 压缩传输的内容编码</h3>\n<p>内容编码指明应用在实体内容上编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。</p>\n<p>常见的内容编码有以下几种：</p>\n<blockquote>\n<ul>\n<li>gzip(GNU zip)</li>\n<li>compress(UNIX 系统的标准压缩)</li>\n<li>deflate(zlib)</li>\n<li>identity(不进行编码)</li>\n</ul>\n</blockquote>\n<h3 id=\"分割发送的分块传输编码\">3.3.3 分割发送的分块传输编码</h3>\n<p>在 HTTP\n通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。</p>\n<p>这种把实体主体分块的功能称为<strong>分块传输编码。</strong></p>\n<p>分块传输编码会将实体主体分成多个部分（块）。每一块都会用十六进制来标记块的大小，而实体主体的最后一块会使用<code>\"0(CR+LF)\"</code>来标识。</p>\n<p>使用分块传输编码的实体主体会由接收的客户端负责解码。</p>\n<h2 id=\"发送多种数据的多部分对象集合\">3.4\n发送多种数据的多部分对象集合</h2>\n<p>HTTP\n协议中采纳了多部分对象集合，发送的一份报文主体可含有多类型主体。通常是在图片或文本文件等上传时使用。</p>\n<p>多部分对象集合包含的对象如下：</p>\n<ul>\n<li><p>multipart/form-data</p>\n<blockquote>\n<p>在Web表单文件上传时使用</p>\n</blockquote></li>\n<li><p>multipart/byteranges</p>\n<blockquote>\n<p>状态码206响应报文包含了多个范围的内容时使用</p>\n</blockquote></li>\n</ul>\n<p>在 HTTP\n报文中使用多部分对象集合时，需要在首部字段里加上<code>Content-type</code>。</p>\n<p>使用<code>boundary</code>字符串来划分多部分对象集合指明的各类实体。</p>\n<h2 id=\"获取部分内容的范围请求\">3.5 获取部分内容的范围请求</h2>\n<p>要实现恢复的机制需要指定下载的实体范围。指定实体的请求叫做<strong>范围请求(Range\nRequest)</strong>。</p>\n<p>对一份 10 000 字节大小的资源，如果使用范围请求，可以只请求 5001 - 10\n000 字节内的资源。</p>\n<p><img src=\"图解HTTP/3.5.jpg\" /></p>\n<p>执行范围请求时，会用到首部字段 Range 来指定资源的 byte 范围。byte\n范围的指定形式如下：</p>\n<ul>\n<li><p>5001 - 10 000字节</p>\n<blockquote>\n<p>Range: bytes=5001 - 10000</p>\n</blockquote></li>\n<li><p>从 5001 字节之后全部的</p>\n<blockquote>\n<p>Range: bytes=50001-</p>\n</blockquote></li>\n<li><p>从一开始到 3000 字节和 5000 - 7000 字节的多重范围</p>\n<blockquote>\n<p>Range: types=-3000, 5000-7000</p>\n</blockquote></li>\n</ul>\n<p>针对范围请求，响应会返回状态码为 206 Partial Content\n的响应报文。另外，对于多重范围的范围请求，响应会在首部字段\nContent-Type标明 multipart/byteranges 后返回响应报文。</p>\n<p>如果服务器无法响应范围请求，则会返回状态码 200 OK\n和完整的实体内容。</p>\n<h2 id=\"内容协商返回最合适的内容\">3.6 内容协商返回最合适的内容</h2>\n<p>同一个 Web 网站有可能存在着多份相同内容的页面。比如英文版和中文版的\nWeb 页面，它们内容上虽相同，但使用的语言却不同。</p>\n<p>当浏览器的默认语言为英语或中文，访问相同的URI 的 Web\n页面时，则会显示对应的英语版或中文版的 Web\n页面。这样的机制称为<strong>内容协商</strong>。</p>\n<p><strong>内容协商机制</strong>是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。</p>\n<p>基准：</p>\n<blockquote>\n<ul>\n<li>Accept</li>\n<li>Accept-Charset</li>\n<li>Accept-Encoding</li>\n<li>Accept-Language</li>\n<li>Content-Language</li>\n</ul>\n</blockquote>\n<p>内容协商技术有以下3种类型：</p>\n<p><strong>服务器驱动协商</strong></p>\n<p><strong>客户端驱动协商</strong></p>\n<p><strong>透明协商</strong></p>\n","categories":["计算机网络","图解HTTP"],"tags":["计算机网络","图解HTTP"]},{"title":"图解HTTP 第二章 简单的HTTP协议","url":"/2022/04/17/%E5%9B%BE%E8%A7%A3HTTP-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%AE%80%E5%8D%95%E7%9A%84HTTP%E5%8D%8F%E8%AE%AE/","content":"<h1 id=\"第二章-简单的http协议\">第二章 简单的HTTP协议</h1>\n<p>主要使用 HTTP/1.1版本</p>\n<span id=\"more\"></span>\n<h2 id=\"http-协议用于客户端和服务器端之间的通信\">2.1 HTTP\n协议用于客户端和服务器端之间的通信</h2>\n<p>请求访问文本或图像等资源的一端称为客户端，而提供资源响应的一端称为服务器端。</p>\n<h2 id=\"通过请求和响应的交换达成通信\">2.2\n通过请求和响应的交换达成通信</h2>\n<p>HTTP协议规定，请求从客户端发出，最后服务器端响应应该请求并返回。</p>\n<p><img src=\"图解HTTP/2.2.jpg\" /></p>\n<p>下面则是从客户端发送给某个HTTP服务器端的请求报文中的内容。</p>\n<blockquote>\n<p>GET /index.html HTTP/1.1</p>\n<p>Host: hackr.jp</p>\n</blockquote>\n<p>起始行开头的GET表示请求访问服务器的类型，称为方法。随后的字符串/index.html\n指明了请求访问的资源对象，也叫做请求URI。最后的HTTP/1.1，即HTTP的版本号，用来提示客户端使用的HTTP协议功能。</p>\n<p>综合来看，这段请求内容的意思是：请求访问某台HTTP服务器上的/index.html\n页面资源。</p>\n<p>请求报文是由请求方法，请求URI，协议版本，可选的请求首部字段和内容实体构成的。</p>\n<p><img src=\"图解HTTP/2.2.2.jpg\" /></p>\n<p>接收到请求的服务器，会将请求内容的处理结果以响应的形式返回。</p>\n<p><img src=\"图解HTTP/2.2.3.jpg\" /></p>\n<p>在起始行开头的HTTP/1.1 表示服务器对应的HTTP版本。</p>\n<p><code>200 OK</code>表示请求的处理结果的<strong>状态码</strong>和原因短语。下一行显示了创建响应的日期时间，是首部字段内的一个属性。</p>\n<p>接着以一空行分隔，之后的内容称为资源实体的主体。</p>\n<p><img src=\"图解HTTP/2.2.4.jpg\" /></p>\n<h2 id=\"http是不保存状态的协议\">2.3 HTTP是不保存状态的协议</h2>\n<p>HTTP是一种不保存状态，即无状态协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个级别，协议对于发送过的请求或响应都不做<strong>持久化处理</strong>。</p>\n<p>可是，随着 Web\n的不断发展，因无状态而导致业务处理变得棘手的情况增多了。比如，用户登陆到一家购物网站，即便他跳转到该网站的其他页面后，也需要能继续保持登陆状态。</p>\n<p>HTTP/1.1\n虽然是无状态协议，但为了实现期望的保持状态功能，于是引入了<code>Cookie</code>技术。有了<code>Cookie</code>再用HTTP协议通信，就可以管理状态了。</p>\n<h2 id=\"请求-uri-定位资源\">2.4 请求 URI 定位资源</h2>\n<p>HTTP协议使用 URI 定位互联网上的资源。</p>\n<p>当客户端请求访问资源而发送请求时，URI 需要将作为请求报文中的请求 URI\n包含在内。指定请求 URI 的方式有很多。</p>\n<p><img src=\"图解HTTP/2.4.jpg\" /></p>\n<p>除此之外，如果不是访问特定资源而是对服务器本身发起请求，可以用一个<code>*</code>来代替请求\nURI。</p>\n<blockquote>\n<p>OPTION * HTTP/1.1</p>\n</blockquote>\n<h2 id=\"告知服务器意图的http方法\">2.5 告知服务器意图的HTTP方法</h2>\n<h3 id=\"get获取资源\">GET：获取资源</h3>\n<p>GET 方法用来请求已被URI\n识别的资源。指定的资源经服务器端解析后返回响应内容。</p>\n<p><img src=\"图解HTTP/2.5.1.jpg\" /></p>\n<h3 id=\"post传输实体主体\">POST：传输实体主体</h3>\n<p>虽然用GET方法也可以传输实体的主体，但一般不用GET方法进行传输，而是用POST方法。POST的主要目的并不是获取响应的主体内容。</p>\n<p><img src=\"图解HTTP/2.5.2.jpg\" /></p>\n<blockquote>\n<p>ps: GET和POST请求的区别？</p>\n<p>最大的区别是，请求带参数时，报文格式不同，GET方法的参数放在URL中，POST方法的参数放在请求体中。不带参数的请求，没有区别。</p>\n<p>POST比GET更安全，因为参数不会被保存在浏览器历史或者Web服务器日记中。</p>\n</blockquote>\n<h3 id=\"put传输文件\">PUT：传输文件</h3>\n<p>鉴于HTTP/1.1的PUT方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，一般情况下不使用该方法。</p>\n<h3 id=\"head获得报文头部\">HEAD：获得报文头部</h3>\n<p>HEAD方法和GET方法一样，只是不返回报文主体部分。用于确认URI的有效性及资源更新的日期时间等。</p>\n<p><img src=\"图解HTTP/2.5.3.jpg\" /></p>\n<h3 id=\"delete删除文件\">DELETE：删除文件</h3>\n<p>DELETE方法用来删除文件。DELETE方法按请求URI删除指定的资源。</p>\n<p>DELETE方法和PUT方法一样不带验证机制，所以一般的Web网站也不使用DELETE方法。</p>\n<h3 id=\"option询问支持的方法\">OPTION：询问支持的方法</h3>\n<p>OPTION方法用来查询针对请求URI指定的资源支持的方法。</p>\n<h3 id=\"trace追踪路径\">TRACE：追踪路径</h3>\n<p>TRACE方法是让Web服务器端将之前的请求通信环回给客户端的方法。</p>\n<p>发送请求时，在Max-Forwards首部字段填入数值，每经过一个服务器端就将该数字减1，当数字刚好减到0时，就停止继续传输，最后接收到请求的服务器端则返回状态码<code>200 OK</code>的响应。</p>\n<h3\nid=\"connect要求用隧道协议连接代理\">CONNECT：要求用隧道协议连接代理</h3>\n<p>CONNECT方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用\nSSL 和 TLS 协议把通信内容加密后经网络隧道传输。</p>\n<p>CONNECT方法的格式：</p>\n<blockquote>\n<p>CONNECT 代理服务器名：端口号 HTTP版本</p>\n</blockquote>\n<h2 id=\"使用方法下达命令\">2.6 使用方法下达命令</h2>\n<p>向请求URI 指定的资源发送请求报文时，采用称为方法的命令。</p>\n<p><img src=\"图解HTTP/2.6.jpg\" /></p>\n<h2 id=\"持久连接节通信量\">2.7 持久连接节通信量</h2>\n<p>###2.7.1 持久连接</p>\n<p>为了解决每次请求都要建立连接的问题，提出了持久连接（HTTP\nkeep-alive）的方法。持久连接的特点是，只要任意一端没有明确提出断开连接。则保持TCP连接状态。</p>\n<p><img src=\"图解HTTP/2.7.1.jpg\" /></p>\n<p>持久连接的好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。</p>\n<h3 id=\"管线化\">2.7.2 管线化</h3>\n<p>持久连接使得多数请求以管线化方式发送成为可能。从前发送请求后需要等待并收到回应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。</p>\n<h2 id=\"使用-cookie-的状态管理\">2.8 使用 Cookie 的状态管理</h2>\n<p>HTTP是无状态协议，无法根据之前状态进行本次的请求。</p>\n<p>Cookie 技术通过在请求和响应报文中写入 Cookie\n信息来控制客户端的状态。</p>\n<p>Cookie\n会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie\n值后发送出去。</p>\n<p>服务器端发现客户端发送过来的Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p>\n<p><img src=\"图解HTTP/2.8.1.jpg\" /></p>\n<p><img src=\"图解HTTP/2.8.2.jpg\" /></p>\n<p><img src=\"图解HTTP/2.8.3.jpg\" /></p>\n","categories":["计算机网络","图解HTTP"],"tags":["计算机网络","图解HTTP"]},{"title":"图解HTTP 第五章 与HTTP报文协作的Web服务器","url":"/2022/04/25/%E5%9B%BE%E8%A7%A3HTTP-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%B8%8EHTTP%E6%8A%A5%E6%96%87%E5%8D%8F%E4%BD%9C%E7%9A%84Web%E6%9C%8D%E5%8A%A1%E5%99%A8/","content":"<p>#第五章 与HTTP报文协作的Web服务器</p>\n<p>一台<code>Web</code>服务器可搭建多个独立域名的<code>Web</code>网站，也可以作为通信路径上的中转服务器提升传输效率。</p>\n<span id=\"more\"></span>\n<h2 id=\"用单台虚拟主机实现多个域名\">5.1用单台虚拟主机实现多个域名</h2>\n<p>HTTP/1.1\n规范允许一台HTTP服务器搭建多个<code>Web</code>站点。即使物理层面只有一台服务器，但只要使用虚拟主机的功能，则可以假想已具有多台服务器。</p>\n<p>所以当一台服务器托管了多个域名，当收到请求时就需要弄清楚究竟要访问哪个域名。</p>\n<p>在相同的<code>IP</code>地址下，由于虚拟主机可以寄存多个不同主机名和域名的<code>Web</code>网站，因此在发送HTTP请求时，必须在<code>Host</code>首部内完整指定主机名或域名的<code>URI</code>。</p>\n<h2 id=\"通信数据转发程序代理网关隧道\">5.2\n通信数据转发程序：代理，网关，隧道</h2>\n<p>这些应用程序和服务器可以将请求转发给通信线路上的下一站服务器，并且能接收从那台服务器发送的响应再转发给客户端。</p>\n<h3 id=\"代理\">5.2.1 代理</h3>\n<p><img src=\"图解HTTP/5.2.1.jpg\" /></p>\n<p>代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。代理不会改变请求<code>URI</code>，会直接发送给前方持有资源的目标服务器。</p>\n<p>拥有资源实体的服务器被称为源服务器。从源服务器返回的响应经过代理服务器后再传给客户端。</p>\n<p><img src=\"图解HTTP/5.2.1_1.jpg\" /></p>\n<p>在HTTP通信过程中，可级联多台代理服务器。请求和响应的转发会经过数台类似锁链一样连接起来的代理服务器。转发时，需要附加<code>Via</code>首部字段以标记出经过的主机信息。</p>\n<p><strong>使用代理服务器的理由：</strong></p>\n<blockquote>\n<p>利用缓存技术减少网络带宽的流量，组织内部针对网站的访问控制，以获取访问日志为主要目的。</p>\n</blockquote>\n<p>代理有多种使用方法，按两种基准分类。一种是是否使用缓存，另一种是是否会修改报文。</p>\n<p><strong>缓存代理</strong></p>\n<blockquote>\n<p>代理转发响应时，缓存代理会预先将资源的副本保存在代理服务器上。</p>\n<p>当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回。</p>\n</blockquote>\n<p><strong>透明代理</strong></p>\n<blockquote>\n<p>转发请求或响应时，不对报文做任何加工的代理类型就称为透明代理。反之，非透明代理</p>\n</blockquote>\n<h3 id=\"网关\">5.2.2 网关</h3>\n<p><img src=\"图解HTTP/5.2.2.jpg\" /></p>\n<p>网关能使通信线路上的服务器提供非<code>HTTP</code>协议服务。</p>\n<p>利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。比如，网关可以连接数据库，使用<code>SQL</code>语句查询数据。另外，在<code>Web</code>购物网站上进行信用卡结算时，网关可以和信用卡结算系统联动。</p>\n<h3 id=\"隧道\">5.2.3 隧道</h3>\n<p>隧道可按要求建立起一条与其他服务器的通信线路，届时使用<code>SSL</code>等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信。</p>\n<p>隧道本身不会去解析HTTP请求。也就是说，请求保持原样中转给之后的服务器。隧道会在通信双方断开连接时结束。</p>\n","categories":["计算机网络","图解HTTP"],"tags":["计算机网络","图解HTTP"]},{"title":"图解HTTP 第四章 返回结果的HTTP状态码","url":"/2022/04/18/%E5%9B%BE%E8%A7%A3HTTP-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E7%9A%84HTTP%E7%8A%B6%E6%80%81%E7%A0%81/","content":"<p>#第四章 返回结果的HTTP状态码</p>\n<p>HTTP状态码负责表示客户端HTTP请求的返回结果，标记服务器端的处理是否正常，通知出现的错误等。</p>\n<span id=\"more\"></span>\n<h2 id=\"状态码告知从服务器端返回的请求结果\">4.1\n状态码告知从服务器端返回的请求结果</h2>\n<p><img src=\"图解HTTP/4.1.jpg\" /></p>\n<h2 id=\"xx-成功\">4.2 2XX 成功</h2>\n<p>2XX 的响应结果表明请求被正常处理了。</p>\n<h3 id=\"ok\">4.2.1 200 OK</h3>\n<p>​\n<code>200 OK</code>表示从客户端发来的请求在服务器端被正常处理了。</p>\n","categories":["计算机网络","图解HTTP"],"tags":["计算机网络","图解HTTP"]},{"title":"图解HTTP 第一章 了解 Web 及网络基础","url":"/2022/04/16/%E5%9B%BE%E8%A7%A3HTTP/","content":"<h1 id=\"第一章-了解-web-及网络基础\">第一章 了解 Web 及网络基础</h1>\n<h2 id=\"使用http协议访问web\">1.1 使用HTTP协议访问Web</h2>\n<p>当我们在网页浏览器中的地址栏中输入URL时，Web页面是如何呈现的？</p>\n<p>简单的说就是：</p>\n<p><img src=\"图解HTTP/1.1.jpg\" /></p>\n<p>（1）从浏览器输入网址后，首先要经过域名解析，因为浏览器并不能直接通过域名找到服务器，而是通过IP地址找到对应的服务器，DNS将域名解析为IP地址；</p>\n<p>（2）浏览器通过IP地址找到服务器，建立TCP连接，通过三次握手以同步客户端和服务端的序列号和确认号，并交换TCP窗口大小的信息；</p>\n<p>（3）TCP三次握手结束后，开始发送HTTP请求；</p>\n<p>（4）服务器处理请求，并返回HTTP响应报文；</p>\n<p>（5）浏览器拿到响应文本HTML后，解析渲染页面；</p>\n<p>（6）当数据传送完毕后，断开TCP连接。</p>\n<span id=\"more\"></span>\n<h2 id=\"http的诞生\">1.2 HTTP的诞生</h2>\n<p>...</p>\n<p>##1.3 网络基础 TCP/IP</p>\n<p>通常使用的网络（互联网）是在TCP/IP\n协议族的基础上运作的。而HTTP属于它内部的一个子集。</p>\n<h3 id=\"tcpip-协议族\">1.3.1 TCP/IP 协议族</h3>\n<p>计算机与网络设备要互相通信，双方就必须基于相同的方法。我们把这种规则称为协议。</p>\n<h3 id=\"tcpip-的分层管理\">1.3.2 TCP/IP 的分层管理</h3>\n<p>TCP/IP协议族里最重要的一点就是分层。TCP/IP协议族按层次分别分为以下4层，==应用层，传输层，网络层和数据链路层==。</p>\n<p>把TCP/IP分层是有好处的，如果互联网只由一个协议统筹，某个地方需要改变设计时，就必须把所有部分整体替换掉。而分层之后只需把变动的层替换掉即可。</p>\n<p>TCP/IP协议族各层的作用如下：</p>\n<p><strong>应用层</strong></p>\n<p>应用层决定了用户提供应用服务时通信的活动。</p>\n<p>TCP/IP协议族内预存了各类通用的应用服务。比如，FTP（文本传输协议）和DNS（域名系统）。</p>\n<p>HTTP协议也处在该层。</p>\n<p><strong>传输层</strong></p>\n<p>传输层对上层应用层，提供处于网络链接中的两台计算机之间的数据传输。</p>\n<p>在传输层有两个性质不同的协议：TCP（传输控制协议）和UDP（用户数据报协议）</p>\n<p><strong>网络层</strong></p>\n<p>网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。</p>\n<p>与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。</p>\n<p><strong>链路层</strong></p>\n<p>用来处理连接网络的硬件部分。</p>\n<h3 id=\"tcpip-通信传输流\">1.3.3 TCP/IP 通信传输流</h3>\n<p><img src=\"图解HTTP/1.3.jpg\" /></p>\n<p>发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时，就会把对应的首部消去。</p>\n<p>这种把数据信息包装起来的做法称为封装。</p>\n<p>##1.4 与HTTP关系密切的协议：IP，TCP和DNS</p>\n<h3 id=\"负责传输的-ip-协议\">1.4.1 负责传输的 IP 协议</h3>\n<p>按层次分，IP 网际协议位于网络层。可能会有人把“IP”和“IP地址”搞混，“IP”\n其实是一种协议的名称。</p>\n<p>IP\n协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是\nIP 地址和 MAC 地址。</p>\n<p>IP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定地址。IP\n地址可以和MAC地址进行配对。IP地址可变换，但MAC地址基本不会改变。</p>\n<h4\nid=\"使用arp协议凭借mac地址进行通信\">使用ARP协议凭借MAC地址进行通信</h4>\n<p>IP\n间的通信依赖MAC地址。在网络上，通信双方在同一局域网(LAN)内的情况是很少的，通常是经过多台计算机和网络设备中转才能连接到对方。而进行中转时，会利用下一站中转设备的MAC地址来搜索下一个中转目标。这时，会采用ARP协议。ARP是一种用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址。</p>\n<h4\nid=\"没有人能够全面掌握互联网中的传输状况\">没有人能够全面掌握互联网中的传输状况</h4>\n<p>无论哪台计算机，哪台网络设备，它们都无法掌握互联网中的细节。</p>\n<h3 id=\"确保可靠的-tcp-协议\">1.4.2 确保可靠的 TCP 协议</h3>\n<p>TCP位于<strong>传输层</strong>，==提供可靠的字节流服务。==</p>\n<p>所谓的字节流服务是指，为了方便传输，将大块数据分割成以<strong>报文段</strong>为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠地传送给对方。</p>\n<h4 id=\"确保数据能到达目标\">确保数据能到达目标</h4>\n<p>为了准确无误地将数据送达目标处，TCP\n协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标记------\nSYN 和 ACK。</p>\n<p>发送端首先发送一个带有SYN标记的数据包给对方。接收端收到后，回传一个带有SYN/ACK标记的数据包以示传达确认信息。最后，发送端再回传一个带ACK标记的数据包，代表“握手”结束。</p>\n<p><img src=\"图解HTTP/1.4.jpg\" /></p>\n<blockquote>\n<p>ps:</p>\n<p><strong>刚开始客户端处于 closed 的状态，服务端处于 listen\n状态</strong>。</p>\n<p>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号\n<strong>ISN(c)</strong>。此时客户端处于 <strong>SYN_Send</strong>\n状态。</p>\n<p>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN\n报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)，同时会把客户端的\nISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于\n<strong>SYN_REVD</strong> 的状态。</p>\n<p>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK\n报文，当然，也是一样把服务器的 ISN + 1 作为 ACK\n的值，表示已经收到了服务端的 SYN 报文，此时客户端处于\n<strong>establised</strong> 状态。</p>\n<p>服务器收到 ACK 报文之后，也处于 <strong>establised\n状态</strong>，此时，双方以建立起了链接。</p>\n</blockquote>\n<p>为什么要进行三次握手？</p>\n<p>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p>\n<p>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</p>\n<p>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</p>\n<p>因此，需要三次握手才能确认双方的接收与发送能力是否正常。</p>\n<h2 id=\"负责域名解析的dns服务\">1.5 负责域名解析的DNS服务</h2>\n<p>DNS服务是和HTTP协议一样位于应用层的协议。它提供域名到IP地址之间的解析服务。</p>\n<p>用户通常使用主机名或域名来访问对方的计算机，而不是直接通过IP地址访问。因为与IP地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯。</p>\n<p>但是要让计算机去理解名称，相对而言就变困难了。</p>\n<p>为了解决上述问题，DNS服务应运而生。DNS协议提供通过域名查找IP地址，或逆向从IP地址反查域名的服务。</p>\n<p><img src=\"图解HTTP/1.5.jpg\" /></p>\n<h2 id=\"各种协议与http协议的关系\">1.6 各种协议与HTTP协议的关系</h2>\n<p><img src=\"图解HTTP/1.6.jpg\" /></p>\n<h2 id=\"uri-和-url\">1.7 URI 和 URL</h2>\n<p>URI(Uniform Resource Identifier) 统一资源标识符</p>\n<p>URL(Uniform Resource Locator) 统一资源定位符</p>\n<p>URL正是使用Web浏览器等访问Web页面时输入的网页地址。</p>\n<h3 id=\"统一资源标识符uri\">1.7.1 统一资源标识符：URI</h3>\n<p>URI\n就是由某个协议方案表示的资源的定位标识符。协议方案是指访问资源所使用的协议类型名称。</p>\n<p>采用HTTP协议时，协议方案就是http。除此之外，还有ftp,mailto,telnet,file等。</p>\n<p>==URI 用字符串标识某一互联网资源，而 URL 表示资源的地址。可见 URL\n是URI 的子集。==</p>\n<p>URI:</p>\n<p><img src=\"图解HTTP/1.7.1.jpg\" /></p>\n<h3 id=\"uri-格式\">1.7.2 URI 格式</h3>\n<p>表示指定的URI，要使用涵盖全部必要信息的绝对URI，绝对URL以及相对URL。相对URL，是指从浏览器中基本URI处指定的URL，形如：/image/logo.gif。</p>\n<p>绝对URI的格式：</p>\n<p><img src=\"图解HTTP/1.7.2.jpg\" /></p>\n","categories":["计算机网络","图解HTTP"],"tags":["计算机网络","图解HTTP"]},{"title":"在 nvim 中使用模糊查找 fzf","url":"/2022/05/13/%E5%9C%A8-nvim-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%A8%A1%E7%B3%8A%E6%9F%A5%E6%89%BE-fzf/","content":"<h1 id=\"fzf\">fzf</h1>\n<p>快速模糊搜索查找工具</p>\n<span id=\"more\"></span>\n<h2 id=\"安装和配置\">安装和配置</h2>\n<h3 id=\"在终端中安装-fzf-工具\"><strong>1. 在终端中安装 <code>fzf</code>\n工具</strong></h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">brew install fzf</span><br></pre></td></tr></table></figure>\n<p>地址：<a href=\"https://github.com/junegunn/fzf\">FZF</a></p>\n<p>如果你使用的是<code>bash</code>的话，到<code>bash_profile</code>中配置</p>\n<p>我使用的是<code>zsh</code>，就需要到<code>.zshrc</code>中配置</p>\n<p>如果你不想配置的话可以直接调用官方的</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"># To install useful key bindings <span class=\"keyword\">and</span> fuzzy completion:</span><br><span class=\"line\">$(brew --prefix)/opt/fzf/install</span><br></pre></td></tr></table></figure>\n<h4 id=\"配置\">配置</h4>\n<p>这里说明下一些操作</p>\n<p>具体可自己打开</p>\n<p>也可以直接输入</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">命令 + **&lt;TAB&gt;</span><br></pre></td></tr></table></figure>\n<p>就可以直接搜索</p>\n<p><img src=\"在-nvim-中使用模糊查找-fzf/1.jpg\" /></p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>快捷键</th>\n<th>操作</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td><code>Ctrl + t</code></td>\n<td>搜索</td>\n</tr>\n<tr class=\"even\">\n<td><code>Ctrl + r</code></td>\n<td>显示最近输入历史记录</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"在nvim的init.vim中安装fzf插件\"><strong>2.\n在<code>nvim</code>的<code>init.vim</code>中安装<code>fzf</code>插件</strong></h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">Plug <span class=\"string\">&#x27;junegunn/fzf&#x27;</span>, &#123; <span class=\"string\">&#x27;do&#x27;</span>: &#123; -&gt; fzf<span class=\"meta\">#install() &#125; &#125;</span></span><br><span class=\"line\">Plug <span class=\"string\">&#x27;junegunn/fzf.vim&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>然后在 vim 中配置 fzf 插件的相关设置</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot; open fzf</span></span><br><span class=\"line\"><span class=\"string\">nnoremap &lt;Leader&gt;ff :FZF&lt;CR&gt;</span></span><br><span class=\"line\"><span class=\"string\">let g:fzf_preview_window = &#x27;right:40%&#x27;</span></span><br><span class=\"line\"><span class=\"string\">let g:fzf_commits_log_options = &#x27;--graph --color=always --format=&quot;</span>%<span class=\"built_in\">C</span>(<span class=\"keyword\">auto</span>)%h%d %s %<span class=\"built_in\">C</span>(black)%<span class=\"built_in\">C</span>(bold)%cr<span class=\"string\">&quot;&#x27;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">function! s:list_buffers()</span></span><br><span class=\"line\"><span class=\"string\">  redir =&gt; list</span></span><br><span class=\"line\"><span class=\"string\">  silent ls</span></span><br><span class=\"line\"><span class=\"string\">  redir END</span></span><br><span class=\"line\"><span class=\"string\">  return split(list, &quot;</span>\\n<span class=\"string\">&quot;)</span></span><br><span class=\"line\"><span class=\"string\">endfunction</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">function! s:delete_buffers(lines)</span></span><br><span class=\"line\"><span class=\"string\">  execute &#x27;bwipeout&#x27; join(map(a:lines, &#123;_, line -&gt; split(line)[0]&#125;))</span></span><br><span class=\"line\"><span class=\"string\">endfunction</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">command! BD call fzf#run(fzf#wrap(&#123;</span></span><br><span class=\"line\"><span class=\"string\">  \\ &#x27;source&#x27;: s:list_buffers(),</span></span><br><span class=\"line\"><span class=\"string\">  \\ &#x27;sink*&#x27;: &#123; lines -&gt; s:delete_buffers(lines) &#125;,</span></span><br><span class=\"line\"><span class=\"string\">  \\ &#x27;options&#x27;: &#x27;--multi --reverse --bind ctrl-a:select-all+accept&#x27;</span></span><br><span class=\"line\"><span class=\"string\">\\ &#125;))</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">noremap &lt;c-d&gt; :BD&lt;CR&gt;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">let g:fzf_layout = &#123; &#x27;window&#x27;: &#123; &#x27;width&#x27;: 0.95, &#x27;height&#x27;: 0.95 &#125; &#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"命令\">命令</h3>\n<p><code>:Files [path]</code>: 列出 path 路径下的所有文件 (功能等价于\n<code>:FZF</code> 命令) <code>:Buffers</code>: 文件缓冲区切换\n<code>:Colors</code>: 选择 Vim 配色方案 <code>:Tags [QUERY]</code>:\n当前项目中的 Tag (等价于: ctags -R) <code>:BTags</code>: [QUERY]\n当前活动缓冲区的标记 <code>:Marks</code>: 所有 Vim 标记\n<code>:Windows</code>: 窗口 <code>:Lines [QUERY]</code>:\n在所有加载的文件缓冲区里包含目标词的所有行 <code>:BLines [QUERY]</code>:\n在当前文件缓冲区里包含目标词的行 <code>:Locate PATTERN</code>: locate\ncommand output <code>:History</code>: v:oldfiles and open buffers\n<code>:History:</code>: 命令行命令历史 <code>:History/</code>: 搜索历史\n<code>:Commands</code>: Vim 命令列表 <code>:Maps</code>:\n普通模式下的按键映射 <code>:Snippets</code>: Snippets ([UltiSnips][us])\n<code>:Commits</code>: Git commits (requires [fugitive.vim][f])\n<code>:BCommits</code>: 查看与当前缓冲区有关的 commit\n<code>:GFiles [OPTS]</code>: Git files (git ls-files)\n<code>:GFiles?</code>: Git files (git status)\n<code>:Ag [PATTERN]</code>: ag search result (ALT-A to select all, ALT-D\nto deselect all) <code>:Rg [PATTERN]</code>: rg search result (ALT-A to\nselect all, ALT-D to deselect all) <code>:Filetypes</code>: File\ntypes</p>\n","categories":["nvim","fzf"],"tags":["nvim","fzf"]},{"title":"多数元素","url":"/2022/05/09/%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/","content":"<h1 id=\"多数元素\"><a\nhref=\"https://leetcode.cn/problems/majority-element/\">169.\n多数元素</a></h1>\n<p>给定一个大小为 <code>n</code>的数组\n<code>nums</code>，返回其中的多数元素。多数元素是指在数组中出现次数 大于\n<code>⌊ n/2 ⌋</code>的元素。</p>\n<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>\n<h2 id=\"示例\">示例：</h2>\n<blockquote>\n<p>输入：nums = [2,2,1,1,1,2,2] 输出：2</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"思路\">思路：</h3>\n<h4 id=\"方法一哈希表\">方法一：哈希表</h4>\n<p>时间，空间复杂度为：<code>O(n)</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        unordered_map&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt; mp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            mp[nums[i]]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(mp[nums[i]] &gt; (n / <span class=\"number\">2</span>))&#123;</span><br><span class=\"line\">                res = nums[i];</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二排序\">方法二：排序</h4>\n<p>时间复杂度为：<code>O(nlogn)</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[nums.<span class=\"built_in\">size</span>() / <span class=\"number\">2</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法三摩尔投票法\">方法三：摩尔投票法</h3>\n<p>这里我们重点讲摩尔投票法，时间复杂度为<code>o(n)</code>，空间复杂度为<code>O(1)</code>。</p>\n<p>因为多数元素的次数总是大于<code>[n/2]</code>，那么其他元素只能小于<code>[n/2]</code>，所以我们选出一个候选人<code>candidate</code>，他本身的票数为<code>count = 1</code>，我们遍历数组，如果和这个数一样，那么我们票数加一，否则票数减一，如果票数为负，则我们让下一个元素当候选人，票数设为一。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> candidate = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span> count = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; nums.<span class=\"built_in\">size</span>(); i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[i] == candidate)&#123;</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(--count &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                candidate = nums[i];</span><br><span class=\"line\">                count = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> candidate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["众数"],"tags":["排序","众数","哈希表"]},{"title":"字典序排数","url":"/2022/04/18/%E5%AD%97%E5%85%B8%E5%BA%8F%E6%8E%92%E6%95%B0/","content":"<h1 id=\"字典序排数\"><a\nhref=\"https://leetcode-cn.com/problems/lexicographical-numbers/\">386.\n字典序排数</a></h1>\n<p>给你一个整数 <code>n</code> ，按字典序返回范围 <code>[1, n]</code>\n内所有整数。</p>\n<p>你必须设计一个时间复杂度为 <code>O(n)</code> 且使用 <code>O(1)</code>\n额外空间的算法。</p>\n<h2 id=\"示例\">示例：</h2>\n<blockquote>\n<p>输入：n = 13 输出：[1,10,11,12,13,2,3,4,5,6,7,8,9]</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"思路\">思路：</h3>\n<p>440</p>\n<h4 id=\"方法一dfs\">方法一：DFS</h4>\n<p><img src=\"字典序排数/1.jpg\" /></p>\n<p>我们可以发现求字典序就是一棵树，我们从第二层开始递归遍历</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">lexicalOrder</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">9</span>; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(res, i, n);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; res, <span class=\"type\">int</span> k, <span class=\"type\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(k &gt; n) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        res.<span class=\"built_in\">push_back</span>(k);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= <span class=\"number\">9</span>; i++)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(res, k * <span class=\"number\">10</span> + i, n);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>时间复杂度：本质上在搜索一棵节点数量为 n\n的多阶树（形态类似于字典树），复杂度为 O(n)</li>\n<li>空间复杂度：忽略递归带来的额外空间开销，复杂度为 O(1)</li>\n</ul>\n<h4 id=\"方法二迭代\">方法二：迭代</h4>\n<p>递归具有额外的空间开销，为了实现严格的 O(1)\n空间，我们需要使用「迭代」来实现 <code>DFS</code>。</p>\n<p>共有 n 个数需要被处理，假设当前处理到的数为\nj，根据字典序规则，在满足条件的前提下，我们优先在 j 的后面添加 0（即 j *\n10 &lt; n 满足），否则我们考虑将上一位回退并进行加一操作。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">lexicalOrder</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">1</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            res.<span class=\"built_in\">push_back</span>(j);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(j * <span class=\"number\">10</span> &lt;= n)&#123;</span><br><span class=\"line\">                j *= <span class=\"number\">10</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span>(j % <span class=\"number\">10</span> == <span class=\"number\">9</span> || j + <span class=\"number\">1</span> &gt; n)&#123;</span><br><span class=\"line\">                    j /= <span class=\"number\">10</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["DFS"],"tags":["DFS"]},{"title":"字母异位词分组","url":"/2022/04/27/%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/","content":"<h1 id=\"字母异位词分组\"><a\nhref=\"https://leetcode-cn.com/problems/group-anagrams/\">49.\n字母异位词分组</a></h1>\n<p>给你一个字符串数组，请你将 字母异位词\n组合在一起。可以按任意顺序返回结果列表。</p>\n<p>字母异位词\n是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p>\n<h2 id=\"示例\">示例：</h2>\n<blockquote>\n<p>输入: strs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"] 输出:\n[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"思路\">思路：</h3>\n<h4 id=\"方法一哈希-排序\">方法一：哈希 + 排序</h4>\n<p>由于互为字母异位词的两个字符串包含的字母相同，因此对两个字符串分别进行排序之后得到的字符串一定是相同的，故可以将排序之后的字符串作为哈希表的键。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;string&gt;&gt; <span class=\"built_in\">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class=\"line\">        unordered_map&lt;string, vector&lt;string&gt; &gt; mp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(string&amp; str : strs)&#123;</span><br><span class=\"line\">            string key = str;</span><br><span class=\"line\">            <span class=\"built_in\">sort</span>(key.<span class=\"built_in\">begin</span>(), key.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">            mp[key].<span class=\"built_in\">push_back</span>(str);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        vector&lt;vector&lt;string&gt; &gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> it = mp.<span class=\"built_in\">begin</span>(); it != mp.<span class=\"built_in\">end</span>(); it++)&#123;</span><br><span class=\"line\">            res.<span class=\"built_in\">emplace_back</span>(it-&gt;second);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二哈希-计数\">方法二：哈希 + 计数</h4>\n<p>例如 <code>aabbc</code></p>\n<p>转化为 <code>a2b2c1</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;string&gt;&gt; <span class=\"built_in\">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class=\"line\">        unordered_map&lt;string, vector&lt;string&gt; &gt; codeToGroup;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(string s : strs)&#123;</span><br><span class=\"line\">            string code = <span class=\"built_in\">encode</span>(s);</span><br><span class=\"line\">            codeToGroup[code].<span class=\"built_in\">push_back</span>(s);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        vector&lt;vector&lt;string&gt; &gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> it = codeToGroup.<span class=\"built_in\">begin</span>(); it != codeToGroup.<span class=\"built_in\">end</span>(); ++it) &#123;</span><br><span class=\"line\">            res.<span class=\"built_in\">push_back</span>(it-&gt;second);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//利用每个字符的出现次数进行编码</span></span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">encode</span><span class=\"params\">(string s)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">code</span><span class=\"params\">(<span class=\"number\">26</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">char</span> c : s)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> delta = c - <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">            code[delta]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        string res;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">26</span>; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(code[i] != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                res += (<span class=\"type\">char</span>)(<span class=\"string\">&#x27;a&#x27;</span> + i) + <span class=\"built_in\">to_string</span>(code[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["字符串","哈希表"],"tags":["字符串","哈希表"]},{"title":"天然货仓","url":"/2022/04/10/%E5%A4%A9%E7%84%B6%E8%B4%A7%E4%BB%93/","content":"<h1 id=\"天然货仓\">天然货仓</h1>\n<p><strong>题目描述</strong></p>\n<ul>\n<li>有一个天然形成的大坑，为台阶状结构，每个台阶的长度都为1，每个台阶的值为整数（正整数表示高于地平面，零表示与地平面平齐，负整数表示低于地平面）。</li>\n<li>有一批同等规格的货品（长度为N，高度为1），货品只能平放，且货物的上表面不能超过地平面（深度为零），或者说，高于地平面的坑中也不可存放货物。</li>\n<li>计算一个给定的大坑中最多可以放多少个货品？</li>\n<li>如下图所示，[0,-1,-2,0]\n组成的大坑，货品长度为2，可以放入1个货品（阴影矩形），返回1。</li>\n</ul>\n<p><strong>输入描述</strong></p>\n<ul>\n<li>输入依次为N，M，一维数组。</li>\n<li>N为该批次货物的长度（1 &lt; N &lt;= 100000），M为一维数组的长度（1\n&lt;= M &lt;= 100000），</li>\n<li>一维数组为大坑从左到右每个台阶的值（-10000 &lt; 值 &lt;\n10000）。</li>\n</ul>\n<p><strong>输出描述</strong></p>\n<ul>\n<li>可以放入的货品总数，不能放入或异常返回 0。</li>\n</ul>\n<span id=\"more\"></span>\n<p><strong>样例 1</strong></p>\n<p><strong>输入：</strong></p>\n<blockquote>\n<p>2 4 0,-1,-2,0</p>\n</blockquote>\n<p><strong>解释：</strong></p>\n<ul>\n<li>见样例 1 图示，坑中只能放入一个长度为 2 的货品，返回 1 。</li>\n</ul>\n<p><img src=\"天然货仓/1.png\" /></p>\n<h2 id=\"思路\">思路：</h2>\n<p>我们可以把一维数组转化为二维数组，并且不需要考虑大于0的地区，我们只需要得出最小的数<code>minNum</code>。</p>\n<p>然后转化为<code>matrix[abs(minNum)][M]</code></p>\n<p>例如样例1，</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th style=\"text-align: left;\">0</th>\n<th style=\"text-align: center;\">1</th>\n<th>1</th>\n<th>0</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td style=\"text-align: left;\">0</td>\n<td style=\"text-align: center;\">0</td>\n<td>1</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n<p>我们用0表示不可以放，1表示可以放。</p>\n<p>然后对每个等于1的数开始<code>DFS</code>(只需要遍历右边即可),遍历到就把1变为0，遍历到了2个数，答案就加一，表示可以放下一个货物。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unordered_map&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ll;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">double</span> ld;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; pii;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> vector&lt;<span class=\"type\">int</span>&gt; vi;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> N;</span><br><span class=\"line\"><span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt;&amp; martrix, <span class=\"type\">int</span> x, <span class=\"type\">int</span> y, <span class=\"type\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> m = martrix.<span class=\"built_in\">size</span>(), n = martrix[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"comment\">//base case</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x &gt; m || y &gt; n) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"comment\">//原来就不可以放</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(martrix[x][y] == <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"comment\">//变为不可放</span></span><br><span class=\"line\">    martrix[x][y] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    k++;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(k == <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//答案加一</span></span><br><span class=\"line\">        res++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(martrix, x, y + <span class=\"number\">1</span>, k);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> M;</span><br><span class=\"line\">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">nums</span><span class=\"params\">(M)</span></span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> minNum = INT_MAX;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; M; i++)&#123;</span><br><span class=\"line\">        cin &gt;&gt; nums[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums[i] &lt; minNum)&#123;</span><br><span class=\"line\">            minNum = nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//处理数组</span></span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; <span class=\"built_in\">matrix</span>(<span class=\"built_in\">abs</span>(minNum), <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt; (M, <span class=\"number\">0</span>));</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; M; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums[i] &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> j = <span class=\"built_in\">abs</span>(nums[i]);</span><br><span class=\"line\">            <span class=\"type\">int</span> k = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(k &lt; j)&#123;</span><br><span class=\"line\">                matrix[k++][i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//dfs</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; matrix.<span class=\"built_in\">size</span>(); i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; matrix[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>(); j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(matrix[i][j] == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">dfs</span>(matrix, i, j, <span class=\"number\">0</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["DFS"],"tags":["DFS","华为机试"]},{"title":"差分数组","url":"/2022/07/17/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/","content":"<p>[[toc]]</p>\n<h1 id=\"差分数组\">差分数组</h1>\n<p>前面我们了解了<a\nhref=\"https://sjchen404.github.io/2022/03/24/前缀和数组/\">前缀和</a></p>\n<p><strong>前缀和主要适用于原始数组不会被修改的情况下，频繁查询某个区间的累加和</strong></p>\n<p><strong>差分数组主要适用于频繁对原始数组的某个区间的元素进行增减</strong></p>\n<p>比如我们给定一个数组<code>nums</code></p>\n<table>\n<thead>\n<tr class=\"header\">\n<th></th>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>nums</td>\n<td>8</td>\n<td>2</td>\n<td>6</td>\n<td>3</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<p>要求给区间<code>nums[2..6]</code>全部加1，再给<code>nums[3..9]</code>全部减3，再给<code>nums[0..4]</code>全部加2，最后问<code>nums</code>数组的值为多少？</p>\n<p>常规做法就是每次在所给区间循环加上或者减去给定的值，时间复杂度为：<code>O(m)</code>，效率比较低。</p>\n<p>这时就需要用到差分数组，我们先对<code>nums</code>数组构造一个<code>diff</code>差分数组，<code>diff[i] = nums[i] - nums[i-1]</code></p>\n<span id=\"more\"></span>\n<table>\n<thead>\n<tr class=\"header\">\n<th></th>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>nums</td>\n<td>8</td>\n<td>2</td>\n<td>6</td>\n<td>3</td>\n<td>1</td>\n</tr>\n<tr class=\"even\">\n<td>diff</td>\n<td>8</td>\n<td>-6</td>\n<td>4</td>\n<td>-3</td>\n<td>-2</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">diff</span><span class=\"params\">(nums.size())</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 构造差分数组</span></span><br><span class=\"line\">diff[<span class=\"number\">0</span>] = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; nums.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">    diff[i] = nums[i] - nums[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在我们如何通过差分数组<code>diff</code>反推出元素数组<code>nums</code>？\n我们可以看出<code>nums[1]</code>是前一个数的结果加上<code>diff[i]</code>得出的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">res</span><span class=\"params\">(diff.size())</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 根据差分数组构造出结果数组</span></span><br><span class=\"line\">res[<span class=\"number\">0</span>] = diff[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; diff.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">    res[i] = res[i - <span class=\"number\">1</span>] + diff[i];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么现在假如我们对区间<code>nums[1..3]</code>的元素全部加3，我们应该如何计算呢？</p>\n<p>我们只需要让<code>diff[i] += 3</code>,最后在让<code>diff[j + 1] -= 3</code>即可。</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th></th>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>nums</td>\n<td>8</td>\n<td>5</td>\n<td>9</td>\n<td>6</td>\n<td>1</td>\n</tr>\n<tr class=\"even\">\n<td>diff</td>\n<td>8</td>\n<td>-3</td>\n<td>4</td>\n<td>-3</td>\n<td>-5</td>\n</tr>\n</tbody>\n</table>\n<p>原理很简单，回想前面<code>diff</code>数组反推<code>nums</code>\n数组的过程，<code>diff[i] += 3</code>意味着给<code>nums[i..]</code>后所有的元素都加上了3，\n然后<code>diff[j + 1] -= 3</code>又意味着给<code>nums[j + 1..]</code>后的所有元素减3，综合起来，就是相当于只对区间<code>nums[i..j]</code>中的所有元素都加3.</p>\n<p>这样只需花费<code>O(1)</code>的时间修改<code>diff</code>数组，就相当于给<code>nums</code>的整个区间做了修改。</p>\n<p>我们把差分数组抽象成一个类，包括<code>increment</code>和<code>result</code>方法。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> 差分数组工具类</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Difference</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; diff;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 输入一个初始数组，区间操作将在这个数组上进行</span></span><br><span class=\"line\">    <span class=\"built_in\">Difference</span>(vector&lt;<span class=\"type\">int</span>&gt; nums) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums.<span class=\"built_in\">size</span>() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            diff.<span class=\"built_in\">resize</span>(nums.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">            <span class=\"comment\">// 根据初始数组构造差分数组</span></span><br><span class=\"line\">            diff[<span class=\"number\">0</span>] = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; nums.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">                diff[i] = nums[i] - nums[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 给区间[i,j]增加 val （可以是负数）</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">increment</span><span class=\"params\">(<span class=\"type\">int</span> i, <span class=\"type\">int</span> j, <span class=\"type\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        diff[i] += val;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(j + <span class=\"number\">1</span> &lt; diff.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">            diff[j + <span class=\"number\">1</span>] -= val;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 返回结果数组</span></span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">result</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">res</span><span class=\"params\">(diff.size())</span></span>;</span><br><span class=\"line\">        <span class=\"comment\">// 根据差分数组构造结果数组</span></span><br><span class=\"line\">        res[<span class=\"number\">0</span>] = diff[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; diff.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">            res[i] += res[i - <span class=\"number\">1</span>] + diff[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"算法实践\">算法实践</h1>\n<h2 id=\"区间加法\">370. 区间加法</h2>\n<p>假设你有一个长度为<code>n</code>的数组，初始情况下所有数字均为0，你将会被给出<code>k</code>个更新的操作。\n其中，每个操作会被表示为一个三元组：<code>[startIndex, endIndex, inc]</code>，你需要将子数组<code>A[startIndex...endIndex]</code>(包括\nstartIndex和endIndex),增加<code>inc</code>.</p>\n<p>请你返回<code>k</code>次操作后的数组。</p>\n<h3 id=\"示例\">示例：</h3>\n<blockquote>\n<p>length = 5, updates = [[1,3,2],[2,4,3],[0,2,-2]]<br>\n输出：[-2,0,3,5,3]</p>\n<p>解释：</p>\n</blockquote>\n<blockquote>\n<p>初始状态：<br> [0,0,0,0,0]<br> 进行了操作[1,3,2]后的状态<br>\n[0,2,2,2,0]<br> 进行了操作[2,4,3]<br> [0,2,5,5,3]<br>\n进行了操作[0,2,-1]<br> [-2,0,3,5,3]</p>\n</blockquote>\n<p>我们直接使用前面实现的类就可以解决：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> 差分数组工具类</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Difference</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; diff;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 输入一个初始数组，区间操作将在这个数组上进行</span></span><br><span class=\"line\">    <span class=\"built_in\">Difference</span>(vector&lt;<span class=\"type\">int</span>&gt; nums) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums.<span class=\"built_in\">size</span>() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            diff.<span class=\"built_in\">resize</span>(nums.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">            <span class=\"comment\">// 根据初始数组构造差分数组</span></span><br><span class=\"line\">            diff[<span class=\"number\">0</span>] = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; nums.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">                diff[i] = nums[i] - nums[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 给区间[i,j]增加 val （可以是负数）</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">increment</span><span class=\"params\">(<span class=\"type\">int</span> i, <span class=\"type\">int</span> j, <span class=\"type\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        diff[i] += val;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(j + <span class=\"number\">1</span> &lt; diff.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">            diff[j + <span class=\"number\">1</span>] -= val;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 返回结果数组</span></span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">result</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">res</span><span class=\"params\">(diff.size())</span></span>;</span><br><span class=\"line\">        <span class=\"comment\">// 根据差分数组构造结果数组</span></span><br><span class=\"line\">        res[<span class=\"number\">0</span>] = diff[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; diff.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">            res[i] += res[i - <span class=\"number\">1</span>] + diff[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">getModifiedArray</span><span class=\"params\">(<span class=\"type\">int</span> length, vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; updates)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">nums</span><span class=\"params\">(length, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"comment\">// 构造差分解法</span></span><br><span class=\"line\">        Difference* df = <span class=\"keyword\">new</span> <span class=\"built_in\">Difference</span>(nums);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(vector&lt;<span class=\"type\">int</span>&gt; update : updates) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> i = update[<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"type\">int</span> j = update[<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"type\">int</span> val = update[<span class=\"number\">2</span>];</span><br><span class=\"line\">            df-&gt;<span class=\"built_in\">increment</span>(i, j, val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> df-&gt;<span class=\"built_in\">result</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["差分数组"],"tags":["差分数组"]},{"title":"引用","url":"/2022/08/02/%E5%BC%95%E7%94%A8/","content":"<p>引用常说的是“左值引用”，<code>C++11</code>中新增了一种引用，即“右值引用”。</p>\n<span id=\"more\"></span>\n<h1 id=\"左值引用\">左值引用</h1>\n<p><strong>引用</strong>为对象起了另外一个名字，<em>引用必须初始化。</em></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> ival = <span class=\"number\">1024</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> &amp;refVal = ival;         <span class=\"comment\">// refVal指向ival(是ival的另一个名字)</span></span><br><span class=\"line\"><span class=\"type\">int</span> &amp;refVal2;               <span class=\"comment\">// 报错；引用必须初始化</span></span><br></pre></td></tr></table></figure>\n<p>因为，一般在初始化时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。\n一但初始值完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另一个对象，因此引用必须初始化。</p>\n<p><strong>引用即别名：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> ival = <span class=\"number\">1024</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> &amp;refVal = ival;</span><br><span class=\"line\">    refVal = <span class=\"number\">2</span>;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;ival = &quot;</span> &lt;&lt; ival &lt;&lt; std::endl;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;refVal = &quot;</span> &lt;&lt; refVal &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出： &gt; ival = 2<br> &gt; refVal = 2</p>\n<p>我们更改引用<code>refVal</code>的值，发现<code>ival</code>的值也发生了改变，这正是因为引用只是原来对象的别名。</p>\n<p><strong>引用的定义：</strong></p>\n<p>允许一条语句中定义多个引用，其中每个引用标识符都必须以字符<code>&amp;</code>开头。</p>\n<p><em>引用只能绑定在对象上。</em></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> &amp;refVal4 = <span class=\"number\">10</span>;          <span class=\"comment\">// 错误：引用类型的初始值必须是一个对象</span></span><br><span class=\"line\"><span class=\"type\">double</span> dval = <span class=\"number\">3.14</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> &amp;refVal5 = dval;        <span class=\"comment\">// 错误：此处引用类型初始值必须是int型对象</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"右值引用rvalue-reference\">右值引用(rvalue reference)</h1>\n<p>为了支持移动操作，新标准引入了一种新的引用类型----<strong>右值引用</strong>。</p>\n<p>所谓右值引用就是必须绑定到右值的引用，我们通过<code>&amp;&amp;</code>而不是<code>&amp;</code>来获得右值引用。</p>\n<p><em>右值引用只能绑定到一个将要销毁的对象。</em></p>\n<p>一般而言，一个左值表达式表示的是一个对象的身份，而一个右值表达式表示的是对象的值。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> i = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> &amp;r = i;             <span class=\"comment\">// 正确：r引用int</span></span><br><span class=\"line\"><span class=\"type\">int</span> &amp;&amp;rr = i;           <span class=\"comment\">// 错误：不能将一个右值引用绑定到一个左值上</span></span><br><span class=\"line\"><span class=\"type\">int</span> &amp;r2 = i * <span class=\"number\">42</span>;       <span class=\"comment\">// 错误：i * 42 是一个右值</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> &amp;r3 = i * <span class=\"number\">42</span>; <span class=\"comment\">// 正确：我们可以将一个const的引用绑定到一个右值上</span></span><br><span class=\"line\"><span class=\"type\">int</span> &amp;&amp;rr2 = i * <span class=\"number\">42</span>;     <span class=\"comment\">// 正确：i * 42为一个右值</span></span><br></pre></td></tr></table></figure>\n<p>返回左值的函数，连同赋值，下标，解引用和前置递增/递减运算符，都是返回左值的表达式。\n我们可以将一个左值引用绑定到这类表达式的结果上。</p>\n<p>返回非引用类型的函数，连同算术，关系，位以及后置递增/递减运算符，都生成右值。\n我们可以将一个<code>const</code>的左值引用或一个右值引用绑定到这类表达式上。</p>\n<h2 id=\"左值持久右值短暂\">左值持久。右值短暂</h2>\n<p>左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。</p>\n<h2 id=\"变量是左值\">变量是左值</h2>\n<p>变量可以看作只有一个运算对象而没有运算符的表达式。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> &amp;&amp;rr1 = <span class=\"number\">42</span>;         <span class=\"comment\">// 正确：字面常量是右值</span></span><br><span class=\"line\"><span class=\"type\">int</span> &amp;&amp;rr2 = rr1;        <span class=\"comment\">// 错误：表达式rr1是左值！</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"标准库movw函数\">标准库movw函数</h2>\n<p>虽然不能将一个右值引用直接绑定到一个左值上，但我们可以显式地将一个左值转换为对应的右值引用类型。我们还可以通过调用一个名为<code>move</code>的新标准\n库函数来获得绑定到左值上的引用。</p>\n<p>此函数定义在头文件<code>utility</code>中。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> &amp;&amp;rr1 = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> &amp;&amp;rr3 = std::<span class=\"built_in\">move</span>(rr1);</span><br></pre></td></tr></table></figure>\n<p><code>move</code>调用告诉编译器：我们有一个左值，但我们希望像一个右值一样处理它。</p>\n<p>调用<code>move</code>就意味着承诺：除了对<code>rr1</code>赋值或销毁它外，我们将不再使用它。在调用<code>move</code>之后，我们不能对移后源对象的值做任何假设。</p>\n","categories":["C++"],"tags":["C++"]},{"title":"并查集","url":"/2022/04/16/%E5%B9%B6%E6%9F%A5%E9%9B%86/","content":"<p>#<strong>问题背景</strong></p>\n<p>当下，我们每个人都有自己的亲感，但你能保证认识你所有的亲戚吗？如何确定一个陌生人是否是你的亲威呢？\n如果有这样一个前提：拥有相同祖先的两个人是亲威。那么并查集就可以帮助我们判断某个陌生人是否是我们的亲戚。\n通俗地讲一个故事：儿个家族进行宴会，但是家族音遍长寿，所以人数众多由于长时间的分离以及年龄的增长，这些人逐渐忘掉了自己的亲人，只记得自己的爸爸是谁了，而最长者（称为「祖先」）的父亲已经去世，他具知道自己是祖先。为了确定自己是哪个家族，他们想出了个办法，只要问自己的爸爸是不是祖先，一层一层的向上问，直到问到祖先。如果要判断两人是否在同一家族，只要看两人的祖先是不是同一人就可以了。</p>\n<span id=\"more\"></span>\n<h1 id=\"并查集应用\">并查集应用</h1>\n<ul>\n<li>”边带权“并查集与“扩展域”并查集</li>\n<li>判断图是否连通</li>\n<li>最小生成树 Kruskal 算法</li>\n<li>最近公共祖先LCA</li>\n</ul>\n<p>#并查集定义：</p>\n<p>并查集是一种可以动态维护若干个不重叠的集合，并支持<strong>合并</strong>和<strong>查询</strong>的树形数据结构。</p>\n<p>主要有以下两个基本操作：</p>\n<ul>\n<li>find，查询一个==元素==属于哪一个集合。</li>\n<li>merge，把两个集合合并为一个集合。</li>\n</ul>\n<blockquote>\n<p>ps: 元素的表现形式是多样的，但最终会抽象为数字</p>\n</blockquote>\n<h2 id=\"如何表示一个集合\">如何表示一个集合？</h2>\n<p>第一种：<strong>”代表元“</strong>法，每个集合选择一个固定的元素，树形结构中自然会想到树根作为该颗树的代表。</p>\n<p>第二种：定义一个数组<code>fa[]</code>表示某个元素的父亲节点，特别地，根节点的父亲节点是自身（需要初始化）。</p>\n<p><img src=\"并查集/1.jpg\" /></p>\n<h2 id=\"如何合并两个集合\">如何合并两个集合？</h2>\n<p>集合 a 的代表元是 a, <code>fa[a] = a</code>，集合 b 的代表元是\nb，<code>fa[b] = b</code></p>\n<p>现在让集合 a 的父亲变为\nb，使<code>fa[a] = b</code>，从而实现合并两个集合的操作。</p>\n<p><img src=\"并查集/2.jpg\" /></p>\n<p>这里我们具体问题具体分析，这里只是讲一下思想，方便了解。</p>\n<p>在合并时，我们<strong>按秩合并</strong>：==“秩” =\n树的深度或者集合的大小，把元素少的集合合并到元素多的集合上。==</p>\n<p><img src=\"并查集/4.jpg\" /></p>\n<p><img src=\"并查集/5.jpg\" /></p>\n<h2 id=\"路径压缩\">路径压缩</h2>\n<p>集合中如果要查寻节点4,5的集合代表元，要向上搜索很多次，效率低。所以需要考虑<em>路径压缩</em>，在查询<code>find</code>的过程中，让集合中的每一个元素的父亲都变为根节点。</p>\n<p><img src=\"并查集/3.jpg\" /></p>\n<p>例如我们按照DFS来路径压缩。</p>\n<p>不使用了路径压缩</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//找到 x 的根节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(x == fa[x])<span class=\"comment\">//本身是父亲节点</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x</span><br><span class=\"line\">  <span class=\"keyword\">else</span>\t<span class=\"comment\">//否则向上递归查找</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">find</span>(fa[x]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用路径压缩</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//找到 x 的根节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(x != fa[x])</span><br><span class=\"line\">    fa[x] = <span class=\"built_in\">find</span>(fa[x]);\t<span class=\"comment\">//返回的就是根节点</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> fa[x];\t<span class=\"comment\">//返回的就是当前这个集合的根节点</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"如何实现merge函数\">如何实现merge()函数</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">  x = <span class=\"built_in\">find</span>(x);\t<span class=\"comment\">//寻找 x 的祖先，在寻找的过程中路径压缩</span></span><br><span class=\"line\">  y = <span class=\"built_in\">find</span>(y);</span><br><span class=\"line\">  fa[x] = y;\t\t<span class=\"comment\">//将 x 的祖先变为 y,在一个集合中只有祖先能代表这个集合</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"初始化init\">初始化init()</h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"type\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">    fa[i] = i;\t<span class=\"comment\">//初始化每个节点的父亲节点为本身</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"例题\">例题</h1>\n<p>##<a href=\"https://www.luogu.com.cn/problem/P1551\">P1551 亲戚</a></p>\n<h3 id=\"题目背景\">题目背景</h3>\n<p>若某个家族人员过于庞大，要判断两个是否是亲戚，确实还很不容易，现在给出某个亲戚关系图，求任意给出的两个人是否具有亲戚关系。</p>\n<h3 id=\"题目描述\">题目描述</h3>\n<p>规定：x 和 y 是亲戚，y 和 z 是亲戚，那么 x 和 z 也是亲戚。如果 x，y\n是亲戚，那么 x 的亲戚都是 y的亲戚，y 的亲戚也都是 x 的亲戚。</p>\n<h3 id=\"输入格式\">输入格式</h3>\n<p>第一行：三个整数 n , m p，（n,m,p≤5000），分别表示有 n\n个人，m个亲戚关系，询问 p 对亲戚关系。</p>\n<p>以下 m 行：每行两个数 <span class=\"math display\">\\[M_i,M_j, 1 ≤\nM_i,M_j ≤ N  \\]</span>，表示 <span class=\"math display\">\\[M_i\\]</span>和\n<span class=\"math display\">\\[M_j\\]</span>具有亲戚关系。</p>\n<p>接下来 p行：每行两个数 <span\nclass=\"math display\">\\[p_i,p_j\\]</span>，询问 <span\nclass=\"math display\">\\[p_i\\]</span>和 <span\nclass=\"math display\">\\[p_j\\]</span>是否具有亲戚关系。</p>\n<h3 id=\"输出格式\">输出格式</h3>\n<p>p 行，每行一个 <code>Yes</code> 或 <code>No</code>。表示第\ni<em>i</em> 个询问的答案为“具有”或“不具有”亲戚关系。</p>\n<p><strong>输入 #1</strong></p>\n<blockquote>\n<p>6 5 3 1 2 1 5 3 4 5 2 1 3 1 4 2 3 5 6</p>\n</blockquote>\n<p><strong>输出 #1</strong></p>\n<blockquote>\n<p>Yes Yes No</p>\n</blockquote>\n<h4 id=\"思路\">思路：</h4>\n<p>典型的并查集，我们可以注意到描述中说的，x 和 y 是亲戚，y 和 z\n是亲戚，那么 x 和 z\n也是亲戚。这表示了具有传递性，要具体问题具体分析。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ll;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">double</span> ld;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; pii;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> vector&lt;<span class=\"type\">int</span>&gt; vi;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e5</span> + <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> fa[N];</span><br><span class=\"line\"><span class=\"type\">int</span> n,m,p;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//寻找 x 的根节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//判断 x 是不是根节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x != fa[x])&#123;</span><br><span class=\"line\">        <span class=\"comment\">//路径压缩</span></span><br><span class=\"line\">        fa[x] = <span class=\"built_in\">find</span>(fa[x]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fa[x];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//找到 x 和 y 的祖先</span></span><br><span class=\"line\">    x = <span class=\"built_in\">find</span>(x);</span><br><span class=\"line\">    y = <span class=\"built_in\">find</span>(y);</span><br><span class=\"line\">    <span class=\"comment\">//这里可以进一步优化，按秩合并</span></span><br><span class=\"line\">    fa[x] = y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">        fa[i] = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; p;</span><br><span class=\"line\">    <span class=\"built_in\">init</span>();</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(m--)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> x, y;</span><br><span class=\"line\">        <span class=\"comment\">//x 和 y 是亲戚</span></span><br><span class=\"line\">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class=\"line\">        <span class=\"built_in\">merge</span>(x,y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p--)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> x, y;</span><br><span class=\"line\">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class=\"line\">        <span class=\"comment\">//判断 x 和 y 的根节点是否相同</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">find</span>(x) == <span class=\"built_in\">find</span>(y))&#123;</span><br><span class=\"line\">            cout &lt;&lt; <span class=\"string\">&quot;Yes\\n&quot;</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            cout &lt;&lt;<span class=\"string\">&quot;No\\n&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"被围绕的区域\"><a\nhref=\"https://leetcode-cn.com/problems/surrounded-regions/\">130.\n被围绕的区域</a></h2>\n<p>给你一个 <code>m x n</code> 的矩阵 <code>board</code> ，由若干字符\n<code>'X'</code> 和 <code>'O'</code> ，找到所有被 <code>'X'</code>\n围绕的区域，并将这些区域里所有的 <code>'O'</code> 用 <code>'X'</code>\n填充。</p>\n<p>###示例：</p>\n<p><img src=\"并查集/6.jpg\" /></p>\n<blockquote>\n<p>输入：board =\n[[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]\n输出：[[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]\n解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 'O'\n都不会被填充为 'X'。 任何不在边界上，或不与边界上的 'O' 相连的 'O'\n最终都会被填充为\n'X'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</p>\n</blockquote>\n<h4 id=\"思路-1\">思路：</h4>\n<p>常规方法就是DFS，从边界开始搜，和前面的岛屿问题类似。具体可以看一下写的岛屿部分。</p>\n<p>这里直接给出代码，我们具体将并查集做法。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> m = board.<span class=\"built_in\">size</span>(), n = board[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(m == <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//遍历上边</span></span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(board, <span class=\"number\">0</span>, i);</span><br><span class=\"line\">            <span class=\"comment\">//遍历下边</span></span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(board, m - <span class=\"number\">1</span>, i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//遍历左边</span></span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(board, i, <span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"comment\">//遍历右边</span></span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(board, i, n - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//遍历整个区域，如果为 A 则表示没有被包围，为 O 则表示被包围</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; n; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(board[i][j] == <span class=\"string\">&#x27;A&#x27;</span>)&#123;</span><br><span class=\"line\">                    board[i][j] = <span class=\"string\">&#x27;O&#x27;</span>;</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(board[i][j] == <span class=\"string\">&#x27;O&#x27;</span>)&#123;</span><br><span class=\"line\">                    board[i][j] = <span class=\"string\">&#x27;X&#x27;</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">char</span>&gt; &gt;&amp; board, <span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> m = board.<span class=\"built_in\">size</span>(), n = board[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x &lt; <span class=\"number\">0</span> || x &gt;= m || y &lt; <span class=\"number\">0</span> || y &gt;= n) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(board[x][y] != <span class=\"string\">&#x27;O&#x27;</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"comment\">//变为A</span></span><br><span class=\"line\">        board[x][y] = <span class=\"string\">&#x27;A&#x27;</span>;</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(board, x + <span class=\"number\">1</span>, y);</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(board, x - <span class=\"number\">1</span>, y);</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(board, x, y + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(board, x, y - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>并查集就是定义一个节点，把边界的<code>O</code>和这个根节点连通，</p>\n<p><img src=\"并查集/7.jpg\" /></p>\n<p>然后再遍历整个 <code>board</code>，那些和 <code>dummy</code> 不连通的\n<code>O</code> 就是被围绕的区域，需要被替换。</p>\n<p>这里需要用到把二维数组映射为一维数组，<code>(x,y) = x * n + y</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> m, n;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; fa;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"type\">int</span> len)</span></span>&#123;</span><br><span class=\"line\">        fa.<span class=\"built_in\">resize</span>(len);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; len; i++)&#123;</span><br><span class=\"line\">            fa[i] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x != fa[x])</span><br><span class=\"line\">            fa[x] = <span class=\"built_in\">find</span>(fa[x]);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fa[x];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">to_union</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">        x = <span class=\"built_in\">find</span>(x);</span><br><span class=\"line\">        y = <span class=\"built_in\">find</span>(y);</span><br><span class=\"line\">        fa[x] = y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">char</span>&gt; &gt;&amp; board)</span> </span>&#123;</span><br><span class=\"line\">        m = board.<span class=\"built_in\">size</span>(), n = board[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"built_in\">init</span>(n * m + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">//定义根节点</span></span><br><span class=\"line\">        <span class=\"type\">int</span> dummy = m * n;</span><br><span class=\"line\">        <span class=\"comment\">//将首列和末列的 O 与 dummy 连通</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(board[i][<span class=\"number\">0</span>] == <span class=\"string\">&#x27;O&#x27;</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//连通,把二维映射为一维</span></span><br><span class=\"line\">                <span class=\"built_in\">to_union</span>(i * n, dummy);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(board[i][n - <span class=\"number\">1</span>] == <span class=\"string\">&#x27;O&#x27;</span>)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">to_union</span>(i * n + n - <span class=\"number\">1</span>, dummy);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//将首行和末行的 O 与 dummy 连通</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(board[<span class=\"number\">0</span>][i] == <span class=\"string\">&#x27;O&#x27;</span>)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">to_union</span>(i, dummy);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(board[m - <span class=\"number\">1</span>][i] == <span class=\"string\">&#x27;O&#x27;</span>)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">to_union</span>(n * (m - <span class=\"number\">1</span>) + i, dummy);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//搜索上下左右的 O</span></span><br><span class=\"line\">        <span class=\"type\">int</span> dx[<span class=\"number\">4</span>] = &#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\">        <span class=\"type\">int</span> dy[<span class=\"number\">4</span>] = &#123;<span class=\"number\">1</span>,<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; m - <span class=\"number\">1</span>; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt; n - <span class=\"number\">1</span>; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(board[i][j] == <span class=\"string\">&#x27;O&#x27;</span>)&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//将此 O 与上下左右的 O 连通</span></span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k = <span class=\"number\">0</span>; k &lt; <span class=\"number\">4</span>; k++)&#123;</span><br><span class=\"line\">                        <span class=\"type\">int</span> x = i + dx[k];</span><br><span class=\"line\">                        <span class=\"type\">int</span> y = j + dy[k];</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(board[x][y] == <span class=\"string\">&#x27;O&#x27;</span>)&#123;</span><br><span class=\"line\">                            <span class=\"built_in\">to_union</span>(x * n + y, i * n + j);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//所有不和 dummy 连通的 O 都要被替换</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; m - <span class=\"number\">1</span>; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt; n - <span class=\"number\">1</span>; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"built_in\">find</span>(dummy) != <span class=\"built_in\">find</span>(i * n + j))&#123;</span><br><span class=\"line\">                    board[i][j] = <span class=\"string\">&#x27;X&#x27;</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["并查集"],"tags":["图","并查集"]},{"title":"快速幂","url":"/2019/04/17/%E5%BF%AB%E9%80%9F%E5%B9%82/","content":"<h2 id=\"前言\"><code>前言</code></h2>\n<blockquote>\n<p>在算法程序设计竞赛中，我们竞赛选手会经常碰到对某个数N进行求大数次幂并对1e9+7取模的运算的题目，一方面求大数次幂是一个时间复杂度很高的运算（容易超时），另一方面对1e9+7取模，暗示着结果是连long\nlong都存不下（同余定理），所以这时候快速幂取模算法就派上用场了。</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"同余定理\">同余定理</h2>\n<p><strong>这里我们不证明了</strong> <span class=\"math display\">\\[\n(a+b)\\%c=(a\\%c + b\\%c)\\%c\n\\]</span></p>\n<p><span class=\"math display\">\\[\n(a*b)\\%c = (a \\% c)*(b \\% c) \\%c\n\\]</span></p>\n<p><span class=\"math display\">\\[\n(a^b)\\%c = (a\\%c)^b \\%c\n\\]</span></p>\n<h2 id=\"快速幂取模\">快速幂取模</h2>\n<h3 id=\"原理\">原理</h3>\n<p>首先假设我们有 <span class=\"math display\">\\[\na^b\\%c\n\\]</span>\n这里(1&lt;=a,b&lt;=1e5,c=1e9+7),要求算出它的结果，如果我们按照正常的手段去算的话，结果肯定会超时或者溢出，所以我们可以先把式子展开：</p>\n<ol type=\"1\">\n<li>把b转换为二进制串</li>\n<li>根据同余定理算 <strong>这里我们用一个例子来说明，已知</strong></li>\n</ol>\n<p><span class=\"math display\">\\[\n2^{10}=1024, 10_{(10)} = 1010_{(2)}\n\\]</span></p>\n<p><span class=\"math display\">\\[\n2^{(10)}=2^{0*2^0+1*2^1+0*2^2+1*2^3}\n\\]</span></p>\n<p><span class=\"math display\">\\[\n2^{(10)}=2^{0*2^0}*2^{1*2^1}*2^{0*2^2}*2*{1*2^3}\n\\]</span></p>\n<p><span class=\"math display\">\\[\n2^{(10)}=1*2^{1*2^1}*1*2^{1*2^3}\n\\]</span></p>\n<p><span class=\"math display\">\\[\n2^{(10)}=1*2^2*1*2^8\n\\]</span></p>\n<blockquote>\n<p>观察第二条推导式可知从左往右第二项数起每一项的指数都是前一项的平方倍，所以在用代码实现的时候，我们对指数（二进制）按位平方略过为指数为0的项，大大降低了时间复杂度（0较多的前提下）。</p>\n</blockquote>\n<h3 id=\"代码如下\">代码如下</h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">long</span> <span class=\"type\">long</span> <span class=\"title\">quick_mod</span><span class=\"params\">(<span class=\"type\">long</span> <span class=\"type\">long</span> a,<span class=\"type\">long</span> <span class=\"type\">long</span> b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"type\">long</span> ans = <span class=\"number\">1</span>;</span><br><span class=\"line\">    a %= Mod; <span class=\"comment\">//对刚进来的a进行取模运算，避免后面第一次求平方运算溢出</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(b)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(b&amp;<span class=\"number\">1</span>) <span class=\"comment\">//对二进制下的 b 进行按位与1运算，求二进制下 b 的最低位是否为1</span></span><br><span class=\"line\">            ans = ans * a % Mod; <span class=\"comment\">//对结果进行保存</span></span><br><span class=\"line\">        b&gt;&gt;=<span class=\"number\">1</span>; <span class=\"comment\">//二进制下的 b 右移一位，相当于十进制下的 b 除以2</span></span><br><span class=\"line\">        a = a * a % Mod; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans % Mod;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://www.luogu.org/problemnew/show/P1226\">p1226快速幂</a>\nb,p,k,k为长整型 输出b^p mod k = s</p>\n<blockquote>\n<p>输入 2 10 9 输出 2^10 mod 9=7</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;set&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\">ll b,p,k;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ll <span class=\"title\">quick_mod</span><span class=\"params\">(ll x,ll y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ll ans=<span class=\"number\">1</span>;</span><br><span class=\"line\">    x %= k;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(y)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(y&amp;<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            ans = ans*x%k;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        y&gt;&gt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">        x=x*x%k;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans%k;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;b&gt;&gt;p&gt;&gt;k;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%lld^%lld mod %lld=%lld\\n&quot;</span>,b,p,k,<span class=\"built_in\">quick_mod</span>(b, p));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["算法","快速幂"],"tags":["快速幂取模"]},{"title":"快速排序和归并排序","url":"/2019/04/06/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/","content":"<p>快速排序之所比较快，因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。因此总的比较和交换次数就少了，速度自然就提高了。当然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的都是O(N2)，它的平均时间复杂度为O(NlogN)。其实快速排序是基于一种叫做“二分”的思想。我们后面还会遇到“二分”思想。</p>\n<p>知道快排的思想后，我们可以看下这道题：</p>\n<span id=\"more\"></span>\n<p><a\nhref=\"https://www.luogu.org/problemnew/show/P1309\">我是链接</a></p>\n<h1 id=\"题目背景\">题目背景</h1>\n<p>在双人对决的竞技性比赛，如乒乓球、羽毛球、国际象棋中，最常见的赛制是淘汰赛和循环赛。前者的特点是比赛场数少，每场都紧张刺激，但偶然性较高。后者的特点是较为公平，偶然性较低，但比赛过程往往十分冗长。</p>\n<p>本题中介绍的瑞士轮赛制，因最早使用于1895年在瑞士举办的国际象棋比赛而得名。它可以看作是淘汰赛与循环赛的折中，既保证了比赛的稳定性，又能使赛程不至于过长。</p>\n<h2 id=\"题目描述\">题目描述</h2>\n<p>2×N名编号为 1∼2N 的选手共进行R\n轮比赛。每轮比赛开始前，以及所有比赛结束后，都会按照总分从高到低对选手进行一次排名。选手的总分为第一轮开始前的初始分数加上已参加过的所有比赛的得分和。总分相同的，约定编号较小的选手排名靠前。</p>\n<p>每轮比赛的对阵安排与该轮比赛开始前的排名有关：第1 名和第2 名、第 3\n名和第 4名、……、第2K−1名和第2K名、……\n、第2N−1名和第2N名，各进行一场比赛。每场比赛胜者得1分，负者得\n0分。也就是说除了首轮以外，其它轮比赛的安排均不能事先确定，而是要取决于选手在之前比赛中的表现。</p>\n<p>现给定每个选手的初始分数及其实力值，试计算在R 轮比赛过后，排名第Q\n的选手编号是多少。我们假设选手的实力值两两不同，且每场比赛中实力值较高的总能获胜。</p>\n<h3 id=\"输入输出格式\">输入输出格式</h3>\n<p>输入格式：</p>\n<p>第一行是三个正整数N,R,Q,每两个数之间用一个空格隔开，表示有\n2×N名选手、<em>R</em> 轮比赛，以及我们关心的名次 Q。</p>\n<p>第二行是2×N\n个非负整数s1,s2,…,s2N，每两个数之间用一个空格隔开，其中si表示编号为i\n的选手的初始分数。 第三行是2×N\n个正整数w1,w2,…,w2N，每两个数之间用一个空格隔开，其中 wi 表示编号为i\n的选手的实力值。</p>\n<p>输出格式：</p>\n<p>一个整数，即R轮比赛结束后，排名第Q 的选手的编号。</p>\n<h4 id=\"输入样例\">输入样例：</h4>\n<blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">2 4 2 </span><br><span class=\"line\">7 6 6 7 </span><br><span class=\"line\">10 5 20 15</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h4 id=\"输出样例\">输出样例:</h4>\n<blockquote>\n<p>1</p>\n</blockquote>\n<p>【数据范围】</p>\n<p>对于30%的数据，1≤N≤100；</p>\n<p>对于50%的数据，1≤N≤10,000；</p>\n<p>对于100%的数据，1≤N≤100,000,1≤R≤50,1≤Q≤2N,0≤s1,s2,…,s2N≤10<sup>8,1≤w1,w2,…,w2N≤10</sup>8.</p>\n<p>noip2011普及组第3题。</p>\n<h5 id=\"解题思路\">解题思路:</h5>\n<p>刚开始没注意看范围，以为直接快排就能过，但是TLE了。</p>\n<p>后面看了下，发现赢的基本上位置没有发生变化，当然输的相对位置也没有发生变化，</p>\n<p>这不就是归并排序吗？</p>\n<figure>\n<img src=\"快速排序和归并排序/sort.PNG\" alt=\"归并排序\" />\n<figcaption aria-hidden=\"true\">归并排序</figcaption>\n</figure>\n<p>下面先附上TLE的代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">xs</span>&#123;</span><br><span class=\"line\">    ll s,w,id;</span><br><span class=\"line\">&#125;p[<span class=\"number\">200000</span>+<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"type\">const</span> xs &amp;a, <span class=\"type\">const</span> xs &amp;b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a.s==b.s) <span class=\"keyword\">return</span> a.id&lt;b.id;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.s&gt;b.s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ll n,r,q;</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; r &gt;&gt; q;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(ll i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">2</span>*n;i++)&#123;</span><br><span class=\"line\">        p[i].id = i+<span class=\"number\">1</span>;</span><br><span class=\"line\">        cin&gt;&gt;p[i].s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ll i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">2</span>*n;i++)&#123;</span><br><span class=\"line\">        cin &gt;&gt; p[i].w;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(r--)&#123;</span><br><span class=\"line\">        ll j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(j=<span class=\"number\">0</span>;j&lt;<span class=\"number\">2</span>*n;j=j+<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p[j].w&gt;p[j+<span class=\"number\">1</span>].w) p[j].s+=<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> p[j+<span class=\"number\">1</span>].s+=<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(p,p+<span class=\"number\">2</span>*n,cmp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; p[q<span class=\"number\">-1</span>].id &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>下面是归并排序的算法</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\">ll n,r,q;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">xs</span>&#123;</span><br><span class=\"line\">    ll id;<span class=\"comment\">//编号</span></span><br><span class=\"line\">    ll s;<span class=\"comment\">//总分</span></span><br><span class=\"line\">    ll w;<span class=\"comment\">//能力</span></span><br><span class=\"line\">&#125; p[<span class=\"number\">200010</span>], a[<span class=\"number\">200010</span>],b[<span class=\"number\">200010</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"type\">const</span> xs &amp;a, <span class=\"type\">const</span> xs &amp;b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (a.s==b.s) <span class=\"keyword\">return</span> a.id&lt;b.id;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.s&gt;b.s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin &gt;&gt; n&gt;&gt;r&gt;&gt;q;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=<span class=\"number\">2</span>*n; i++)&#123;</span><br><span class=\"line\">        cin&gt;&gt;p[i].s;</span><br><span class=\"line\">        p[i].id = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">2</span>*n;i++)&#123;</span><br><span class=\"line\">        cin&gt;&gt;p[i].w;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(p+<span class=\"number\">1</span>,p+<span class=\"number\">2</span>*n+<span class=\"number\">1</span>,cmp);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=r;i++)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> ai=<span class=\"number\">0</span>,bi=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=<span class=\"number\">2</span>*n;j = j+<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(p[j].w&gt;p[j+<span class=\"number\">1</span>].w)&#123;</span><br><span class=\"line\">                p[j].s++;</span><br><span class=\"line\">                b[++bi]=p[j+<span class=\"number\">1</span>];<span class=\"comment\">//输的人进b</span></span><br><span class=\"line\">                a[++ai]=p[j];<span class=\"comment\">//赢的人</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                p[j+<span class=\"number\">1</span>].s++;</span><br><span class=\"line\">                b[++bi]=p[j];</span><br><span class=\"line\">                a[++ai]=p[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">merge</span>(a+<span class=\"number\">1</span>,a+n+<span class=\"number\">1</span>,b+<span class=\"number\">1</span>,b+n+<span class=\"number\">1</span>,p+<span class=\"number\">1</span>,cmp);<span class=\"comment\">//归并排序</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; p[q].id &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["排序"],"tags":["排序"]},{"title":"剑指offer","url":"/2022/02/24/%E5%89%91%E6%8C%87offer/","content":"<p>剑指<code>offer</code></p>\n<span id=\"more\"></span>\n<h4 id=\"从尾到头打印链表\">06.从尾到头打印链表</h4>\n<p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>\n<p><strong>示例：</strong></p>\n<blockquote>\n<p>输入：head= 【1，3，2】</p>\n<p>输出：[2,3,1]</p>\n</blockquote>\n<p><strong>方法一：遍历翻转</strong></p>\n<p>借助栈的后进先出特性来实现</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">reversePrint</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt;res;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(head)&#123;</span><br><span class=\"line\">            res.<span class=\"built_in\">push_back</span>(head-&gt;val);</span><br><span class=\"line\">            head = head-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">reverse</span>(res.<span class=\"built_in\">rbegin</span>(),res.<span class=\"built_in\">rend</span>());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>方法二：递归法</strong></p>\n<p>先走到链表末端，回溯时依次将节点值加入列表，这样就可以实现链表的倒叙输出</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt;res;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">reversePrint</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(head-&gt;next!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">reversePrint</span>(head-&gt;next);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res.<span class=\"built_in\">push_back</span>(head-&gt;val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"重建二叉树\">07. 重建二叉树</h4>\n<p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</p>\n<p>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>\n<p><strong>示例：</strong></p>\n<blockquote>\n<p>输入：preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]</p>\n<p>输出：[3,9,20,null,null,15,7]</p>\n</blockquote>\n<p><strong>解题思路：</strong></p>\n<p>前序遍历性质： 节点按照 [ 根节点 | 左子树 | 右子树 ] 排序。\n中序遍历性质： 节点按照 [ 左子树 | 根节点 | 右子树 ] 排序。</p>\n<p>以题目示例为例：</p>\n<p>前序遍历划分 [ 3 | 9 | 20 15 7 ] 中序遍历划分 [ 9 | 3 | 15 20 7 ]\n根据以上性质，可得出以下推论：</p>\n<p>前序遍历的首元素 为 树的根节点 node 的值。 在中序遍历中搜索根节点\nnode 的索引 ，可将 中序遍历 划分为 [ 左子树 | 根节点 | 右子树 ] 。\n根据中序遍历中的左（右）子树的节点数量，可将 前序遍历 划分为 [ 根节点 |\n左子树 | 右子树 ] 。</p>\n<p>通过以上三步，可确定 三个节点\n：1.树的根节点、2.左子树根节点、3.右子树根节点。</p>\n<p>根据「分治算法」思想，对于树的左、右子树，仍可复用以上方法划分子树的左右子树。</p>\n<p><strong>分治算法解析：</strong></p>\n<ul>\n<li><p>递推参数： 根节点在前序遍历的索引 root 、子树在中序遍历的左边界\nleft 、子树在中序遍历的右边界 right ；</p></li>\n<li><p>终止条件： 当 left &gt; right ，代表已经越过叶节点，此时返回 null\n；</p></li>\n<li><p>递推工作： 1，建立根节点 node ： 节点值为 preorder[root] ；\n2，划分左右子树： 查找根节点在中序遍历 inorder 中的索引 i ；</p>\n<blockquote>\n<p>为了提升效率，本文使用哈希表 dic\n存储中序遍历的值与索引的映射，查找操作的时间复杂度为O(1) ；</p>\n</blockquote>\n<p>构建左右子树： 开启左右子树递归； 根节点索引 中序遍历左边界\n中序遍历右边界</p>\n<p>左子树 root + 1 left i - 1 右子树 i - left + root + 1 i + 1 right</p>\n<blockquote>\n<p>TIPS： i - left + root + 1含义为 根节点索引 + 左子树长度 + 1</p>\n</blockquote></li>\n</ul>\n<p>返回值： 回溯返回 node ，作为上一层递归中根节点的左 / 右子节点；</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    unordered_map&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt;mp;</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">buildTree</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; preorder, vector&lt;<span class=\"type\">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//将中序序列用哈希表存储，便于查找根节点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;inorder.<span class=\"built_in\">size</span>();i++)&#123;</span><br><span class=\"line\">            mp[inorder[i]] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//传入参数：前序、中序、前序序列根节点、中序序列左边界、中序序列右边界</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">recur</span>(preorder,inorder,<span class=\"number\">0</span>,<span class=\"number\">0</span>,inorder.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">recur</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; preorder,vector&lt;<span class=\"type\">int</span>&gt;&amp; inorder,<span class=\"type\">int</span> pre_root,<span class=\"type\">int</span> in_left,<span class=\"type\">int</span> in_right)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(in_left &gt; in_right) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"comment\">//建立新节点</span></span><br><span class=\"line\">        TreeNode* root = <span class=\"keyword\">new</span> <span class=\"built_in\">TreeNode</span>(preorder[pre_root]);</span><br><span class=\"line\">        <span class=\"comment\">//根节点在中序序列中的位置，用于划分左右子树的边界</span></span><br><span class=\"line\">        <span class=\"type\">int</span> in_root = mp[preorder[pre_root]];</span><br><span class=\"line\">        <span class=\"comment\">//左子树在前序中的根节点位于：pre_root+1,左子树在中序中的边界：[int_left,in_root-1]</span></span><br><span class=\"line\">        root-&gt;left = <span class=\"built_in\">recur</span>(preorder,inorder,pre_root+<span class=\"number\">1</span>,in_left,in_root<span class=\"number\">-1</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 右子树在前序中的根节点位于：根节点+左子树长度+1 = pre_root+in_root-in_left+1</span></span><br><span class=\"line\">        <span class=\"comment\">// 右子树在中序中的边界：[in_root+1,in_right]</span></span><br><span class=\"line\">        root-&gt;right = <span class=\"built_in\">recur</span>(preorder,inorder,pre_root+in_root-in_left+<span class=\"number\">1</span>,in_root+<span class=\"number\">1</span>,in_right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>####<a\nhref=\"https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/\">09.\n用两个栈实现队列</a></p>\n<p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail\n和 deleteHead\n，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead\n操作返回 -1 )</p>\n<p><strong>示例1:</strong></p>\n<blockquote>\n<p>输入：</p>\n<p>[\"CQueue\",\"appendTail\",\"deleteHead\",\"deleteHead\"]</p>\n<p>[[],[3],[],[]]</p>\n<p>输出：</p>\n<p>[null,null,3,-1]</p>\n</blockquote>\n<p><strong>题目理解：</strong></p>\n<p>[\"CQueue\",\"appendTail\",\"deleteHead\",\"deleteHead\"]\n这里是要执行的方法，从左到右执行</p>\n<p>[[],[3],[],[]]对应上面的方法，是上面方法的参数。CQueue和deleteHead方法不需要指定数字，只有添加才需要指定数字</p>\n<p>1.创建队列，返回值为null</p>\n<p>2.将3压入栈，返回值为null</p>\n<p>3.将栈底的元素删除，也就是消息队列中先进来的元素，所以是deleteHead，返回该元素的数值，所以为3</p>\n<p>4.继续删除栈底的元素，但是没有元素了，所以返回-1</p>\n<p>所以就有了下面的输出 输出：[null,null,3,-1]</p>\n<p><strong>解题思路：</strong></p>\n<p>双栈可以实现列表倒序</p>\n<p>1，加入队尾appenTail()函数：将数字val加入栈A</p>\n<p>2，删除队首deleteHead()函数：有以下三种情况</p>\n<p>​\n1）当栈B不为空时：B中仍有已完成倒序的元素，因此直接返回B的栈顶元素</p>\n<p>​ 2）否则，当A为空时：即两个栈都为空，无元素，因此返回-1</p>\n<p>​\n3）否则，将栈A元素全部转移至栈B中，实现元素倒序，并返回栈B的栈顶元素</p>\n<p>时间复杂度：appenTail()为O(1);deleteHead()在N次队首元素删除操作中总共需完成N个元素的倒序。</p>\n<p>空间复杂度：最差情况下，栈A和栈B共保存N个元素</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CQueue</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    stack&lt;<span class=\"type\">int</span>&gt; A,B;</span><br><span class=\"line\">    <span class=\"built_in\">CQueue</span>() &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">appendTail</span><span class=\"params\">(<span class=\"type\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\">        A.<span class=\"built_in\">push</span>(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">deleteHead</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//栈B不空</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!B.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> res = B.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">            B.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//B空A空</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(A.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//B空A不空，将A中元素倒序到B中</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!A.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">            B.<span class=\"built_in\">push</span>(A.<span class=\"built_in\">top</span>());</span><br><span class=\"line\">            A.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> ans = B.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        B.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>####<a\nhref=\"https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/\">10-\nI. 斐波那契数列</a></p>\n<p>写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第\n<code>n</code> 项（即 <code>F(N)</code>）。斐波那契数列的定义如下：</p>\n<blockquote>\n<p>F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.</p>\n</blockquote>\n<p>斐波那契数列由 0 和 1\n开始，之后的斐波那契数就是由之前的两数相加而得出。</p>\n<p>答案需要取模\n1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>\n<p><strong>示例：</strong></p>\n<blockquote>\n<p>输入：n=2</p>\n<p>输出：1</p>\n</blockquote>\n<p><strong>思路：</strong></p>\n<p>方法一：递归法</p>\n<p>​\n原理：把f(n)问题拆分为f(n-1)和f(n-2)两个子问题的计算，以f(0),f(1)为终止条件。</p>\n<p>​ 缺点：大量重复的递归计算</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">fib</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n==<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n==<span class=\"number\">1</span> || n==<span class=\"number\">2</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"built_in\">fib</span>(n<span class=\"number\">-1</span>)+<span class=\"built_in\">fib</span>(n<span class=\"number\">-2</span>))%<span class=\"number\">1000000007</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>方法二：记忆化递归</p>\n<p>​\n原理：在递归法的基础上，新建一个长度为n的数组，用于递归时存储f(0)至f(n)的数字值，重复遇到某数字时则直接从数组取用，避免重复的递归计算。</p>\n<p>​ 缺点：需要使用O(N)的额外空间。</p>\n<p>方法三：动态规划</p>\n<p>​ 原理：以斐波那契数列性质f(n+1)=f(n)+f(n-1)为转移方程。</p>\n<p>动态规划解析：</p>\n<ul>\n<li>状态定义：设dp为一维数组，其中dp[i]的值代表斐波那契数列第几个数字。</li>\n<li>转移方程：dp[i+1] = dp[i] + dp[i-1]</li>\n<li>初始状态：dp[0]=0,dp[1]=1</li>\n<li>返回值：dp[n],即斐波那契数列的第n个数字</li>\n</ul>\n<p>空间复杂度分析：</p>\n<blockquote>\n<p>若新建长度为 n 的 dp 列表，则空间复杂度为 O(N) 。</p>\n</blockquote>\n<ul>\n<li>由于<code>dp</code>列表第<code>i</code>项只与第<code>i-1</code>和第<code>i-2</code>有关，因此只需要初始化三个整形变量<code>sum</code>、<code>a</code>、<code>b</code>，利用辅助<code>sum</code>使a,b两数字交替前进即可。</li>\n<li>节省了dp列表空间，因此空间复杂度降至O(1)。</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">fib</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n==<span class=\"number\">0</span> || n==<span class=\"number\">1</span>) <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">        <span class=\"type\">int</span> a = <span class=\"number\">0</span>,b=<span class=\"number\">1</span>,sum=a+b;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">2</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">            a = b;</span><br><span class=\"line\">            b =sum;</span><br><span class=\"line\">            sum = (a+b)%<span class=\"number\">1000000007</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"ii.-青蛙跳台阶问题\"><a\nhref=\"https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/\">10-\nII. 青蛙跳台阶问题</a></h4>\n<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n\n级的台阶总共有多少种跳法。</p>\n<p>答案需要取模\n1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>\n<p><strong>示例：</strong></p>\n<blockquote>\n<p>输入：n=2</p>\n<p>输出：2</p>\n<p>输入：n=7</p>\n<p>输出：21</p>\n<p>输入：n=0</p>\n<p>输出：0</p>\n</blockquote>\n<p><strong>思路：</strong></p>\n<p>也是斐波那契数列的变形，到达第n阶，则前面一定是n-1或者n-2,也就是f(n)=f(n-1)+f(n-2)</p>\n<p>方法一：时间复杂度为O(n)，空间复杂度为O(n)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">numWays</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n==<span class=\"number\">0</span> || n==<span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> dp[n+<span class=\"number\">1</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">1</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\">        dp[<span class=\"number\">2</span>]=<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">3</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">            dp[i] = (dp[i<span class=\"number\">-1</span>]+dp[i<span class=\"number\">-2</span>])%<span class=\"number\">1000000007</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>复杂度为O(1)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">numWays</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n==<span class=\"number\">0</span> || n==<span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> a=<span class=\"number\">1</span>,b=<span class=\"number\">2</span>,sum;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">3</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">            sum = (a+b)%<span class=\"number\">1000000007</span>;</span><br><span class=\"line\">            a=b;</span><br><span class=\"line\">            b=sum;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"旋转数组的最小数字\"><a\nhref=\"https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/\">11.\n旋转数组的最小数字</a></h4>\n<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p>\n<p>给你一个可能存在 重复 元素值的数组 numbers\n，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组\n[3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为1。</p>\n<p><strong>示例：</strong></p>\n<blockquote>\n<p>输入：[3,4,5,1,2]</p>\n<p>输出：1</p>\n</blockquote>\n<p><strong>思路：</strong></p>\n<p><strong>方法一：排序直接输出</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">minArray</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(numbers.<span class=\"built_in\">size</span>()&lt;=<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(numbers.<span class=\"built_in\">begin</span>(),numbers.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> numbers[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>方法二：二分查找</strong></p>\n<p>算法流程：</p>\n<p>1，初始化：声明i,j双指针分别指向nums数组左右两端</p>\n<p>2，循环二分：设m=(i+j)/2为每次二分的中点，可分为以下三种情况：</p>\n<ul>\n<li><p>当nums[m]&gt;nums[j]时：m一定在左排序数组中，即旋转点x一定在[m+1,j]，因此执行i=m+1;</p></li>\n<li><p>当nums[m]&lt;nums[j]时：m一定在右排序数组中，即旋转点x一定在[i,m]，因此执行j=m;</p></li>\n<li><p>当nums[m]=nums[j]时：无法判断m在哪个排序数组中，即无法判断旋转点x在[i,m]还是[m+1,j]中。\n解决方案：直接遍历</p></li>\n</ul>\n<p>3，返回值：当j=j时跳出循环，并返回旋转点的值nums[i]即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">minArray</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> i=<span class=\"number\">0</span>,j=numbers.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i&lt;j)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> m=(i+j)/<span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(numbers[m]&gt;numbers[j]) i=m+<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(numbers[m]&lt;numbers[j]) j=m;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> x =i;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k=i+<span class=\"number\">1</span>;k&lt;j;k++)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(numbers[k]&lt;numbers[x]) x=k;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> numbers[x];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> numbers[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"矩阵中的路径\"><a\nhref=\"https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/\">12.\n矩阵中的路径</a></h4>\n<p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word\n存在于网格中，返回 true ；否则，返回 false 。</p>\n<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>\n<p>例如，在下面的 3×4 的矩阵中包含单词\n\"ABCCED\"（单词中的字母已标出）</p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/11/04/word2.jpg\" alt=\"img\" style=\"zoom:50%;\" /></p>\n<h5 id=\"示例\">示例：</h5>\n<blockquote>\n<p>输入：board =\n[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word =\n\"ABCCED\"</p>\n<p>输出：true</p>\n</blockquote>\n<h5 id=\"思路dfs\">思路：dfs</h5>\n<p>1，递归参数：当前元素在矩阵中的行列索引i和j,当前目标字符在word中的索引k。</p>\n<p>2,递归终止条件：</p>\n<p>​ 当行列索引越界或当前元素与目标字符不同</p>\n<p>3，递推工作：</p>\n<p>​\n1，标记当前单元格，将board[i][j]修改为空字符，代表已经访问过，防止之后重复访问</p>\n<p>​\n2，搜索下一单元格，计算当前元素的上下左右，看是否是word的相连字符，不是就放回false</p>\n<p>​ 3，还原当前矩阵元素</p>\n<p>4，返回值：返回布尔量res,代表是否搜索到目标字符串</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">exist</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">char</span>&gt; &gt;&amp; board, string word)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> rows = board.<span class=\"built_in\">size</span>(),cols = board[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;rows;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;cols;j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(<span class=\"built_in\">dfs</span>(board,word,i,j,<span class=\"number\">0</span>)) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">char</span>&gt; &gt;&amp;board,string word,<span class=\"type\">int</span> i,<span class=\"type\">int</span> j,<span class=\"type\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//递归终止条件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i&gt;=board.<span class=\"built_in\">size</span>() || i &lt; <span class=\"number\">0</span> || j&gt;=board[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>() || j&lt;<span class=\"number\">0</span> || board[i][j] != word[k]) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">//递归</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(k==word.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">//保证不走回头路</span></span><br><span class=\"line\">        board[i][j] =<span class=\"string\">&#x27;/0&#x27;</span>;</span><br><span class=\"line\">        <span class=\"type\">bool</span> res = <span class=\"built_in\">dfs</span>(board,word,i+<span class=\"number\">1</span>,j,k+<span class=\"number\">1</span>) || <span class=\"built_in\">dfs</span>(board,word,i<span class=\"number\">-1</span>,j,k+<span class=\"number\">1</span>) || <span class=\"built_in\">dfs</span>(board,word,i,j+<span class=\"number\">1</span>,k+<span class=\"number\">1</span>) || <span class=\"built_in\">dfs</span>(board,word,i,j<span class=\"number\">-1</span>,k+<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">//还原，只代表本次搜索已经访问过</span></span><br><span class=\"line\">        board[i][j] = word[k];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>####<a\nhref=\"https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/\">13.\n机器人的运动范围</a></p>\n<p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1]\n。一个机器人从坐标 [0, 0]\n的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格\n[35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35,\n38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>\n<h5 id=\"示例-1\">示例：</h5>\n<blockquote>\n<p>输入：m=2,n=3,k=1</p>\n<p>输出：3</p>\n<p>输入：m=3,n=1,k=0</p>\n<p>输出：0</p>\n</blockquote>\n<h5 id=\"思路\">思路：</h5>\n<h6 id=\"方法一深度优先遍历dfs\">方法一：深度优先遍历DFS</h6>\n<p>DFS通过递归，先朝一个方向搜到底，再回溯至上一个节点，沿另一个方向搜索。</p>\n<p>剪枝：\n在搜索中，遇到数位和超出目标值、此元素已访问，则应立即返回，称之为\n可行性剪枝 。</p>\n<p><strong>算法解析：</strong></p>\n<p><strong>递归参数：</strong>\n当前元素在矩阵中的行列索引i和j,两者的数位和si,sj;</p>\n<p><strong>终止条件：</strong>\n当行列索引越界或数位和超出目标值K或当前元素已经访问过，返回0，代表计入不可达;</p>\n<p><strong>递推工作：</strong></p>\n<p>​ 1，标记当前单元格：将索引(i,j)存入set\nvisited中，代表此单元格已经访问过。</p>\n<p>​\n2，搜索下一单元格：计算当前元素的下，右两个方向元素的数位和，并开启下层递归。</p>\n<p><strong>回溯返回值：</strong> 返回 1 + 右边搜索可达解总数 +\n下边可达解总数，代表从本单元格递归搜索的可达解总数;</p>\n<p><strong>代码1：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">movingCount</span><span class=\"params\">(<span class=\"type\">int</span> m, <span class=\"type\">int</span> n, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//标记数组</span></span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">bool</span>&gt; &gt; <span class=\"built_in\">visited</span>(m,<span class=\"built_in\">vector</span>&lt;<span class=\"type\">bool</span>&gt;(n,<span class=\"number\">0</span>));</span><br><span class=\"line\">        <span class=\"comment\">//递归访问</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">dfs</span>(visited,m,n,k,<span class=\"number\">0</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">bool</span>&gt; &gt;&amp; visited,<span class=\"type\">int</span> m,<span class=\"type\">int</span> n,<span class=\"type\">int</span> k,<span class=\"type\">int</span> i, <span class=\"type\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//递归终止条件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i&gt;=m || j&gt;=n || visited[i][j] || <span class=\"built_in\">bitSum</span>(i)+<span class=\"built_in\">bitSum</span>(j) &gt; k) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//访问</span></span><br><span class=\"line\">        visited[i][j]=<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">//递归访问下边和右边</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span> + <span class=\"built_in\">dfs</span>(visited,m,n,k,i+<span class=\"number\">1</span>,j) + <span class=\"built_in\">dfs</span>(visited,m,n,k,i,j+<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//计算数位和</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">bitSum</span><span class=\"params\">(<span class=\"type\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(n&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            sum += n % <span class=\"number\">10</span>;</span><br><span class=\"line\">            n /= <span class=\"number\">10</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h6 id=\"方法二广度优先遍历bfs\">方法二：广度优先遍历BFS</h6>\n<p>BFS通常利用队列实现</p>\n<p><strong>算法解析：</strong></p>\n<p><strong>初始化:</strong> 将机器人初始点(0,0)加入队列queue</p>\n<p><strong>递归终止条件：</strong>\nqueue为空。代表已遍历完所有可达解；</p>\n<p><strong>迭代工作：</strong>*</p>\n<p>​\n1，单元格出队：将队首单元格的索引，数位和弹出，作为当前搜索单元格；</p>\n<p>​\n2，判断是否跳过：当行列索引越界或数位和超出目标值K或当前元素已经访问过，返回0，代表计入不可达，执行continue;</p>\n<p>​\n3，标记当前单元格：将单元格索引(i,j)存入visited中，代表此单元格已被访问过；</p>\n<p>​\n4，单元格入队：将当前元素的下边、右边单元格的索引、数位和加入queue中；</p>\n<p><strong>返回值：</strong> visited的长度即为可达解数量;</p>\n<p><strong>代码2:</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">movingCount</span><span class=\"params\">(<span class=\"type\">int</span> m, <span class=\"type\">int</span> n, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//标记数组</span></span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">bool</span>&gt; &gt; <span class=\"built_in\">visited</span>(m,<span class=\"built_in\">vector</span>&lt;<span class=\"type\">bool</span>&gt;(n,<span class=\"number\">0</span>));</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//辅助队列</span></span><br><span class=\"line\">        queue&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; que;</span><br><span class=\"line\">        que.<span class=\"built_in\">push</span>(&#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(que.<span class=\"built_in\">size</span>()&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//弹出队首元素</span></span><br><span class=\"line\">            vector&lt;<span class=\"type\">int</span>&gt; x = que.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">            que.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            <span class=\"type\">int</span> i=x[<span class=\"number\">0</span>],j=x[<span class=\"number\">1</span>],si=x[<span class=\"number\">2</span>],sj=x[<span class=\"number\">3</span>];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i&gt;=m || j&gt;=n || visited[i][j] || si + sj &gt; k) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"comment\">//访问</span></span><br><span class=\"line\">            visited[i][j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            res++;</span><br><span class=\"line\">            <span class=\"comment\">//将下边和右边入队</span></span><br><span class=\"line\">            que.<span class=\"built_in\">push</span>(&#123;i+<span class=\"number\">1</span>,j,<span class=\"built_in\">bitSum</span>(i+<span class=\"number\">1</span>),sj&#125;);</span><br><span class=\"line\">            que.<span class=\"built_in\">push</span>(&#123;i,j+<span class=\"number\">1</span>,si,<span class=\"built_in\">bitSum</span>(j+<span class=\"number\">1</span>)&#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">bitSum</span><span class=\"params\">(<span class=\"type\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(n&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            sum += n % <span class=\"number\">10</span>;</span><br><span class=\"line\">            n /= <span class=\"number\">10</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"i.-剪绳子\"><a\nhref=\"https://leetcode-cn.com/problems/jian-sheng-zi-lcof/\">14- I.\n剪绳子</a></h4>\n<p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m\n段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为\nk[0],k[1]...k[m-1] 。请问 k[0]<em>k[1]</em>...*k[m-1]\n可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>\n<h5 id=\"示例-2\">示例：</h5>\n<blockquote>\n<p>输入：2</p>\n<p>输出：1</p>\n</blockquote>\n<h5 id=\"思路-1\">思路：</h5>\n<p>关于为什么切分为3的优先级最高 可以利用均值不等式求出乘积最大值\nL(m)=(n/m)^m 对此式求导（可利用对数法），</p>\n<p>可以证明当 m=n/e 时，乘积取最大，此时每段绳子的长度为\nn/(n/e)=e，自然对数e的值为2.718，显然接近3，所以总体来讲3最好</p>\n<p>均值不等式 <span class=\"math display\">\\[\n\\frac{n_1+n_2+...n_a}n \\quad  \\geq \\sqrt[n]{n_1n_2...n_a}\n\\]</span></p>\n<p>由数学推导可得：</p>\n<p>1，当所有绳段长度相等时，乘积最大。</p>\n<p>2，最优的绳段长度为3</p>\n<p>切分规则：</p>\n<p>1，最优：3.把绳子尽可能切为多个长度为3的片段，留下的最后一段绳子的长度可能为9，1，2三种情况</p>\n<p>2，次优：2.若最后一段绳子长度为2；则保留，不再拆分为1+1</p>\n<p>3，最差：1，若最后一段绳子长度为1；则应把一份3+1替换成2+2。</p>\n<p>算法流程：</p>\n<p>1，当n&lt;=3时，按照规则应不切分，但由于题目要求必须切成m&gt;1段，因此必须剪出一段长度为1的绳子，即返回n-1</p>\n<p>2，当n&gt;3时，求n除以3的整数部分a和余数部分b(即n=3a+b)，并分为以下三种情况：</p>\n<p>​ 当b=0时，直接返回3^n</p>\n<p>​ 当b=1时，要将一个1+3转换为2+2,因此返回3^(a-1)*4</p>\n<p>​ 当b=2时，返回3^a*2</p>\n<p>时间复杂度：O(1)</p>\n<p>空间复杂度：O(1)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">cuttingRope</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n&lt;=<span class=\"number\">3</span>) <span class=\"keyword\">return</span> n<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> a = n/<span class=\"number\">3</span>,b = n%<span class=\"number\">3</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(b==<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"built_in\">pow</span>(<span class=\"number\">3</span>,a);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(b==<span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"built_in\">pow</span>(<span class=\"number\">3</span>,a<span class=\"number\">-1</span>)*<span class=\"number\">4</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"built_in\">pow</span>(<span class=\"number\">3</span>,a)*<span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>方法二：动态规划:</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">cuttingRope</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n&lt;=<span class=\"number\">3</span>) <span class=\"keyword\">return</span> n<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"comment\">//里的3可以不需要再分了，因为3分段最大才2，不分就是3。记录最大的。</span></span><br><span class=\"line\">        <span class=\"type\">int</span> dp[n+<span class=\"number\">1</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        dp[<span class=\"number\">2</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">        dp[<span class=\"number\">3</span>] = <span class=\"number\">3</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">4</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> maxValue = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=i/<span class=\"number\">2</span>;j++)&#123;</span><br><span class=\"line\">                maxValue = <span class=\"built_in\">max</span>(maxValue,dp[j]*dp[i-j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            dp[i] = maxValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"ii.-剪绳子-ii\"><a\nhref=\"https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/\">14- II.\n剪绳子 II</a></h4>\n<p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m\n段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]...k[m\n- 1] 。请问 k[0]<em>k[1]</em>...*k[m - 1]\n可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>\n<p>答案需要取模\n1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>\n<p>在上一题的基础上取模,最佳方法就是<a\nhref=\"https://sjchen404.github.io/2019/04/17/快速幂/\">快速幂</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">cuttingRope</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n&lt;=<span class=\"number\">3</span>) <span class=\"keyword\">return</span> n<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> a = n/<span class=\"number\">3</span>,b=n%<span class=\"number\">3</span>,k= <span class=\"number\">1000000007</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(b==<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"built_in\">quick_mod</span>(<span class=\"number\">3</span>,a,k)%k;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(b==<span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"built_in\">quick_mod</span>(<span class=\"number\">3</span>,a<span class=\"number\">-1</span>,k)*<span class=\"number\">4</span>%k;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"built_in\">quick_mod</span>(<span class=\"number\">3</span>,a,k)*<span class=\"number\">2</span>%k;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">//快速幂</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">long</span> <span class=\"type\">long</span> <span class=\"title\">quick_mod</span><span class=\"params\">(<span class=\"type\">long</span> x,<span class=\"type\">long</span> y,<span class=\"type\">long</span> k)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"type\">long</span> <span class=\"type\">long</span> ans = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">//对刚进来的x进行取模运算，避免后面第一次求平方溢出</span></span><br><span class=\"line\">        x %= k;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(y)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(y&amp;<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                ans = ans*x%k;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            y&gt;&gt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">            x = x * x %k;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans%k;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>方法二：循环求余</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title\">cuttingRope</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n &lt;= <span class=\"number\">3</span>) <span class=\"keyword\">return</span> n - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> b = n % <span class=\"number\">3</span>, p = <span class=\"number\">1000000007</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">long</span> rem = <span class=\"number\">1</span>, x = <span class=\"number\">3</span> ,a = n / <span class=\"number\">3</span>;</span><br><span class=\"line\">        <span class=\"comment\">//直接套循环求余公式</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; ((b == <span class=\"number\">1</span>)?a<span class=\"number\">-1</span>:a); i++) &#123; <span class=\"comment\">//b == 1代表余数为1的时候，需要单独取出一个3出来凑成2*2达到最大值效果</span></span><br><span class=\"line\">            rem = (rem * x) % p;</span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(b == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> (<span class=\"type\">int</span>)(rem % p);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(b == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> (<span class=\"type\">int</span>)(rem * <span class=\"number\">4</span> % p);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"type\">int</span>)(rem * <span class=\"number\">2</span> % p);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"二进制中1的个数\"><a\nhref=\"https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/\">15.\n二进制中1的个数</a></h4>\n<p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为\n'1' 的个数（也被称为 汉明重量).）。</p>\n<p>提示：</p>\n<p>请注意，在某些语言（如\nJava）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。\n在 Java 中，编译器使用 二进制补码 记法来表示有符号整数。因此，在上面的\n示例 3 中，输入表示有符号整数 -3。</p>\n<h5 id=\"示例-3\">示例：</h5>\n<blockquote>\n<p>输入：n = 11 (控制台输入 00000000000000000000000000001011) 输出：3\n解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为\n'1'。</p>\n</blockquote>\n<h5 id=\"思路-2\">思路：</h5>\n<p><strong>方法一: </strong></p>\n<p>&amp;1,并且右移1位</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">hammingWeight</span><span class=\"params\">(<span class=\"type\">uint32_t</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(n)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(n&amp;<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            n&gt;&gt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>方法二：</strong></p>\n<p>直接n&amp;(n-1)即可得到1的数量</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">hammingWeight</span><span class=\"params\">(<span class=\"type\">uint32_t</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(n)&#123;</span><br><span class=\"line\">            n &amp;= n<span class=\"number\">-1</span>;</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"数值的整数次方\"><a\nhref=\"https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/\">16.\n数值的整数次方</a></h4>\n<p>实现 <a\nhref=\"https://www.cplusplus.com/reference/valarray/pow/\">pow(<em>x</em>,\n<em>n</em>)</a> ，即计算 x 的 n\n次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题</p>\n<h5 id=\"示例-4\">示例：</h5>\n<blockquote>\n<p>输入：x = 2.00000, n = 10 输出：1024.00000</p>\n<p>输入：x = 2.10000, n = 3 输出：9.26100</p>\n<p>输入：x = 2.00000, n = -2 输出：0.25000 解释：2-2 = 1/22 = 1/4 =\n0.25</p>\n</blockquote>\n<h5 id=\"思路-3\">思路：</h5>\n<p>快速幂，但是需要注意当n =\n(-1)*n时会出现错误，我们需要把n放到long中</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">myPow</span><span class=\"params\">(<span class=\"type\">double</span> x, <span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">double</span> sum;</span><br><span class=\"line\">        <span class=\"type\">long</span> m = n;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n==<span class=\"number\">0</span> || x==<span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            sum = <span class=\"built_in\">quick_mod</span>(x,m);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            m = (<span class=\"number\">-1</span>)*m;</span><br><span class=\"line\">            sum = <span class=\"number\">1</span>/<span class=\"built_in\">quick_mod</span>(x,m);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">quick_mod</span><span class=\"params\">(<span class=\"type\">double</span> x,<span class=\"type\">long</span> y)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"type\">double</span> ans = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(y)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(y&amp;<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                ans = ans*x;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            y&gt;&gt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">            x = x*x;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"打印从1到最大的n位数\"><a\nhref=\"https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/\">17.\n打印从1到最大的n位数</a></h4>\n<p>输入数字 <code>n</code>，按顺序打印出从 1 到最大的 n\n位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p>\n<h5 id=\"示例-5\">示例：</h5>\n<blockquote>\n<p>输入: n = 1 输出: [1,2,3,4,5,6,7,8,9]</p>\n</blockquote>\n<h5 id=\"思路-4\">思路：</h5>\n<p>不考虑大数的话</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">printNumbers</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> high = <span class=\"built_in\">pow</span>(<span class=\"number\">10</span>,n)<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">res</span><span class=\"params\">(high)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;high;i++)&#123;</span><br><span class=\"line\">            res[i]=i+<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>考虑大数</p>\n<p>我们要转化为string来处理</p>\n<p><strong>递归生成全排列:</strong></p>\n<p>基于分治算法的思想，先固定高位，向低位递归，当个位已被固定时，添加数字的字符串。例如当n=2时，(数字范围1-99)，固定十位为0-9，按顺序依次开启递归，固定个位0-9，终止递归并添加数字字符串。</p>\n<p><img src=\"https://pic.leetcode-cn.com/83f4b5930ddc1d42b05c724ea2950ee7f00427b11150c86b45bd88405f8c7c87-Picture1.png\" alt=\"Picture1.png\" style=\"zoom:50%;\" /></p>\n<p>但是也有两个问题</p>\n<p>1，删除高位多余的0</p>\n<p>2，列表从1开始</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;string&gt; res;</span><br><span class=\"line\">    string cur;</span><br><span class=\"line\">    <span class=\"type\">char</span> num[<span class=\"number\">10</span>] = &#123;<span class=\"string\">&#x27;0&#x27;</span>,<span class=\"string\">&#x27;1&#x27;</span>,<span class=\"string\">&#x27;2&#x27;</span>,<span class=\"string\">&#x27;3&#x27;</span>,<span class=\"string\">&#x27;4&#x27;</span>,<span class=\"string\">&#x27;5&#x27;</span>,<span class=\"string\">&#x27;6&#x27;</span>,<span class=\"string\">&#x27;7&#x27;</span>,<span class=\"string\">&#x27;8&#x27;</span>,<span class=\"string\">&#x27;9&#x27;</span>&#125;;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;string&gt; <span class=\"title\">printNumbers</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//数字长度</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) <span class=\"built_in\">dfs</span>(<span class=\"number\">0</span>,i);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> len)</span></span>&#123;</span><br><span class=\"line\">      \t<span class=\"comment\">//添加到结果中</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x==len)&#123;</span><br><span class=\"line\">            res.<span class=\"built_in\">push_back</span>(cur);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//x=0表示左边第一位数字，不能为0</span></span><br><span class=\"line\">        <span class=\"type\">int</span> start = x==<span class=\"number\">0</span> ? <span class=\"number\">1</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=start;i&lt;<span class=\"number\">10</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//确定本位数字</span></span><br><span class=\"line\">            cur.<span class=\"built_in\">push_back</span>(num[i]);</span><br><span class=\"line\">            <span class=\"comment\">//确定下一位数字</span></span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(x+<span class=\"number\">1</span>,len);</span><br><span class=\"line\">            <span class=\"comment\">//删除本位数字</span></span><br><span class=\"line\">            cur.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>转化为int</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;string&gt; res;</span><br><span class=\"line\">    string cur;</span><br><span class=\"line\">    <span class=\"type\">char</span> num[<span class=\"number\">10</span>] = &#123;<span class=\"string\">&#x27;0&#x27;</span>,<span class=\"string\">&#x27;1&#x27;</span>,<span class=\"string\">&#x27;2&#x27;</span>,<span class=\"string\">&#x27;3&#x27;</span>,<span class=\"string\">&#x27;4&#x27;</span>,<span class=\"string\">&#x27;5&#x27;</span>,<span class=\"string\">&#x27;6&#x27;</span>,<span class=\"string\">&#x27;7&#x27;</span>,<span class=\"string\">&#x27;8&#x27;</span>,<span class=\"string\">&#x27;9&#x27;</span>&#125;;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">printNumbers</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//数字长度</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++) <span class=\"built_in\">dfs</span>(<span class=\"number\">0</span>,i);</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; res_int;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;res.<span class=\"built_in\">size</span>();i++)&#123;</span><br><span class=\"line\">            res_int.<span class=\"built_in\">push_back</span>(<span class=\"built_in\">stoi</span>(res[i]));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res_int;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> len)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x==len)&#123;</span><br><span class=\"line\">            res.<span class=\"built_in\">push_back</span>(cur);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//x=0表示左边第一位数字，不能为0</span></span><br><span class=\"line\">        <span class=\"type\">int</span> start = x==<span class=\"number\">0</span> ? <span class=\"number\">1</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=start;i&lt;<span class=\"number\">10</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//确定本位数字</span></span><br><span class=\"line\">            cur.<span class=\"built_in\">push_back</span>(num[i]);</span><br><span class=\"line\">            <span class=\"comment\">//确定下一位数字</span></span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(x+<span class=\"number\">1</span>,len);</span><br><span class=\"line\">            <span class=\"comment\">//删除本位数字</span></span><br><span class=\"line\">            cur.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"删除链表的节点\"><a\nhref=\"https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/\">18.\n删除链表的节点</a></h4>\n<p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p>\n<p>返回删除后的链表的头节点。</p>\n<p><strong>注意：</strong>此题对比原题有改动</p>\n<h5 id=\"示例-6\">示例：</h5>\n<blockquote>\n<p>输入: head = [4,5,1,9], val = 5 输出: [4,1,9] 解释: 给定你链表中值为\n5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt;\n9.</p>\n</blockquote>\n<h5 id=\"思路-5\">思路：</h5>\n<p><strong>双指针法：</strong></p>\n<p>算法流程：</p>\n<p>1，定义<code>*pre = head*·</code> `<em>cur=head-&gt;next</em></p>\n<p>2，判断当<code>cur</code>不为空和<code>cur-&gt;val != val</code>\n时，指针向前运动</p>\n<p>3，返回值：如果<code>cur不为空</code>，代表找到了，我们只需要删除即可，最后返回头节点</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">deleteNode</span><span class=\"params\">(ListNode* head, <span class=\"type\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head==<span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head-&gt;val==val) <span class=\"keyword\">return</span> head-&gt;next;</span><br><span class=\"line\">        ListNode* cur = head-&gt;next,*pre=head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur!=<span class=\"literal\">nullptr</span> &amp;&amp; cur-&gt;val != val)&#123;</span><br><span class=\"line\">            pre = cur;</span><br><span class=\"line\">            cur = cur-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cur != <span class=\"literal\">nullptr</span>) pre-&gt;next = cur-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>####<a\nhref=\"https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/\">21.\n调整数组顺序使奇数位于偶数前面</a></p>\n<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。</p>\n<p><strong>示例：</strong></p>\n<blockquote>\n<p>输入：</p>\n<p>nums=[1,2,3,4]</p>\n<p>输出：</p>\n<p>[1,3,2,4]或[3,1,2,4]</p>\n</blockquote>\n<p><strong>思路：</strong></p>\n<p>排序</p>\n<p>方法一：采用双指针法</p>\n<p>定义双指针在数组两端，循环执行（i=j时跳出）：</p>\n<p>​ 1，指针i从左往右寻找偶数</p>\n<p>​ 2，指针j从右往左寻找奇数</p>\n<p>​ 3，交换</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">exchange</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> i = <span class=\"number\">0</span>,j = nums.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i&lt;j)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(i&lt;j &amp;&amp; (nums[i] &amp; <span class=\"number\">1</span>) == <span class=\"number\">1</span>) i++;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(i&lt;j &amp;&amp; (nums[j] &amp; <span class=\"number\">1</span>) == <span class=\"number\">0</span>) j--;</span><br><span class=\"line\">            <span class=\"built_in\">swap</span>(nums[i],nums[j]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>方法二：快慢指针</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">exchange</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> slow =<span class=\"number\">0</span>,fast=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(fast&lt;nums.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[fast]&amp;<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">swap</span>(nums[slow],nums[fast]);</span><br><span class=\"line\">                slow++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            fast++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"链表中倒数第k个节点\"><a\nhref=\"https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/\">22.\n链表中倒数第k个节点</a></h4>\n<p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p>\n<p>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是\n1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</p>\n<h5 id=\"示例-7\">示例：</h5>\n<blockquote>\n<p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</p>\n<p>返回链表 4-&gt;5.</p>\n</blockquote>\n<h5 id=\"思路-6\">思路：</h5>\n<p><strong>方法一：</strong></p>\n<p>1，先遍历求链表长度n</p>\n<p>2，再回到头节点走n-k步</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">getKthFromEnd</span><span class=\"params\">(ListNode* head, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">        ListNode *cur = head;</span><br><span class=\"line\">        <span class=\"comment\">//确定链表长度</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur!=<span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            n++;</span><br><span class=\"line\">            cur = cur-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//判断溢出</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(k&gt;n) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"comment\">//回到头节点</span></span><br><span class=\"line\">        cur = head;</span><br><span class=\"line\">        <span class=\"comment\">//移动到第n-k个位置</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n-k;i++)&#123;</span><br><span class=\"line\">            cur = cur-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cur;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>方法二：双指针</strong></p>\n<p>1，定义一个指针cur向前走k步，pre指向头节点</p>\n<p>2，判断溢出</p>\n<p>3，两个指针同时运动，直到cur指向null,返回pre</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">getKthFromEnd</span><span class=\"params\">(ListNode* head, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        ListNode *pre = head,*cur=head;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;k;i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//判断溢出</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(cur==<span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">            cur = cur-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur!=<span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            cur = cur-&gt;next;</span><br><span class=\"line\">            pre = pre -&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pre;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"反转链表\"><a\nhref=\"https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/\">24.\n反转链表</a></h4>\n<p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>\n<h5 id=\"示例-8\">示例：</h5>\n<blockquote>\n<p>输入：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</p>\n<p>输出：5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>\n</blockquote>\n<h5 id=\"思路-7\">思路：</h5>\n<p><strong>方法一：双指针</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">reverseList</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        ListNode* cur = head,*pre=<span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur!=<span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            ListNode* tmp = cur-&gt;next;</span><br><span class=\"line\">            cur-&gt;next = pre;</span><br><span class=\"line\">            pre = cur;</span><br><span class=\"line\">            cur = tmp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pre;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>方法二：递归</strong></p>\n<p><em>算法流程：</em></p>\n<p><strong>recur(cur,pre):</strong></p>\n<p>1，终止条件：当cur为空，则返回尾节点pre(即反转链表的头节点)</p>\n<p>2，递归后继节点，记录返回值为res</p>\n<p>3，修改当前节点cur指向前驱节点pre</p>\n<p>4，返回res</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">reverseList</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">recur</span>(head,<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">recur</span><span class=\"params\">(ListNode* cur,ListNode* pre)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//终止条件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cur==<span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> pre;</span><br><span class=\"line\">        <span class=\"comment\">//递归后继节点</span></span><br><span class=\"line\">        ListNode* res = <span class=\"built_in\">recur</span>(cur-&gt;next,cur);</span><br><span class=\"line\">        <span class=\"comment\">//修改节点引用指向</span></span><br><span class=\"line\">        cur-&gt;next = pre;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"合并两个排序的链表\"><a\nhref=\"https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/\">25.\n合并两个排序的链表</a></h4>\n<p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>\n<h5 id=\"示例-9\">示例：</h5>\n<blockquote>\n<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4\n输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>\n</blockquote>\n<h5 id=\"思路-8\">思路：</h5>\n<p><strong>方法一：双指针</strong></p>\n<p>双指针l1、l2遍历两链表。</p>\n<p>算法流程：</p>\n<p>1，初始化：创建伪节点dum,节点cur指向dum</p>\n<p>2，循环合并：当l1或l2为空时跳出：</p>\n<ul>\n<li><p>当l1.val &lt;\nl2.val时：cur的后继节点指定为l1,l1向前走一步</p></li>\n<li><p>当l1.val &gt;=\nl2.val时：cur的后继节点指定为l2,l2向前走一步</p></li>\n<li><p>节点cur向前走一步，即cur=cur-&gt;next</p></li>\n</ul>\n<p>3，合并剩余尾部</p>\n<ul>\n<li><p>l1不空，将l1添加至节点cur后</p></li>\n<li><p>否则，将l2添加至节点cur之后</p></li>\n</ul>\n<p>4，返回值：合并链表在伪节点dum之后，因此返回dum-&gt;next</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">mergeTwoLists</span><span class=\"params\">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//判断</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l1==<span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> l2;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l2==<span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> l1;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l1==<span class=\"literal\">nullptr</span> &amp;&amp; l2==<span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"comment\">//创建伪节点</span></span><br><span class=\"line\">        ListNode* dum = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(<span class=\"number\">0</span>),*cur = dum;</span><br><span class=\"line\">        <span class=\"comment\">//循环合并</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l1 != <span class=\"literal\">nullptr</span> &amp;&amp; l2 != <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//l1-&gt;val&lt;l2.val，指向l1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class=\"line\">                cur-&gt;next = l1;</span><br><span class=\"line\">                l1 = l1-&gt;next;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                cur-&gt;next = l2;</span><br><span class=\"line\">                l2 = l2-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cur = cur-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//合并剩余尾部</span></span><br><span class=\"line\">        cur-&gt;next = l1 != <span class=\"literal\">nullptr</span> ? l1 : l2;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dum-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>方法二：递归</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">mergeTwoLists</span><span class=\"params\">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//判断</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l1==<span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> l2;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l2==<span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> l1;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l1==<span class=\"literal\">nullptr</span> &amp;&amp; l2==<span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l1-&gt;val &lt;= l2-&gt;val)&#123;</span><br><span class=\"line\">            l1-&gt;next = <span class=\"built_in\">mergeTwoLists</span>(l1-&gt;next,l2);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> l1;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            l2-&gt;next = <span class=\"built_in\">mergeTwoLists</span>(l1,l2-&gt;next);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> l2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"二叉树的镜像\"><a\nhref=\"https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/\">27.\n二叉树的镜像</a></h4>\n<p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>\n<p>例如输入：</p>\n<p>4 /<br />\n2 7 /   /<br />\n1 3 6 9</p>\n<p>镜像输出：</p>\n<p>4 /<br />\n7 2 /   /<br />\n9 6 3 1</p>\n<h5 id=\"示例-10\">示例：</h5>\n<blockquote>\n<p>输入：root = [4,2,7,1,3,6,9] 输出：[4,7,2,9,6,3,1]</p>\n</blockquote>\n<h5 id=\"思路-9\">思路：</h5>\n<p><strong>方法一：递归</strong></p>\n<p>根据二叉树镜像的定义，考虑递归(dfs)二叉树，交换每个节点的左/右子节点，即可生成二叉树的镜像</p>\n<p>算法流程：</p>\n<p>1，终止条件：当root为空时，返回null</p>\n<p>2，递推工作：</p>\n<ul>\n<li><p>初始化节点tmp,用于暂存root的左子节点；</p></li>\n<li><p>开启递归右子节点mirrorTree(root-&gt;right)，并将返回值作为root的左子节点；</p></li>\n<li><p>开启递归右子节点mirrorTree(tmp)，并将返回值作为root的右子节点；</p></li>\n</ul>\n<p>3，返回值：返回当前节点root</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">mirrorTree</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        TreeNode* tmp = root-&gt;left;</span><br><span class=\"line\">        root-&gt;left = <span class=\"built_in\">mirrorTree</span>(root-&gt;right);</span><br><span class=\"line\">        root-&gt;right = <span class=\"built_in\">mirrorTree</span>(tmp);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>方法二：辅助栈</strong></p>\n<p>算法流程：</p>\n<p>1，初始化：设置一个链表栈，root入栈</p>\n<p>2，设置node指针指向栈顶，然后出栈，左右子树入栈</p>\n<p>3，交换左右子树</p>\n<p>4，返回root</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">mirrorTree</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root==<span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        stack&lt;TreeNode*&gt; st;</span><br><span class=\"line\">        st.<span class=\"built_in\">push</span>(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!st.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">            TreeNode* node = st.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">            <span class=\"comment\">//出栈</span></span><br><span class=\"line\">            st.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            <span class=\"comment\">//左右子树入栈</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(node-&gt;left != <span class=\"literal\">nullptr</span>) st.<span class=\"built_in\">push</span>(node-&gt;left);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(node-&gt;right != <span class=\"literal\">nullptr</span>) st.<span class=\"built_in\">push</span>(node-&gt;right);</span><br><span class=\"line\">            <span class=\"comment\">//交换左右子树</span></span><br><span class=\"line\">            TreeNode* tmp = node-&gt;left;</span><br><span class=\"line\">            node-&gt;left = node-&gt;right;</span><br><span class=\"line\">            node-&gt;right = tmp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"对称的二叉树\"><a\nhref=\"https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/\">28.\n对称的二叉树</a></h4>\n<p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>\n<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>\n<p>1 /<br />\n2 2 /  /<br />\n3 4 4 3</p>\n<p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>\n<p>1 /<br />\n2 2  <br />\n3 3</p>\n<h5 id=\"示例-11\">示例：</h5>\n<blockquote>\n<p>输入：root = [1,2,2,3,4,4,3] 输出：true</p>\n</blockquote>\n<h5 id=\"思路-10\">思路：</h5>\n<p>对称二叉树定义：对于树中任意两个对称节点L和R，一定有：</p>\n<p>​ 1，L.val = R.val</p>\n<p>​ 2，L.left.val = R.right.val</p>\n<p>​ 3，L.right.val = R.left.val</p>\n<p>算法流程：</p>\n<p>1，终止条件：</p>\n<ul>\n<li><p>当L和R同时越过叶节点；此树丛顶至顶都对称，返回true</p></li>\n<li><p>当L或R中有一个越过叶节点：此树不对称，返回false</p></li>\n<li><p>当节点L值 != R值：不对称，返回false</p></li>\n</ul>\n<p>2，递推工作：</p>\n<ul>\n<li><p>判断两节点L.left和R.right是否对称,即recur(L.left,R.right);</p></li>\n<li><p>判断两节点L.right和R.left是否对称,即recur(L.right,R.left);</p></li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isSymmetric</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">//递归</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">recur</span>(root-&gt;left,root-&gt;right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">recur</span><span class=\"params\">(TreeNode* L,TreeNode* R)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//左右同时结束</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(L==<span class=\"literal\">nullptr</span> &amp;&amp; R==<span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">//左子树或者右子树一边没有元素或者两边不等</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(L == <span class=\"literal\">nullptr</span> || R==<span class=\"literal\">nullptr</span> || L-&gt;val != R-&gt;val) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">//递归</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">recur</span>(L-&gt;left,R-&gt;right) &amp;&amp; <span class=\"built_in\">recur</span>(L-&gt;right,R-&gt;left);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"包含min函数的栈\"><a\nhref=\"https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/\">30.\n包含min函数的栈</a></h4>\n<p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min\n函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>\n<h5 id=\"示例-12\">示例：</h5>\n<blockquote>\n<p>MinStack minStack = new MinStack(); minStack.push(-2);\nminStack.push(0); minStack.push(-3); minStack.min(); --&gt; 返回 -3.\nminStack.pop(); minStack.top(); --&gt; 返回 0. minStack.min(); --&gt;\n返回 -2.</p>\n</blockquote>\n<h5 id=\"思路-11\">思路：</h5>\n<p>普通栈push()和pop()复杂度为O(1),而获取栈最小值min()需要遍历整个栈，复杂度为O(N);</p>\n<p>我们可以通过建立辅助栈实现：</p>\n<ul>\n<li><p>数据栈A：栈A用于存储所有元素，保证push()、pop()、top()函数的正常逻辑</p></li>\n<li><p>数据栈B：栈B中存储栈A中所有非严格降序的元素，则栈A中的最小元素始终对应栈B的栈顶元素，即min()只需返回栈B的栈顶元素即可；</p></li>\n</ul>\n<p>#####算法流程：</p>\n<p>push(x): 重点保持栈B的元素是非严格降序的</p>\n<p>​ 1，将x压入栈A；</p>\n<p>​ 2，若栈B为空或x小于等于栈B的栈顶元素，则将x压入栈B</p>\n<p>pop():重点保持栈A，B的元素一致性</p>\n<p>​ 1，执行栈A出栈，将出栈元素记为y;</p>\n<p>​ 2，若y等于栈B的栈顶元素，则执行栈B出栈；</p>\n<p>top():直接返回栈A的栈顶元素</p>\n<p>min():直接返回栈B的栈顶元素</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MinStack</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/** initialize your data structure here. */</span></span><br><span class=\"line\">    stack&lt;<span class=\"type\">int</span>&gt;A,B;</span><br><span class=\"line\">    <span class=\"built_in\">MinStack</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        A.<span class=\"built_in\">push</span>(x);</span><br><span class=\"line\">        <span class=\"comment\">//B空或者栈B的栈顶元素小于x，入栈B</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(B.<span class=\"built_in\">empty</span>() || x&lt;=B.<span class=\"built_in\">top</span>())&#123;</span><br><span class=\"line\">            B.<span class=\"built_in\">push</span>(x);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> y=A.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        A.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"comment\">//保持一致性</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(B.<span class=\"built_in\">top</span>()==y)&#123;</span><br><span class=\"line\">            B.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">top</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> A.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">min</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> B.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"复杂链表的复制\"><a\nhref=\"https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/\">35.\n复杂链表的复制</a></h4>\n<p>请实现 copyRandomList\n函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next\n指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者\nnull。</p>\n<h5\nid=\"示例1\">示例1:<img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png\" alt=\"img\" style=\"zoom:50%;\" /></h5>\n<blockquote>\n<p>输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</p>\n<p>输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</p>\n</blockquote>\n<h5 id=\"思路-12\">思路：</h5>\n<p>######<strong>方法一：哈希表</strong></p>\n<p>利用哈希表的查询特点，考虑构建 原链表节点 和 新链表对应节点\n的键值对映射关系，</p>\n<p>再遍历构建新链表各节点的 next 和 random 引用指向即可。</p>\n<p><strong>算法流程：</strong></p>\n<p>1，若头节点head为空节点，直接返回null;</p>\n<p>2，初始化：哈希表dic，节点cur指向头节点;</p>\n<p>3，复制链表：</p>\n<ul>\n<li><p>建立新节点，并向dic添加键值对(原cur节点，新cur节点)</p></li>\n<li><p>cur遍历至原链表下一节点；</p></li>\n</ul>\n<p>4，构建新链表的引用指向：</p>\n<ul>\n<li><p>1，构建新节点的next和random引用指向；</p></li>\n<li><p>2，cur遍历至原链表下一节点；</p></li>\n</ul>\n<p>5，返回值：新链表的头节点dic[cur]；</p>\n<p>时间复杂度O(N): 两轮遍历链表，使用O(N)时间。</p>\n<p>空间复杂度O(N)：哈希表dic使用线性大小的额外空间；</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">Node* <span class=\"title\">copyRandomList</span><span class=\"params\">(Node* head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head==<span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        Node* cur = head;</span><br><span class=\"line\">        unordered_map&lt;Node*,Node*&gt;map;</span><br><span class=\"line\">        <span class=\"comment\">//复制链表，并建立“原节点-&gt;新节点“的map映射</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur != <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            map[cur] = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(cur-&gt;val);</span><br><span class=\"line\">            cur = cur-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//指向头节点,重新遍历</span></span><br><span class=\"line\">        cur = head;</span><br><span class=\"line\">        <span class=\"comment\">//构建新链表的next和random指向</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur != <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            map[cur]-&gt;next = map[cur-&gt;next];</span><br><span class=\"line\">            map[cur]-&gt;random = map[cur-&gt;random];</span><br><span class=\"line\">            cur = cur-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//返回新链表的头节点</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> map[head];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h6 id=\"方法二拼接拆分\">方法二：拼接+拆分</h6>\n<p>考虑构建:\n原节点1-&gt;新节点1-&gt;原节点2-&gt;新节点2-&gt;....的拼接链表，如此便可在访问原节点的random指向节点</p>\n<p>的同时找到新对应新节点的random指向节点;</p>\n<p><strong>算法流程：</strong></p>\n<p>1，复制各节点，构建拼接链表：</p>\n<ul>\n<li>设原节点为node1-&gt;node2...,构建成node1-&gt;node1-&gt;node2-&gt;node2-&gt;....</li>\n</ul>\n<p>2，构建新链表各节点的random指向：</p>\n<ul>\n<li>当访问原节点cur的随机指向节点cur.random时，对应新节点的cur.next的随机指向节点为cur.random-&gt;next</li>\n</ul>\n<p>3，拆分原/新链表：</p>\n<ul>\n<li>设置pre/cur分别指向原/新链表头节点，遍历执行pre.next =\npre.next.next和cur.next = cur.next.next将两链表拆分开</li>\n</ul>\n<p>4，返回新链表的头节点res即可</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">Node* <span class=\"title\">copyRandomList</span><span class=\"params\">(Node* head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"comment\">//设置cur指向头节点</span></span><br><span class=\"line\">        Node* cur = head;</span><br><span class=\"line\">        <span class=\"comment\">//1，复制各节点，并构建拼接新链表</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur != <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//构建新节点</span></span><br><span class=\"line\">            Node* tmp = <span class=\"keyword\">new</span> <span class=\"built_in\">Node</span>(cur-&gt;val);</span><br><span class=\"line\">            tmp-&gt;next = cur-&gt;next;</span><br><span class=\"line\">            cur-&gt;next = tmp;</span><br><span class=\"line\">            cur = tmp-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//构建各新节点的random指向</span></span><br><span class=\"line\">        <span class=\"comment\">//返回头节点，重新遍历</span></span><br><span class=\"line\">        cur = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur != <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(cur-&gt;random != <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">                cur-&gt;next-&gt;random = cur-&gt;random-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cur = cur-&gt;next-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//3,拆分两链表</span></span><br><span class=\"line\">        cur=head-&gt;next;</span><br><span class=\"line\">        Node* pre = head,*res = head-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur-&gt;next != <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            pre-&gt;next = pre-&gt;next-&gt;next;</span><br><span class=\"line\">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class=\"line\">            pre = pre-&gt;next;</span><br><span class=\"line\">            cur = cur-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//单独处理原链表尾节点</span></span><br><span class=\"line\">        pre-&gt;next = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>####<a\nhref=\"https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/\">39.\n数组中出现次数超过一半的数字</a></p>\n<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>\n<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>\n<p><strong>示例：</strong></p>\n<blockquote>\n<p>输入：</p>\n<p>[1,2,3,2,2,2,5,4,2]</p>\n<p>输出：</p>\n<p>2</p>\n</blockquote>\n<p><strong>思路：</strong></p>\n<p>方法一：哈希表统计法</p>\n<p>时间空间复杂度为O(N)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        map&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt;mp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> num:nums)&#123;</span><br><span class=\"line\">            mp[num]++;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(mp[num] &gt; (nums.<span class=\"built_in\">size</span>()/<span class=\"number\">2</span>))&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> num;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>方法二：数组排序法</p>\n<p>将数组排序，数组中点的元素一定为众数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(nums.<span class=\"built_in\">begin</span>(),nums.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums[nums.<span class=\"built_in\">size</span>()/<span class=\"number\">2</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>方法三：摩尔投票法</p>\n<p>投票法简单来说就是不同则抵消，占半数以上的数字必然留到最后。这句话是摩尔投票法的精髓</p>\n<p>时间和空间复杂度为O(N)和O(1)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">majorityElement</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> x=<span class=\"number\">0</span>,votes=<span class=\"number\">0</span>,count=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> num:nums)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(votes==<span class=\"number\">0</span>) x=num;</span><br><span class=\"line\">            votes += num == x ? <span class=\"number\">1</span>:<span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//验收</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> num:nums)</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(num == x) count++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count&gt;nums.<span class=\"built_in\">size</span>()/<span class=\"number\">2</span> ? x:<span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>####<a\nhref=\"https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/\">40.\n最小的k个数</a></p>\n<p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code>\n个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p>\n<p><strong>示例：</strong></p>\n<blockquote>\n<p>输入：arr = [3,2,1], k = 2</p>\n<p>输出：[1,2] 或者 [2,1]</p>\n<p>输入：arr = [0,1,2,1],k = 1</p>\n<p>输出：[0]</p>\n</blockquote>\n<p><strong>ToK问题：</strong></p>\n<p>#####<strong>方法一：快排</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">getLeastNumbers</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">vec</span><span class=\"params\">(k,<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(arr.<span class=\"built_in\">begin</span>(),arr.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;k;i++)&#123;</span><br><span class=\"line\">            vec[i]=arr[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> vec;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>不用api</p>\n<p>快速排序原理：</p>\n<p>快速排序算法有两个核心点，分别为 “哨兵划分” 和 “递归” 。</p>\n<p>哨兵划分操作： 以数组某个元素（一般选取首元素）为 基准数\n，将所有小于基准数的元素移动至其左边，大于基准数的元素移动至其右边。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">getLeastNumbers</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">quickSort</span>(arr,<span class=\"number\">0</span>,arr.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>);</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt;res;</span><br><span class=\"line\">        <span class=\"comment\">//assign()函数主要是将一个容器中元素全部复制到另一个容器中</span></span><br><span class=\"line\">        res.<span class=\"built_in\">assign</span>(arr.<span class=\"built_in\">begin</span>(),arr.<span class=\"built_in\">begin</span>()+k);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">quickSort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr, <span class=\"type\">int</span> l, <span class=\"type\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//子数组长度为1时递归终止</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l&gt;=r) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"comment\">//哨兵划分操作（以arr[1]作为基准）</span></span><br><span class=\"line\">        <span class=\"type\">int</span> i=l,j=r;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i&lt;j)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(i&lt;j &amp;&amp; arr[j]&gt;=arr[l]) j--;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(i&lt;j &amp;&amp; arr[i]&lt;=arr[l]) i++;</span><br><span class=\"line\">            <span class=\"built_in\">swap</span>(arr[i],arr[j]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//使左边小于等于基准，右边大于等于基准</span></span><br><span class=\"line\">        <span class=\"built_in\">swap</span>(arr[i],arr[l]);</span><br><span class=\"line\">        <span class=\"comment\">//递归左右子数组执行哨兵划分</span></span><br><span class=\"line\">        <span class=\"built_in\">quickSort</span>(arr,l,i<span class=\"number\">-1</span>);</span><br><span class=\"line\">        <span class=\"built_in\">quickSort</span>(arr,i+<span class=\"number\">1</span>,r);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>#####<strong>方法二：基于快速排序的数组划分</strong></p>\n<p>题目只要求返回最小的 k 个数，对这 k\n个数的顺序并没有要求。因此，只需要将数组划分为 最小的 k 个数 和 其他数字\n两部分即可，而快速排序的哨兵划分可完成此目标。</p>\n<p>根据快速排序原理，如果某次哨兵划分后 基准数正好是第 k+1 小的数字\n，那么此时基准数左边的所有数字便是题目所求的 最小的 k 个数 。</p>\n<p>根据此思路，考虑在每次哨兵划分后，判断基准数在数组中的索引是否等于k\n，若 true 则直接返回此时数组的前k 个数字即可。</p>\n<p>算法流程：</p>\n<p><strong>getLeastNumbers()</strong></p>\n<p>​ 1，若k大于数组长度，则直接返回整个数组；</p>\n<p>​ 2，执行并返回quick_sort()</p>\n<p><strong>quick_sort()</strong></p>\n<p>​ 功能不是排序整个数组，而是搜索并返回最小的k个数</p>\n<ul>\n<li>哨兵划分：</li>\n</ul>\n<p>​ 划分完毕后，基准数为arr[i],左/右子数组区间分别为[l,i-1],[i+1,r];</p>\n<ul>\n<li><p>递归或返回：</p>\n<ul>\n<li><p>若K&lt;i，代表第 k+1\n小的数字在左子数组中，则递归左子数组；</p></li>\n<li><p>若K&gt;i，代表第 k+1\n小的数字在右子数组中，则递归右子数组；</p></li>\n<li><p>若K=i，代表此时arr[k]即为第k+1小的数字，则直接返回数组前k个数字即可；</p></li>\n</ul></li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">getLeastNumbers</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(k&gt;=arr.<span class=\"built_in\">size</span>()) <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">quick_sort</span>(arr,k,<span class=\"number\">0</span>,arr.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">quick_sort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr,<span class=\"type\">int</span> k,<span class=\"type\">int</span> l,<span class=\"type\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> i=l,j=r;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i&lt;j)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(i&lt;j &amp;&amp; arr[j] &gt;= arr[l]) j--;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(i&lt;j &amp;&amp; arr[i] &lt;= arr[l]) i++;</span><br><span class=\"line\">            <span class=\"built_in\">swap</span>(arr[i],arr[j]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">swap</span>(arr[i],arr[l]);</span><br><span class=\"line\">        <span class=\"comment\">//递归左数组</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i&gt;k) <span class=\"keyword\">return</span> <span class=\"built_in\">quick_sort</span>(arr,k,l,i<span class=\"number\">-1</span>);</span><br><span class=\"line\">        <span class=\"comment\">//递归右数组</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i&lt;k) <span class=\"keyword\">return</span> <span class=\"built_in\">quick_sort</span>(arr,k,i+<span class=\"number\">1</span>,r);</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt;res;</span><br><span class=\"line\">        res.<span class=\"built_in\">assign</span>(arr.<span class=\"built_in\">begin</span>(),arr.<span class=\"built_in\">begin</span>()+k);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h5 id=\"方法三堆\">方法三：堆</h5>\n<p>我们用一个大根堆实时维护数组的前 k\n小值。首先将前k个数插入大根堆中，</p>\n<p>随后从第k+1\n个数开始遍历，如果当前遍历到的数比大根堆的堆顶的数要小，就把堆顶的数弹出，再插入当前遍历到的数。</p>\n<p>最后将大根堆里的数存入数组返回即可。在下面的代码中，由于 C++\n语言中的堆（即优先队列）为大根堆，我们可以这么做。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">getLeastNumbers</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">vec</span><span class=\"params\">(k,<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(k==<span class=\"number\">0</span>) <span class=\"keyword\">return</span> vec;</span><br><span class=\"line\">        priority_queue&lt;<span class=\"type\">int</span>&gt; Q;</span><br><span class=\"line\">        <span class=\"comment\">//把前k个数入堆</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;k;i++)&#123;</span><br><span class=\"line\">            Q.<span class=\"built_in\">push</span>(arr[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=k;i&lt;arr.<span class=\"built_in\">size</span>();i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//把堆中大的元素出堆</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(Q.<span class=\"built_in\">top</span>()&gt;arr[i])&#123;</span><br><span class=\"line\">                Q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                Q.<span class=\"built_in\">push</span>(arr[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//输出堆中的元素即最小k位</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;k;i++)&#123;</span><br><span class=\"line\">            vec[i]=Q.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">            Q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> vec;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>####<a\nhref=\"https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/\">41.\n数据流中的中位数</a></p>\n<p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>\n<p>例如，</p>\n<p>[2,3,4] 的中位数是 3</p>\n<p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p>\n<p>设计一个支持以下两种操作的数据结构：</p>\n<p>void addNum(int num) - 从数据流中添加一个整数到数据结构中。 double\nfindMedian() - 返回目前所有元素的中位数。</p>\n<p><strong>示例：</strong></p>\n<blockquote>\n<p>输入：</p>\n<p>[\"MedianFinder\",\"addNum\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\"]</p>\n<p>[[],[1],[2],[],[3],[]]</p>\n<p>输出：</p>\n<p>[null,null,null,1.50000,null,2.00000]</p>\n</blockquote>\n<h5 id=\"方法用大小堆\">方法：用大小堆</h5>\n<p>小顶堆A保存较大的数</p>\n<p>大顶堆B保存较小的数</p>\n<p>A和B尽量保存一样的数量，中位数可以根据栈顶元素计算得出</p>\n<p>算法流程：</p>\n<p>设元素总数为N=m+n,m和n分别为A和B中的元素</p>\n<p>addNum(num)函数</p>\n<p>1，当m=n(即N为偶数时)：需向A添加一个元素。实现方法：将新元素num插入至B，再将B堆顶元素插入至A；</p>\n<p>2，当m≠n(即N为奇数时)：需向B添加一个元素。实现方法：将新元素num插入至A，再将A堆顶元素插入至B；</p>\n<p>这样始终保持A保存较大一半、B保存较小一半。</p>\n<p>findMedian()函数</p>\n<p>1，当m=n：中位数为(A的堆顶元素+B的堆顶元素)/2；</p>\n<p>2，当m≠n(即N为奇数时)：则中位数为A的堆顶元素</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MedianFinder</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 最大堆，存储左边一半的数据，堆顶为最大值</span></span><br><span class=\"line\">    priority_queue&lt;<span class=\"type\">int</span>,vector&lt;<span class=\"type\">int</span>&gt;,less&lt;<span class=\"type\">int</span>&gt;&gt; maxHeap_B;</span><br><span class=\"line\">    <span class=\"comment\">// 最小堆， 存储右边一半的数据，堆顶为最小值</span></span><br><span class=\"line\">    priority_queue&lt;<span class=\"type\">int</span>,vector&lt;<span class=\"type\">int</span>&gt;,greater&lt;<span class=\"type\">int</span>&gt;&gt; minHeap_A;</span><br><span class=\"line\">    <span class=\"comment\">/** initialize your data structure here. */</span></span><br><span class=\"line\">    <span class=\"built_in\">MedianFinder</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 维持堆数据平衡，并保证左边堆的最大值小于或等于右边堆的最小值</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addNum</span><span class=\"params\">(<span class=\"type\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//当m=n(即N为偶数时)：需向A添加一个元素。实现方法：将新元素num插入至B，再将B堆顶元素插入至A；</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(maxHeap_B.<span class=\"built_in\">size</span>()==minHeap_A.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">            maxHeap_B.<span class=\"built_in\">push</span>(num);</span><br><span class=\"line\">            <span class=\"type\">int</span> top=maxHeap_B.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">            maxHeap_B.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            minHeap_A.<span class=\"built_in\">push</span>(top);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            minHeap_A.<span class=\"built_in\">push</span>(num);</span><br><span class=\"line\">            <span class=\"type\">int</span> top=minHeap_A.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">            minHeap_A.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            maxHeap_B.<span class=\"built_in\">push</span>(top);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">findMedian</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(minHeap_A.<span class=\"built_in\">size</span>()==maxHeap_B.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (maxHeap_B.<span class=\"built_in\">top</span>()+minHeap_A.<span class=\"built_in\">top</span>())*<span class=\"number\">1.0</span>/<span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> minHeap_A.<span class=\"built_in\">top</span>()*<span class=\"number\">1.0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>####<a\nhref=\"https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/\">44.\n数字序列中某一位的数字</a></p>\n<p>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</p>\n<p>请写一个函数，求任意第n位对应的数字。</p>\n<p><strong>示例：</strong></p>\n<blockquote>\n<p>输入：n = 3</p>\n<p>输出：3</p>\n<p>输入：n = 11</p>\n<p>输出：0</p>\n</blockquote>\n<p><strong>思路：</strong></p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>数字范围</th>\n<th>位数</th>\n<th>数字数量</th>\n<th>数位数量</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>1-9</td>\n<td>1</td>\n<td>9</td>\n<td>9</td>\n</tr>\n<tr class=\"even\">\n<td>10-99</td>\n<td>2</td>\n<td>90</td>\n<td>180</td>\n</tr>\n<tr class=\"odd\">\n<td>100-999</td>\n<td>3</td>\n<td>900</td>\n<td>2700</td>\n</tr>\n<tr class=\"even\">\n<td>...</td>\n<td>...</td>\n<td>...</td>\n<td>...</td>\n</tr>\n<tr class=\"odd\">\n<td>start - end</td>\n<td>digit</td>\n<td>9*start</td>\n<td>9*start*digit</td>\n</tr>\n</tbody>\n</table>\n<p>1，确定n所在数字的位数，记为digit;</p>\n<p>2，确定n所在的数字，记为num;</p>\n<p>3，确定n是num中的哪一数位，并返回结果;</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">findNthDigit</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//数位</span></span><br><span class=\"line\">        <span class=\"type\">int</span> digit = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">//当前数字范围的左区间</span></span><br><span class=\"line\">        <span class=\"type\">long</span> start = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">//数位数量</span></span><br><span class=\"line\">        <span class=\"type\">long</span> count = <span class=\"number\">9</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//定位目标数字所在的数字范围</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(n&gt;count)&#123;</span><br><span class=\"line\">            n -= count;</span><br><span class=\"line\">            digit += <span class=\"number\">1</span>;</span><br><span class=\"line\">            start *= <span class=\"number\">10</span>;</span><br><span class=\"line\">            count = <span class=\"number\">9</span>*start*digit;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//确定n所在的数字</span></span><br><span class=\"line\">        <span class=\"type\">long</span> num = start + (n<span class=\"number\">-1</span>) / digit;</span><br><span class=\"line\">        <span class=\"comment\">//index最大取digit-1，即此时num坐标从左往右为0,1...digit-1,共digit位</span></span><br><span class=\"line\">        <span class=\"type\">int</span> index = (n<span class=\"number\">-1</span>)%digit;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(index&lt;(digit<span class=\"number\">-1</span>))&#123;</span><br><span class=\"line\">            <span class=\"comment\">//最后的结果是num中的第index个数字</span></span><br><span class=\"line\">            num/=<span class=\"number\">10</span>;</span><br><span class=\"line\">            digit--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//结果为num右侧末尾数字</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> num%<span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"数组中的逆序对\"><a\nhref=\"https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/\">51.\n数组中的逆序对</a></h4>\n<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>\n<p>#####<strong>示例：</strong></p>\n<blockquote>\n<p>输入：[7,5,6,4]</p>\n<p>输出：5</p>\n</blockquote>\n<p>#####<strong>思路：</strong></p>\n<p>归并排序与逆序对是息息相关的归并排序体现了“分治思想”</p>\n<h5 id=\"算法流程\"><strong>算法流程：</strong></h5>\n<p><img src=\"https://pic.leetcode-cn.com/1614274007-nBQbZZ-Picture1.png\" alt=\"Picture1.png\" style=\"zoom: 33%;\" /></p>\n<p>merge_sort()归并排序与逆序对统计：</p>\n<p>1，<strong>终止条件：</strong>\n当l&gt;=r时，代表子数组长度为1，此时终止划分；</p>\n<p>2，<strong>递归划分：</strong>\n计算数组中点m，递归划分左子数组merge_sort(1,m)和右子数组merge_sort(m+1,r);</p>\n<p>3，<strong>合并与逆序对统计：</strong></p>\n<p>​ （1），暂存数组nums[i,r]内的元素至辅助数组tmp；</p>\n<p>​ （2），循环合并：设置双指针i,j分别指向左/右子数组的首元素：</p>\n<ul>\n<li>当i=m+1时：代表左子数组已合并完，因此添加右子数组当前元素tmp[j],并执行j=j+1;</li>\n<li>否则，当j=r+1时：代表右子数组已合并完，因此添加左子数组当前元素\ntmp[i],并执行i=i+1;</li>\n<li>否则，当tmp[i]&lt;=tmp[j]时：添加左子数组当前元素tmp[i],并执行i=i+1;</li>\n<li>否则(即tmp[i]&gt;tmp[j])时：添加右子数组当前元素tmp[j],并执行j=j+1;此时构成m-i+1个逆序对，统计添加至res;</li>\n</ul>\n<p>4，返回值：res</p>\n<p>reversePairs()函数：</p>\n<p>1，初始化：辅助数组tmp,用于合并阶段暂存元素；</p>\n<p>2，返回值：执行归并排序，并返回逆序对总数；</p>\n<p>时间复杂度：O(Nlog N)</p>\n<p>空间复杂度：O(N)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">reversePairs</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt;<span class=\"built_in\">tmp</span>(nums.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">merge_sort</span>(<span class=\"number\">0</span>,nums.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>,nums,tmp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">merge_sort</span><span class=\"params\">(<span class=\"type\">int</span> l,<span class=\"type\">int</span> r,vector&lt;<span class=\"type\">int</span>&gt;&amp; nums,vector&lt;<span class=\"type\">int</span>&gt;&amp; tmp)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//终止条件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l&gt;=r) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//递归划分</span></span><br><span class=\"line\">        <span class=\"type\">int</span> m = (l+r)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"comment\">//分成两份后结果分别相加</span></span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"built_in\">merge_sort</span>(l,m,nums,tmp) + <span class=\"built_in\">merge_sort</span>(m+<span class=\"number\">1</span>,r,nums,tmp); </span><br><span class=\"line\">        <span class=\"comment\">//合并阶段</span></span><br><span class=\"line\">        <span class=\"type\">int</span> i = l,j=m+<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">//用一个数组保存合并之前的模样</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k=l;k&lt;=r;k++)&#123;</span><br><span class=\"line\">            tmp[k] = nums[k];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k=l;k&lt;=r;k++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//m及其左边元素合并完，把右边剩下的放在合并后的数组</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i==m+<span class=\"number\">1</span>) nums[k]=tmp[j++];</span><br><span class=\"line\">            <span class=\"comment\">//m+1及其右边元素合并完毕，把左边剩下的放入合并后的数组 或者 左边数组的元素小于等于右边，</span></span><br><span class=\"line\">            <span class=\"comment\">//将左边数组的元素放入结果数组中，并让索引i+1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(j==r+<span class=\"number\">1</span> || tmp[i]&lt;=tmp[j]) nums[k]=tmp[i++];</span><br><span class=\"line\">            <span class=\"comment\">//右边数组的元素小于左边,将右边数组的元素其放入结果数组中,并让索引j加1</span></span><br><span class=\"line\">            <span class=\"comment\">//并且此时左边数组中的从i到m的所有数都是大于tmp[j]的(因为m左右的数组都是已经排好序的，第15行代码的功劳)</span></span><br><span class=\"line\">            <span class=\"comment\">//即此时有m-i+1个逆序对，加到res上即可</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                nums[k]=tmp[j++];</span><br><span class=\"line\">                res += m-i+<span class=\"number\">1</span>;   <span class=\"comment\">//统计逆序对</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"i.-在排序数组中查找数字-i\"><a\nhref=\"https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/\">53\n- I. 在排序数组中查找数字 I</a></h4>\n<p>统计一个数字在排序数组中出现的次数。</p>\n<h5 id=\"示例-13\">示例：</h5>\n<blockquote>\n<p>输入: nums = [5,7,7,8,8,10], target = 8 输出: 2</p>\n</blockquote>\n<h5 id=\"思路-13\">思路：</h5>\n<p><strong>方法一：哈希表</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">search</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        map&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt; mp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;nums.<span class=\"built_in\">size</span>();i++)&#123;</span><br><span class=\"line\">            mp[nums[i]]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mp[target];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>方法二：二次二分</strong></p>\n<p>寻找左边界left和右边界right,数量为right-left-1</p>\n<p>算法流程：</p>\n<p>1，初始化：左边界i=0,右边界j=len-1</p>\n<p>2，循环二分：当闭区间[i,j]无元素时跳出</p>\n<ul>\n<li><p>计算m=(i+j)/2</p></li>\n<li><p>若nums[m] &lt;\ntarget，则target在闭区间[m+1,j]中，执行i=m+1</p></li>\n<li><p>若nums[m] &gt;\ntarget，则target在闭区间[i,m-1]中，执行j=m-1</p></li>\n<li><p>若nums[m] =\ntarget，则右边界right在[m+1,j]中，左边界left在[i,m-1]中，因此分两种情况：</p>\n<ul>\n<li>若查找right，则执行i=m+!;(跳出时i指向右边界)</li>\n<li>若查找left，则执行j=m-1;(跳出时j指向左边界)</li>\n</ul></li>\n</ul>\n<p>3，返回值：right-left-1</p>\n<p>==以上可以优化为都查找右边界==</p>\n<ul>\n<li><p>查找target的右边界</p></li>\n<li><p>查找target-1的右边界</p></li>\n</ul>\n<p>时间复杂度O(logN)</p>\n<p>空间复杂度O(1)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">search</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">helper</span>(nums,target) - <span class=\"built_in\">helper</span>(nums,target<span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">helper</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums,<span class=\"type\">int</span> tar)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> i=<span class=\"number\">0</span>,j=nums.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"comment\">//这边是“小于等于”，因此当循环结束后，ij不重合，且如果存在target值的话，</span></span><br><span class=\"line\">        <span class=\"comment\">//i的位置就是右边界（target值序列右边第一个大于target值的位置），因为最后一次循环一定是i=mid+1；</span></span><br><span class=\"line\">        <span class=\"comment\">//且此时j指向target</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i&lt;=j)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> m=(i+j)/<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"comment\">//这里是“小于等于”，目的是为了确定右边界，就是说当mid等于target时，因为不确定后面还有没有target，所以同样需要左边收缩范围</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[m] &lt;= tar) i = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> j = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"ii.-0n-1中缺失的数字\"><a\nhref=\"https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/\">53 - II.\n0～n-1中缺失的数字</a></h4>\n<p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>\n<h5 id=\"示例-14\">示例：</h5>\n<blockquote>\n<p>输入: [0,1,3] 输出: 2</p>\n</blockquote>\n<h5 id=\"思路-14\">思路：</h5>\n<p><strong>方法一：数学或者直接判断</strong></p>\n<p>nums[i] 是否等于i</p>\n<p><strong>方法二：二分查找</strong></p>\n<p>方法三：二分查找</p>\n<p>排序数组中的搜索问题，首先想到二分法</p>\n<p>左子数组：nums[i]=i</p>\n<p>右子数组：nums[i]!=i</p>\n<p>算法流程：</p>\n<p>1，初始化：左边界i=0,右边界j=len-1;代表区间[i,j]</p>\n<p>2，循环二分：当i&lt;=j时循环</p>\n<ul>\n<li><p>计算中点m=(i+j)/2</p></li>\n<li><p>若nums[m]=m，则右子数组的首位元素一定在[m+1,j]中，执行i=m+1;</p></li>\n<li><p>若nums[m]!=m，则左子数组的末位元素一定在[i,m-1]中，执行j=m-1</p></li>\n</ul>\n<p>3，返回值：跳出时，i和j分别指向右子数组的首位元素和左子数组的末位元素，因此返回i即可</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">missingNumber</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> i = <span class=\"number\">0</span>, j = nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i&lt;=j)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> m = (i + j) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[m] == m) i = m + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> j = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"和为s的两个数字\"><a\nhref=\"https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/\">57.\n和为s的两个数字</a></h4>\n<p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p>\n<h5 id=\"示例-15\">示例：</h5>\n<blockquote>\n<p>输入：nums = [2,7,11,15], target = 9 输出：[2,7] 或者 [7,2]</p>\n</blockquote>\n<h5 id=\"思路-15\">思路：</h5>\n<p><strong>方法一：哈希表</strong></p>\n<p>复杂度为O(N)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">twoSum</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        unordered_set&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt;mp;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">res</span><span class=\"params\">(<span class=\"number\">2</span>,<span class=\"number\">-1</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(mp.<span class=\"built_in\">count</span>(target-nums[i]) &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                res[<span class=\"number\">0</span>] = target - nums[i];</span><br><span class=\"line\">                res[<span class=\"number\">1</span>] = nums[i];</span><br><span class=\"line\">                <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            mp.<span class=\"built_in\">insert</span>(nums[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>方法二：双指针</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">twoSum</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> i = <span class=\"number\">0</span>, j = nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i &lt; j)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> sum = nums[i] + nums[j];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sum &lt; target) i++;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(sum &gt; target) j--;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                res.<span class=\"built_in\">push_back</span>(nums[i]);</span><br><span class=\"line\">                res.<span class=\"built_in\">push_back</span>(nums[j]);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"ii.-左旋转字符串\"><a\nhref=\"https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/\">58\n- II. 左旋转字符串</a></h4>\n<p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串\"abcdefg\"和数字2，该函数将返回左旋转两位得到的结果\"cdefgab\"。</p>\n<h5 id=\"示例-16\">示例:</h5>\n<blockquote>\n<p>输入: s = \"abcdefg\", k = 2 输出: \"cdefgab\"</p>\n</blockquote>\n<h5 id=\"思路-16\">思路：</h5>\n<p><strong>方法一：借用一个string</strong></p>\n<p>时间复杂度O(N)</p>\n<p>空间复杂度O(N)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">reverseLeftWords</span><span class=\"params\">(string s, <span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> len = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        string res;</span><br><span class=\"line\">      \t<span class=\"comment\">//res = s.substr(n,len-1)+s.substr(0,n);</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=n;i&lt;len;i++)&#123;</span><br><span class=\"line\">            res.<span class=\"built_in\">push_back</span>(s[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">            res.<span class=\"built_in\">push_back</span>(s[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>方法二：三次翻转</strong></p>\n<p>时间复杂度O(N)</p>\n<p>空间复杂度O(1)</p>\n<p>三次翻转</p>\n<p>例如：</p>\n<p>s = \"abcdefg\" k=2</p>\n<p>第一次翻转：整体翻转 gfedcba reverse(s.begin(),s.end());</p>\n<p>第二次翻转：翻转len-n个 cdefgba reverse(s.begin(),s.end()-n);</p>\n<p>第三次翻转：翻转最后n个 cdefgab reverse(s.end()-n,s.end());</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">reverseLeftWords</span><span class=\"params\">(string s, <span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//整体翻转</span></span><br><span class=\"line\">        <span class=\"built_in\">reverse</span>(s.<span class=\"built_in\">begin</span>(),s.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"comment\">//翻转len-n个</span></span><br><span class=\"line\">        <span class=\"built_in\">reverse</span>(s.<span class=\"built_in\">begin</span>(),s.<span class=\"built_in\">end</span>()-n);</span><br><span class=\"line\">        <span class=\"comment\">//翻转最后n个</span></span><br><span class=\"line\">        <span class=\"built_in\">reverse</span>(s.<span class=\"built_in\">end</span>()-n,s.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["剑指offer"],"tags":["剑指offer"]},{"title":"报文解压缩","url":"/2022/04/11/%E6%8A%A5%E6%96%87%E8%A7%A3%E5%8E%8B%E7%BC%A9/","content":"<h1 id=\"报文解压缩\">报文解压缩</h1>\n<p><strong>■ 题目描述</strong></p>\n<ul>\n<li>为了提升数据传输的效率，会对传输的报文进行压缩处理。</li>\n<li>输入一个压缩后的报文，请返回它解压后的原始报文。</li>\n<li>压缩规则：n[str]，表示方括号内部的 str 正好重复 n 次。</li>\n<li>注意 n 为正整数（0 &lt; n &lt;=\n100），str只包含小写英文字母，不考虑异常情况。</li>\n</ul>\n<p><strong>输入描述:</strong></p>\n<p><strong>输入压缩后的报文：</strong></p>\n<ol type=\"1\">\n<li>不考虑无效的输入，报文没有额外的空格，方括号总是符合格式要求的；</li>\n<li>原始报文不包含数字，所有的数字只表示重复的次数 n ，例如不会出现像 5b\n或 3[8] 的输入；</li>\n</ol>\n<p><strong>输出描述:</strong></p>\n<ul>\n<li>解压后的原始报文</li>\n</ul>\n<p><strong>注：</strong></p>\n<ul>\n<li>原始报文长度不会超过1000，不考虑异常的情况</li>\n</ul>\n<p><strong>示例 1</strong>\n输入输出示例仅供调试，后台判题数据一般不包含示例</p>\n<span id=\"more\"></span>\n<p><strong>输入</strong></p>\n<blockquote>\n<p>3[k]2[mn]</p>\n</blockquote>\n<p><strong>输出</strong></p>\n<blockquote>\n<p>kkkmnmn</p>\n</blockquote>\n<p><strong>说明</strong></p>\n<ul>\n<li>k 重复3次，mn 重复2次，最终得到 kkkmnmn</li>\n</ul>\n<p><strong>示例 2</strong>\n输入输出示例仅供调试，后台判题数据一般不包含示例</p>\n<p><strong>输入</strong></p>\n<blockquote>\n<p>3[m2[c]]</p>\n</blockquote>\n<p><strong>输出</strong></p>\n<blockquote>\n<p>mccmccmcc</p>\n</blockquote>\n<p><strong>说明</strong></p>\n<ul>\n<li>m2[c] 解压缩后为 mcc，重复三次为 mccmccmcc</li>\n</ul>\n<h2 id=\"思路\">思路：</h2>\n<p>我们全部压入栈后，遇到<code>]</code>后弹出计算，然后再压会栈中，最后判断栈是否为空即可</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ll;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">double</span> ld;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; pii;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> vector&lt;<span class=\"type\">int</span>&gt; vi;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    string code;</span><br><span class=\"line\">    cin &gt;&gt; code;</span><br><span class=\"line\">    stack&lt;string&gt; st;</span><br><span class=\"line\">    string decode;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    string tmp;</span><br><span class=\"line\">    tmp = code[i];</span><br><span class=\"line\">    st.<span class=\"built_in\">push</span>(tmp);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!st.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(code[i] != <span class=\"string\">&#x27;]&#x27;</span> &amp;&amp; i &lt; code.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">            string tmp;</span><br><span class=\"line\">            tmp = code[i];</span><br><span class=\"line\">            st.<span class=\"built_in\">push</span>(tmp);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            string str;</span><br><span class=\"line\">            string num;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!st.<span class=\"built_in\">empty</span>() &amp;&amp; st.<span class=\"built_in\">top</span>() != <span class=\"string\">&quot;[&quot;</span>)&#123;</span><br><span class=\"line\">                str += st.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">                st.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//去掉[</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!st.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">                st.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//计算数字</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!st.<span class=\"built_in\">empty</span>() &amp;&amp; st.<span class=\"built_in\">top</span>() &gt;= <span class=\"string\">&quot;0&quot;</span> &amp;&amp; st.<span class=\"built_in\">top</span>() &lt;= <span class=\"string\">&quot;9&quot;</span>)&#123;</span><br><span class=\"line\">                num += st.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">                st.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(num != <span class=\"string\">&quot;&quot;</span>)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">reverse</span>(num.<span class=\"built_in\">begin</span>(), num.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">                <span class=\"type\">int</span> cnt = <span class=\"built_in\">stoi</span>(num);</span><br><span class=\"line\">                string strTmp;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; cnt; i++)&#123;</span><br><span class=\"line\">                    strTmp += str;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                st.<span class=\"built_in\">push</span>(strTmp);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            decode = str;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//由于是栈，后进先出，所以需要翻转</span></span><br><span class=\"line\">    <span class=\"built_in\">reverse</span>(decode.<span class=\"built_in\">begin</span>(), decode.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    cout &lt;&lt; decode &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["字符串","栈"],"tags":["字符串","栈","华为机试"]},{"title":"打家劫舍","url":"/2022/03/19/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/","content":"<p>#<a href=\"https://leetcode-cn.com/problems/house-robber/\">198.\n打家劫舍</a></p>\n<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</strong></p>\n<p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>不触动警报装置的情况下\n</strong>，一夜之内能够偷窃到的最高金额。</p>\n<h2 id=\"示例\">示例：</h2>\n<blockquote>\n<p>输入：[1,2,3,1] 输出：4 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3\n号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"思路\">思路：</h2>\n<p><strong>解决动态规划问题就是找「状态」和「选择」</strong></p>\n<p>假设你就是这个小偷，从左到右走过这一排房子，在每间房子前都有两种「选择」：偷或者不偷。</p>\n<p>如果你偷了这间房子，那么你肯定不能偷相邻的下一间房子，只能从下下间房子开始重复这样的选择。</p>\n<p>如果你不偷这间房子，那么你就可以走到下一间房子前，继续做选择。</p>\n<p>当你走过了最后一间房子后，你就没有房子偷了，偷到的钱为0（base\ncase）。</p>\n<p><img src=\"打家劫舍/1.jpg\" /></p>\n<p>在两个选择中，每次选择更大的结果，最后得到的就是最多能偷到的钱</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">rob</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums.<span class=\"built_in\">size</span>() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">dp</span>(nums, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dp</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> i)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//base case</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i &gt;= nums.<span class=\"built_in\">size</span>()) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//如果你抢了这间房间，那你就不能抢相邻的下一间房子，只能从下下间房子开始做选择</span></span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"built_in\">max</span>(<span class=\"built_in\">dp</span>(nums, i + <span class=\"number\">1</span>),<span class=\"built_in\">dp</span>(nums, i + <span class=\"number\">2</span>) + nums[i]);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>明确了状态转移，就可以发现对于同一个\n<code>i</code>位置，是存在重叠子问题的，可以用备忘录进行优化，避免多次递归浪费时间</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; memo;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">rob</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums.<span class=\"built_in\">size</span>() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        memo.<span class=\"built_in\">resize</span>(nums.<span class=\"built_in\">size</span>(), <span class=\"number\">-1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">dp</span>(nums, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dp</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> i)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//base case</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i &gt;= nums.<span class=\"built_in\">size</span>()) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//避免重复计算</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(memo[i] != <span class=\"number\">-1</span>) <span class=\"keyword\">return</span> memo[i];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//如果你抢了这间房间，那你就不能抢相邻的下一间房子，只能从下下间房子开始做选择</span></span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"built_in\">max</span>(<span class=\"built_in\">dp</span>(nums, i + <span class=\"number\">1</span>),<span class=\"built_in\">dp</span>(nums, i + <span class=\"number\">2</span>) + nums[i]);</span><br><span class=\"line\">        memo[i] = res;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这是自顶向下的动态规划，我们也可以改成自底向上：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">自底向上</span></span><br><span class=\"line\"><span class=\"comment\">dp[i] = x 表示 从第 i 间开始抢劫，最多能抢到的钱为 x</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">rob</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums.<span class=\"built_in\">size</span>() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(n + <span class=\"number\">2</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"comment\">//base case</span></span><br><span class=\"line\">        dp[n] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = n - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">            dp[i] = <span class=\"built_in\">max</span>(dp[i + <span class=\"number\">1</span>], dp[i + <span class=\"number\">2</span>] + nums[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>我们又发现状态转移只和<code>dp[i]</code>最近的两个状态有关，所以可以进一步优化，将空间复杂度降低到\nO(1)。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">rob</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums.<span class=\"built_in\">size</span>() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> dp_i_1 = <span class=\"number\">0</span>, dp_i_2 = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//记录 dp[i]</span></span><br><span class=\"line\">        <span class=\"type\">int</span> dp_i = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = n - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">            dp_i = <span class=\"built_in\">max</span>(dp_i_1, dp_i_2 + nums[i]);</span><br><span class=\"line\">            dp_i_2 = dp_i_1;</span><br><span class=\"line\">            dp_i_1 = dp_i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp_i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"打家劫舍-ii\"><a\nhref=\"https://leetcode-cn.com/problems/house-robber-ii/\">213. 打家劫舍\nII</a></h1>\n<p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都<strong>围成一圈</strong>\n，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统,，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警\n。</strong></p>\n<p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>在不触动警报装置的情况下\n</strong>，今晚能够偷窃到的最高金额。</p>\n<h2 id=\"示例-1\">示例：</h2>\n<blockquote>\n<p>输入：nums = [2,3,2] 输出：3 解释：你不能先偷窃 1 号房屋（金额 =\n2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</p>\n</blockquote>\n<h2 id=\"思路-1\">思路：</h2>\n<p>环形方案：首尾不能同时偷，有三种不同情况</p>\n<p>1，都不偷</p>\n<p>2，只偷首个房子</p>\n<p>3，只偷尾房子</p>\n<p>取最大结果即可</p>\n<p>我们可以只考虑情况2和情况3，因为这两种情况对于房子的选择余地比情况一大，因为房子里的钱都是正数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">rob</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">max</span>(<span class=\"built_in\">dp</span>(nums, <span class=\"number\">0</span>, n - <span class=\"number\">2</span>), <span class=\"built_in\">dp</span>(nums, <span class=\"number\">1</span>, n - <span class=\"number\">1</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dp</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> start, <span class=\"type\">int</span> end)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// base case 为什么是 end + 1，因为最后一次要选择偷这家还是下家</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(start &gt;= end + <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"built_in\">max</span>(<span class=\"built_in\">dp</span>(nums, start + <span class=\"number\">1</span>, end), <span class=\"built_in\">dp</span>(nums, start + <span class=\"number\">2</span>, end) + nums[start]);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>有重叠子问题，借用备忘录进行优化。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; memo;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">rob</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        memo.<span class=\"built_in\">resize</span>(n, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(n, <span class=\"number\">-1</span>));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">max</span>(<span class=\"built_in\">dp</span>(nums, <span class=\"number\">0</span>, n - <span class=\"number\">2</span>), <span class=\"built_in\">dp</span>(nums, <span class=\"number\">1</span>, n - <span class=\"number\">1</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dp</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> start, <span class=\"type\">int</span> end)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//base case</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(start &gt;= end + <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(memo[start][end] != <span class=\"number\">-1</span>) <span class=\"keyword\">return</span> memo[start][end];</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"built_in\">max</span>(<span class=\"built_in\">dp</span>(nums, start + <span class=\"number\">1</span>, end), <span class=\"built_in\">dp</span>(nums, start + <span class=\"number\">2</span>, end) + nums[start]);</span><br><span class=\"line\">        memo[start][end] = res;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>我们又发现状态转移只和<code>dp[i][j]</code>最近的两个状态有关，所以可以进一步优化，将空间复杂度降低到\nO(1)。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">rob</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">max</span>(<span class=\"built_in\">robRange</span>(nums, <span class=\"number\">0</span>, n - <span class=\"number\">2</span>), <span class=\"built_in\">robRange</span>(nums, <span class=\"number\">1</span>, n - <span class=\"number\">1</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">robRange</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> start, <span class=\"type\">int</span> end)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> dp_i_1 = <span class=\"number\">0</span>, dp_i_2 = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> dp_i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = end; i &gt;= start; i--)&#123;</span><br><span class=\"line\">            dp_i = <span class=\"built_in\">max</span>(dp_i_1, dp_i_2 + nums[i]);</span><br><span class=\"line\">            dp_i_2 = dp_i_1;</span><br><span class=\"line\">            dp_i_1 = dp_i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp_i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"打家劫舍-iii\"><a\nhref=\"https://leetcode-cn.com/problems/house-robber-iii/\">337. 打家劫舍\nIII</a></h1>\n<p>小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为\nroot 。</p>\n<p>除了 root\n之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。\n如果<strong>两个直接相连的房子在同一天晚上被打劫</strong>\n，房屋将自动报警。</p>\n<p>给定二叉树的 root 。返回<strong>在不触动警报的情况下</strong>\n，小偷能够盗取的最高金额 。</p>\n<h2 id=\"示例-2\">示例：</h2>\n<p><img src=\"打家劫舍/2.jpg\" /></p>\n<blockquote>\n<p>输入: root = [3,2,3,null,3,null,1] 输出: 7 解释:\n小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7</p>\n</blockquote>\n<h3 id=\"结构\">结构</h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">TreeNode</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> val;</span><br><span class=\"line\">    TreeNode *left;</span><br><span class=\"line\">    TreeNode *right;</span><br><span class=\"line\">    <span class=\"built_in\">TreeNode</span>() : <span class=\"built_in\">val</span>(<span class=\"number\">0</span>), <span class=\"built_in\">left</span>(<span class=\"literal\">nullptr</span>), <span class=\"built_in\">right</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">TreeNode</span>(<span class=\"type\">int</span> x) : <span class=\"built_in\">val</span>(x), <span class=\"built_in\">left</span>(<span class=\"literal\">nullptr</span>), <span class=\"built_in\">right</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">TreeNode</span>(<span class=\"type\">int</span> x, TreeNode *left, TreeNode *right) : <span class=\"built_in\">val</span>(x), <span class=\"built_in\">left</span>(left), <span class=\"built_in\">right</span>(right) &#123;&#125;</span><br><span class=\"line\"> &#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"思路-2\">思路：</h2>\n<p>还是和之前一样的套路，我们如果偷了节点，那么他的左右子树就不能偷。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">rob</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//base case</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//偷</span></span><br><span class=\"line\">        <span class=\"type\">int</span> do_it = root-&gt;val +</span><br><span class=\"line\">                    (root-&gt;left == <span class=\"literal\">nullptr</span> ? <span class=\"number\">0</span> : <span class=\"built_in\">rob</span>(root-&gt;left-&gt;left) + <span class=\"built_in\">rob</span>(root-&gt;left-&gt;right)) +</span><br><span class=\"line\">                    (root-&gt;right == <span class=\"literal\">nullptr</span> ? <span class=\"number\">0</span> : <span class=\"built_in\">rob</span>(root-&gt;right-&gt;left) + <span class=\"built_in\">rob</span>(root-&gt;right-&gt;right));</span><br><span class=\"line\">        <span class=\"comment\">//不偷</span></span><br><span class=\"line\">        <span class=\"type\">int</span> not_do = <span class=\"built_in\">rob</span>(root-&gt;left) + <span class=\"built_in\">rob</span>(root-&gt;right);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"built_in\">max</span>(do_it, not_do);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>备忘录优化</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    map&lt;TreeNode*, <span class=\"type\">int</span>&gt; memo;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">rob</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//base case</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//避免重复计算</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(memo[root])&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> memo[root];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//偷，然后去下家</span></span><br><span class=\"line\">        <span class=\"type\">int</span> do_it = root-&gt;val</span><br><span class=\"line\">                + (root-&gt;left == <span class=\"literal\">nullptr</span> ? <span class=\"number\">0</span> : <span class=\"built_in\">rob</span>(root-&gt;left-&gt;left) + <span class=\"built_in\">rob</span>(root-&gt;left-&gt;right))</span><br><span class=\"line\">                + (root-&gt;right == <span class=\"literal\">nullptr</span> ? <span class=\"number\">0</span> : <span class=\"built_in\">rob</span>(root-&gt;right-&gt;left) + <span class=\"built_in\">rob</span>(root-&gt;right-&gt;right));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//不偷，然后去下家</span></span><br><span class=\"line\">        <span class=\"type\">int</span> not_do = <span class=\"built_in\">rob</span>(root-&gt;left) + <span class=\"built_in\">rob</span>(root-&gt;right);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"built_in\">max</span>(do_it, not_do);</span><br><span class=\"line\">        memo[root] = res;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>最后一种就是采用树形<code>dp</code>，采用后续遍历的方式，时间复杂度为<code>O(n)</code>，空间复杂度为<code>O(logn)</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">rob</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">res</span><span class=\"params\">(<span class=\"number\">2</span>)</span></span>;</span><br><span class=\"line\">        res = <span class=\"built_in\">dfs</span>(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">max</span>(res[<span class=\"number\">0</span>],res[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 长度为2的数组，0：不偷，1：偷</span></span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dfs</span><span class=\"params\">(TreeNode* root)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//后序遍历</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> &#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; left = <span class=\"built_in\">dfs</span>(root-&gt;left);</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; right = <span class=\"built_in\">dfs</span>(root-&gt;right);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//偷当前节点 下家就不能抢了</span></span><br><span class=\"line\">        <span class=\"type\">int</span> do_it = root-&gt;val + left[<span class=\"number\">0</span>] + right[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"comment\">//不偷当前节点 下家可抢可不抢，取决于收益大小</span></span><br><span class=\"line\">        <span class=\"type\">int</span> not_do = <span class=\"built_in\">max</span>(left[<span class=\"number\">0</span>], left[<span class=\"number\">1</span>]) + <span class=\"built_in\">max</span>(right[<span class=\"number\">0</span>], right[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;not_do, do_it&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["动态规划","leetcode"],"tags":["动态规划"]},{"title":"拓扑排序","url":"/2022/04/14/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/","content":"<p>拓扑排序的对象是有向无环图，所以我们先了解下如何判断是否有环。</p>\n<h1 id=\"判断有向图是否存在环\">判断有向图是否存在环</h1>\n<h2 id=\"课程表\"><a\nhref=\"https://leetcode-cn.com/problems/course-schedule/\">207.\n课程表</a></h2>\n<p>你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。</p>\n<p>在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites\n给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须\n先学习课程 bi 。</p>\n<p>例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。\n请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回\nfalse 。</p>\n<h3 id=\"示例\">示例：</h3>\n<blockquote>\n<p>输入：numCourses = 2, prerequisites = [[1,0]] 输出：true 解释：总共有\n2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。</p>\n</blockquote>\n<span id=\"more\"></span>\n<h4 id=\"思路\">思路：</h4>\n<p><strong>看到依赖问题，首先想到的就是把问题转化成「有向图」这种数据结构，只要图中存在环，那就说明存在循环依赖</strong>。</p>\n","categories":["图","拓扑排序"],"tags":["图","拓扑排序"]},{"title":"排序链表","url":"/2022/04/01/%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/","content":"<h1 id=\"排序链表\"><a\nhref=\"https://leetcode-cn.com/problems/sort-list/\">148.\n排序链表</a></h1>\n<p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong>\n排列并返回 <strong>排序后的链表</strong> 。</p>\n<h2 id=\"示例\">示例</h2>\n<p><img src=\"排序链表/1.jpg\" /></p>\n<blockquote>\n<p>输入：head = [4,2,1,3] 输出：[1,2,3,4]</p>\n<p>输入：head = [-1,5,3,4,0] 输出：[-1,0,3,4,5]</p>\n<p>输入：head = [] 输出：[]</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"思路归并排序\">思路：归并排序</h2>\n<p>把链表从中间节点分成两个链表，然后递归下去，直到都为空。</p>\n<p><img src=\"排序链表/2.jpg\" /></p>\n<p>那么我们如何找到中间节点呢？只需要通过快慢指针即可，慢指针每次走一步，快指针走两步，这样快指针走向空时，慢指针指向的就是中间节点。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(fast != <span class=\"literal\">nullptr</span> &amp;&amp; fast-&gt;next != <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">\tslow = slow-&gt;next;</span><br><span class=\"line\">\tfast = fast-&gt;next-&gt;next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于分割递归的<code>base case</code>：</p>\n<p>当\n<code>head == nullptr</code>时，直接返回<code>nullptr</code>（对应链表没有元素）</p>\n<p>当<code>head-&gt;next == nullptr</code>时，直接返回<code>head</code>（链表只有一个元素，无法再分）</p>\n<p><strong>合并阶段：</strong></p>\n<ul>\n<li>当两个链表都不为空时，我们把小的元素添加到新的链表上</li>\n<li>当<code>list1</code>不为空，<code>list2</code>为空时，直接把链表插到开头</li>\n<li>当<code>list2</code>不为空，<code>list1</code>为空时，直接把链表插到开头</li>\n</ul>\n<p>综上代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ListNode</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> val;</span><br><span class=\"line\">    ListNode *next;</span><br><span class=\"line\">    <span class=\"built_in\">ListNode</span>() : <span class=\"built_in\">val</span>(<span class=\"number\">0</span>), <span class=\"built_in\">next</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">ListNode</span>(<span class=\"type\">int</span> x) : <span class=\"built_in\">val</span>(x), <span class=\"built_in\">next</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">ListNode</span>(<span class=\"type\">int</span> x, ListNode *next) : <span class=\"built_in\">val</span>(x), <span class=\"built_in\">next</span>(next) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">sortList</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head-&gt;next == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">sort_list</span>(head, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">sort_list</span><span class=\"params\">(ListNode* head, ListNode* tail)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head-&gt;next == tail) &#123;</span><br><span class=\"line\">            head-&gt;next = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//采用快慢指针找到中间节点</span></span><br><span class=\"line\">        ListNode* slow = head, *fast = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(fast != tail &amp;&amp; fast-&gt;next != tail)&#123;</span><br><span class=\"line\">            slow = slow-&gt;next;</span><br><span class=\"line\">            fast = fast-&gt;next-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//中间节点</span></span><br><span class=\"line\">        ListNode* mid = slow;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">merge</span>(<span class=\"built_in\">sort_list</span>(head, mid), <span class=\"built_in\">sort_list</span>(mid, tail));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">merge</span><span class=\"params\">(ListNode* list1, ListNode* list2)</span></span>&#123;</span><br><span class=\"line\">        ListNode* dummy = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">        ListNode* temp = dummy, *temp1 = list1, *temp2 = list2;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(temp1 != <span class=\"literal\">nullptr</span> &amp;&amp; temp2 != <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(temp1-&gt;val &lt;= temp2-&gt;val)&#123;</span><br><span class=\"line\">                temp-&gt;next = temp1;</span><br><span class=\"line\">                temp1 = temp1-&gt;next;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                temp-&gt;next = temp2;</span><br><span class=\"line\">                temp2 = temp2-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            temp = temp-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(temp1 != <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            temp-&gt;next = temp1;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(temp2 != <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            temp-&gt;next = temp2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dummy-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//构造链表</span></span><br><span class=\"line\"><span class=\"function\">ListNode* <span class=\"title\">construct</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; v)</span></span>&#123;</span><br><span class=\"line\">    ListNode* node = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">    ListNode* head = node;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; v.<span class=\"built_in\">size</span>(); i++)&#123;</span><br><span class=\"line\">        ListNode* temp = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(v[i]);</span><br><span class=\"line\">        head-&gt;next = temp;</span><br><span class=\"line\">        head = head-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node-&gt;next;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; v = &#123;<span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span> ,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">    ListNode* head = <span class=\"built_in\">construct</span>(v);</span><br><span class=\"line\">    Solution a;</span><br><span class=\"line\">    ListNode* res = a.<span class=\"built_in\">sortList</span>(head);</span><br><span class=\"line\">    ListNode* cur = res;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cur != <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">        cout &lt;&lt; cur-&gt;val &lt;&lt; <span class=\"string\">&quot;-&gt;&quot;</span>;</span><br><span class=\"line\">        cur = cur-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["链表","归并排序","leetcode"],"tags":["链表","归并排序"]},{"title":"搜索旋转排序数组","url":"/2022/04/26/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/","content":"<h1 id=\"搜索旋转排序数组\"><a\nhref=\"https://leetcode-cn.com/problems/search-in-rotated-sorted-array/\">33.\n搜索旋转排序数组</a></h1>\n<p>整数数组 <code>nums</code>按升序排列，数组中的值 互不相同 。</p>\n<p>在传递给函数之前，<code>nums</code>在预先未知的某个下标\n<code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了\n旋转，使数组变为\n<code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标\n从 <code>0</code>开始 计数）。例如，<code>[0,1,2,4,5,6,7]</code> 在下标\n<code>3</code>处经旋转后可能变为<code>[4,5,6,7,0,1,2] 。</code></p>\n<p>给你 旋转后 的数组 <code>nums</code> 和一个整数\n<code>target</code>，如果 <code>nums</code>中存在这个目标值\n<code>target</code>，则返回它的下标，否则返回 <code>-1</code> 。</p>\n<h2 id=\"示例\">示例：</h2>\n<blockquote>\n<p>输入：nums = [4,5,6,7,0,1,2], target = 0 输出：4</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"思路\">思路：</h3>\n<p>对于有序数组，可以使用二分查找的方法查找元素。</p>\n<p>但是这道题中，数组本身不是有序的，进行旋转后只保证了数组的局部是有序的，这还能进行二分查找吗？答案是可以的。</p>\n<p>可以发现的是，我们将数组从中间分开成左右两部分的时候，一定有一部分的数组是有序的。</p>\n<p>比如将<code>[0-7]</code>，我们从<code>6</code>这个位置分开后，数组变为了<code>[4,5,6]</code>和<code>[7,0,1,2,3]</code>两个部分，可以发现左边是有序的。</p>\n<p>我们假设<code>lo = 0, hi = nums.size() - 1</code></p>\n<ul>\n<li>如果<code>[lo, mid - 1]</code>是有序数组，且<code>target</code>在区间<code>[nums[lo], nums[mid]]</code>中，则我们应该将搜索范围缩小到<code>[lo, mid - 1]</code>，否则在<code>[mid + 1, hi]</code>中寻找。</li>\n<li>如果<code>[mid, hi]</code>是有序数组，且<code>target</code>在区间<code>[nums[mid + 1], nums[hi]]</code>中，则我们应该将搜索范围缩小为<code>[mid + 1, hi]</code>，否则在<code>[lo, mid - 1]</code>中寻找。</li>\n</ul>\n<p>代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">search</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>] == target ? <span class=\"number\">0</span> : <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> lo = <span class=\"number\">0</span>, hi = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(lo &lt;= hi)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> mid = (lo + hi) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[mid] == target) <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[<span class=\"number\">0</span>] &lt;= nums[mid])&#123;</span><br><span class=\"line\">                <span class=\"comment\">//这段有序，我们二分查找</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nums[<span class=\"number\">0</span>] &lt;= target &amp;&amp; target &lt; nums[mid])&#123;</span><br><span class=\"line\">                    hi = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    lo = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">//前面无序</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nums[mid] &lt; target &amp;&amp; target &lt;= nums[n - <span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//后面有序</span></span><br><span class=\"line\">                    lo = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    hi = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["二分查找"],"tags":["二分查找"]},{"title":"排序总结","url":"/2022/04/26/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/","content":"<p>知识框架：</p>\n<p><img src=\"排序总结/1.jpg\" /></p>\n<p><img src=\"排序总结/2.png\" /></p>\n<p>我们需要重点掌握<strong>快速排序，堆排序，归并排序</strong></p>\n<span id=\"more\"></span>\n<h1 id=\"基本概念\">1. 基本概念：</h1>\n<p>我们需要让排列表中的数据按关键字有序。例如<code>[1,2,3,4,5]</code>就是有序的。</p>\n<p><strong>算法的稳定性：</strong>假如排序表中有两个元素<code>a</code>和<code>b</code>，它们的关键字相同，在开始排序之前，<code>a</code>在<code>b</code>之前，排序之后，<code>a</code>还是在<code>b</code>之前，则称为<strong>稳定排序</strong>，反之，不稳定。</p>\n<h1 id=\"内部排序\">2. 内部排序</h1>\n<h2 id=\"插入排序\">2.1 插入排序</h2>\n<h3 id=\"直接插入排序\">2.1.1 直接插入排序</h3>\n<h3 id=\"折半插入排序\">2.1.2 折半插入排序</h3>\n<h3 id=\"希尔排序\">2.1.3 希尔排序</h3>\n<h2 id=\"交换排序\">2.2 交换排序</h2>\n<h3 id=\"冒泡排序\">2.2.1 冒泡排序</h3>\n<h3 id=\"快速排序\">2.2.2 快速排序</h3>\n<p>快速排序的思想是基于分治法的。</p>\n<h4 id=\"基本思想\">基本思想：</h4>\n<p>在待排序的表<code>L[1...n]</code>中任取一个元素<code>pivot</code>作为基准（通常取首元素），通过一趟排序后将待排序表划分为独立的两部分<code>L[1...k-1]</code>和<code>L[k+1...n]</code>，使得<code>L[1...k-1]</code>中的所有元素小于<code>pivot</code>，<code>L[k + 1...n]</code>中所有元素大于等于<code>pivot</code>，则<code>pivot</code>就放在了最终的位置上，这个过程称为一趟快速排序。然后分别递归对两个字表重复上述过程，直到每部分只有一个元素或空为止。</p>\n<blockquote>\n<p>ps: 需要了解一趟和一次的区别</p>\n</blockquote>\n<p>对此，我们可以得出一个结论，<strong>每趟快速排序都可以最小确定一个元素的位置。</strong></p>\n<p><img src=\"排序总结/3.jpg\" /></p>\n<p><strong>算法流程：</strong></p>\n<p>指针<code>j</code>从<code>high</code>往前搜，直到找到第一个小于基准<code>pivot = 49</code>的数<code>27</code>，将<code>27</code>交换到<code>i</code>所指的位置。</p>\n<p><img src=\"排序总结/4.jpg\" /></p>\n<p>指针<code>i</code>从<code>low</code>往后搜，直到找到第一个大于基准<code>pivot = 49</code>的数<code>65</code>，将<code>65</code>交换到<code>j</code>所指的位置。</p>\n<p><img src=\"排序总结/5.jpg\" /></p>\n<p>指针<code>j</code>从<code>high</code>往前搜，直到找到第一个小于基准<code>pivot = 49</code>的数<code>13</code>，将<code>13</code>交换到<code>i</code>所指的位置。</p>\n<p><img src=\"排序总结/6.jpg\" /></p>\n<p>指针<code>i</code>从<code>low</code>往后搜，直到找到第一个大于基准<code>pivot = 49</code>的数<code>97</code>，将<code>97</code>交换到<code>j</code>所指的位置。</p>\n<p><img src=\"排序总结/7.jpg\" /></p>\n<p>指针<code>j</code>继续往前搜索小于基准<code>pivot</code>的元素，直到<code>i == j</code></p>\n<p><img src=\"排序总结/8.jpg\" /></p>\n<p>这时候我们的第一趟排序也就完成了。</p>\n<p>然后我们递归以上过程，即可得到最终的答案。</p>\n<p><img src=\"排序总结/9.jpg\" /></p>\n<p>希望不理解的可以手动模拟多遍。</p>\n<p><strong>总结：</strong></p>\n<ul>\n<li>从后往前寻找比基准小的元素，然后和<code>i</code>交换</li>\n<li>从前往后寻找比基准大的元素，然后和<code>j</code>交换</li>\n<li>知道<code>i==j</code>我们停止继续搜索</li>\n<li>递归以上过程</li>\n</ul>\n<h4 id=\"时间和空间复杂度\">时间和空间复杂度：</h4>\n<p><strong>空间效率：</strong>由于快速排序是递归的，需要借用栈来辅助，其容量应与递归调用的最大深度一样，最好情况下为<code>O(logN)</code>，最坏情况下，需要进行<code>n-1</code>次递归，所以栈的深度为<code>O(N)</code>，平均情况下，栈的深度为<code>O(logN)</code>。</p>\n<p><strong>时间效率：</strong>\n<em>快速排序的运行时间与划分是否对称有关</em>，最坏情况发生在两个区域分别包含<code>n-1</code>和<code>0</code>个元素时，即程序基本有序或基本逆序，得到的最坏时间复杂度为<code>O(n^2)</code>。理想情况下，左右两个子列表都不大于<code>n/2</code>，时间复杂度为<code>O(nlogn)</code></p>\n<p><strong>稳定性：</strong>是不稳定的。例如给{3,<strong>2</strong>,2}，经过一趟排序后{2,<strong>2</strong>,3}，可以发现<code>2</code>的相对次序已经发生了改变，所以是不稳定的。</p>\n<p><strong>快速排序是所有内部排序算法中平均性能最优的排序算法</strong></p>\n<h4 id=\"代码如下\">代码如下：</h4>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ll;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">double</span> ld;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; pii;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> vector&lt;<span class=\"type\">int</span>&gt; vi;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//划分</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">partition</span><span class=\"params\">(vi&amp; nums, <span class=\"type\">int</span> lo, <span class=\"type\">int</span> hi)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//基准</span></span><br><span class=\"line\">    <span class=\"type\">int</span> pivot = nums[lo];</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(lo &lt; hi)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//从后往前找到第一个小于pivot的元素</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(lo &lt; hi &amp;&amp; nums[hi] &gt;= pivot) hi--;</span><br><span class=\"line\">        <span class=\"built_in\">swap</span>(nums[lo], nums[hi]);</span><br><span class=\"line\">        <span class=\"comment\">//从前往后找到第一个大于pivot的元素</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(lo &lt; hi &amp;&amp; nums[lo] &lt;= pivot) lo++;</span><br><span class=\"line\">        <span class=\"built_in\">swap</span>(nums[lo], nums[hi]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lo;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">quickSort</span><span class=\"params\">(vi&amp; nums, <span class=\"type\">int</span> lo, <span class=\"type\">int</span> hi)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(lo &lt; hi)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//划分操作，找到基准pivot 的位置</span></span><br><span class=\"line\">        <span class=\"type\">int</span> pivotPos = <span class=\"built_in\">partition</span>(nums, lo, hi);</span><br><span class=\"line\">        <span class=\"built_in\">quickSort</span>(nums, lo, pivotPos);</span><br><span class=\"line\">        <span class=\"built_in\">quickSort</span>(nums, pivotPos + <span class=\"number\">1</span>, hi);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    vi nums = &#123;<span class=\"number\">49</span>,<span class=\"number\">38</span>,<span class=\"number\">65</span>,<span class=\"number\">97</span>,<span class=\"number\">76</span>,<span class=\"number\">13</span>,<span class=\"number\">27</span>,<span class=\"number\">49</span>&#125;;</span><br><span class=\"line\">    <span class=\"type\">int</span> lo = <span class=\"number\">0</span>, hi = nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">quickSort</span>(nums, lo, hi);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= hi; i++)&#123;</span><br><span class=\"line\">        cout &lt;&lt; nums[i] &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"选择排序\">2.3 选择排序</h2>\n<h3 id=\"简单选择排序\">2.3.1 简单选择排序</h3>\n<h3 id=\"堆排序\">2.3.2 堆排序</h3>\n<h2 id=\"归并排序和基数排序\">2.4 归并排序和基数排序</h2>\n","categories":["排序"],"tags":["排序"]},{"title":"数组和字符串","url":"/2022/02/22/%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/","content":"<p>###堆和栈的区别</p>\n<span id=\"more\"></span>\n<p>##1.1 知识要点</p>\n<h3 id=\"数组\">1.1.1数组</h3>\n<p>在栈上创建：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> array[M][N];</span><br></pre></td></tr></table></figure>\n<p>在堆上创建：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> **array = <span class=\"keyword\">new</span> <span class=\"type\">int</span>*[M]; \\\\或者(<span class=\"type\">int</span>**) <span class=\"built_in\">malloc</span> (M * <span class=\"built_in\">sizeof</span>(<span class=\"type\">int</span>*))</span><br></pre></td></tr></table></figure>\n<p>数组可以通过下标随机访问元素，所以在修改、读取某个元素的时候效率很高，具有O(1)的时间复杂度。在插入、删除的时候为O(n)。</p>\n<h3 id=\"哈希表\">1.1.2 哈希表</h3>\n<p>哈希表(Hash\nTable)主要基于“键(key)“的查找，存储的基本元素是键-值对。</p>\n<p>哈希表的本质是当使用者提供一个键，根据哈希表自身定义的哈 希函数（Hash\nFunction），映射出一个下标，根据这个下标决定需要\n把当前的元素存储在什么位置。在一些合理的假设情况下，查找一个\n元素的平均时间复杂度是 O(1)，插入一个元素的平摊（amortized）\n时间复杂度是 O(1)。</p>\n<p>当对于不同的键，哈希函数提供相同的存储地址时，哈希表就遇\n到了所谓的冲突（collision）。解决冲突的方式有链接法（chaining）\n和开放地址法（Open Addressing）两种。简单来说，链接法相当于\n利用辅助数据结构（比如链表），将哈希函数映射出相同地址的那些\n元素链接起来。而开放地址法是指以某种持续的哈希方式继续哈希，\n直到产生的下标对应尚未被使用的存储地址，然后把当前元素存储在\n这个地址里。</p>\n<p>链接法实现相对简便，但是可能需要附加空间，并且利用\n当前空间的效率不如开放地址法高。开放地址法更需要合理设计的连\n续哈希函数，但是可以获得更好的空间使用效率。</p>\n<p>C++标准库中提供 map 容器，可以插入、删除、查找键-值对，底\n层以平衡二叉搜索树的方式实现，根据键进行了排序。严格来说，map\n并不是一个哈希表，原因是查找时间从 O(1)变为了 O(log n)，但是\n好处在于能够根据键值，顺序地输出元素，对于某些应用场景可能更 为合适。在\nC++11 中，标准库添加了 unordered_map，更符合哈希表\n的传统定义，平均查找时间 O(1)。</p>\n<p>###1.1.3 String</p>\n<p>在 C 语言中，字符串指的是一个以‘\\0’结尾的 char 数组。关\n于字符串的函数通常需要传入一个字符型指针。然而，在 C++ 中， String\n是一个类，并且可以通过调用类函数实现判断字符串长度等 等操作。</p>\n<h2 id=\"模式识别\">2.1 模式识别</h2>\n<h3 id=\"使用哈希表\">2.1.1 使用哈希表</h3>\n<p>当遇到某些题目需要统计元素集中一个元素出现的次数，应该直觉反应使用哈希表，即使用\nstd::unordered_map 或 std::map：键是\n元素，值是出现的次数。特别地，有一些题目仅仅需要判断元素出现\n与否（相当于判断值是 0 还是 1），可以用 bitvector，即 bitset，利 用一个\nbit 来表示当前的下标是否有值。</p>\n<p>​ 例题1：</p>\n<blockquote>\n<p><a\nhref=\"https://leetcode-cn.com/problems/is-unique-lcci/\">判断一个字符串所有的字符是否都是唯一的</a></p>\n</blockquote>\n<p>如果运用哈希表，我们可 以直接用字符作为键，出现的次数作为值。</p>\n<p>如果运用 bitset，我们需要建立字符到整数下标的映射关系。</p>\n<p><strong>复杂度分析</strong>：哈希表和 bitset\n做法都需要扫描整个字符串，每次插入操作时间复杂度 O(1)，假设字符串长度为\nn，则平均时间复杂 度都是\nO(n)。空间上，每个合法字符都有可能出现，假设字符集大小 为\nm，则平均空间是 O(m)。哈希表的数据结构需要占用更多空间，所以 bitset\n是更合理的数据结构。</p>\n<p><strong>参考答案：</strong></p>\n<p><strong>法一:</strong> 用hashmap</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isUnique</span><span class=\"params\">(string astr)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//判断位数</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(astr.<span class=\"built_in\">size</span>() &lt;= <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      unordered_map&lt;<span class=\"type\">char</span>,<span class=\"type\">int</span>&gt;mp;</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"type\">const</span> <span class=\"type\">char</span> c:astr)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(mp.<span class=\"built_in\">count</span>(c))&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        mp[c] = <span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>法二：先排序，看看是否存在相邻的两个字符相同的情况</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isUnique</span><span class=\"params\">(string astr)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//判断位数</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(astr.<span class=\"built_in\">size</span>() &lt;= <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      <span class=\"built_in\">sort</span>(astr.<span class=\"built_in\">begin</span>(),astr.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">      <span class=\"type\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"keyword\">while</span>(j != astr.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(astr[i] == astr[j])&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ++i;</span><br><span class=\"line\">        ++j;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>法三：位运算：</strong></p>\n<p>1、假如字符串不在['a'-'z']之间</p>\n<p>2、设置一个26位的二进制数，将其中某一位置为1表示对应的char字符，0000...0001（26位）表示a，用dist表示当前字符在二进制数中的位置。</p>\n<p>3、用now_post记录26个位置中有多少个位置已经出现1</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isUnique</span><span class=\"params\">(string astr)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"type\">int</span> dist = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"type\">int</span> now_pos = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"type\">const</span> <span class=\"type\">char</span> c:astr)&#123;</span><br><span class=\"line\">        dist = c -<span class=\"string\">&#x27;a&#x27;</span>;\t\t\t<span class=\"comment\">//得到所在的位置</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(now_pos &amp; <span class=\"number\">1</span> &lt;&lt; dist) &#123;\t<span class=\"comment\">//如果这个位置已经出现过1，即表示该字符已经出现过</span></span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        now_pos |= (<span class=\"number\">1</span>&lt;&lt;dist);\t\t\t<span class=\"comment\">//更新存在1的位置</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>例题2:</p>\n<blockquote>\n<p><a\nhref=\"https://leetcode-cn.com/problems/check-permutation-lcci/\">给定两个字符串，判断它们是否互为字符重排</a></p>\n</blockquote>\n<p><strong>解题分析：</strong></p>\n<p>​\n我们需要找到两个字符串之间的共同点，即通过某种映射，使得所有置换得到相同的结果。考虑到置换的特性：无论如何变化，每个字符出现的次数一定相同。<em>一旦需要统计\n一个元素集中元素出现的次数，我们就应该想到哈希表。</em></p>\n<p><strong>复杂度分析：</strong></p>\n<p>​ 哈希表需要扫描整个字符串，每次插入操作时间复 杂度\nO(1)，假设字符串的长度为 n，则平均时间复杂度都是 O(n)。最 后比较两个\nhash 是否相同，每个合法字符都有可能出现，假设字符 集大小为\nm，则需要的时间复杂度是 O(m)，故总的时间复杂度 O(m+n)。\n空间上，平均空间是 O(m)。</p>\n<p><strong>参考答案：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">CheckPermutation</span><span class=\"params\">(string s1, string s2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 若 s1, s2 长度不同，则不互为重排</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s1.<span class=\"built_in\">length</span>() != s2.<span class=\"built_in\">length</span>())</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化哈希表 dic</span></span><br><span class=\"line\">        unordered_map&lt;<span class=\"type\">char</span>, <span class=\"type\">int</span>&gt; dic;</span><br><span class=\"line\">        <span class=\"comment\">// 统计字符串 s1 各字符数量，遇到 +1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">char</span> c : s1) &#123;</span><br><span class=\"line\">            dic[c] += <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 统计字符串 s2 各字符数量，遇到 -1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">char</span> c : s2) &#123;</span><br><span class=\"line\">            dic[c] -= <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历 s1, s2 中各字符的数量差</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> kv : dic) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 若 s1, s2 中某字符的数量不一致，则不互为重排</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (kv.second != <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 所有字符数量都一致，因此互为重排</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"利用哈希表实现动态规划的思想\">2.1.2\n利用哈希表实现动态规划的思想</h3>\n<p>当处理当前节点需要依赖于之前的部分结果时，可以考虑使用哈希表记录之前的处理结果。\n其本质类似于动态规划（ Dynamic Programming），利用哈希表以\nO(1)的时间复杂度利用之前的结果。</p>\n<p>例4:</p>\n<blockquote>\n<p><a\nhref=\"https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/\">输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可</a></p>\n</blockquote>\n<p><strong>解题分析：</strong></p>\n","categories":["程序员面试白皮书","数组","字符串"],"tags":["字符串","数组"]},{"title":"数组去重unique函数","url":"/2022/04/10/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8Dunique%E5%87%BD%E6%95%B0/","content":"<h1 id=\"unique函数\">unique函数</h1>\n<p>我们很多时候需要去重。</p>\n<span id=\"more\"></span>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  vector&lt;<span class=\"type\">int</span>&gt; nums = &#123;<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>&#125;;</span><br><span class=\"line\">  <span class=\"comment\">//使用unique函数必须先排序</span></span><br><span class=\"line\">  <span class=\"built_in\">sort</span>(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">  <span class=\"comment\">//使用erase把重复的元素删除</span></span><br><span class=\"line\">  nums.<span class=\"built_in\">erase</span>(<span class=\"built_in\">unique</span>(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>()), nums.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); i++)&#123;</span><br><span class=\"line\">    cout &lt;&lt; nums[i] &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果为</p>\n<blockquote>\n<p>1 2 3 4</p>\n</blockquote>\n","categories":["数组","去重"],"tags":["数组","去重"]},{"title":"数组和指针的区别","url":"/2022/04/18/%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"<h1 id=\"数组和指针的区别\">数组和指针的区别</h1>\n<h2 id=\"概念\">1. 概念</h2>\n<ul>\n<li><strong>数组：</strong>数组是用于存储多个相同类型数据的集合。</li>\n<li><strong>指针：</strong>指针相当于一个变量，但是它和不同变量不一样，它存放的是其它变量在内存中的地址。</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"赋值存储方式求sizeof初始化\">2.\n赋值，存储方式，求sizeof，初始化</h2>\n<h3 id=\"赋值\">1.赋值</h3>\n<blockquote>\n<p>同类型指针变量可以相互赋值，数组不行，只能一个一个元素的赋值或者拷贝</p>\n</blockquote>\n<h3 id=\"存储方式\">2.存储方式</h3>\n<ul>\n<li><p><strong>数组：</strong>数组在内存中是连续存放的，开辟一块连续的内存空间。</p>\n<blockquote>\n<p>数组的存储空间，不是在静态区就数组在栈上</p>\n</blockquote></li>\n<li><p><strong>指针：</strong>指针可以指向任意类型的数据。指针的类型说明了它所指向地址空间的内存。</p>\n<blockquote>\n<p><strong>指针：由于指针本身就是一个变量，再加上它所存放的也是变量，所以指针的存储空间不能确定。</strong></p>\n</blockquote></li>\n</ul>\n<h3 id=\"求sizeof\">3. 求sizeof</h3>\n<ul>\n<li><p>数组</p>\n<blockquote>\n<p>数组所占存储空间的内存：sizeof（数组名）\n数组的大小：sizeof（数组名）/sizeof（数据类型）</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> a[] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"built_in\">sizeof</span>(a) &lt;&lt; endl;      <span class=\"comment\">// 16-&gt;sizeof(a)表示计算整个数组大小，一个int元素为4字节，4个元素，所以为16</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"built_in\">sizeof</span>(*a) &lt;&lt; endl;     <span class=\"comment\">// 4-&gt;对a解引用，就是首元素的大小，同上</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>指针：</p>\n<blockquote>\n<p>在32位平台下，无论指针的类型是什么，sizeof（指针名）都是4，在64位平台下，无论指针的类型是什么，sizeof（指针名）都是8。</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> *p = <span class=\"string\">&quot;abcde&quot;</span>;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"built_in\">sizeof</span>(p) &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"初始化\">4. 初始化</h2>\n","categories":["C++"],"tags":["C++"]},{"title":"最大子数组和","url":"/2022/04/27/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/","content":"<h1 id=\"最大子数组和\"><a\nhref=\"https://leetcode-cn.com/problems/maximum-subarray/\">53.\n最大子数组和</a></h1>\n<p>给你一个整数数组 <code>nums</code>\n，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>\n<p><strong>子数组</strong> 是数组中的一个连续部分。</p>\n<h2 id=\"示例\">示例：</h2>\n<blockquote>\n<p>输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组\n[4,-1,2,1] 的和最大，为 6 。</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"思路\">思路：</h3>\n<p>因为数组中存在负数，所以我们不能使用滑动窗口。</p>\n<p>定义<code>dp</code>数组：以<code>nums[i]</code>为结尾的「最大数组和」为<code>dp[i]</code></p>\n<p>假设我们已经知道了<code>dp[i-1]</code>，那么如何推导得到<code>dp[i]</code>呢？</p>\n<p>我们知道，<code>dp[i]</code>有两种选择，要么和前面的相邻子数组连接，形成一个更大的子数组，要么不与前面连接，自成一个子数组。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maxSubArray</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>( n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//定义 dp[i] 记录以 nums[i] 为结尾的「最大子数组和」</span></span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">        <span class=\"comment\">//base case: 第一个元素前面没有子数组</span></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"comment\">//状态转移方程</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            dp[i] = <span class=\"built_in\">max</span>(nums[i], nums[i] + dp[i - <span class=\"number\">1</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//得到 nums 的最大子数组</span></span><br><span class=\"line\">        <span class=\"type\">int</span> res = INT_MIN;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            res = <span class=\"built_in\">max</span>(res, dp[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>从状态转移方程可以看出</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">dp[i] = <span class=\"built_in\">max</span>(nums[i], nums[i] + dp[i - <span class=\"number\">1</span>])；</span><br></pre></td></tr></table></figure>\n<p><code>dp[i]</code>只与<code>dp[i-1]</code>有关。所以我们可以进行状态压缩。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maxSubArray</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>( n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// base case</span></span><br><span class=\"line\">        <span class=\"type\">int</span> dp_0 = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span> dp_1 = <span class=\"number\">0</span>, res = dp_0;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// dp[i] = max(nums[i], nums[i] + dp[i - 1]);</span></span><br><span class=\"line\">            dp_1 = <span class=\"built_in\">max</span>(nums[i], nums[i] + dp_0);</span><br><span class=\"line\">            <span class=\"comment\">//保存dp_1 变成下一次开始前的 dp_0</span></span><br><span class=\"line\">            dp_0 = dp_1;</span><br><span class=\"line\">            <span class=\"comment\">//计算最大结果</span></span><br><span class=\"line\">            res = <span class=\"built_in\">max</span>(res, dp_1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["动态规划"],"tags":["动态规划"]},{"title":"最小栈","url":"/2022/05/09/%E6%9C%80%E5%B0%8F%E6%A0%88/","content":"<h1 id=\"最小栈\"><a href=\"https://leetcode.cn/problems/min-stack/\">155.\n最小栈</a></h1>\n<p>设计一个支持\n<code>push</code>，<code>pop</code>，<code>top</code>操作，并能在常数时间内检索到最小元素的栈。</p>\n<p>实现 <code>MinStack</code>类:</p>\n<ul>\n<li><code>MinStack()</code> 初始化堆栈对象。</li>\n<li><code>void push(int val)</code> 将元素val推入堆栈。</li>\n<li><code>void pop()</code> 删除堆栈顶部的元素。</li>\n<li><code>int top()</code> 获取堆栈顶部的元素。</li>\n<li><code>int getMin()</code> 获取堆栈中的最小元素。</li>\n</ul>\n<h2 id=\"示例\">示例</h2>\n<blockquote>\n<p>输入：\n[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]\n[[],[-2],[0],[-3],[],[],[],[]]</p>\n<p>输出： [null,null,null,null,-3,null,0,-2]</p>\n<p>解释： MinStack minStack = new MinStack(); minStack.push(-2);\nminStack.push(0); minStack.push(-3); minStack.getMin(); --&gt; 返回 -3.\nminStack.pop(); minStack.top(); --&gt; 返回 0. minStack.getMin(); --&gt;\n返回 -2.</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"思路\">思路：</h2>\n<h4 id=\"方法一-辅助栈\">方法一： 辅助栈</h4>\n<p>栈是一种先进后出的线性表。</p>\n<p>对于栈来说，如果一个元素\n<code>a</code>在入栈时，栈里有其它的元素<code>b, c, d</code>,那么无论这个栈在之后经历了什么操作，只要\n<code>a</code>在栈中，<code>b, c, d</code> 就一定在栈中，因为在\n<code>a</code>被弹出之前，<code>b, c, d</code> 不会被弹出。</p>\n<p>因此，在操作过程中的任意一个时刻，只要栈顶的元素是\n<code>a</code>，那么我们就可以确定栈里面现在的元素一定是\n<code>a, b, c, d</code>。</p>\n<p>那么，我们可以在每个元素 <code>a</code>入栈时把当前栈的最小值\n<code>m</code>存储起来。在这之后无论何时，如果栈顶元素是\n<code>a</code>，我们就可以直接返回存储的最小值 <code>m</code>。</p>\n<p><img src=\"最小栈/155_fig1.gif\" /></p>\n<p><strong>算法：</strong></p>\n<p>按照上面的思路，我们只需要设计一个数据结构，使得每个元素\n<code>a</code>与其相应的最小值\n<code>m</code>时刻保持一一对应。因此我们可以使用一个辅助栈，与元素栈同步插入与删除，用于存储与每个元素对应的最小值。</p>\n<p>当一个元素要入栈时，我们取当前辅助栈的栈顶存储的最小值，与当前元素比较得出最小值，将这个最小值插入辅助栈中；</p>\n<p>当一个元素要出栈时，我们把辅助栈的栈顶元素也一并弹出；</p>\n<p>在任意一个时刻，栈内元素的最小值就存储在辅助栈的栈顶元素中。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MinStack</span> &#123;</span><br><span class=\"line\">    stack&lt;<span class=\"type\">int</span>&gt; st;</span><br><span class=\"line\">    stack&lt;<span class=\"type\">int</span>&gt; min_stack;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">MinStack</span>() &#123;</span><br><span class=\"line\">        min_stack.<span class=\"built_in\">push</span>(INT_MAX);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"type\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        st.<span class=\"built_in\">push</span>(val);</span><br><span class=\"line\">        min_stack.<span class=\"built_in\">push</span>(<span class=\"built_in\">min</span>(min_stack.<span class=\"built_in\">top</span>(), val));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        st.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        min_stack.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">top</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> st.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getMin</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> min_stack.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二一个栈\">方法二：一个栈</h4>\n<p>我们每次存入的是 <strong>原来值 - 当前最小值</strong>。</p>\n<p>当原来值大于等于当前最小值的时候，我们存入的肯定就是非负数，所以出栈的时候就是\n<strong>栈中的值 + 当前最小值 。</strong></p>\n<p>当原来值小于当前最小值的时候，我们存入的肯定就是负值，此时的值我们不入栈，用\n<code>min</code>保存起来，同时将差值入栈。</p>\n<p>当后续如果出栈元素是负数的时候，那么要出栈的元素其实就是\n<code>min</code>。此外之前的\n<code>min</code>值，我们可以通过栈顶的值和当前\n<code>min</code>值进行还原，就是用\n<code>min</code>减去栈顶元素即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MinStack</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> minVal;</span><br><span class=\"line\">    stack&lt;<span class=\"type\">long</span>&gt; min_stack;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">MinStack</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"type\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(min_stack.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">            minVal = val;</span><br><span class=\"line\">            min_stack.<span class=\"built_in\">push</span>(val - minVal);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            min_stack.<span class=\"built_in\">push</span>(val - minVal);</span><br><span class=\"line\">            <span class=\"comment\">//更新最小值</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(val &lt; minVal)&#123;</span><br><span class=\"line\">                minVal = val;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//判空</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(min_stack.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">long</span> popVal = min_stack.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        min_stack.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"comment\">//如果弹出的是负数，则更新最小值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(popVal &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            minVal = minVal - popVal;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">top</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">long</span> topVal = min_stack.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(topVal &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//直接返回最小值</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> (<span class=\"type\">int</span>)(minVal);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//返回最小值加上当前栈顶值</span></span><br><span class=\"line\">            <span class=\"built_in\">return</span> (<span class=\"type\">int</span>)(topVal + minVal);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getMin</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"type\">int</span>)(minVal);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["栈"],"tags":["栈"]},{"title":"最大连续子串长度","url":"/2022/04/11/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E4%B8%B2%E9%95%BF%E5%BA%A6/","content":"<h1 id=\"最大连续子串长度\">最大连续子串长度</h1>\n<p><strong>■ 题目描述</strong></p>\n<p>给定字符串A、B和正整数V，A的长度与B的长度相等，\n请计算A中满足如下条件的最大连续子串的长度：</p>\n<ol type=\"1\">\n<li>该连续子串在A和B中的位置和长度均相同。</li>\n<li>该连续子串 <strong>|A[i] – B[i]|</strong> 之和小于等于V。其中\n<strong>|A[i] – B[i]|</strong> 表示两个字母ASCII码之差的绝对值。</li>\n</ol>\n<p><strong>输入描述：</strong></p>\n<ul>\n<li>输入为三行： 第一行为字符串A，仅包含小写字符，1 &lt;= A.length &lt;=\n1000。</li>\n<li>第二行为字符串B，仅包含小写字符，1 &lt;= B.length &lt;= 1000。</li>\n<li>第三行为正整数V，0 &lt;= V &lt;= 10000。</li>\n</ul>\n<p><strong>输出描述：</strong></p>\n<ul>\n<li>字符串最大连续子串的长度，要求该子串 <strong>|A[i] – B[i]|</strong>\n之和小于等于V。</li>\n</ul>\n<p><strong>示例 1</strong>\n输入输出示例仅供调试，后台判题数据一般不包含示例</p>\n<p><strong>输入</strong></p>\n<blockquote>\n<p>xxcdefg cdefghi 5</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"思路\">思路：</h2>\n<p>我们先计算出最长公共子串，并且保证最长公共子串的<span\nclass=\"math inline\">\\(|A[i] - B[i]| &lt;= N\\)</span></p>\n<p>那我们应该如何求最长公共子串呢？</p>\n<p>这里我们采用动态规划，那首先要确定的就是「状态」和「选择」。</p>\n<ul>\n<li><strong>状态：</strong> 就是此时所指的字符</li>\n<li><strong>选择：</strong> 就是现在是上面移动还是下面移动</li>\n</ul>\n<p><code>dp[i][j] 表示 s1 前 i 个字符和 s2 前 j 个字符（以其为尾字符）的最长公共子串长度</code></p>\n<p>现在我们确定转移方程：</p>\n<ul>\n<li>当<code>s1[i] == s2[j]</code>时，很明显我们的\n<code>dp[i][j] = dp[i-1][j-1] + 1</code></li>\n<li><code>s1[i] != s2[j]</code>时，<code>dp[i][j] = 0</code></li>\n<li>判断此时<code>dp[i][j] &gt; maxlen &amp;&amp; abs(j - i) &lt;= N</code></li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ll;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">double</span> ld;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; pii;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> vector&lt;<span class=\"type\">int</span>&gt; vi;</span><br><span class=\"line\"><span class=\"type\">int</span> N;</span><br><span class=\"line\"><span class=\"type\">int</span> res;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">LCS</span><span class=\"params\">(string s1, string s2)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> m = s1.<span class=\"built_in\">size</span>(), n = s2.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"comment\">//dp[i][j] 表示 s1 前 i 个字符和 s2 前 j 个字符（以其为尾字符）的最长公共子串长度</span></span><br><span class=\"line\">    <span class=\"type\">int</span> dp[m + <span class=\"number\">1</span>][n+<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"type\">int</span> maxlen = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= m; i++) dp[i][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= n; i++) dp[<span class=\"number\">0</span>][i] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s1[i - <span class=\"number\">1</span>] == s2[j - <span class=\"number\">1</span>]) dp[i][j] = dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> dp[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dp[i][j] &gt; maxlen &amp;&amp; <span class=\"built_in\">abs</span>(j - i) &lt;= N)&#123;</span><br><span class=\"line\">                maxlen = dp[i][j];</span><br><span class=\"line\">                res = <span class=\"built_in\">abs</span>(j - i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//先求公共子串</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    string s1, s2;</span><br><span class=\"line\">    cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class=\"line\">    cin &gt;&gt; N;</span><br><span class=\"line\">    <span class=\"built_in\">LCS</span>(s1,s2);</span><br><span class=\"line\">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["字符串","动态规划"],"tags":["动态规划","字符串","华为机试"]},{"title":"最小路径和","url":"/2022/04/27/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/","content":"<p>#<a href=\"https://leetcode-cn.com/problems/minimum-path-sum/\">64.\n最小路径和</a></p>\n<p>给定一个包含非负整数的 <code>m x n</code> 网格 <code>grid</code>\n，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>\n<p><strong>说明：</strong>每次只能向下或者向右移动一步。</p>\n<h2 id=\"示例\">示例：</h2>\n<p><img src=\"最小路径和/minpath.jpg\" /></p>\n<blockquote>\n<p>输入：grid = [[1,3,1],[1,5,1],[4,2,1]] 输出：7 解释：因为路径\n1→3→1→1→1 的总和最小。</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"思路\">思路：</h3>\n<p><img src=\"最小路径和/1.jpg\" /></p>\n<p>我们想计算从<code>D</code>达到<code>B</code>的最小路径和，那我们就要解决如何才到到达<code>B</code>，因为只能向下或者向右移动一步，所以<code>B</code></p>\n<p>只能是从<code>A</code>或者<code>C</code>过来的，那么我们如何确定是从<code>A</code>过来的，而不是从<code>C</code>过来的，难道是因为<code>A</code>比<code>c</code>小吗？</p>\n<p><strong>当然不是，因为从<code>D</code>走到<code>A</code>的最小路径和为<code>6</code>，也就是上面橙色的部分，而从<code>D</code>走到<code>C</code>的最小路径和为<code>8</code>(1-&gt;1-&gt;4-&gt;2)，所以一定是从<code>A</code>走到<code>B</code></strong></p>\n<p>这样我们就把「从<code>D</code>走到<code>B</code>的最小路径和」这个问题转换为了「从<code>D</code>走到<code>A</code>的最小路径和」和「从<code>D</code>走到<code>C</code>的最小路径和」,这样就可以得出状态转移方程</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">min</span>(<span class=\"built_in\">dp</span>(i - <span class=\"number\">1</span>, j), <span class=\"built_in\">dp</span>(i, j - <span class=\"number\">1</span>)) + nums[i][j]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; memo;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">minPathSum</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> m = grid.<span class=\"built_in\">size</span>(), n = grid[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(m == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        memo.<span class=\"built_in\">resize</span>(m, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(n, <span class=\"number\">-1</span>));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">dp</span>(grid, m - <span class=\"number\">1</span>, n - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dp</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt;&amp; grid, <span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> m = grid.<span class=\"built_in\">size</span>(), n = grid[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"comment\">//base case</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x == <span class=\"number\">0</span> &amp;&amp; y == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> grid[<span class=\"number\">0</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x &lt; <span class=\"number\">0</span> || y &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果索引出界，返回一个很大的值，保证在取 min 的时候不会取到</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> INT_MAX;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(memo[x][y] != <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> memo[x][y];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      \t<span class=\"comment\">//状态转移方程</span></span><br><span class=\"line\">        memo[x][y] = <span class=\"built_in\">min</span>(<span class=\"built_in\">dp</span>(grid, x - <span class=\"number\">1</span>, y), <span class=\"built_in\">dp</span>(grid, x, y - <span class=\"number\">1</span>)) + grid[x][y];</span><br><span class=\"line\">        <span class=\"keyword\">return</span> memo[x][y];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>我们借用了一个备忘录来处理重叠子问题。</p>\n<p>时间和空间复杂度都为<code>O(MN)</code>。</p>\n<p><strong>迭代：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">minPathSum</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> m = grid.<span class=\"built_in\">size</span>(), n = grid[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(m == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; <span class=\"built_in\">dp</span>(m, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(n, <span class=\"number\">0</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = grid[<span class=\"number\">0</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"comment\">//计算最左边</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; m; i++)&#123;</span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>] = dp[i - <span class=\"number\">1</span>][<span class=\"number\">0</span>] + grid[i][<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//计算最上边</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt; n; j++)&#123;</span><br><span class=\"line\">            dp[<span class=\"number\">0</span>][j] = dp[<span class=\"number\">0</span>][ j - <span class=\"number\">1</span>] + grid[<span class=\"number\">0</span>][j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; m; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt; n; j++)&#123;</span><br><span class=\"line\">                dp[i][j] = <span class=\"built_in\">min</span>(dp[i - <span class=\"number\">1</span>][j], dp[i][j - <span class=\"number\">1</span>]) + grid[i][j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m - <span class=\"number\">1</span>][n - <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["动态规划"],"tags":["动态规划"]},{"title":"最近公共祖先问题","url":"/2022/05/08/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E9%97%AE%E9%A2%98/","content":"<h1 id=\"二叉树的最近公共祖先\"><a\nhref=\"https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/\">236.\n二叉树的最近公共祖先</a></h1>\n<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>\n<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点\n<code>p</code>、<code>q</code>，最近公共祖先表示为一个节点\n<code>x</code>，满足 <code>x</code>是\n<code>p</code>、<code>q</code>的祖先且\n<code>x</code>的深度尽可能大（一个节点也可以是它自己的祖先）。</p>\n<h2 id=\"示例\">示例：</h2>\n<p><img src=\"最近公共祖先问题/binarytree.png\" /></p>\n<blockquote>\n<p>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 输出：3\n解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</p>\n<p>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 输出：5\n解释：节点 5 和节点 4 的最近公共祖先是节点 5\n。因为根据定义最近公共祖先节点可以为节点本身。</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"思路\">思路：</h3>\n<p>祖先的定义： 若节点 <code>p</code>在节点\n<code>root</code>的左（右）子树中，或\n<code>p = root</code>，则称<code>root</code> 是<code>p</code>\n的祖先。</p>\n<p>最近公共祖先的定义： 设节点<code>root</code> 为节点\n<code>p,q</code>的某公共祖先，若其左子节点\n<code>root-&gt;left</code>和右子节点<code>root-&gt;right</code>都不是<code>p,q</code>\n的公共祖先，则称 <code>root</code>是 “最近的公共祖先” 。</p>\n<p>根据以上定义：若<code>root</code>是<code>p</code>，<code>q</code>的<strong>最近公共祖先</strong></p>\n<ul>\n<li><code>p</code>和<code>q</code>在<code>root</code>的左或右子树中。</li>\n<li><code>p= root</code>，<code>q</code>在<code>root</code>的左或右子树中</li>\n<li><code>q = root</code>，<code>p</code>在<code>root</code>的左或右子树中</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">TreeNode</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> val;</span><br><span class=\"line\">    TreeNode *left;</span><br><span class=\"line\">    TreeNode *right;</span><br><span class=\"line\">    <span class=\"built_in\">TreeNode</span>() : <span class=\"built_in\">val</span>(<span class=\"number\">0</span>), <span class=\"built_in\">left</span>(<span class=\"literal\">nullptr</span>), <span class=\"built_in\">right</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">TreeNode</span>(<span class=\"type\">int</span> x) : <span class=\"built_in\">val</span>(x), <span class=\"built_in\">left</span>(<span class=\"literal\">nullptr</span>), <span class=\"built_in\">right</span>(<span class=\"literal\">nullptr</span>) &#123;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">TreeNode</span>(<span class=\"type\">int</span> x, TreeNode *left, TreeNode *right) : <span class=\"built_in\">val</span>(x), <span class=\"built_in\">left</span>(left), <span class=\"built_in\">right</span>(right) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">lowestCommonAncestor</span><span class=\"params\">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">find</span>(root, p-&gt;val, q-&gt;val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">find</span><span class=\"params\">(TreeNode *root, <span class=\"type\">int</span> val1, <span class=\"type\">int</span> val2)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"comment\">//前序位置,如果p,q为根节点，则公共祖先为根节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root-&gt;val == val1 || root-&gt;val == val2)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        TreeNode *left = <span class=\"built_in\">find</span>(root-&gt;left, val1, val2);</span><br><span class=\"line\">        TreeNode *right = <span class=\"built_in\">find</span>(root-&gt;right, val1, val2);</span><br><span class=\"line\">        <span class=\"comment\">//如果p,q为在单独一边，则去那边找</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(left == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> right;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(right == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> left;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//后序位置，p,q在两边</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(left != <span class=\"literal\">nullptr</span> &amp;&amp; right != <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//当前节点为 LCA 节点</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"二叉搜索树的最近公共祖先\"><a\nhref=\"https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/\">235.\n二叉搜索树的最近公共祖先</a></h1>\n<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>\n<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点\n<code>p</code>、<code>q</code>，最近公共祖先表示为一个结点\n<code>x</code>，满足 <code>x</code>是\n<code>p</code>、<code>q</code>的祖先且\n<code>x</code>的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>\n<p>例如，给定如下二叉搜索树:\n<code>root = [6,2,8,0,4,7,9,null,null,3,5</code>]</p>\n<h2 id=\"示例-1\">示例；</h2>\n<p><img src=\"最近公共祖先问题/binarytree.png\" /></p>\n<blockquote>\n<p>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 输出: 6\n解释: 节点 2 和节点 8 的最近公共祖先是 6。</p>\n</blockquote>\n<h3 id=\"思路-1\">思路：</h3>\n<p>用上面的方法可以做出来，但是没有用到二叉搜索树左小右大的性质，效率比较低。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">lowestCommonAncestor</span><span class=\"params\">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> val1 = <span class=\"built_in\">min</span>(p-&gt;val, q-&gt;val);</span><br><span class=\"line\">        <span class=\"type\">int</span> val2 = <span class=\"built_in\">max</span>(p-&gt;val, q-&gt;val);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">find</span>(root, val1, val2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">find</span><span class=\"params\">(TreeNode *root, <span class=\"type\">int</span> val1, <span class=\"type\">int</span> val2)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"comment\">//比最大的大，去左边找</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root-&gt;val &gt; val2)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">find</span>(root-&gt;left, val1, val2);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//比最小的小，去右边找</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root-&gt;val &lt; val1)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">find</span>(root-&gt;right, val1, val2);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["最近公共祖先"],"tags":["二叉树","最近公共祖先"]},{"title":"最长公共子序列","url":"/2022/04/14/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/","content":"<h1 id=\"最长公共子序列\"><a\nhref=\"https://leetcode-cn.com/problems/longest-common-subsequence/\">1143.\n最长公共子序列</a></h1>\n<p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列\n的长度。如果不存在 公共子序列 ，返回 0 。</p>\n<p>一个字符串的 子序列\n是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>\n<p>例如，\"ace\" 是 \"abcde\" 的子序列，但 \"aec\" 不是 \"abcde\" 的子序列。\n两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p>\n<h2 id=\"示例\">示例：</h2>\n<blockquote>\n<p>输入：text1 = \"abcde\", text2 = \"ace\" 输出：3<br />\n解释：最长公共子序列是 \"ace\" ，它的长度为 3 。</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"思路\">思路：</h3>\n<p><strong>对于两个字符串求子序列的问题，都是用两个指针<code>i</code>和<code>j</code>分别在两个字符串上移动，大概率是动态规划思路</strong>。</p>\n<p>我们定义一个<code>dp[i][j]</code>表示：<strong><code>s1[0...i-1]</code>和<code>s2[0...j-1]</code>的\nLCS的长度为 <code>dp[i][j]</code> </strong></p>\n<p><strong>接下来，咱不要看<code>s1</code>和<code>s2</code>两个字符串，而是要具体到每一个字符，思考每个字符该做什么</strong>。</p>\n<p><img src=\"最长公共子序列/1.jpg\" /></p>\n<p>我们只看<code>s1[i]</code>和<code>s2[j]</code>，<strong>如果<code>s1[i] == s2[j]</code>，说明这个字符一定在<code>lcs</code>中</strong>：</p>\n<p><img src=\"最长公共子序列/2.jpg\" /></p>\n<p>这样，就找到了一个<code>lcs</code>中的字符，根据<code>dp</code>函数的定义，我们可以完善一下代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(s1[i] == s2[j])&#123;</span><br><span class=\"line\">  dp[i][j] = dp[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果<code>s1[i] != s2[j]</code>，<strong>意味着，<code>s1[i]</code>和<code>s2[j]</code>中至少有一个字符不在<code>lcs</code>中</strong>：</p>\n<p><img src=\"最长公共子序列/3.jpg\" /></p>\n<p>我们只需要计算这三种情况中的最大值。</p>\n<p>可以发现情况三其实可以忽略，因为我们要求的是最长公共子序列，情况一和情况二肯定会比情况三长。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(s1[i] != s2[j])&#123;</span><br><span class=\"line\">  dp[i][j] = <span class=\"built_in\">max</span>(dp[i<span class=\"number\">-1</span>][j], dp[i][j<span class=\"number\">-1</span>]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>完整代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">longestCommonSubsequence</span><span class=\"params\">(string text1, string text2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> m = text1.<span class=\"built_in\">size</span>(), n = text2.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"comment\">//初始化为0,表示最长公共子序列长度为0</span></span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; <span class=\"built_in\">dp</span>(m + <span class=\"number\">1</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt; (n + <span class=\"number\">1</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(text1[i - <span class=\"number\">1</span>] == text2[j - <span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                    dp[i][j] = dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//至少有一个不在 LCS 中</span></span><br><span class=\"line\">                    dp[i][j] = <span class=\"built_in\">max</span>(dp[i][j - <span class=\"number\">1</span>], dp[i - <span class=\"number\">1</span>][j]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m][n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>为了加深理解，我们可以自己手推一下<code>dp</code>数组。</p>\n<p>假设<code>s1 = abecbab</code>,<code>s2 = bdcbabb</code></p>\n<p>相等时，<code>dp[i][j] = dp[i-1][j-1] + 1</code>，也就是左上角元素➕1</p>\n<p>不等时，<code>dp[i][j] = max(dp[i-1][j], dp[i][j-1])</code>，左边和上边的最大值</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th style=\"text-align: center;\"></th>\n<th>a</th>\n<th>b</th>\n<th>e</th>\n<th>c</th>\n<th>b</th>\n<th>a</th>\n<th>b</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td style=\"text-align: center;\">b</td>\n<td>0</td>\n<td><code>1</code></td>\n<td>1</td>\n<td>1</td>\n<td><code>1</code></td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: center;\">d</td>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: center;\">c</td>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td><code>2</code></td>\n<td>2</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: center;\">b</td>\n<td>0</td>\n<td><code>1</code></td>\n<td>1</td>\n<td>2</td>\n<td><code>3</code></td>\n<td>3</td>\n<td><code>3</code></td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: center;\">a</td>\n<td><code>1</code></td>\n<td>1</td>\n<td>1</td>\n<td>2</td>\n<td>3</td>\n<td><code>4</code></td>\n<td>4</td>\n</tr>\n<tr class=\"even\">\n<td style=\"text-align: center;\">b</td>\n<td>1</td>\n<td><code>2</code></td>\n<td>2</td>\n<td>2</td>\n<td><code>3</code></td>\n<td>4</td>\n<td><code>5</code></td>\n</tr>\n<tr class=\"odd\">\n<td style=\"text-align: center;\">b</td>\n<td>1</td>\n<td><code>2</code></td>\n<td>2</td>\n<td>2</td>\n<td><code>3</code></td>\n<td>4</td>\n<td><code>5</code></td>\n</tr>\n</tbody>\n</table>\n<p>所以最终我们的结果就为<code>dp[m][n] = 5</code></p>\n<p>现在我们求出了最长公共子序列的长度，假如需要我们输出任意一个路径，我们应该如何写呢？</p>\n<p>这里我们先简单的提一下思路：</p>\n<p>我们可以根据我们得到的<code>dp</code>数组，从后往前递推。</p>\n<p><img src=\"最长公共子序列/4.jpg\" /></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ll;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">double</span> ld;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; pii;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> vector&lt;<span class=\"type\">int</span>&gt; vi;</span><br><span class=\"line\"></span><br><span class=\"line\">string s1,s2;</span><br><span class=\"line\">vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; dp;</span><br><span class=\"line\">unordered_set&lt;string&gt; lcs;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">longestCommonSubsequence</span><span class=\"params\">(string text1, string text2)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = text1.<span class=\"built_in\">size</span>(), m = text2.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"comment\">//初始化为-1，表示没有计算过</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= m; j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(text1[i - <span class=\"number\">1</span>] == text2[j - <span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                dp[i][j] = <span class=\"number\">1</span> + dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">//至少有一个不在 lcs 中</span></span><br><span class=\"line\">                dp[i][j] = <span class=\"built_in\">max</span>(dp[i][j - <span class=\"number\">1</span>], dp[i - <span class=\"number\">1</span>][j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[n][m];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print_lcs</span><span class=\"params\">(<span class=\"type\">int</span> i, <span class=\"type\">int</span> j, string lcs_str)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &gt; <span class=\"number\">0</span> &amp;&amp; j &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s1[i<span class=\"number\">-1</span>] == s2[j<span class=\"number\">-1</span>])&#123;</span><br><span class=\"line\">            lcs_str.<span class=\"built_in\">push_back</span>(s1[i<span class=\"number\">-1</span>]);</span><br><span class=\"line\">            --i;</span><br><span class=\"line\">            --j;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dp[i<span class=\"number\">-1</span>][j] &gt; dp[i][j<span class=\"number\">-1</span>]) --i;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(dp[i<span class=\"number\">-1</span>][j] &lt; dp[i][j<span class=\"number\">-1</span>]) --j;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">//两个dp值相同</span></span><br><span class=\"line\">                <span class=\"built_in\">print_lcs</span>(i<span class=\"number\">-1</span>,j,lcs_str);</span><br><span class=\"line\">                <span class=\"built_in\">print_lcs</span>(i,j<span class=\"number\">-1</span>,lcs_str);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">reverse</span>(lcs_str.<span class=\"built_in\">begin</span>(), lcs_str.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    lcs.<span class=\"built_in\">insert</span>(lcs_str);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    s1 = <span class=\"string\">&quot;abcbdab&quot;</span>;</span><br><span class=\"line\">    s2 = <span class=\"string\">&quot;bdcaba&quot;</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> s1_len = s1.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"type\">int</span> s2_len = s2.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    dp.<span class=\"built_in\">resize</span>(s1_len + <span class=\"number\">1</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(s2_len + <span class=\"number\">1</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\">    <span class=\"type\">int</span> res = <span class=\"built_in\">longestCommonSubsequence</span>(s1,s2);</span><br><span class=\"line\">    cout &lt;&lt; res &lt;&lt; <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">    string str;</span><br><span class=\"line\">    <span class=\"built_in\">print_lcs</span>(s1_len,s2_len,str);</span><br><span class=\"line\">    unordered_set&lt;string&gt;::iterator it = lcs.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(; it != lcs.<span class=\"built_in\">end</span>(); it++)&#123;</span><br><span class=\"line\">        cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["动态规划"],"tags":["动态规划","leetcode"]},{"title":"最长有效括号","url":"/2022/04/25/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/","content":"<h1 id=\"最长有效括号\"><a\nhref=\"https://leetcode-cn.com/problems/longest-valid-parentheses/\">32.\n最长有效括号</a></h1>\n<p>给你一个只包含 <code>'('</code> 和 <code>')'</code>\n的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p>\n<h2 id=\"示例\">示例：</h2>\n<blockquote>\n<p>输入：s = \"(()\" 输出：2 解释：最长有效括号子串是 \"()\"</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"思路\">思路：</h3>\n<p>####<strong>方法一：栈</strong></p>\n<p>具体做法是我们始终保持栈底元素为当前已经遍历过的元素中「最后一个没有被匹配的右括号的下标」，</p>\n<p>这样的做法主要是考虑了边界条件的处理，栈里其他元素维护左括号的下标：</p>\n<ul>\n<li><p>对于遇到的每个<code>'('</code>，我们将它的下标放入栈中</p></li>\n<li><p>对于遇到的每个<code>')'</code>,我们先弹出栈顶元素表示匹配了当前右括号：</p>\n<ul>\n<li><p>如果栈为空，说明当前的右括号为没有被匹配的右括号，我们将其下标放入栈中来更新我们之前提到的「最后一个没有被匹配的右括号的下标」</p></li>\n<li><p>如果栈不为空，当前右括号的下标减去栈顶元素即为「以该右括号为结尾的最长有效括号的长度」</p></li>\n</ul></li>\n</ul>\n<p><img src=\"最长有效括号/1.jpg\" /></p>\n<p><img src=\"最长有效括号/2.jpg\" /></p>\n<p><img src=\"最长有效括号/3.jpg\" /></p>\n<p><img src=\"最长有效括号/4.jpg\" /></p>\n<p><img src=\"最长有效括号/5.jpg\" /></p>\n<p><img src=\"最长有效括号/6.jpg\" /></p>\n<p><img src=\"最长有效括号/7.jpg\" /></p>\n<p><img src=\"最长有效括号/8.jpg\" /></p>\n<p><img src=\"最长有效括号/9.jpg\" /></p>\n<p><img src=\"最长有效括号/10.jpg\" /></p>\n<p>到此我们可以写出如下代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">longestValidParentheses</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> maxLen = <span class=\"number\">0</span>;</span><br><span class=\"line\">        stack&lt;<span class=\"type\">int</span>&gt; st;</span><br><span class=\"line\">        st.<span class=\"built_in\">push</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; s.<span class=\"built_in\">size</span>(); i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[i] == <span class=\"string\">&#x27;(&#x27;</span>)&#123;</span><br><span class=\"line\">                st.<span class=\"built_in\">push</span>(i);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                st.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(st.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//栈为空，则把这个右括号入栈</span></span><br><span class=\"line\">                    st.<span class=\"built_in\">push</span>(i);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    maxLen = <span class=\"built_in\">max</span>(maxLen, i - st.<span class=\"built_in\">top</span>());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxLen;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"方法二动态规划\">方法二：动态规划</h4>\n<p>首先，我们定义一个 <code>dp</code>数组，其中第 <code>i</code>\n个元素表示以下标为 <code>i</code>\n的字符结尾的最长有效子字符串的长度。</p>\n<p>我们先看第<code>i</code>个位置，这个位置的元素<code>s[i]</code>可能有如下两种情况：</p>\n<ul>\n<li><p><code>s[i]=='('</code>：</p>\n<blockquote>\n<p>这时，<code>s[i]</code>无法和之前的元素组成有效的括号对，所以<code>dp[i] = 0</code></p>\n</blockquote></li>\n<li><p><code>s[i] == ')'</code>:</p>\n<p>这时需要看其前面元素来判断是否有有效括号对。</p>\n<ul>\n<li><p>情况一：<code>s[i - 1] == '('</code>:</p>\n<blockquote>\n<p>即<code>s[i]</code>和<code>s[i-1]</code>组成一对有效括号，有效括号新增长度\n2\n，<code>i</code>位置的最长有效括号长度为<strong>其之前两个位置的最长括号长度加上当前新增的\n2</strong></p>\n<p>即：</p>\n<p><code>dp[i] = dp[i - 2] + 2</code></p>\n</blockquote></li>\n<li><p>情况二：<code>s[i - 1] == ')'</code>:</p>\n<blockquote>\n<p>这种情况下，如果前面有和<code>s[i]</code>组成有效括号对的字符，即形如<code>((...))</code>，就要求<code>s[i - 1]</code>位置必然是有效的括号对，否则<code>s[i]</code>无法和前面组成有效括号对。</p>\n<p>这时，我们只需要找到和<code>s[i]</code>配对的括号位置，并判断其是否配对。</p>\n<p>和其配对的位置为：<code>i - 1 - dp[i-1]</code>。因为如果<code>s[i]</code>为有效的话<code>s[i-1]</code>也必然有效，而<code>s[i-1]</code>表示的是以<code>i-1</code>为结尾的最长有效子字符串的长度，所以和<code>s[i]</code>配对的括号位置为:<code>i - 1 - dp[i - 1]</code>。</p>\n<ul>\n<li><p>如果<code>s[i - 1 - dp[i-1]] == '('</code>：</p>\n<p>有效括号长度新增 2， 即<code>dp[i] = dp[i - 1] + 2</code></p></li>\n</ul>\n<p>这里需要注意的是，我们还需要加上<code>dp[i - 2 - dp[i - 1]]</code>这个位置的最长有效子字符串的长度，（也就是和<code>s[i]</code>配对的括号的前一个的最长有效子字符串长度）</p>\n<p>即：</p>\n<p><code>dp[i] = dp[i] + dp[i - 2 + dp[i - 1]]</code></p>\n</blockquote></li>\n</ul></li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">longestValidParentheses</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(n, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s[i] == <span class=\"string\">&#x27;)&#x27;</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//匹配</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(s[i - <span class=\"number\">1</span>] == <span class=\"string\">&#x27;(&#x27;</span>)&#123;</span><br><span class=\"line\">                    dp[i] = <span class=\"number\">2</span>;</span><br><span class=\"line\">                    <span class=\"comment\">//判断前面是不是匹配</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(i - <span class=\"number\">2</span> &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                        dp[i] = dp[i] + dp[i - <span class=\"number\">2</span>];</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(dp[i - <span class=\"number\">1</span>] &gt;= <span class=\"number\">0</span>)&#123;<span class=\"comment\">//代表s[i]前面的匹配了</span></span><br><span class=\"line\">                    <span class=\"comment\">//(i - 1) - dp[i - 1]这个含义就是当前下标减去当前下标对应最长有效括号长度,</span></span><br><span class=\"line\">                    <span class=\"comment\">//也就是当前索引下的对应最长有效括号的前一个下标</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>((i - <span class=\"number\">1</span> - dp[i - <span class=\"number\">1</span>]) &gt;= <span class=\"number\">0</span> &amp;&amp; s[i - <span class=\"number\">1</span> - dp[i - <span class=\"number\">1</span>]] == <span class=\"string\">&#x27;(&#x27;</span>)&#123;</span><br><span class=\"line\">                        dp[i] = dp[i - <span class=\"number\">1</span>] + <span class=\"number\">2</span>;</span><br><span class=\"line\">                       <span class=\"comment\">//加上和s[i]配对的括号的前一个字符的最长有效子字符串长度</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(i - <span class=\"number\">2</span> - dp[i - <span class=\"number\">1</span>] &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                            dp[i] = dp[i] + dp[i - <span class=\"number\">2</span> - dp[i - <span class=\"number\">1</span>]];</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res = <span class=\"built_in\">max</span>(res, dp[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["括号"],"tags":["动态规划","栈"]},{"title":"最长等差数列","url":"/2022/04/12/%E6%9C%80%E9%95%BF%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97/","content":"<h1 id=\"最长等差数列\"><a\nhref=\"https://leetcode-cn.com/problems/longest-arithmetic-subsequence/\">1027.\n最长等差数列</a></h1>\n<p>给你一个整数数组 nums，返回 nums 中最长等差子序列的长度。</p>\n<p>回想一下，nums 的子序列是一个列表 nums[i1], nums[i2], ..., nums[ik]\n，且 0 &lt;= i1 &lt; i2 &lt; ... &lt; ik &lt;= nums.length - 1。并且如果\n<span class=\"math inline\">\\(seq[i+1] - seq[i]\\)</span> ( 0 &lt;= i &lt;\nseq.length - 1) 的值都相同，那么序列 seq 是等差的。</p>\n<h2 id=\"示例\">示例：</h2>\n<blockquote>\n<p>输入：nums = [3,6,9,12] 输出：4 解释： 整个数组是公差为 3\n的等差数列。</p>\n</blockquote>\n<blockquote>\n<p>输入：nums = [9,4,7,2,10] 输出：3 解释： 最长的等差子序列是\n[4,7,10]。</p>\n</blockquote>\n<blockquote>\n<p>输入：nums = [20,1,15,3,10,5,8] 输出：4 解释： 最长的等差子序列是\n[20,15,10,5]。</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"思路\">思路：</h3>\n<p>由于最少需要两个元素才能定义等差数列，所以定义状态<code>dp[i][j]</code>为<code>nums[i]</code>和<code>nums[j]</code>为最后两个元素的等差数列的长度。</p>\n<p>根据等差数列的性质，如果最后两个数定了，那么前一个元素也就确定了，<code>target = 2 * nums[i] - nums[j]</code>，</p>\n<p>例如：</p>\n<blockquote>\n<p>nums = [9,4,7,2,10]</p>\n</blockquote>\n<p>例如我们现在<code>nums[i] = 4</code>,<code>nums[j] = 10</code>，把么下一个可以构成等差数列的数就是<code>2 * 4 - 10 = 4</code></p>\n<p>然后查找<code>i</code>前面是否存在这样一个元素即可。</p>\n<p><code>dp[i][j] = dp[ID_target][i] + 1</code></p>\n<p>所以可以选择三重循环来解决。时间复杂度为<code>O(N^3)</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">longestArithSeqLength</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//dp[i][j]表示以 nums[i] 和 nums[j] 为最后两个元素的等差数列长度</span></span><br><span class=\"line\">        <span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">       <span class=\"comment\">//base case</span></span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; <span class=\"built_in\">dp</span>(n, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(n,<span class=\"number\">2</span>));</span><br><span class=\"line\">        <span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = i + <span class=\"number\">1</span>; j &lt; n; j++)&#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> target = <span class=\"number\">2</span> * nums[i] - nums[j];</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k = i - <span class=\"number\">1</span>; k &gt;= <span class=\"number\">0</span>; k--)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(nums[k] == target)&#123;</span><br><span class=\"line\">                        dp[i][j] = dp[k][i] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                ans = <span class=\"built_in\">max</span>(ans, dp[i][j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>我们还有优化的空间吗？可以看到内部的第三重循环可以使用哈希表来优化，通过一个哈希表记录每个在<code>i</code>之前的数出现的最后一个下标，就可以在<code>O(1)</code>的时间内找到<code>target</code>所在的下标。</p>\n<p>时间复杂度为<code>O(n^2)</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">longestArithSeqLength</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        unordered_map&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt; mp;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; <span class=\"built_in\">dp</span>(n, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(n, <span class=\"number\">2</span>));</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = i + <span class=\"number\">1</span>; j &lt; n; j++)&#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> target = <span class=\"number\">2</span> * nums[i] - nums[j];</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(mp.<span class=\"built_in\">count</span>(target)) dp[i][j] = dp[mp[target]][i] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                res = <span class=\"built_in\">max</span>(res, dp[i][j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            mp[nums[i]] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["leetcode","动态规划"],"tags":["动态规划","leetcode"]},{"title":"杨辉三角形","url":"/2022/07/31/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E5%BD%A2/","content":"<h1 id=\"杨辉三角\"><a\nhref=\"https://leetcode.cn/problems/pascals-triangle/\">118.\n杨辉三角</a></h1>\n<p>给定一个非负整数 <code>numRows</code>，生成「杨辉三角」的前\n<code>numRows</code> 行。</p>\n<p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>\n<p><img\nsrc=\"https://sjchen404.oss-cn-shenzhen.aliyuncs.com/img/1.gif\" /></p>\n<h2 id=\"示例1\">示例1:</h2>\n<blockquote>\n<p>输入：numRows = 5<br>\n输出：[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"思路\">思路：</h3>\n<p>计算原理我们可以从图片中得出，我们也可以知道，第<code>i</code>行有<code>i</code>个数，并且第一个和最后一个数字为<code>1</code>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> 时间复杂度：O(numRows^2)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">generate</span>(<span class=\"type\">int</span> numRows) &#123;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; <span class=\"built_in\">dp</span>(numRows);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; numRows; i++) &#123;</span><br><span class=\"line\">            dp[i].<span class=\"built_in\">resize</span>(i + <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 每行第一个和最后一个数为 1</span></span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>] = dp[i][i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt; i; j++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 状态转移方程</span></span><br><span class=\"line\">                dp[i][j] = dp[i - <span class=\"number\">1</span>][j] + dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["动态规划"],"tags":["动态规划"]},{"title":"柱状图中最大的矩形","url":"/2022/05/07/%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/","content":"<p>单调栈的具体思路可以看<a\nhref=\"https://sjchen404.github.io/2022/04/06/单调栈/\">单调栈</a></p>\n<h1 id=\"柱状图中最大的矩形\"><a\nhref=\"https://leetcode-cn.com/problems/largest-rectangle-in-histogram/\">84.\n柱状图中最大的矩形</a></h1>\n<p>给定 <em>n</em>\n个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1\n。</p>\n<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>\n<h2 id=\"示例\">示例</h2>\n<p><img src=\"柱状图中最大的矩形/histogram.jpg\" /></p>\n<blockquote>\n<p>输入：heights = [2,1,5,6,2,3] 输出：10\n解释：最大的矩形为图中红色区域，面积为 10</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"思路\">思路：</h3>\n<p>具体可以参考<a\nhref=\"https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/bao-li-jie-fa-zhan-by-liweiwei1419/\">题解</a>，讲得挺好的，这里我简单讲下思路。</p>\n<p>我们在遍历的时候，需要记录的是下标，如果当前的高度比它之前的高度严格小于的时候，就可以直接确定之前的<strong>那个高的柱形的最大矩形的面积</strong>，为了确定这个最大矩形的左边界，我们还要找到第一个严格小于它的高度的矩形，向左回退的时候，其实就可以当中间这些柱形不存在一样。</p>\n<p>为了方便计算，我们左右两边加上哨兵，作用就是：</p>\n<ul>\n<li><p>左边的柱形（第 1\n个柱形）由于它一定比输入数组里任何一个元素小，它肯定不会出栈，因此栈一定不会为空；</p></li>\n<li><p>右边的柱形（第 2\n个柱形）也正是因为它一定比输入数组里任何一个元素小，它会让所有输入数组里的元素出栈（第\n1 个哨兵元素除外）。</p></li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">largestRectangleArea</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(heights.<span class=\"built_in\">size</span>() == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> heights[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span> area = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//插入哨兵</span></span><br><span class=\"line\">        heights.<span class=\"built_in\">insert</span>(heights.<span class=\"built_in\">begin</span>(), <span class=\"number\">0</span>);</span><br><span class=\"line\">        heights.<span class=\"built_in\">push_back</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"type\">int</span> n = heights.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        stack&lt;<span class=\"type\">int</span>&gt; st;</span><br><span class=\"line\">        st.<span class=\"built_in\">push</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(heights[i] &lt; heights[st.<span class=\"built_in\">top</span>()])&#123;</span><br><span class=\"line\">                <span class=\"comment\">//确定前一个高的柱形的最大矩阵高度</span></span><br><span class=\"line\">                <span class=\"type\">int</span> height = heights[st.<span class=\"built_in\">top</span>()];</span><br><span class=\"line\">                st.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                <span class=\"type\">int</span> width = i - st.<span class=\"built_in\">top</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">                area = <span class=\"built_in\">max</span>(area, height * width);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            st.<span class=\"built_in\">push</span>(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> area;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["单调栈"],"tags":["单调栈"]},{"title":"最长递增子序列","url":"/2022/04/11/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/","content":"<h1 id=\"最长递增子序列\"><a\nhref=\"https://leetcode-cn.com/problems/longest-increasing-subsequence/\">300.\n最长递增子序列</a></h1>\n<p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>\n<p>子序列\n是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7]\n是数组 [0,3,1,6,2,2,7] 的子序列。</p>\n<h2 id=\"示例\">示例：</h2>\n<blockquote>\n<p>输入：nums = [10,9,2,5,3,7,101,18] 输出：4 解释：最长递增子序列是\n[2,3,7,101]，因此长度为 4 。</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"思路\">思路：</h2>\n<p>###动态规划解法</p>\n<p><strong><code>dp[i]</code>表示以<code>nums[i]</code>这个数结尾的最长递增子序列的长度</strong></p>\n<p>根据这个定义，我们就可以推出\n<code>base case</code>：<code>dp[i]</code>的初始值为\n1，因为以<code>nums[i]</code>结尾的最长递增子序列起码要包含自己。</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>index</th>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>nums</td>\n<td><code>1</code></td>\n<td>4</td>\n<td><code>3</code></td>\n<td><code>4</code></td>\n<td>2</td>\n</tr>\n</tbody>\n</table>\n<p><code>dp[3] = 3</code></p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>index</th>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>nums</td>\n<td><code>1</code></td>\n<td>4</td>\n<td>3</td>\n<td>4</td>\n<td><code>2</code></td>\n</tr>\n</tbody>\n</table>\n<p><code>dp[4] = 2</code></p>\n<p>==递推关系，我们只要找到前面比<code>nums[i]</code>小的子序列，然后把<code>nums[i]</code>接到后面，就可以形成一个新的递推增子序列，而且这个新的子序列长度加1==</p>\n<p>所以可以写出:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">lengthOfLIS</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//base case: dp 数组全都初始化为 1</span></span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(nums.size(),<span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; i; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nums[i] &gt; nums[j])&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//找到前面比自己小的递增子序列</span></span><br><span class=\"line\">                    dp[i] = <span class=\"built_in\">max</span>(dp[i], dp[j] + <span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//取最长递增子序列</span></span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; dp.<span class=\"built_in\">size</span>(); i++)&#123;</span><br><span class=\"line\">            res = <span class=\"built_in\">max</span>(res, dp[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>⾄此，这道题就解决了，时间复杂度<code>O(N^2)</code>，可以看出时间复杂度还很高，我们有没有办法降低。</p>\n<h3 id=\"二分查找法\">二分查找法</h3>\n<p>时间复杂度为<code>O(NlogN)</code></p>\n<p>根据题⽬的意思，我都很难想象这个问题竟然能和⼆分查找扯上关系。其实最⻓递增⼦序列和⼀种叫做patience\ngame 的纸牌游戏有关，甚⾄有⼀种排序⽅法就叫做 patience\nsorting（耐⼼排序）。</p>\n<p>⾸先，给你⼀排扑克牌，我们像遍历数组那样从左到右⼀张⼀张处理这些扑克牌，最终要把这些牌分成若⼲堆。</p>\n<p><img src=\"最长递增子序列/1.jpg\" /></p>\n<p><strong>处理这些扑克牌要遵循以下规则：</strong></p>\n<p>只能把点数⼩的牌压到点数⽐它⼤的牌上；如果当前牌点数较⼤没有可以放置的堆，则新建⼀个堆，把这张牌放进去；如果当前牌有多个堆可以选择，则选择最左边的那一堆放置。</p>\n<p>⽐如说上述的扑克牌最终会被分成这样 5 堆（我们认为纸牌 A\n的牌⾯是最⼤的，纸牌 2 的牌⾯是最⼩的）。</p>\n<p><img src=\"最长递增子序列/2.jpg\" /></p>\n<p>为什么遇到多个可选择堆的时候要放到最左边的堆上呢？因为这样可以保证牌堆顶的牌有序（2,\n4, 7, 8，Q）</p>\n<p>按照上述规则执⾏，可以算出最⻓递增⼦序列，牌的堆数就是最⻓递增⼦序列的⻓度，证明略。</p>\n<p><img src=\"最长递增子序列/3.jpg\" /></p>\n<p>我们只要把处理扑克牌的过程编程写出来即可。每次处理⼀张扑克牌不是要找⼀个合适的牌堆顶来放吗，牌堆顶部的牌不就是有序吗？</p>\n<p>这就能用到二分查找了：==用二分查找来搜索当前牌应放置的位置。==</p>\n<p>最长递增子序列的个数就是堆牌的个数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">lengthOfLIS</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">top</span><span class=\"params\">(nums.size(), <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"comment\">// 牌堆数初始化为0</span></span><br><span class=\"line\">        <span class=\"type\">int</span> piles = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 想要处理的扑克牌</span></span><br><span class=\"line\">            <span class=\"type\">int</span> poker = nums[i];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 搜索左侧边界的二分查找</span></span><br><span class=\"line\">            <span class=\"type\">int</span> left = <span class=\"number\">0</span>, right = piles;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(left &lt; right)&#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> mid = (left + right) / <span class=\"number\">2</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(top[mid] &gt; poker)&#123;</span><br><span class=\"line\">                    right = mid;</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(top[mid] &lt; poker)&#123;</span><br><span class=\"line\">                    left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    right = mid;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 没找到合适的牌堆，新建一堆</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(left == piles) piles++;</span><br><span class=\"line\">            <span class=\"comment\">// 把这张牌放到牌堆顶</span></span><br><span class=\"line\">            top[left] = poker;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> piles;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["leetcode","动态规划"],"tags":["动态规划","leetcode"]},{"title":"桂林电子科技大学第三届ACM程序设计竞赛","url":"/2019/04/15/%E6%A1%82%E6%9E%97%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E7%AC%AC%E4%B8%89%E5%B1%8AACM%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B/","content":"<p><a\nhref=\"https://ac.nowcoder.com/acm/contest/558#question\">比赛链接</a></p>\n<span id=\"more\"></span>\n<p>A,串串</p>\n<blockquote>\n<p>不会写</p>\n</blockquote>\n<p>B，重复</p>\n<blockquote>\n<p>查重，直接set就完事了,然后求长度就ok了</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;set&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ll n,m;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    string str[n];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(ll i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">        cin&gt;&gt;str[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    set&lt;string&gt;<span class=\"built_in\">map</span>(str,str+n);</span><br><span class=\"line\">    cout&lt;&lt;map.<span class=\"built_in\">size</span>()&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>C，二元</p>\n<blockquote>\n<p>思路： 暂无</p>\n<p>二元： 暂无</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;set&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> maxn=<span class=\"number\">1e5</span>+<span class=\"number\">50</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,k;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">T</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> a,b;</span><br><span class=\"line\">&#125;p[maxn&lt;&lt;<span class=\"number\">2</span>];</span><br><span class=\"line\">priority_queue&lt;<span class=\"type\">int</span>,vector&lt;<span class=\"type\">int</span>&gt;,greater&lt;<span class=\"type\">int</span>&gt;&gt;q;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"type\">const</span> T &amp;a,<span class=\"type\">const</span> T &amp;b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.a&gt;b.a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)</span><br><span class=\"line\">        cin&gt;&gt;p[i].a&gt;&gt;p[i].b;</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(p,p+n,cmp);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;k;i++) q.<span class=\"built_in\">push</span>(p[i].b);</span><br><span class=\"line\">    <span class=\"type\">int</span> ans=q.<span class=\"built_in\">top</span>()+p[k<span class=\"number\">-1</span>].a;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=k;i&lt;n;i++)&#123;</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        q.<span class=\"built_in\">push</span>(p[i].b);</span><br><span class=\"line\">        ans=<span class=\"built_in\">max</span>(ans,p[i].a+q.<span class=\"built_in\">top</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>D，查找</p>\n<blockquote>\n<p>树，</p>\n<p>不会</p>\n</blockquote>\n<p>E，区间</p>\n<blockquote>\n<p>直接模拟</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;set&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> maxn=<span class=\"number\">1000</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> t;</span><br><span class=\"line\">    cin&gt;&gt;t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n;</span><br><span class=\"line\">        cin&gt;&gt;n;</span><br><span class=\"line\">        <span class=\"type\">int</span> a[maxn];</span><br><span class=\"line\">        <span class=\"type\">int</span> l=<span class=\"number\">1</span>,min=<span class=\"number\">1</span>;;</span><br><span class=\"line\">        <span class=\"type\">int</span> cnt=<span class=\"number\">0</span>,max=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">            cin&gt;&gt;a[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a[i<span class=\"number\">-1</span>]&lt;=a[i])&#123;</span><br><span class=\"line\">                cnt++;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(cnt&gt;max)&#123;</span><br><span class=\"line\">                    l=min;</span><br><span class=\"line\">                    max=cnt;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                min=i+<span class=\"number\">1</span>;</span><br><span class=\"line\">                cnt=<span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d %d\\n&quot;</span>,l,l+max);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>F，点对</p>\n<blockquote>\n<p>有相图，连通性</p>\n<p>定义一个大数组，M [a] [b] == 1 &amp;&amp; M[b] [a]==1 成立时，\nans++</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;set&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> maxn=<span class=\"number\">310</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> n,m;</span><br><span class=\"line\"><span class=\"type\">int</span> M[maxn][maxn];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"type\">int</span> u,v;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;m;i++)&#123;</span><br><span class=\"line\">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class=\"line\">        M[u][v]=<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k=<span class=\"number\">1</span>;k&lt;=n;k++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(M[i][k]==<span class=\"number\">1</span>&amp;&amp;M[k][j]==<span class=\"number\">1</span>)</span><br><span class=\"line\">                    M[i][j]=<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=i+<span class=\"number\">1</span>;j&lt;=n;j++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(M[i][j] &amp;&amp; M[j][i]) ans++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>G，路径</p>\n<blockquote>\n<p>没写</p>\n</blockquote>\n<p>H，分离</p>\n<blockquote>\n<p>模拟就完事了</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> t;</span><br><span class=\"line\">    cin&gt;&gt;t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">        string str;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">char</span>&gt;m;</span><br><span class=\"line\">        cin&gt;&gt;str;</span><br><span class=\"line\">        m.<span class=\"built_in\">push_back</span>(str[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;str.<span class=\"built_in\">size</span>();i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i%<span class=\"number\">2</span>==<span class=\"number\">0</span>) m.<span class=\"built_in\">push_back</span>(str[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;m.<span class=\"built_in\">size</span>();i++)&#123;</span><br><span class=\"line\">            cout&lt;&lt;m[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout&lt;&lt;endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>I，选择</p>\n<blockquote>\n<p>还没写</p>\n</blockquote>\n<p>J，相聚</p>\n<blockquote>\n<p>连通性问题，只要找到1，就dfs</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;set&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> maxn=<span class=\"number\">50</span>+<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">char</span> str[maxn][maxn];</span><br><span class=\"line\"><span class=\"type\">int</span> n,m;</span><br><span class=\"line\"><span class=\"type\">int</span> dir[][<span class=\"number\">2</span>]=&#123;&#123;<span class=\"number\">-1</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">1</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">0</span>,<span class=\"number\">-1</span>&#125;,&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>&#125;&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    str[x][y]=<span class=\"string\">&#x27;0&#x27;</span>;<span class=\"comment\">//注意</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x&lt;<span class=\"number\">0</span>||x&gt;n||y&lt;<span class=\"number\">0</span>||y&gt;m) <span class=\"keyword\">return</span>;<span class=\"comment\">//结束条件</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> dx=x+dir[i][<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"type\">int</span> dy=y+dir[i][<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(str[dx][dy]==<span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">                <span class=\"built_in\">dfs</span>(dx,dy);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> t;</span><br><span class=\"line\">    cin&gt;&gt;t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">        cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">        <span class=\"type\">int</span> ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(str, <span class=\"string\">&#x27;0&#x27;</span>,<span class=\"built_in\">sizeof</span>(str));</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;m;j++)</span><br><span class=\"line\">                cin&gt;&gt;str[i][j];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;m;j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(str[i][j]==<span class=\"string\">&#x27;1&#x27;</span>)&#123;</span><br><span class=\"line\">                    <span class=\"built_in\">dfs</span>(i,j);</span><br><span class=\"line\">                    ans++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,ans);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["比赛"],"tags":["dfs","字符串","模拟"]},{"title":"每日一题 429 N 叉树的层序遍历","url":"/2022/04/09/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-429-N-%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/","content":"<h1 id=\"n-叉树的层序遍历\"><a\nhref=\"https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/\">429.\nN 叉树的层序遍历</a></h1>\n<p>给定一个 N\n叉树，返回其节点值的<em>层序遍历</em>。（即从左到右，逐层遍历）。</p>\n<p>树的序列化输入是用层序遍历，每组子节点都由 null\n值分隔（参见示例）。</p>\n<h2 id=\"示例\">示例：</h2>\n<p><img src=\"每日一题-429-N-叉树的层序遍历/1.png\" /></p>\n<blockquote>\n<p>输入：root = [1,null,3,2,4,null,5,6] 输出：[[1],[3,2,4],[5,6]]</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>结构如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> val;</span><br><span class=\"line\">    vector&lt;Node*&gt; children;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Node</span>() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Node</span>(<span class=\"type\">int</span> _val) &#123;</span><br><span class=\"line\">        val = _val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">Node</span>(<span class=\"type\">int</span> _val, vector&lt;Node*&gt; _children) &#123;</span><br><span class=\"line\">        val = _val;</span><br><span class=\"line\">        children = _children;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"思路\">思路：</h3>\n<p>采用BFS</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; <span class=\"built_in\">levelOrder</span>(Node* root) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">        queue&lt;Node*&gt; q;</span><br><span class=\"line\">        q.<span class=\"built_in\">push</span>(root);</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> sz = q.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">            vector&lt;<span class=\"type\">int</span>&gt; tmp;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; sz; i++)&#123;</span><br><span class=\"line\">                Node* cur = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">                q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                tmp.<span class=\"built_in\">push_back</span>(cur-&gt;val);</span><br><span class=\"line\">\t\t\t\t\t\t\t\t<span class=\"comment\">// 孩子节点入队列</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (Node* child: cur-&gt;children) &#123;</span><br><span class=\"line\">                    q.<span class=\"built_in\">push</span>(child);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res.<span class=\"built_in\">push_back</span>(tmp);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["树","BFS","leetcode","每日一题"],"tags":["BFS","层次遍历","树"]},{"title":"正则表达式匹配","url":"/2022/03/26/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/","content":"<p>这两个通配符是最常用的，其中点号「.」可以匹配任意一个字符，星号「*」可以让之前的那个字符重复任意次数（包括\n0 次）。</p>\n<p>比如说模式串<code>\".a*b\"</code>就可以匹配文本<code>\"zaaab\"</code>，也可以匹配<code>\"cb\"</code>；模式串<code>\"a..b\"</code>可以匹配文本<code>\"amnb\"</code>；而模式串<code>\".*\"</code>就比较牛逼了，它可以匹配任何文本。</p>\n<p>题目会给我们输入两个字符串<code>s</code>和<code>p</code>，<code>s</code>代表文本，<code>p</code>代表模式串，请你判断模式串<code>p</code>是否可以匹配文本<code>s</code>。我们可以假设模式串只包含小写字母和上述两种通配符且一定合法，不会出现<code>*a</code>或者<code>b**</code>这种不合法的模式串，</p>\n<p><a\nhref=\"https://mp.weixin.qq.com/s/rnaFK05IcFWvNN1ppNf2ug\">总结自labuladong大神</a></p>\n<span id=\"more\"></span>\n<h1 id=\"正则表达式匹配\"><a\nhref=\"https://leetcode-cn.com/problems/regular-expression-matching/\">10.\n正则表达式匹配</a></h1>\n<p>给你一个字符串<code>s</code>和一个字符规律<code>p</code>，请你来实现一个支持<code>'.'</code>和\n<code>'*'</code> 的正则表达式匹配。</p>\n<ul>\n<li><code>'.'</code> 匹配任意单个字符</li>\n<li><code>'*'</code> 匹配零个或多个前面的那一个元素 所谓匹配，是要涵盖\n整个 字符串 s的，而不是部分字符串。</li>\n</ul>\n<h2 id=\"示例\">示例：</h2>\n<blockquote>\n<p>输入：s = \"aa\", p = \"a\" 输出：false 解释：\"a\" 无法匹配 \"aa\"\n整个字符串。</p>\n<p>输入：s = \"aa\", p = \"a<em>\" 输出：true 解释：因为 '</em>'\n代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是\n'a'。因此，字符串 \"aa\" 可被视为 'a' 重复了一次。</p>\n<p>输入：s = \"ab\", p = \".<em>\" 输出：true 解释：\".</em>\"\n表示可匹配零个或多个（'*'）任意字符（'.'）。</p>\n</blockquote>\n<h3 id=\"思路\">思路：</h3>\n<p>我们先脑补一下，<code>s</code>和<code>p</code>相互匹配的过程大致是，两个指针<code>i, j</code>分别在<code>s</code>和<code>p</code>上移动，如果最后两个指针都能移动到字符串的末尾，那么就匹配成功，反之则匹配失败。</p>\n<p><strong>正则表达算法问题只需要把住一个基本点：看两个字符是否匹配，一切逻辑围绕匹配/不匹配两种情况展开即可。</strong></p>\n<p>如果不考虑<code>*</code>通配符，面对两个待匹配字符<code>s[i]</code>和<code>p[j]</code>，我们唯一能做的就是看他俩是否匹配：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isMatch</span><span class=\"params\">(string s, string p)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt; s.<span class=\"built_in\">size</span>() &amp;&amp; j &lt; p.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 「.」通配符就是万金油</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s[i] == p[j] || p[j] == <span class=\"string\">&#x27;.&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 匹配，接着匹配 s[i+1..] 和 p[j+1..]</span></span><br><span class=\"line\">            i++; j++;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 不匹配</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i == j;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么考虑一下，如果加入<code>*</code>通配符，局面就会稍微复杂一些，不过只要分情况来分析，也不难理解。</p>\n<p><strong>当<code>p[j + 1]</code>为<code>*</code>通配符时，我们分情况讨论下</strong>：</p>\n<p>1、如果匹配，即<code>s[i] == p[j]</code>，那么有两种情况：</p>\n<p>1.1<code>p[j]</code>有可能会匹配多个字符，比如<code>s = \"aaa\", p = \"a*\"</code>，那么<code>p[0]</code>会通过<code>*</code>匹配\n3 个字符<code>\"a\"</code>。</p>\n<p>1.2<code>p[i]</code>也有可能匹配 0\n个字符，比如<code>s = \"aa\", p = \"a*aa\"</code>，由于后面的字符可以匹配<code>s</code>，所以<code>p[0]</code>只能匹配\n0 次。</p>\n<p>2、如果不匹配，即<code>s[i] != p[j]</code>，只有一种情况：</p>\n<p><code>p[j]</code>只能匹配 0\n次，然后看下一个字符是否能和<code>s[i]</code>匹配。比如说<code>s = \"aa\", p = \"b*aa\"</code>，此时<code>p[0]</code>只能匹配\n0 次。</p>\n<p>综上，可以把之前的代码针对<code>*</code>通配符进行一下改造：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (s[i] == p[j] || p[j] == <span class=\"string\">&#x27;.&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 匹配</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (j &lt; p.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span> &amp;&amp; p[j + <span class=\"number\">1</span>] == <span class=\"string\">&#x27;*&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 有 * 通配符，可以匹配 0 次或多次</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 无 * 通配符，老老实实匹配 1 次</span></span><br><span class=\"line\">        i++; j++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 不匹配</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (j &lt; p.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span> &amp;&amp; p[j + <span class=\"number\">1</span>] == <span class=\"string\">&#x27;*&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 有 * 通配符，只能匹配 0 次</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 无 * 通配符，匹配无法进行下去了</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>整体的思路已经很清晰了，但现在的问题是，遇到<code>*</code>通配符时，到底应该匹配\n0 次还是匹配多次？多次是几次？</p>\n<p>你看，这就是一个做「选择」的问题，要把所有可能的选择都穷举一遍才能得出结果。动态规划算法的核心就是「状态」和「选择」，<strong>「状态」无非就是<code>i</code>和<code>j</code>两个指针的位置，「选择」就是<code>p[j]</code>选择匹配几个字符</strong>。</p>\n<h4 id=\"动态规划解法\">动态规划解法</h4>\n<p>根据「状态」，我们可以定义一个<code>dp</code>函数：</p>\n<blockquote>\n<p><strong>bool</strong> <strong>dp</strong>(string&amp; s,\n<strong>int</strong> i, string&amp; p, <strong>int</strong> j);</p>\n</blockquote>\n<p><code>dp</code>函数的定义如下：</p>\n<blockquote>\n<p><strong>若<code>dp(s,i,p,j) = true</code>，则表示<code>s[i..]</code>可以匹配<code>p[j..]</code>；</strong></p>\n<p><strong>若<code>dp(s,i,p,j) = false</code>，则表示<code>s[i..]</code>无法匹配<code>p[j..]</code>。</strong></p>\n</blockquote>\n<p>根据这个定义，我们想要的答案就是<code>i = 0,j = 0</code>时<code>dp</code>函数的结果，所以可以这样使用这个<code>dp</code>函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isMatch</span><span class=\"params\">(string s, string p)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 指针 i，j 从索引 0 开始移动</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">dp</span>(s, <span class=\"number\">0</span>, p, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<p>可以根据之前的代码写出<code>dp</code>函数的主要逻辑：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">dp</span><span class=\"params\">(string&amp; s, <span class=\"type\">int</span> i, string&amp; p, <span class=\"type\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s[i] == p[j] || p[j] == <span class=\"string\">&#x27;.&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 匹配</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (j &lt; p.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span> &amp;&amp; p[j + <span class=\"number\">1</span>] == <span class=\"string\">&#x27;*&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 1.1 通配符匹配 0 次或多次</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">dp</span>(s, i, p, j + <span class=\"number\">2</span>)</span><br><span class=\"line\">                || <span class=\"built_in\">dp</span>(s, i + <span class=\"number\">1</span>, p, j);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 1.2 常规匹配 1 次</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">dp</span>(s, i + <span class=\"number\">1</span>, p, j + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 不匹配</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (j &lt; p.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span> &amp;&amp; p[j + <span class=\"number\">1</span>] == <span class=\"string\">&#x27;*&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 2.1 通配符匹配 0 次</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">dp</span>(s, i, p, j + <span class=\"number\">2</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 2.2 无法继续匹配</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>==<strong>1.1 通配符匹配 0 次或多次</strong>==</p>\n<p>将<code>j</code>加\n2，<code>i</code>不变，含义就是直接跳过<code>p[j]</code>和之后的通配符，即通配符匹配\n0 次：</p>\n<p><img src=\"正则表达式匹配/1.jpg\" style=\"zoom:67%;\" /></p>\n<p>将<code>i</code>加\n1，<code>j</code>不变，含义就是<code>p[j]</code>匹配了<code>s[i]</code>，但<code>p[j]</code>还可以继续匹配，即通配符匹配多次的情况：</p>\n<p><img src=\"正则表达式匹配/2.jpg\" style=\"zoom:67%;\" /></p>\n<p>两种情况只要有一种可以完成匹配即可，所以对上面两种情况求或运算。</p>\n<p>==<strong>1.2 常规匹配 1 次</strong>==</p>\n<p>由于这个条件分支是无<code>*</code>的常规匹配，那么如果<code>s[i] == p[j]</code>，就是<code>i</code>和<code>j</code>分别加一：</p>\n<p><img src=\"正则表达式匹配/3.jpg\" style=\"zoom:67%;\" /></p>\n<p>==<strong>2.1 通配符匹配 0 次</strong>==</p>\n<p>类似情况 1.1，将<code>j</code>加 2，<code>i</code>不变：</p>\n<p><img src=\"正则表达式匹配/4.jpg\" style=\"zoom:67%;\" /></p>\n<p>==<strong>2.2\n如果没有<code>*</code>通配符，也无法匹配，那只能说明匹配失败了：</strong>==</p>\n<p><img src=\"正则表达式匹配/5.jpg\" style=\"zoom:67%;\" /></p>\n<p>看图理解应该很容易了，现在可以思考一下<code>dp</code>函数的 base\ncase：</p>\n<p><strong>一个 base case\n是<code>j == p.size()</code>时</strong>，按照<code>dp</code>函数的定义，这意味着模式串<code>p</code>已经被匹配完了，那么应该看看文本串<code>s</code>匹配到哪里了，如果<code>s</code>也恰好被匹配完，则说明匹配成功：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (j == p.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i == s.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>另一个 base case\n是<code>i == s.size()</code>时</strong>，按照<code>dp</code>函数的定义，这种情况意味着文本串<code>s</code>已经全部被匹配了，那么是不是只要简单地检查一下<code>p</code>是否也匹配完就行了呢？</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (i == s.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这样行吗？</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> j == p.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>这是不正确的，此时并不能根据<code>j</code>是否等于<code>p.size()</code>来判断是否完成匹配，只要<code>p[j..]</code>能够匹配空串，就可以算完成匹配</strong>。比如说<code>s = \"a\", p = \"ab*c*\"</code>，当<code>i</code>走到<code>s</code>末尾的时候，<code>j</code>并没有走到<code>p</code>的末尾，但是<code>p</code>依然可以匹配<code>s</code>。</p>\n<p>所以我们可以写出如下代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> m = s.<span class=\"built_in\">size</span>(), n = p.<span class=\"built_in\">size</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (i == s.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果能匹配空串，一定是字符和 * 成对儿出现</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((n - j) % <span class=\"number\">2</span> == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 检查是否为 x*y*z* 这种形式</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; j + <span class=\"number\">1</span> &lt; p.<span class=\"built_in\">size</span>(); j += <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p[j + <span class=\"number\">1</span>] != <span class=\"string\">&#x27;*&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>综上，完整代码如下：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isMatch</span><span class=\"params\">(string s, string p)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">dp</span>(s, <span class=\"number\">0</span>, p, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 备忘录</span></span><br><span class=\"line\">    unordered_map&lt;string, <span class=\"type\">bool</span>&gt; memo;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">dp</span><span class=\"params\">(string&amp; s, <span class=\"type\">int</span> i, string&amp; p, <span class=\"type\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> m = s.<span class=\"built_in\">size</span>(), n = p.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"comment\">//base case</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(j == n)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> i == m;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i == m)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果能匹配空串，一定是字符和 * 成对儿出现</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>((n - j) % <span class=\"number\">2</span> == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//检查是否为 x*y*z* 这种形式</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(; j + <span class=\"number\">1</span> &lt; n; j += <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(p[j + <span class=\"number\">1</span>] != <span class=\"string\">&#x27;*&#x27;</span>)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 记录状态 (i,j) 消除重叠子问题</span></span><br><span class=\"line\">        string key = <span class=\"built_in\">to_string</span>(i) + <span class=\"string\">&quot;,&quot;</span> + <span class=\"built_in\">to_string</span>(j);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(memo.<span class=\"built_in\">count</span>(key)) <span class=\"keyword\">return</span> memo[key];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">bool</span> res = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s[i] == p[j] || p[j] == <span class=\"string\">&#x27;.&#x27;</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 匹配</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(j &lt; n - <span class=\"number\">1</span> &amp;&amp; p[j + <span class=\"number\">1</span>] == <span class=\"string\">&#x27;*&#x27;</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 1.1 通配符匹配 0 次或多次</span></span><br><span class=\"line\">                res = <span class=\"built_in\">dp</span>(s, i, p, j + <span class=\"number\">2</span>) || <span class=\"built_in\">dp</span>(s, i + <span class=\"number\">1</span>, p, j);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 1.2 常规匹配 1 次</span></span><br><span class=\"line\">                res = <span class=\"built_in\">dp</span>(s, i + <span class=\"number\">1</span>, p, j + <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 不匹配</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(j &lt; n - <span class=\"number\">1</span> &amp;&amp; p[j + <span class=\"number\">1</span>] == <span class=\"string\">&#x27;*&#x27;</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 2.1 通配符匹配 0 次</span></span><br><span class=\"line\">                res = <span class=\"built_in\">dp</span>(s, i, p, j + <span class=\"number\">2</span>);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 2.2 无法继续匹配</span></span><br><span class=\"line\">                res = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        memo[key] = res;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["动态规划","正则表达","leetcode"],"tags":["动态规划","正则表达"]},{"title":"每日一题 780 到达终点","url":"/2022/04/09/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-780-%E5%88%B0%E8%BE%BE%E7%BB%88%E7%82%B9/","content":"<h1 id=\"到达终点\"><a\nhref=\"https://leetcode-cn.com/problems/reaching-points/\">780.\n到达终点</a></h1>\n<p>给定四个整数 sx , sy ，tx 和 ty，如果通过一系列的转换可以从起点 (sx,\nsy) 到达终点 (tx, ty)，则返回 true，否则返回 false。</p>\n<p>从点 (x, y) 可以转换到 (x, x+y) 或者 (x+y, y)。</p>\n<h2 id=\"示例\">示例：</h2>\n<blockquote>\n<p>输入: sx = 1, sy = 1, tx = 3, ty = 5 输出: true 解释:\n可以通过以下一系列转换从起点转换到终点： (1, 1) -&gt; (1, 2) (1, 2)\n-&gt; (3, 2) (3, 2) -&gt; (3, 5)</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"思路\">思路：</h2>\n<p>我们可以很轻松的想到递归，每次无非就是要么是<code>(sx + sy, sy)</code>或者<code>(sx, sx + sy)</code>;</p>\n<p>我们可以写出：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">reachingPoints</span><span class=\"params\">(<span class=\"type\">int</span> sx, <span class=\"type\">int</span> sy, <span class=\"type\">int</span> tx, <span class=\"type\">int</span> ty)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sx &gt; tx || sy &gt; ty) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sx == tx &amp;&amp; sy == ty) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">reachingPoints</span>(sx + sy, sy, tx, ty) || <span class=\"built_in\">reachingPoints</span>(sx, sx + sy, tx, ty);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>然后我们发现栈溢出了，这里可以用long解决，但是肯定超时。</p>\n<p>那既然正着求会栈溢出，我们可不可以倒着求呢？</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">reachingPoints</span><span class=\"params\">(<span class=\"type\">int</span> sx, <span class=\"type\">int</span> sy, <span class=\"type\">int</span> tx, <span class=\"type\">int</span> ty)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(tx &lt; sx || ty &lt; sy) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(tx &gt; <span class=\"number\">0</span> &amp;&amp; ty &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sx == tx &amp;&amp; sy == ty)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tx &gt; ty)&#123;</span><br><span class=\"line\">                tx -= ty;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                ty -= tx;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>发现还是超时了，还有哪里可以改进呢，我们发现在<code>tx &gt; ty</code>时，我们不止可以一次减去<code>ty</code>,可以减去最大可以减去，<code>ty &gt; tx</code>处同理</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">reachingPoints</span><span class=\"params\">(<span class=\"type\">int</span> sx, <span class=\"type\">int</span> sy, <span class=\"type\">int</span> tx, <span class=\"type\">int</span> ty)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(tx &lt; sx || ty &lt; sy) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(tx &gt; <span class=\"number\">0</span> &amp;&amp; ty &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sx == tx &amp;&amp; sy == ty)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tx &gt; ty)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//tx - sx是目标与起始值在x的差距，我们需要一次减去n * ty达到快速逼近sx的目的</span></span><br><span class=\"line\">                tx -= <span class=\"built_in\">max</span>((tx - sx)/ty, <span class=\"number\">1</span>) * ty;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">//ty - sy是目标与起始值在y的差距，我们需要一次减去n * tx达到快速逼近sy的目的</span></span><br><span class=\"line\">                ty -= <span class=\"built_in\">max</span>((ty - sy)/tx, <span class=\"number\">1</span>) * tx;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这样就可以解了。</p>\n","categories":["数学","leetcode","每日一题"],"tags":["数学"]},{"title":"每日一题 二倍数对数组","url":"/2022/04/01/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-%E4%BA%8C%E5%80%8D%E6%95%B0%E5%AF%B9%E6%95%B0%E7%BB%84/","content":"<p>#<a\nhref=\"https://leetcode-cn.com/problems/array-of-doubled-pairs/\">954.\n二倍数对数组</a></p>\n<p>给定一个长度为偶数的整数数组 arr，只有对 arr 进行重组后可以满足\n“对于每个 0 &lt;= i &lt; len(arr) /\n2，都有<code>arr[2 * i + 1] = 2 * arr[2 * i]</code>时，返回\ntrue；否则，返回 false。</p>\n<h2 id=\"示例\">示例：</h2>\n<blockquote>\n<p>输入：arr = [3,1,3,6] 输出：false</p>\n</blockquote>\n<blockquote>\n<p>输入：arr = [2,1,2,6] 输出：false</p>\n</blockquote>\n<blockquote>\n<p>输入：arr = [4,-2,2,-4] 输出：true 解释：可以用 [-2,-4] 和 [2,4]\n这两组组成 [-2,-4,2,4] 或是 [2,4,-2,-4]</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"思路\">思路：</h2>\n<p>我们用哈希表记录每个数出现的次数，然后排序，计算当前数的 2 倍，\n负数为除 2， 正数为乘 2。</p>\n<p>如果存在这个数，并且这个数的哈希值不为0，则在哈希表中数量减一。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">canReorderDoubled</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class=\"line\">        unordered_map&lt;<span class=\"type\">float</span> , <span class=\"type\">int</span>&gt; mp;</span><br><span class=\"line\">        <span class=\"comment\">//记录每个数出现次数</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> a : arr)&#123;</span><br><span class=\"line\">            mp[a]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(arr.<span class=\"built_in\">begin</span>(), arr.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> value : arr)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//当前数已经匹配完则继续遍历下一个</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(mp[value] == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">float</span> target;</span><br><span class=\"line\">            <span class=\"comment\">//计算当前数对2倍，负数除 2， 正数乘 2</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(value &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                target = <span class=\"number\">2</span> * value;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                target = value / <span class=\"number\">2.0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//不存在 2 的倍数或者已经匹配完了，则返回false</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!mp.<span class=\"built_in\">count</span>(target) || mp[target] == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">//对应数的数量减一</span></span><br><span class=\"line\">                mp[target]--;</span><br><span class=\"line\">                mp[value]--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["哈希","leetcode","每日一题"],"tags":["哈希"]},{"title":"数组中重复的数据","url":"/2022/05/09/%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E6%8D%AE/","content":"<h1 id=\"数组中重复的数据\"><a\nhref=\"https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/\">442.\n数组中重复的数据</a></h1>\n<p>给你一个长度为 <code>n</code>的整数数组 <code>nums</code>，其中\n<code>nums</code>的所有整数都在范围<code>[1, n]</code>\n内，且每个整数出现 一次 或 两次 。请你找出所有出现 两次\n的整数，并以数组形式返回。</p>\n<p>你必须设计并实现一个时间复杂度为\n<code>O(n)</code>且仅使用常量额外空间的算法解决此问题。</p>\n<h2 id=\"示例\">示例：</h2>\n<blockquote>\n<p>输入：nums = [4,3,2,7,8,2,3,1] 输出：[2,3]</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"思路\">思路：</h3>\n<p>首先我们先想到的是用哈希表保存已经出现过的数字次数。这就不符合题目要求的空间复杂度<code>O(1)</code>。</p>\n<p>对数组排序时间复杂度为<code>O(NlogN)</code>也不符合。</p>\n<p>所以我们只有<strong>「原地修改数组」</strong>了。</p>\n<p>我们注意到数组长度为<code>n</code>，每个数据的取值访问为<code>[1,n]</code>。</p>\n<p>我们只需要把这个数放到它应该要到的位置。当然这里我们不是真的放，而是把应在的位置的值取反。</p>\n<ul>\n<li>从起始位置进行遍历，每次将下标为<code>nums[i]−1</code>\n的数字取反；</li>\n<li>当遍历到值 <code>nums[i] - 1</code>为负数，需要忽略其负号。</li>\n<li>若发现下标为<code>nums[i]</code>的数字已经是负数，说明之前出现过同样的数字\n<code>nums[i]</code>，即找到了重复数字；</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">findDuplicates</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//为负数，代表已经出现过</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[<span class=\"built_in\">abs</span>(nums[i]) - <span class=\"number\">1</span>] &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                res.<span class=\"built_in\">push_back</span>(<span class=\"built_in\">abs</span>(nums[i]));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//应在的位置取反</span></span><br><span class=\"line\">            nums[<span class=\"built_in\">abs</span>(nums[i]) - <span class=\"number\">1</span>] *= <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["哈希表"],"tags":["数组","哈希表"]},{"title":"求数组中最大n个数和最小n个数的和","url":"/2022/04/10/%E6%B1%82%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%80%E5%A4%A7n%E4%B8%AA%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8Fn%E4%B8%AA%E6%95%B0%E7%9A%84%E5%92%8C/","content":"<p>###<strong>题目描述</strong> 输入一个数 <code>M</code> ，表示<a\nhref=\"https://so.csdn.net/so/search?q=数组&amp;spm=1001.2101.3001.7020\">数组</a>中有\n<code>M</code> 个数 输入 <code>M</code> 个数。 输入 <code>n</code>\n求数组 <code>M</code> 中，去除重复值后，最大 <code>n</code> 个数和最小\n<code>n</code> 个数的和 注意：最大和最小的数中不能有重复值，否则输出\n<code>-1</code></p>\n<blockquote>\n<p><strong>样例输入</strong> 5 3 3 2 4 2 2 <strong>样例输出</strong> -1\n<strong>说明</strong>\n去除重复后最大的2个数为[4,3]，最小的2个数为[2,3]；有相同值，所以返回-1</p>\n</blockquote>\n<blockquote>\n<p><strong>样例输入</strong> 5 3 3 2 4 2 1 <strong>样例输出</strong> 6\n<strong>说明</strong>\n去除重复后最大的1个数为[4]，最小的1个数为[2]；没有相同值，返回6</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"思路\">思路：</h3>\n<p>第一步先排序去重。然后判断此时数组中的元素是否大于\n<code>2 * N</code>，如果不大于直接输出<code>-1</code>，然后用双指针从头和尾同时遍历相加，当<code>left == N - 1</code>时结束。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unordered_map&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ll;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">double</span> ld;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; pii;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> vector&lt;<span class=\"type\">int</span>&gt; vi;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    cin &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">nums</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">        cin &gt;&gt; nums[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    nums.<span class=\"built_in\">erase</span>(<span class=\"built_in\">unique</span>(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>()), nums.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    <span class=\"type\">int</span> N;</span><br><span class=\"line\">    cin &gt;&gt; N;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"number\">2</span>* N &gt; nums.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"number\">-1</span> &lt;&lt; endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//双指针</span></span><br><span class=\"line\">    <span class=\"type\">int</span> left = <span class=\"number\">0</span>, right = nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(left &lt; right)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(left &lt; N)&#123;</span><br><span class=\"line\">            res += nums[left] + nums[right];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(left == N - <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                cout &lt;&lt; res &lt;&lt; endl;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            left++;</span><br><span class=\"line\">            right--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["数组"],"tags":["数组","华为机试"]},{"title":"渐进复杂度","url":"/2022/03/20/%E6%B8%90%E8%BF%9B%E5%A4%8D%E6%9D%82%E5%BA%A6/","content":"<h1 id=\"c-1主流长远\">01C-1主流长远</h1>\n<p>1，大O记号</p>\n<p><strong>随着问题规模大增长，计算成本如何增长？</strong></p>\n<p>渐进分析</p>\n<p>T(n)</p>\n<p>S(n) (可忽略)</p>\n<h1 id=\"c-2-大o记号\">01C-2 大O记号</h1>\n<p>与T(n)相比，f(n)</p>\n","categories":["数据结构"],"tags":["数据结构","复杂度"]},{"title":"单词接龙","url":"/2019/04/09/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/","content":"<p><a\nhref=\"https://www.luogu.org/problemnew/show/P1019\">题目链接</a></p>\n<h1 id=\"题目描述\">题目描述</h1>\n<p>单词接龙是一个与我们经常玩的成语接龙相类似的游戏，现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的“龙”（每个单词都最多在“龙”中出现两次），在两个单词相连时，其重合部分合为一部分，例如\nbeast和astonish，如果接成一条龙则变为beastonish，另外相邻的两部分不能存在包含关系，例如at和\natide 间不能相连。</p>\n<span id=\"more\"></span>\n<h2 id=\"输入输出格式\">输入输出格式</h2>\n<p>输入格式：</p>\n<p>输入的第一行为一个单独的整数n (n≤20)表示单词数，以下n\n行每行有一个单词，输入的最后一行为一个单个字符，表示“龙”开头的字母。你可以假定以此字母开头的“龙”一定存在.</p>\n<p>输出格式：</p>\n<p>只需输出以此字母开头的最长的“龙”的长度</p>\n<h3 id=\"输入样例\">输入样例：</h3>\n<blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">5</span><br><span class=\"line\">at</span><br><span class=\"line\">touch</span><br><span class=\"line\">cheat</span><br><span class=\"line\">choose</span><br><span class=\"line\">tact</span><br><span class=\"line\">a</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h3 id=\"输出样例\">输出样例：</h3>\n<blockquote>\n<p>23</p>\n</blockquote>\n<h3 id=\"说明\">说明：</h3>\n<p>连成的龙为<code>atoucheatactactouchoose</code>.</p>\n<h4 id=\"解题思路\">解题思路：</h4>\n<p>把它转化成二叉树，然后dfs就可以了</p>\n<p>具体方式如下（不全，注意思想就好了）:</p>\n<figure>\n<img src=\"深度优先搜索/1.png\" alt=\"dfs\" />\n<figcaption aria-hidden=\"true\">dfs</figcaption>\n</figure>\n<p>黄色部分就是最长的了。</p>\n<p>这道题最关键的不是dfs，而是我们如何找到下一步要接龙的头。也就是要如何找到两个单词最小重叠部分。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">min_cover_word</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span><span class=\"comment\">//x表示当前单词，y表示下一个要接龙的单词</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">bool</span> p=<span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> y_start=<span class=\"number\">0</span>;<span class=\"comment\">//单词y开始搜索位置</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k=str[x].<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;k&gt;=<span class=\"number\">0</span>;k--)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> x_start=k; x_start&lt;str[x].<span class=\"built_in\">size</span>();x_start++)&#123;<span class=\"comment\">//x_start为单词x开始搜索位置</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(str[x][x_start] != str[y][y_start++])&#123;<span class=\"comment\">//不等时直接退出</span></span><br><span class=\"line\">                p=<span class=\"literal\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p==<span class=\"literal\">true</span>) <span class=\"keyword\">return</span> str[x].<span class=\"built_in\">size</span>()-k;<span class=\"comment\">//得到最小重叠长度</span></span><br><span class=\"line\">        y_start=<span class=\"number\">0</span>;</span><br><span class=\"line\">        p=<span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这步可能不太容易理解，可以在草稿中模拟一下就清楚了。</p>\n<p>AC代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\">string str[<span class=\"number\">100</span>];<span class=\"comment\">//储存单词</span></span><br><span class=\"line\"><span class=\"type\">int</span> vis[<span class=\"number\">100</span>];<span class=\"comment\">//判断单词的使用次数</span></span><br><span class=\"line\"><span class=\"type\">int</span> n,ans=<span class=\"number\">-1</span>,now=<span class=\"number\">0</span>;<span class=\"comment\">//now每次搜到的f当前最长串</span></span><br><span class=\"line\"><span class=\"type\">int</span> min_cover[<span class=\"number\">100</span>][<span class=\"number\">100</span>];<span class=\"comment\">//两个单词最小重叠部分</span></span><br><span class=\"line\"><span class=\"type\">char</span> ch;<span class=\"comment\">//龙头</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">min_cover_word</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">bool</span> p=<span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> y_start=<span class=\"number\">0</span>;<span class=\"comment\">//单词y开始搜索位置</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k=str[x].<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>;k&gt;=<span class=\"number\">0</span>;k--)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> x_start=k; x_start&lt;str[x].<span class=\"built_in\">size</span>();x_start++)&#123;<span class=\"comment\">//x_start为单词x开始搜索位置</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(str[x][x_start] != str[y][y_start++])&#123;<span class=\"comment\">//不等时直接退出</span></span><br><span class=\"line\">                p=<span class=\"literal\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p==<span class=\"literal\">true</span>) <span class=\"keyword\">return</span> str[x].<span class=\"built_in\">size</span>()-k;<span class=\"comment\">//得到最小重叠长度</span></span><br><span class=\"line\">        y_start=<span class=\"number\">0</span>;</span><br><span class=\"line\">        p=<span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">bool</span> jx=<span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(vis[i]&gt;=<span class=\"number\">2</span>) <span class=\"keyword\">continue</span>;<span class=\"comment\">//使用了2次就跳过</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(min_cover[x][i]==<span class=\"number\">0</span>) <span class=\"keyword\">continue</span>;<span class=\"comment\">//两个单词没有重合b部分，跳过</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(min_cover[x][i]==str[x].<span class=\"built_in\">size</span>() || min_cover[x][i] == str[i].<span class=\"built_in\">size</span>()) <span class=\"keyword\">continue</span>;<span class=\"comment\">//两者存在包含关系，跳过</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        now += str[i].<span class=\"built_in\">size</span>()-min_cover[x][i];<span class=\"comment\">//两单词合并然后减去重叠部分的长度</span></span><br><span class=\"line\">        vis[i]++;<span class=\"comment\">//使用次数增加</span></span><br><span class=\"line\">        jx=<span class=\"literal\">true</span>;<span class=\"comment\">//标志当前已经成功匹配到一个可以连接的部分</span></span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(i);<span class=\"comment\">//继续合并</span></span><br><span class=\"line\">        now -= str[i].<span class=\"built_in\">size</span>()-min_cover[x][i];<span class=\"comment\">//回溯,返回到上一步的状态</span></span><br><span class=\"line\">        vis[i]--;<span class=\"comment\">//回溯</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(jx==<span class=\"literal\">false</span>) ans=<span class=\"built_in\">max</span>(ans,now);<span class=\"comment\">//n表示已经不能找到可以连接到单词,更新长度</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">        cin&gt;&gt;str[i];</span><br><span class=\"line\">    cin&gt;&gt;ch;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=n;j++)&#123;</span><br><span class=\"line\">            min_cover[i][j]=<span class=\"built_in\">min_cover_word</span>(i,j);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//预处理min_cover数组。min_cover[i][j]就表示，i单词后连接一个j单词的最小重叠部分</span></span><br><span class=\"line\">    <span class=\"comment\">//比如 i表示at,j表示att. min_cover[i][j]就为2 但是min_cover[j][i]就为0.</span></span><br><span class=\"line\">    <span class=\"comment\">//预处理是一个关键</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str[i][<span class=\"number\">0</span>]==ch)&#123;<span class=\"comment\">//找到和首字母和龙头匹配的单词</span></span><br><span class=\"line\">            vis[i]++;<span class=\"comment\">//使用次数增加</span></span><br><span class=\"line\">            now=str[i].<span class=\"built_in\">size</span>();<span class=\"comment\">//更新当前串长度</span></span><br><span class=\"line\">            <span class=\"built_in\">dfs</span>(i);<span class=\"comment\">//连接</span></span><br><span class=\"line\">            vis[i]=<span class=\"number\">0</span>;<span class=\"comment\">//清除影响</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","categories":["dfs"],"tags":["dfs"]},{"title":"盛水问题","url":"/2022/04/15/%E7%9B%9B%E6%B0%B4%E9%97%AE%E9%A2%98/","content":"<p>#<a\nhref=\"https://leetcode-cn.com/problems/container-with-most-water/\">11.\n盛最多水的容器</a></p>\n<p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i\n条线的两个端点是 (i, 0) 和 (i, height[i]) 。</p>\n<p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>\n<p>返回容器可以储存的最大水量。</p>\n<p>说明：你不能倾斜容器。</p>\n<h2 id=\"示例\">示例：</h2>\n<p><img src=\"盛水问题/1.jpg\" /></p>\n<blockquote>\n<p>输入：[1,8,6,2,5,4,8,3,7] 输出：49 解释：图中垂直线代表输入数组\n[1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为\n49。</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"思路\">思路：</h3>\n<p>我们使用双指针来解决。</p>\n<p><code>left</code>和<code>right</code>两个指针从两端向中心收缩，一边收缩一边计算<code>[left,right]</code>之间的矩阵面积，取最大的面积即是答案。</p>\n<p>现在关键是要向那边收缩？</p>\n<p>我们知道，矩形的高度是由最短的边决定的。所以移动较低的那条边，矩阵的高度可能会变高。</p>\n<p><code>min(height[left],height[right])</code>。如果移动高度较高的边，则矩阵的高度不可能变高。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maxArea</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">0</span>, right = height.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left &lt; right)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> cur_ares = <span class=\"built_in\">min</span>(height[left], height[right]) * (right - left);</span><br><span class=\"line\">            res = <span class=\"built_in\">max</span>(res, cur_ares);</span><br><span class=\"line\">            <span class=\"comment\">//移动到较低的一边</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(height[left] &lt; height[right])&#123;</span><br><span class=\"line\">                left++;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                right--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"接雨水\"><a\nhref=\"https://leetcode-cn.com/problems/trapping-rain-water/\">42.\n接雨水</a></h1>\n<p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code>\n的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>\n<h2 id=\"示例-1\">示例：</h2>\n<p><img src=\"盛水问题/2.png\" /></p>\n<blockquote>\n<p>输入：height = [0,1,0,2,1,0,1,3,2,1,2,1] 输出：6 解释：上面是由数组\n[0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6\n个单位的雨水（蓝色部分表示雨水）。</p>\n</blockquote>\n<h3 id=\"思路-1\">思路：</h3>\n<h4 id=\"方法一单调栈\">方法一：单调栈</h4>\n<p>具体的思想可以看<a\nhref=\"https://sjchen404.github.io/2022/04/06/单调栈/\">单调栈</a></p>\n<p>我们把下标入栈，分别淹没现在所在的这一行元素中可以淹没的。</p>\n<p><img src=\"盛水问题/3.jpg\" /></p>\n<p><img src=\"盛水问题/4.jpg\" /></p>\n<p><img src=\"盛水问题/5.jpg\" /></p>\n<p><img src=\"盛水问题/6.jpg\" /></p>\n<p>我们只需要判断此时矩阵中需要填的水，累加就是答案，矩阵的高是由左边界和右边界的最小值决定的，我们需要注意的是，我们是每次处理一层，所以要把左边界和右边界中的最小值减去要弹出的元素的高度。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> top = s.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">s.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\"><span class=\"type\">int</span> left = i;</span><br><span class=\"line\"><span class=\"type\">int</span> curryWidth = s.<span class=\"built_in\">top</span>() - left - i;</span><br><span class=\"line\"><span class=\"type\">int</span> currHeight = <span class=\"built_in\">min</span>(height[left], height[s.<span class=\"built_in\">top</span>()]) - height[top]</span><br><span class=\"line\">ans += currWidth * currHeight;</span><br></pre></td></tr></table></figure>\n<p>完整代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">trap</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class=\"line\">        stack&lt;<span class=\"type\">int</span>&gt; s;</span><br><span class=\"line\">        <span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//倒着进栈</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = height.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//判断个子高低</span></span><br><span class=\"line\">            <span class=\"type\">int</span> temp = height[i];</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!s.<span class=\"built_in\">empty</span>() &amp;&amp; temp &gt;= height[s.<span class=\"built_in\">top</span>()])&#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> top = s.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">                s.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(s.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"type\">int</span> left = i;</span><br><span class=\"line\">                <span class=\"type\">int</span> currWidth = s.<span class=\"built_in\">top</span>() - left - <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"type\">int</span> currHeight = <span class=\"built_in\">min</span>(height[left], height[s.<span class=\"built_in\">top</span>()]) - height[top];</span><br><span class=\"line\">                ans += currWidth * currHeight;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            s.<span class=\"built_in\">push</span>(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度和空间复杂度都为<code>O(N)</code></p>\n<h4 id=\"方法二双指针\">方法二：双指针</h4>\n<p>我们先明确几个变量的意思：</p>\n<blockquote>\n<p>left_max：左边的最大值，它是从左往右遍历找到的\nright_max：右边的最大值，它是从右往左遍历找到的\nleft：从左往右处理的当前下标 right：从右往左处理的当前下标</p>\n</blockquote>\n<p>定理一：在某个位置<code>i</code>处，它能存的水，取决于它左右两边的最大值中较小的一个。</p>\n<p>定理二：当我们从左往右处理到left下标时，左边的最大值left_max对它而言是可信的，但right_max对它而言是不可信的。（见下图，由于中间状况未知，对于left下标而言，right_max未必就是它右边最大的值）</p>\n<p>定理三：当我们从右往左处理到right下标时，右边的最大值right_max对它而言是可信的，但left_max对它而言是不可信的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">                                   right_max</span><br><span class=\"line\"> left_max                             __</span><br><span class=\"line\">   __                                |  |</span><br><span class=\"line\">  |  |__   __??????????????????????  |  |</span><br><span class=\"line\">__|     |__|                       __|  |__</span><br><span class=\"line\">        left                      right</span><br></pre></td></tr></table></figure>\n<p>对于位置<code>left</code>而言，它左边最大值一定是left_max，右边最大值“大于等于”right_max，这时候，如果<code>left_max&lt;right_max</code>成立，那么它就知道自己能存多少水了。无论右边将来会不会出现更大的right_max，都不影响这个结果。\n所以当<code>left_max&lt;right_max</code>时，我们就希望去处理left下标，反之，我们希望去处理right下标。</p>\n<p><img src=\"盛水问题/8.gif\" /></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">trap</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">0</span>, right = height.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> leftMax = <span class=\"number\">0</span>, rightMax = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left &lt; right)&#123;</span><br><span class=\"line\">            leftMax = <span class=\"built_in\">max</span>(leftMax, height[left]);</span><br><span class=\"line\">            rightMax = <span class=\"built_in\">max</span>(rightMax, height[right]);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(height[left] &lt; height[right])&#123;</span><br><span class=\"line\">                res += leftMax - height[left];</span><br><span class=\"line\">                ++left;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                res += rightMax - height[right];</span><br><span class=\"line\">                --right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度为<code>O(N)</code>空间复杂度为<code>O(1)</code>。</p>\n","categories":["贪心","双指针"],"tags":["双指针","单调栈","贪心"]},{"title":"滑动窗口","url":"/2022/03/24/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/","content":"<p>对于子串问题，大部分都可以通过滑动窗口来解决。说起来滑动窗口的思路非常简单，就是维护一个窗口，不断滑动，然后更新答案。这个算法的时间复杂度为<code>O(N)</code>，比字符串暴力算法要高效多了，这里我们可以学习下<a\nhref=\"https://labuladong.gitee.io/algo/2/22/61/\">labuladong</a>大神的框架。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 滑动窗口算法框架 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">slidingWindow</span><span class=\"params\">(string s, string t)</span> </span>&#123;</span><br><span class=\"line\">    unordered_map&lt;<span class=\"type\">char</span>, <span class=\"type\">int</span>&gt; need, window;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">char</span> c : t) need[c]++;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">int</span> left = <span class=\"number\">0</span>, right = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> valid = <span class=\"number\">0</span>; </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (right &lt; s.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// c 是将移入窗口的字符</span></span><br><span class=\"line\">        <span class=\"type\">char</span> c = s[right];</span><br><span class=\"line\">        <span class=\"comment\">// 右移（增大）窗口</span></span><br><span class=\"line\">        right++;</span><br><span class=\"line\">        <span class=\"comment\">// 进行窗口内数据的一系列更新</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*** debug 输出的位置 ***/</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;window: [%d, %d)\\n&quot;</span>, left, right);</span><br><span class=\"line\">        <span class=\"comment\">/********************/</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 判断左侧窗口是否要收缩</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (window needs shrink) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// d 是将移出窗口的字符</span></span><br><span class=\"line\">            <span class=\"type\">char</span> d = s[left];</span><br><span class=\"line\">            <span class=\"comment\">// 左移（缩小）窗口</span></span><br><span class=\"line\">            left++;</span><br><span class=\"line\">            <span class=\"comment\">// 进行窗口内数据的一系列更新</span></span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过下面的一道题来深入了解下滑动窗口：</p>\n<span id=\"more\"></span>\n<h1 id=\"最小覆盖子串\"><a\nhref=\"https://leetcode-cn.com/problems/minimum-window-substring/\">76.\n最小覆盖子串</a></h1>\n<p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t\n所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串\n\"\" 。</p>\n<p>注意：</p>\n<p>对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t\n中该字符数量。 如果 s 中存在这样的子串，我们保证它是唯一的答案。</p>\n<h2 id=\"示例\">示例：</h2>\n<blockquote>\n<p>输入：s = \"ADOBECODEBANC\", t = \"ABC\" 输出：\"BANC\"</p>\n</blockquote>\n<h3 id=\"思路\">思路：</h3>\n<p>第一步想到的肯定是暴力算法，就是在<code>s</code>中找到包含<code>T</code>中全部字母的一个子串，且这个子串一定是所有可能子串中最短的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; s.<span class=\"built_in\">size</span>(); i++)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = i + <span class=\"number\">1</span>; j &lt; s.<span class=\"built_in\">size</span>(); j++)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(s[i:j]) 包含 t 中的所有字母:</span><br><span class=\"line\">\t\t\t更新答案</span><br></pre></td></tr></table></figure>\n<p>思路非常简单，算法时间复杂度肯定大于<code>O(N^2)</code>。</p>\n<h4 id=\"滑动窗口算法的思路是这样的\">滑动窗口算法的思路是这样的：</h4>\n<p>1，我们在字符串<code>s</code>中使用双指针中的左右指针技巧，初始化<code>left=right=0</code>，把索引<strong>左闭右开</strong>区间<code>[left, right]</code>称为一个「窗口」。</p>\n<blockquote>\n<p>PS：理论上你可以设计两端都开或者两端都闭的区间，但设计为左闭右开区间是最方便处理的。因为这样初始化\n<code>left = right = 0</code> 时区间 <code>[0, 0)</code>\n中没有元素，但只要让 <code>right</code> 向右移动一位，区间\n<code>[0, 1)</code> 就包含一个元素 <code>0</code>\n了。如果你设置为两端都开的区间，那么让 <code>right</code>\n向右移动一位后开区间 <code>(0, 1)</code>\n仍然没有元素；如果你设置为两端都闭的区间，那么初始区间\n<code>[0, 0]</code>\n就包含了一个元素。这两种情况都会给边界处理带来不必要的麻烦。</p>\n</blockquote>\n<p>2，我们先不断地增加 <code>right</code> 指针扩大窗口\n<code>[left, right)</code>，直到窗口中的字符串符合要求（包含了\n<code>T</code> 中的所有字符）。</p>\n<p>3，此时，我们停止增加 <code>right</code>，转而不断增加\n<code>left</code> 指针缩小窗口\n<code>[left, right)</code>，直到窗口中的字符串不再符合要求（不包含\n<code>T</code> 中的所有字符了）。同时，每次增加\n<code>left</code>，我们都要更新一轮结果。</p>\n<p>4，重复第 2 和第 3 步，直到 <code>right</code> 到达字符串\n<code>S</code> 的尽头。</p>\n<p>下面画图理解一下，<code>needs</code> 和 <code>window</code>\n相当于计数器，分别记录 <code>T</code>\n中字符出现次数和「窗口」中的相应字符的出现次数。</p>\n<p>初始状态：</p>\n<p><img src=\"滑动窗口/1.png\" style=\"zoom:67%;\" /></p>\n<p>增加 <code>right</code>，直到窗口 <code>[left, right]</code> 包含了\n<code>T</code> 中所有字符：</p>\n<p><img src=\"滑动窗口/2.png\" style=\"zoom:67%;\" /></p>\n<p>现在开始增加 <code>left</code>，缩小窗口\n<code>[left, right]</code>：</p>\n<p><img src=\"滑动窗口/3.png\" style=\"zoom:67%;\" /></p>\n<p>直到窗口中的字符串不再符合要求，<code>left</code> 不再继续移动：</p>\n<p><img src=\"滑动窗口/4.png\" style=\"zoom:67%;\" /></p>\n<p>之后重复上述过程，先移动 <code>right</code>，再移动\n<code>left</code>…… 直到 <code>right</code> 指针到达字符串\n<code>S</code> 的末端，算法结束。</p>\n<p>如果你能够理解上述过程，恭喜，你已经完全掌握了滑动窗口算法思想。<strong>现在我们来看看这个滑动窗口代码框架怎么用</strong>：</p>\n<p>首先，初始化 <code>window</code> 和 <code>need</code>\n两个哈希表，记录窗口中的字符和需要凑齐的字符：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">unordered_map&lt;<span class=\"type\">char</span>, <span class=\"type\">int</span>&gt; need, window;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">char</span> c : t) need[c]++;</span><br></pre></td></tr></table></figure>\n<p>然后，使用 <code>left</code> 和 <code>right</code>\n变量初始化窗口的两端，不要忘了，区间 <code>[left, right)</code>\n是左闭右开的，所以初始情况下窗口没有包含任何元素：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> left = <span class=\"number\">0</span>, right = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> valid = <span class=\"number\">0</span>; </span><br><span class=\"line\"><span class=\"keyword\">while</span> (right &lt; s.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 开始滑动</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>其中 <code>valid</code> 变量表示窗口中满足 <code>need</code>\n条件的字符个数</strong>，如果 <code>valid</code> 和\n<code>need.size</code>\n的大小相同，则说明窗口已满足条件，已经完全覆盖了串 <code>T</code>。</p>\n<p>1、当移动 <code>right</code>\n扩大窗口，即加入字符时，应该更新哪些数据？</p>\n<p>2、什么条件下，窗口应该暂停扩大，开始移动 <code>left</code>\n缩小窗口？</p>\n<p>3、当移动 <code>left</code>\n缩小窗口，即移出字符时，应该更新哪些数据？</p>\n<p>4、我们要的结果应该在扩大窗口时还是缩小窗口时进行更新？</p>\n<p>如果一个字符进入窗口，应该增加 <code>window</code>\n计数器；如果一个字符将移出窗口的时候，应该减少 <code>window</code>\n计数器；当 <code>valid</code> 满足 <code>need</code>\n时应该收缩窗口；应该在收缩窗口的时候更新最终结果。</p>\n<p>下面是完整代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;limits&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">minWindow</span><span class=\"params\">(string s, string t)</span> </span>&#123;</span><br><span class=\"line\">        unordered_map&lt;<span class=\"type\">char</span>, <span class=\"type\">int</span>&gt; need, window;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">char</span> c : t) need[c]++;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">0</span>, right = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 使用 valid 来计算符合 t 的元素数量</span></span><br><span class=\"line\">        <span class=\"type\">int</span> valid = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//记录最小覆盖子串的起始索引及长度</span></span><br><span class=\"line\">        <span class=\"type\">int</span> start = <span class=\"number\">0</span>, len = INT_MAX;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(right &lt; s.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">            <span class=\"comment\">// c 是将移入窗口的字符</span></span><br><span class=\"line\">            <span class=\"type\">char</span> c = s[right];</span><br><span class=\"line\">            <span class=\"comment\">// 右移窗口</span></span><br><span class=\"line\">            right++;</span><br><span class=\"line\">            <span class=\"comment\">// 进行窗口内数据的一系列更新</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(need.<span class=\"built_in\">count</span>(c))&#123;</span><br><span class=\"line\">                window[c]++;</span><br><span class=\"line\">                <span class=\"comment\">// 当前元素符合所需要的个数</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(window[c] == need[c])&#123;</span><br><span class=\"line\">                    valid++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 判断左侧窗口是否要收缩</span></span><br><span class=\"line\">            <span class=\"comment\">// 元素已经可以在 s 中找到</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(valid == need.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">                <span class=\"comment\">//在这里更新最小覆盖子串</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(right - left &lt; len)&#123;</span><br><span class=\"line\">                    start = left;</span><br><span class=\"line\">                    <span class=\"comment\">// 记录子串的长度</span></span><br><span class=\"line\">                    len = right - left;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// d 是将移出窗口的字符</span></span><br><span class=\"line\">                <span class=\"type\">char</span> d = s[left];</span><br><span class=\"line\">                <span class=\"comment\">// 左移窗口</span></span><br><span class=\"line\">                left++;</span><br><span class=\"line\">                <span class=\"comment\">// 进行窗口内数据的一系列更新</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(need.<span class=\"built_in\">count</span>(d))&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(window[d] == need[d])</span><br><span class=\"line\">                        valid--;</span><br><span class=\"line\">                    window[d]--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 返回最小覆盖子串</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> len == INT_MAX ? <span class=\"string\">&quot;&quot;</span> : s.<span class=\"built_in\">substr</span>(start, len);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，当我们发现某个字符在 <code>window</code> 的数量满足了\n<code>need</code> 的需要，就要更新\n<code>valid</code>，表示有一个字符已经满足要求。而且，你能发现，两次对窗口内数据的更新操作是完全对称的。</p>\n<p>当 <code>valid == need.size()</code> 时，说明 <code>T</code>\n中所有字符已经被覆盖，已经得到一个可行的覆盖子串，现在应该开始收缩窗口了，以便得到「最小覆盖子串」。</p>\n<p>移动 <code>left</code>\n收缩窗口时，窗口内的字符都是可行解，所以应该在收缩窗口的阶段进行最小覆盖子串的更新，以便从可行解中找到长度最短的最终结果。</p>\n<h1 id=\"字符串的排列\"><a\nhref=\"https://leetcode-cn.com/problems/permutation-in-string/\">567.\n字符串的排列</a></h1>\n<p>给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1\n的排列。如果是，返回 true ；否则，返回 false 。</p>\n<p>换句话说，s1 的排列之一是 s2 的 子串 。</p>\n<h2 id=\"示例-1\">示例：</h2>\n<blockquote>\n<p>输入：s1 = \"ab\" s2 = \"eidbaooo\" 输出：true 解释：s2 包含 s1\n的排列之一 (\"ba\").</p>\n</blockquote>\n<h3 id=\"思路-1\">思路：</h3>\n<p>这种题目，是明显的滑动窗口算法，<strong>相当给你一个 <code>S</code>\n和一个 <code>T</code>，请问你 <code>S</code> 中是否存在一个子串，包含\n<code>T</code> 中所有字符且不包含其他字符</strong>？</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">checkInclusion</span><span class=\"params\">(string s1, string s2)</span> </span>&#123;</span><br><span class=\"line\">        unordered_map&lt;<span class=\"type\">char</span>, <span class=\"type\">int</span>&gt; need, window;</span><br><span class=\"line\">        <span class=\"comment\">//统计元素和个数</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">char</span> c : s1) need[c]++;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">0</span>, right = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> valid = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(right &lt; s2.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">            <span class=\"comment\">// c 是将要移入窗口的字符</span></span><br><span class=\"line\">            <span class=\"type\">char</span> c = s2[right];</span><br><span class=\"line\">            <span class=\"comment\">// 右移窗口</span></span><br><span class=\"line\">            right++;</span><br><span class=\"line\">            <span class=\"comment\">//进行窗口内数据的更新</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(need.<span class=\"built_in\">count</span>(c))&#123;</span><br><span class=\"line\">                window[c]++;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(need[c] == window[c])&#123;</span><br><span class=\"line\">                    valid++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//判断左侧窗口是否要收缩</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(right - left &gt;= s1.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 在这里更新子串</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(valid == need.<span class=\"built_in\">size</span>())</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// d 是将要移出窗口的字符</span></span><br><span class=\"line\">                <span class=\"type\">char</span> d = s2[left];</span><br><span class=\"line\">                <span class=\"comment\">// 左移窗口</span></span><br><span class=\"line\">                left++;</span><br><span class=\"line\">                <span class=\"comment\">// 进行窗口内数据的更新</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(need.<span class=\"built_in\">count</span>(d))&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(window[d] == need[d])</span><br><span class=\"line\">                        valid--;</span><br><span class=\"line\">                    window[d]--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>对于这道题的解法代码，基本上和最小覆盖子串一模一样，只需要改变两个地方：</p>\n<p>1、本题移动 <code>left</code> 缩小窗口的时机是窗口大小大于\n<code>t.size()</code> 时，应为排列嘛，显然长度应该是一样的。</p>\n<p>2、当发现 <code>valid == need.size()</code>\n时，就说明窗口中就是一个合法的排列，所以立即返回 <code>true</code>。</p>\n<p>至于如何处理窗口的扩大和缩小，和最小覆盖子串完全相同。</p>\n<p>#<a\nhref=\"https://www.nowcoder.com/practice/e8480ed7501640709354db1cc4ffd42a?tpId=37&amp;&amp;tqId=21286\"><strong>HJ63</strong>\n<strong>DNA序列</strong></a></p>\n<h2 id=\"描述\">描述：</h2>\n<p>一个 DNA 序列由 A/C/G/T 四个字母的排列组合组成。 G 和 C\n的比例（定义为 GC-Ratio ）是序列中 G 和 C\n两个字母的总的出现次数除以总的字母数目（也就是序列长度）。在基因工程中，这个比例非常重要。因为高的\nGC-Ratio 可能是基因的起始点。</p>\n<p>给定一个很长的 DNA 序列，以及限定的子串长度 N\n，请帮助研究人员在给出的 DNA 序列中从左往右找出 GC-Ratio 最高且长度为 N\n的第一个子串。</p>\n<p>DNA序列为 ACGT 的子串有: ACG , CG , CGT 等等，但是没有 AGT ， CT\n等等</p>\n<p>数据范围：字符串长度满足 <span\nclass=\"math inline\">\\(1≤n≤1000\\)</span> ，输入的字符串只包含 A/C/G/T\n字母</p>\n<h2 id=\"输入描述\">输入描述：</h2>\n<p>输入一个string型基因序列，和int型子串的长度</p>\n<h2 id=\"输出描述\">输出描述：</h2>\n<p>找出GC比例最高的子串,如果有多个则输出第一个的子串</p>\n<h2 id=\"示例-2\">示例：</h2>\n<blockquote>\n<p>输入：</p>\n<p>ACGT 2</p>\n<p>输出：</p>\n<p>CG</p>\n<p>说明：</p>\n<p>ACGT长度为2的子串有AC,CG,GT3个，其中AC和GT2个的GC-Ratio都为0.5，CG为1，故输出CG</p>\n</blockquote>\n<h3 id=\"思路-2\">思路：</h3>\n<p>也是滑动窗口问题，套用我们之前的框架。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;limits&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">滑动窗口</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    string s;</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(cin &gt;&gt; s &gt;&gt; n)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">0</span>, right = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> valid = <span class=\"number\">0</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">int</span> start = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">float</span> res = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(right &lt; s.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">            <span class=\"comment\">// c 是将要移入窗口的字符</span></span><br><span class=\"line\">            <span class=\"type\">char</span> c = s[right];</span><br><span class=\"line\">            <span class=\"comment\">// 右移窗口</span></span><br><span class=\"line\">            right++;</span><br><span class=\"line\">            <span class=\"comment\">// 进行窗口内数据的更新</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(c == <span class=\"string\">&#x27;C&#x27;</span> || c == <span class=\"string\">&#x27;G&#x27;</span>)&#123;</span><br><span class=\"line\">                valid++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 判断左侧窗口是否需要收缩</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>((right - left) == n)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//更新子串</span></span><br><span class=\"line\">                <span class=\"type\">float</span> tmp = valid / (n * <span class=\"number\">1.0</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(tmp &gt; res)&#123;</span><br><span class=\"line\">                    res = tmp;</span><br><span class=\"line\">                    start = left;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// d 是将移出窗口的字符</span></span><br><span class=\"line\">                <span class=\"type\">char</span> d = s[left];</span><br><span class=\"line\">                <span class=\"comment\">// 左移窗口</span></span><br><span class=\"line\">                left++;</span><br><span class=\"line\">                <span class=\"comment\">//进行窗口内的更新</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(d == <span class=\"string\">&#x27;C&#x27;</span> || d == <span class=\"string\">&#x27;G&#x27;</span>)&#123;</span><br><span class=\"line\">                    valid--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout &lt;&lt; s.<span class=\"built_in\">substr</span>(start, n) &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于这道题的解法代码，只需要改变两个地方：</p>\n<p>1，移动<code>left</code>收缩窗口的时机为当<code>(right - left) &gt; n</code>时，因为给定了子串长度，当长度一样时，就是答案。</p>\n<p>2，当发现<code>(right - left) == n</code>时，就说明窗口中就是一个合法的子串，我们取所有合法子串中包含<code>C,G</code>比例最高的，然后记录开始位置，加上给定的子串长度，我们就可以得出答案。</p>\n<h1 id=\"找到字符串中所有字母异位词\"><a\nhref=\"https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/\">438.\n找到字符串中所有字母异位词</a></h1>\n<p>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词\n的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>\n<p>异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。</p>\n<h2 id=\"示例-3\">示例：</h2>\n<blockquote>\n<p>输入: s = \"cbaebabacd\", p = \"abc\" 输出: [0,6] 解释: 起始索引等于 0\n的子串是 \"cba\", 它是 \"abc\" 的异位词。 起始索引等于 6 的子串是 \"bac\",\n它是 \"abc\" 的异位词。</p>\n</blockquote>\n<h3 id=\"思路-3\">思路：</h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">findAnagrams</span><span class=\"params\">(string s, string p)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; res;</span><br><span class=\"line\">        unordered_map&lt;<span class=\"type\">char</span>, <span class=\"type\">int</span>&gt; need, window;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">char</span> c : p) need[c]++;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">0</span>, right = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> valid = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(right &lt; s.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">            <span class=\"comment\">// c 是将要移入窗口的字符</span></span><br><span class=\"line\">            <span class=\"type\">char</span> c = s[right];</span><br><span class=\"line\">            <span class=\"comment\">// 右移窗口</span></span><br><span class=\"line\">            right++;</span><br><span class=\"line\">            <span class=\"comment\">// 进行窗口内数据的更新</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(need.<span class=\"built_in\">count</span>(c))&#123;</span><br><span class=\"line\">                window[c]++;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(need[c] == window[c])</span><br><span class=\"line\">                    valid++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 判断左侧窗口是否需要收缩</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>((right - left) == p.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 在这里更新子串</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(valid == need.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">                    res.<span class=\"built_in\">push_back</span>(left);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// d 是将要移出窗口的字符</span></span><br><span class=\"line\">                <span class=\"type\">char</span> d = s[left];</span><br><span class=\"line\">                <span class=\"comment\">// 左移窗口</span></span><br><span class=\"line\">                left++;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 进行窗口内数据的更新</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(need.<span class=\"built_in\">count</span>(d))&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(need[d] == window[d])</span><br><span class=\"line\">                        valid--;</span><br><span class=\"line\">                    window[d]--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"无重复字符的最长子串\"><a\nhref=\"https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/\">3.\n无重复字符的最长子串</a></h1>\n<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的\n<strong>最长子串</strong> 的长度。</p>\n<h2 id=\"示例-4\">示例：</h2>\n<blockquote>\n<p>输入: s = \"abcabcbb\" 输出: 3 解释: 因为无重复字符的最长子串是\n\"abc\"，所以其长度为 3。</p>\n</blockquote>\n<h3 id=\"思路-4\">思路：</h3>\n<p>这道题比之前灵活了不少，需要我们改动下框架，更新窗口内数据也只需要简单的更新计数器<code>window</code>即可。</p>\n<p>当 <code>window[c]</code> 值大于 1\n时，说明窗口中存在重复字符，不符合条件，就该移动 <code>left</code>\n缩小窗口了嘛。</p>\n<p>唯一需要注意的是，在哪里更新结果 <code>res</code>\n呢？我们要的是最长无重复子串，哪一个阶段可以保证窗口中的字符串是没有重复的呢？</p>\n<p>这里和之前不一样，要在收缩窗口完成后更新\n<code>res</code>，因为窗口收缩的 while\n条件是存在重复元素，换句话说收缩完成后一定保证窗口中没有重复嘛。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;limits&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        unordered_map&lt;<span class=\"type\">char</span>, <span class=\"type\">int</span>&gt; window;</span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">0</span>, right = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(right &lt; s.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">            <span class=\"type\">char</span> c = s[right];</span><br><span class=\"line\">            right++;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 进行窗口内数据的更新</span></span><br><span class=\"line\">            window[c]++;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 判断左侧窗口是否需要收缩</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(window[c] &gt; <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                <span class=\"type\">char</span> d = s[left];</span><br><span class=\"line\">                left++;</span><br><span class=\"line\">                <span class=\"comment\">// 进行窗口内数据的更新</span></span><br><span class=\"line\">                window[d]--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res = <span class=\"built_in\">max</span>(res, right - left);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"滑动窗口最大值\"><a\nhref=\"https://leetcode-cn.com/problems/sliding-window-maximum/\">239.\n滑动窗口最大值</a></h1>\n<p>给你一个整数数组 nums，有一个大小为 k\n的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k\n个数字。滑动窗口每次只向右移动一位。</p>\n<p>返回 滑动窗口中的最大值 。</p>\n<h2 id=\"示例-5\">示例：</h2>\n<blockquote>\n<p>输入：nums = [1,3,-1,-3,5,3,6,7], k = 3 输出：[3,3,5,5,6,7] 解释：\n滑动窗口的位置 最大值</p>\n<hr />\n<p>[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3\n-1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7</p>\n</blockquote>\n<h3 id=\"思路-5\">思路：</h3>\n<p>1，如果队列不空且当前元素大于队尾元素，则将队尾元素删除，直到队列为空或者当前元素小于新的队尾元素</p>\n<p>2，保持队列<code>q</code>当前递减，第一个数就是窗口内的最大值，第二个为第二大......</p>\n<p>3，当前首元素的下标小于滑动窗口左侧边界 left 时，\n表示队首元素已经不再滑动窗口内，因此将其从队首移除</p>\n<p>4，由于数组下标从 0 开始，因此当窗口边界 right + 1 大于等于窗口 k\n时， 意味着窗口形成。此时，队首元素就是该窗口的最大值。</p>\n<p><img src=\"滑动窗口/111.gif\" /></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;limits&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">优化</span></span><br><span class=\"line\"><span class=\"comment\">时机复杂度O(N)</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">maxSlidingWindow</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums.<span class=\"built_in\">size</span>() &lt; k || k &lt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">        deque&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">res</span><span class=\"params\">(nums.size() - k + <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> right = <span class=\"number\">0</span>; right &lt; nums.<span class=\"built_in\">size</span>(); right++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果队列不空且当前元素大于队尾元素，则将队尾元素删除</span></span><br><span class=\"line\">            <span class=\"comment\">//直到队列为空或者当前元素小于新的队尾元素</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!q.<span class=\"built_in\">empty</span>() &amp;&amp; nums[right] &gt;= nums[q.<span class=\"built_in\">back</span>()])&#123;</span><br><span class=\"line\">                q.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//存储元素下标</span></span><br><span class=\"line\">            q.<span class=\"built_in\">push_back</span>(right);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//计算窗口左侧边界</span></span><br><span class=\"line\">            <span class=\"type\">int</span> left = right - k + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 当前首元素的下标小于滑动窗口左侧边界 left 时</span></span><br><span class=\"line\">            <span class=\"comment\">// 表示队首元素已经不再滑动窗口内，因此将其从队首移除</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(q.<span class=\"built_in\">front</span>() &lt; left)&#123;</span><br><span class=\"line\">                q.<span class=\"built_in\">pop_front</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 由于数组下标从 0 开始，因此当窗口边界 right + 1 大于等于窗口 k 时</span></span><br><span class=\"line\">            <span class=\"comment\">// 意味着窗口形成。此时，队首元素就是该窗口的最大值。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(right + <span class=\"number\">1</span> &gt;= k)&#123;</span><br><span class=\"line\">                res[left] = nums[q.<span class=\"built_in\">front</span>()];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["数组","双指针"],"tags":["数组","滑动窗口"]},{"title":"矩形相交的面积","url":"/2022/04/10/%E7%9F%A9%E5%BD%A2%E7%9B%B8%E4%BA%A4%E7%9A%84%E9%9D%A2%E7%A7%AF/","content":"<h1 id=\"矩形相交的面积\">矩形相交的面积</h1>\n<p><strong>■ 题目描述</strong></p>\n<ul>\n<li>给出3组点坐标(x, y, w, h)，-1000&lt;x,y&lt;1000，w,h为正整数。</li>\n<li>(x, y, w, h)表示平面直角坐标系中的一个矩形：</li>\n<li>x, y为矩形左上角坐标点，w, h，向右w，向下h。</li>\n<li>(x, y, w, h)表示 x 轴 (x, x+w) 和 y 轴 (y, y-h) 围成的矩形区域</li>\n<li>(0, 0, 2, 2)表示 x 轴 (0, 2) 和 y 轴 (0, -2) 围成的矩形区域</li>\n<li>(3, 5, 4, 6)表示 x 轴 (3, 7) 和 y 轴 (5, -1) 围成的矩形区域</li>\n<li>求3组坐标构成的矩形区域重合部分的面积。</li>\n</ul>\n<p><strong>输入描述:</strong></p>\n<ul>\n<li>3行输入分别为3个矩形的位置，分别代表“左上角x坐标”，“左上角y坐标”，“矩形宽w”，“矩形高h”</li>\n<li>参数限制如下：1000 &lt;= x,y &lt; 1000</li>\n</ul>\n<p><strong>输出描述:</strong></p>\n<ul>\n<li>输出 3 个矩形相交的面积，不相交的输出 0。</li>\n</ul>\n<p><strong>示例</strong>\n输入输出示例仅供调试，后台判题数据一般不包含示例</p>\n<span id=\"more\"></span>\n<p><strong>输入</strong></p>\n<blockquote>\n<p>1 6 4 4 3 5 3 4 0 3 7 3</p>\n</blockquote>\n<p><strong>输出</strong></p>\n<blockquote>\n<p>2</p>\n</blockquote>\n<p><img src=\"矩形相交的面积/1.png\" /></p>\n<h2 id=\"思路\">思路：</h2>\n<p>画图了解即可，具体可看之前写过的<a\nhref=\"https://sjchen404.github.io/2019/04/04/矩形面积并/#more\">矩形面积并</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unordered_map&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ll;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">double</span> ld;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; pii;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> vector&lt;<span class=\"type\">int</span>&gt; vi;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x[<span class=\"number\">4</span>], y[<span class=\"number\">4</span>], w[<span class=\"number\">4</span>], h[<span class=\"number\">4</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++)&#123;</span><br><span class=\"line\">        cin &gt;&gt; x[i] &gt;&gt; y[i] &gt;&gt; w[i] &gt;&gt; h[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> left = <span class=\"built_in\">max</span>(x[<span class=\"number\">0</span>],<span class=\"built_in\">max</span>(x[<span class=\"number\">1</span>],x[<span class=\"number\">2</span>]));</span><br><span class=\"line\">    <span class=\"type\">int</span> right = <span class=\"built_in\">min</span>(x[<span class=\"number\">0</span>] + w[<span class=\"number\">0</span>], <span class=\"built_in\">min</span>(x[<span class=\"number\">1</span>] + w[<span class=\"number\">1</span>], x[<span class=\"number\">2</span>] + w[<span class=\"number\">2</span>]));</span><br><span class=\"line\">    <span class=\"type\">int</span> up = <span class=\"built_in\">min</span>(y[<span class=\"number\">0</span>],<span class=\"built_in\">min</span>(y[<span class=\"number\">1</span>], y[<span class=\"number\">2</span>]));</span><br><span class=\"line\">    <span class=\"type\">int</span> down = <span class=\"built_in\">max</span>(y[<span class=\"number\">0</span>] - h[<span class=\"number\">0</span>], <span class=\"built_in\">max</span>(y[<span class=\"number\">1</span>] - h[<span class=\"number\">1</span>], y[<span class=\"number\">2</span>] - h[<span class=\"number\">2</span>]));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(right - left &lt; <span class=\"number\">0</span> || up - down &lt; <span class=\"number\">0</span>) res = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> res = (right - left) * (up - down);</span><br><span class=\"line\">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["矩阵"],"tags":["华为机试","矩阵"]},{"title":"矩形面积并","url":"/2019/04/04/%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF%E5%B9%B6/","content":"<p><a\nhref=\"https://www.hpuoj.com/contest/16/problem/H/\">题目链接</a></p>\n<p>H. Mo的面积</p>\n<p>单测试点时限: 1.0 秒</p>\n<p>内存限制: 512 MB</p>\n<p>Mo的老师给了他两个矩形，让他求两个矩形的面积并。Mo很忙没时间解决这种小case，请你帮他解决。</p>\n<span id=\"more\"></span>\n<h3 id=\"输入\">输入</h3>\n<p>输入两行，每行四个整数 𝑥,𝑦,𝑥1,𝑦1 。(𝑥,𝑦) 是矩形左下角，(𝑥1,𝑦1)\n是矩形的右上角. (0≤𝑥,𝑦,𝑥1,𝑦1≤1000)。</p>\n<h3 id=\"输出\">输出</h3>\n<p>输出一个整数表示二个矩形的面积并。</p>\n<h3 id=\"样例\">样例</h3>\n<p>input</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">0 1 2 3</span><br><span class=\"line\">1 0 3 2</span><br></pre></td></tr></table></figure>\n<p>output</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">7</span><br></pre></td></tr></table></figure>\n<p>##矩形面积并问题</p>\n<p>两个矩形相交的情况总共有以下几种（可能有部分遗漏）：</p>\n<figure>\n<img src=\"矩形面积并/1.png\" alt=\"like this\" />\n<figcaption aria-hidden=\"true\">like this</figcaption>\n</figure>\n<p>我们可以观察到，如果两个矩阵相交，那么它的边的情况只能是这种情况：</p>\n<p>我们假设第一个矩阵的左下角坐标为，a[1],a[2],右上角坐标为a[3],a[4]</p>\n<p>第二个矩阵的左下角坐标为a[5],a[6],右上角坐标为a[7],a[8].</p>\n<p>left = max ( min( a[1] , a[3] ), min( a[5], a[7] ) )</p>\n<p>right = min (max ( a[1], a[3] ), max( a[5], a[7] ) )</p>\n<p>up = min (max ( a[2], a[4]), max ( a[6], a[8] ) )</p>\n<p>down = max (min ( a[2], a[4] ), min ( a[6], a[8] ) )</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> INF=<span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> a[<span class=\"number\">100</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">8</span>; i++) &#123;</span><br><span class=\"line\">        cin &gt;&gt; a[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> l = <span class=\"built_in\">max</span>(<span class=\"built_in\">min</span>(a[<span class=\"number\">1</span>],a[<span class=\"number\">3</span>]),<span class=\"built_in\">min</span>(a[<span class=\"number\">5</span>],a[<span class=\"number\">7</span>]));</span><br><span class=\"line\">    <span class=\"type\">int</span> r = <span class=\"built_in\">min</span>(<span class=\"built_in\">max</span>(a[<span class=\"number\">1</span>],a[<span class=\"number\">3</span>]),<span class=\"built_in\">max</span>(a[<span class=\"number\">5</span>],a[<span class=\"number\">7</span>]));</span><br><span class=\"line\">    <span class=\"type\">int</span> u = <span class=\"built_in\">min</span>(<span class=\"built_in\">max</span>(a[<span class=\"number\">2</span>],a[<span class=\"number\">4</span>]),<span class=\"built_in\">max</span>(a[<span class=\"number\">6</span>],a[<span class=\"number\">8</span>]));</span><br><span class=\"line\">    <span class=\"type\">int</span> d = <span class=\"built_in\">max</span>(<span class=\"built_in\">min</span>(a[<span class=\"number\">2</span>],a[<span class=\"number\">4</span>]),<span class=\"built_in\">min</span>(a[<span class=\"number\">6</span>],a[<span class=\"number\">8</span>]));</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">int</span> area;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r-l &lt; <span class=\"number\">0</span> || u-d &lt; <span class=\"number\">0</span>) area = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> area = (r-l)*(u-d);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,(a[<span class=\"number\">3</span>]-a[<span class=\"number\">1</span>])*(a[<span class=\"number\">4</span>]-a[<span class=\"number\">2</span>]) + (a[<span class=\"number\">7</span>]-a[<span class=\"number\">5</span>])*(a[<span class=\"number\">8</span>]-a[<span class=\"number\">6</span>]) - area);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["算法","矩形面积并"],"tags":["面积"]},{"title":"编辑距离","url":"/2022/04/27/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/","content":"<h1 id=\"编辑距离\"><a\nhref=\"https://leetcode-cn.com/problems/edit-distance/\">72.\n编辑距离</a></h1>\n<p>给你两个单词 <code>word1</code> 和 <code>word2</code>， <em>请返回将\n<code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数</em>\n。</p>\n<p>你可以对一个单词进行如下三种操作：</p>\n<ul>\n<li>插入一个字符</li>\n<li>删除一个字符</li>\n<li>替换一个字符</li>\n</ul>\n<h2 id=\"示例\">示例：</h2>\n<blockquote>\n<p>输入：word1 = \"horse\", word2 = \"ros\" 输出：3 解释： horse -&gt; rorse\n(将 'h' 替换为 'r') rorse -&gt; rose (删除 'r') rose -&gt; ros (删除\n'e')</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"思路\">思路：</h3>\n<p><code>if s1[i] == s2[j]:</code></p>\n<ul>\n<li>什么也不做</li>\n<li><code>i, j</code>同时向前移动</li>\n</ul>\n<p><code>else</code>:</p>\n<p>​ 三选一：</p>\n<ul>\n<li><p>插入（inser）</p></li>\n<li><p>删除（delete）</p></li>\n<li><p>替换（replace）</p></li>\n</ul>\n<p><strong><code>dp(i,j)</code>定义：返回<code>s1[0...i]</code> 和\n<code>s2[0...j]</code> 的最小编辑距离</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">minDistance</span><span class=\"params\">(string word1, string word2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> m = word1.<span class=\"built_in\">size</span>(), n = word2.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">dp</span>(word1, word2, m - <span class=\"number\">1</span>, n - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dp</span><span class=\"params\">(string&amp; s1, string &amp; s2, <span class=\"type\">int</span> i, <span class=\"type\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//base case</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i == <span class=\"number\">-1</span>) <span class=\"keyword\">return</span> j + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(j == <span class=\"number\">-1</span>) <span class=\"keyword\">return</span> i + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">//s1[i] == s2[j]什么都不做，i,j同时向前移</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s1[i] == s2[j])&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">dp</span>(s1, s2, i - <span class=\"number\">1</span>, j - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//插入，删除，替换三选一</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">min</span>(<span class=\"built_in\">dp</span>(s1, s2, i, j - <span class=\"number\">1</span>) + <span class=\"number\">1</span>, <span class=\"comment\">//插入</span></span><br><span class=\"line\">            <span class=\"built_in\">min</span>(<span class=\"built_in\">dp</span>(s1, s2, i - <span class=\"number\">1</span>, j) + <span class=\"number\">1</span>,        <span class=\"comment\">//删除</span></span><br><span class=\"line\">                <span class=\"built_in\">dp</span>(s1, s2, i - <span class=\"number\">1</span>, j - <span class=\"number\">1</span>) + <span class=\"number\">1</span>));  <span class=\"comment\">//替换</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>有大量的重叠子问题，我们采用迭代的方法来解决</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">minDistance</span><span class=\"params\">(string word1, string word2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> m = word1.<span class=\"built_in\">size</span>(), n = word2.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; <span class=\"built_in\">dp</span>(m + <span class=\"number\">1</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt; (n + <span class=\"number\">1</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\">        <span class=\"comment\">//base case, 某一个为空时</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; i++)&#123;</span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++)&#123;</span><br><span class=\"line\">            dp[<span class=\"number\">0</span>][j] = j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 自底向上</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(word1[i - <span class=\"number\">1</span>] == word2[j - <span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                    dp[i][j] = dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    dp[i][j] = <span class=\"built_in\">min</span>(</span><br><span class=\"line\">                        dp[i][j - <span class=\"number\">1</span>] + <span class=\"number\">1</span>,</span><br><span class=\"line\">                        <span class=\"built_in\">min</span>(</span><br><span class=\"line\">                            dp[i - <span class=\"number\">1</span>][j] + <span class=\"number\">1</span>,</span><br><span class=\"line\">                            dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>] + <span class=\"number\">1</span></span><br><span class=\"line\">                        )</span><br><span class=\"line\">                    );</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m][n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["动态规划"],"tags":["动态规划"]},{"title":"简易内存池","url":"/2022/04/10/%E7%AE%80%E6%98%93%E5%86%85%E5%AD%98%E6%B1%A0/","content":"<h1 id=\"简易内存池\">简易内存池</h1>\n<h3 id=\"题目描述\">题目描述</h3>\n<ul>\n<li>请实现一个简易内存池，根据请求命令完成内存分配和释放。</li>\n<li>内存池支持两种操作命令，REQUEST和RELEASE，其格式为：</li>\n<li>REQUEST=请求的内存大小表示请求分配指定大小内存，如果分配成功，返回分配到的内存首地址；</li>\n</ul>\n<p>​ 如果内存不足，或指定的大小为0，则输出error。</p>\n<ul>\n<li>RELEASE=释放的内存首地址表示释放掉之前分配的内存，释放成功无需输出，如果释放不存在的首地址则输出error。</li>\n</ul>\n<p><strong>注意：</strong></p>\n<ol type=\"1\">\n<li>内存池总大小为100字节。</li>\n<li>内存池地址分配必须是连续内存，并优先从低地址分配。</li>\n<li>内存释放后可被再次分配，已释放的内存在空闲时不能被二次释放。</li>\n<li>不会释放已申请的内存块的中间地址。</li>\n<li>释放操作只是针对首地址所对应的单个内存块进行操作，不会影响其它内存块。</li>\n</ol>\n<h4 id=\"输入\"><strong>输入</strong></h4>\n<ul>\n<li>首行为整数 N , 表示操作命令的个数，取值范围：0 &lt; N &lt;=\n100。</li>\n<li>接下来的N行, 每行将给出一个操作命令，操作命令和参数之间用 “=”\n分割。</li>\n</ul>\n<h4 id=\"输出\"><strong>输出</strong></h4>\n<ul>\n<li>见题目描述</li>\n</ul>\n<p><strong>示例 1</strong>\n输入输出示例仅供调试，后台判题数据一般不包含示例</p>\n<span id=\"more\"></span>\n<p><strong>输入</strong></p>\n<blockquote>\n<p>2 REQUEST=10 REQUEST=20</p>\n</blockquote>\n<p><strong>输出</strong></p>\n<blockquote>\n<p>0 10</p>\n</blockquote>\n<p><strong>示例 2</strong>\n输入输出示例仅供调试，后台判题数据一般不包含示例</p>\n<p><strong>输入</strong></p>\n<blockquote>\n<p>5 REQUEST=10 REQUEST=20 RELEASE=0 REQUEST=20 REQUEST=10</p>\n</blockquote>\n<p><strong>输出</strong></p>\n<blockquote>\n<p>0 10 30 0</p>\n</blockquote>\n<p><strong>解释</strong></p>\n<blockquote>\n<p>第一条指令，申请地址0~9的10个字节内存，返回首地址0</p>\n<p>第二条指令，申请地址10~29的20字节内存，返回首地址10</p>\n<p>第三条指令，释放首地址为0的内存申请，0~9地址内存被释放，变为空闲，释放成功，无需输出</p>\n<p>第四条指令，申请20字节内存，0<sub>9地址内存连续空间不足20字节，往后查找到30</sub>49地址，返回首地址30</p>\n<p>第五条指令，申请10字节，0~9地址内存空间足够，返回首地址0</p>\n</blockquote>\n<h2 id=\"思路\">思路：</h2>\n<p>模拟，先定义个数组表示cache，用哈希表存取开始地址和其对应的长度，用来判断释放的是不是我们之前创建的。</p>\n<p>判断申请是否合法主要有以下几种情况：</p>\n<ul>\n<li>申请地址 + 长度 &lt; 100\n<ul>\n<li>第一种之前没有释放过，那么就在申请地址后面申请</li>\n<li>之前释放过，先判断之前释放的空间是否够存放现在申请的</li>\n</ul></li>\n<li>申请地址 + 长度 &gt; 100\n<ul>\n<li>之前没有释放过，直接输出<code>error</code></li>\n<li>之前释放过，也是判断之前释放的是否能够存放现在申请的。</li>\n</ul></li>\n</ul>\n<p>判断释放是否合法</p>\n<ul>\n<li>如果在哈希表中存在，肯定合法，需要移动释放指针</li>\n<li>否则输出error</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unordered_map&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ll;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">long</span> <span class=\"type\">double</span> ld;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; pii;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> vector&lt;<span class=\"type\">int</span>&gt; vi;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> N;</span><br><span class=\"line\">    cin &gt;&gt; N;</span><br><span class=\"line\">    <span class=\"comment\">//申请指针</span></span><br><span class=\"line\">    <span class=\"type\">int</span> reqPos = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//释放指针</span></span><br><span class=\"line\">    <span class=\"type\">int</span> relPos = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//内存池</span></span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">cache</span><span class=\"params\">(<span class=\"number\">100</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">//哈希表存开始地址和其对应的长度</span></span><br><span class=\"line\">    unordered_map&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; mp;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(N--)&#123;</span><br><span class=\"line\">        string str;</span><br><span class=\"line\">        cin &gt;&gt; str;</span><br><span class=\"line\">        <span class=\"type\">int</span> index;</span><br><span class=\"line\">        <span class=\"comment\">//划分操作和长度</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; str.<span class=\"built_in\">size</span>(); i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(str[i] == <span class=\"string\">&#x27;=&#x27;</span>)&#123;</span><br><span class=\"line\">                index = i;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//得到操作数</span></span><br><span class=\"line\">        string op = str.<span class=\"built_in\">substr</span>(<span class=\"number\">0</span>, index);</span><br><span class=\"line\">        <span class=\"comment\">//得到地址或长度</span></span><br><span class=\"line\">        <span class=\"type\">int</span> len = <span class=\"built_in\">stoi</span>(str.<span class=\"built_in\">substr</span>(index + <span class=\"number\">1</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(op == <span class=\"string\">&quot;REQUEST&quot;</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//加入长度为0</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(len == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                cout &lt;&lt; <span class=\"string\">&quot;error&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(reqPos + len &lt;= <span class=\"number\">100</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//长度小于100，表示后面肯定可以成功添加内存</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">//没有释放过</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(relPos == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//记录插入的到哈希表中</span></span><br><span class=\"line\">                    mp[reqPos] = len;</span><br><span class=\"line\">                    <span class=\"comment\">//输出首地址</span></span><br><span class=\"line\">                    cout &lt;&lt; reqPos &lt;&lt; endl;</span><br><span class=\"line\">                    <span class=\"type\">int</span> end = reqPos + len;</span><br><span class=\"line\">                    <span class=\"comment\">//把cache中对应的片段置1,并且移动申请指针到尾部</span></span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = reqPos; i &lt; end; i++, reqPos++)&#123;</span><br><span class=\"line\">                        cache[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(relPos != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//有释放过空间，那么我们先判断释放的空间可不可以存下我们申请的</span></span><br><span class=\"line\">                    <span class=\"comment\">//如果能存下，我们就在释放的地方存，否则到尾部存</span></span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">//从头遍历到释放指针到位置，判断是否有足够的连续空间</span></span><br><span class=\"line\">                    <span class=\"type\">int</span> linkLen = <span class=\"number\">0</span>;</span><br><span class=\"line\">                    <span class=\"type\">int</span> linkPos = <span class=\"number\">-1</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(relPos &gt;= len)&#123;</span><br><span class=\"line\">                        <span class=\"comment\">//遍历</span></span><br><span class=\"line\">                        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; relPos; i++)&#123;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span>(cache[i] == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                                linkLen++;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span>(linkLen == len)&#123;</span><br><span class=\"line\">                                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                                <span class=\"comment\">//当前cache已经被占用</span></span><br><span class=\"line\">                                linkLen = <span class=\"number\">0</span>;</span><br><span class=\"line\">                                linkPos = i;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"comment\">//判断是否成功分配</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(linkLen &gt;= len)&#123;</span><br><span class=\"line\">                            <span class=\"comment\">//成功分配</span></span><br><span class=\"line\">                            mp[linkPos + <span class=\"number\">1</span>] = len;</span><br><span class=\"line\">                            cout &lt;&lt; linkPos + <span class=\"number\">1</span> &lt;&lt; endl;</span><br><span class=\"line\">                            <span class=\"comment\">//cache置1</span></span><br><span class=\"line\">                            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = linkPos + <span class=\"number\">1</span>; i &lt; (linkPos + <span class=\"number\">1</span> + len); i++)&#123;</span><br><span class=\"line\">                                cache[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            <span class=\"comment\">//把释放指针前移</span></span><br><span class=\"line\">                            relPos = linkPos + <span class=\"number\">1</span>;</span><br><span class=\"line\">                        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                            <span class=\"comment\">//前面不存在这么长的连续区间，需要在后面分配</span></span><br><span class=\"line\">                            mp[reqPos] = len;</span><br><span class=\"line\">                            cout &lt;&lt; reqPos &lt;&lt; endl;</span><br><span class=\"line\">                            <span class=\"type\">int</span> end = reqPos + len;</span><br><span class=\"line\">                            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = reqPos; i &lt; end; i++, reqPos++)&#123;</span><br><span class=\"line\">                                cache[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                        <span class=\"comment\">//后面找</span></span><br><span class=\"line\">                        mp[reqPos] = len;</span><br><span class=\"line\">                        cout &lt;&lt; reqPos &lt;&lt; endl;</span><br><span class=\"line\">                        <span class=\"type\">int</span> end = reqPos + len;</span><br><span class=\"line\">                        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = reqPos; i &lt; end; i++, reqPos++)&#123;</span><br><span class=\"line\">                            cache[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(reqPos + len &gt; <span class=\"number\">100</span> &amp;&amp; relPos != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//超过100，前面释放过</span></span><br><span class=\"line\">                <span class=\"type\">int</span> linkLen = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"type\">int</span> linkPos = <span class=\"number\">-1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(relPos &gt;= len)&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//遍历</span></span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; relPos; i++)&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>(cache[i] == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                            linkLen++;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span>(linkLen == len)&#123;</span><br><span class=\"line\">                                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                            <span class=\"comment\">//当前cache已经被占用</span></span><br><span class=\"line\">                            linkLen = <span class=\"number\">0</span>;</span><br><span class=\"line\">                            linkPos = i;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">//判断是否成功分配</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(linkLen &gt;= len)&#123;</span><br><span class=\"line\">                        <span class=\"comment\">//成功分配</span></span><br><span class=\"line\">                        mp[linkPos + <span class=\"number\">1</span>] = len;</span><br><span class=\"line\">                        cout &lt;&lt; linkPos + <span class=\"number\">1</span> &lt;&lt; endl;</span><br><span class=\"line\">                        <span class=\"comment\">//cache置1</span></span><br><span class=\"line\">                        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = linkPos + <span class=\"number\">1</span>; i &lt; (linkPos + <span class=\"number\">1</span> + len); i++)&#123;</span><br><span class=\"line\">                            cache[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"comment\">//把释放指针前移</span></span><br><span class=\"line\">                        relPos = linkPos + <span class=\"number\">1</span>;</span><br><span class=\"line\">                    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                        cout &lt;&lt; <span class=\"string\">&quot;error&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    cout &lt;&lt; <span class=\"string\">&quot;error&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">//超过100，且前面没释放过</span></span><br><span class=\"line\">                cout &lt;&lt; <span class=\"string\">&quot;error&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(op == <span class=\"string\">&quot;RELEASE&quot;</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//释放</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(mp.<span class=\"built_in\">count</span>(len))&#123;</span><br><span class=\"line\">                <span class=\"comment\">//释放的起点和长度</span></span><br><span class=\"line\">                <span class=\"type\">int</span> caplen = mp[len];</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = len; i &lt; caplen; i++)&#123;</span><br><span class=\"line\">                    cache[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                relPos = len + caplen;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">//不存在这个起点的内存</span></span><br><span class=\"line\">                cout &lt;&lt; <span class=\"string\">&quot;error&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["模拟"],"tags":["华为机试","模拟"]},{"title":"贪心算法","url":"/2022/04/08/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/","content":"<p>什么是贪心算法呢？贪心算法可以认为是动态规划算法的一个特例，相比动态规划，使用贪心算法需要满足更多的条件（贪心选择性质），但是效率比动态规划要高。</p>\n<p>比如说一个算法问题使用暴力解法需要指数级时间，如果能使用动态规划消除重叠子问题，就可以降到多项式级别的时间，如果满足贪心选择性质，那么可以进一步降低时间复杂度，达到线性级别的。</p>\n<p>什么是贪心选择性质呢，简单说就是：每一步都做出一个局部最优的选择，最终的结果就是全局最优。注意哦，这是一种特殊性质，其实只有一小部分问题拥有这个性质。</p>\n<p>比如你面前放着 100\n张人民币，你只能拿十张，怎么才能拿最多的面额？显然每次选择剩下钞票中面值最大的一张，最后你的选择一定是最优的。</p>\n<h1 id=\"无重叠区间\"><a\nhref=\"https://leetcode-cn.com/problems/non-overlapping-intervals/\">435.\n无重叠区间</a></h1>\n<p>给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi]\n。返回 需要移除区间的最小数量，使剩余区间互不重叠 。</p>\n<h2 id=\"示例\">示例：</h2>\n<blockquote>\n<p>输入: intervals = [[1,2],[2,3],[3,4],[1,3]] 输出: 1 解释: 移除 [1,3]\n后，剩下的区间没有重叠。</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"思路\">思路：</h3>\n<p>举个例子，<code>intvs=[[1,3],[2,4],[3,6]]</code>，这些区间最多有两个区间互不相交，即<code>[[1,3],[3,6]]</code>，你的算法应该返回\n2。注意边界相同并不算相交。</p>\n<p><strong>这个问题在生活中的应用广泛，比如你今天有好几个活动，每个活动都可以用区间<code>[start,end]</code>表示开始和结束的时间，请问你今天最多能参加几个活动呢？</strong></p>\n<p>这个问题有许多看起来不错的解决思路，实际上都不能得到正确答案。比如说：</p>\n<p>也许我们可以每次选择可选区间中开始最早的那个？但是可能存在某些区间开始很早，但是很长，使得我们错误地错过了一些短的区间。</p>\n<p>或者我们每次选择可选区间中最短的那个？或者选择出现冲突最少的那个区间？这些方案都能很容易举出反例，不是正确的方案。</p>\n<p>正确的思路其实很简单，可以分为以下三步：</p>\n<ol type=\"1\">\n<li>从区间集合 intvs 中选择一个区间 x，这个 x\n是在当前所有区间中<strong>结束最早的</strong>（end 最小）。</li>\n<li>把所有与 x 区间相交的区间从区间集合 intvs 中删除。</li>\n<li>重复步骤 1 和 2，直到 intvs 为空为止。之前选出的那些 x\n就是最大不相交子集。</li>\n</ol>\n<p>把这个思路实现成算法的话，可以按每个区间的<code>end</code>数值升序排序，因为这样处理之后实现步骤\n1 和步骤 2 都方便很多:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">eraseOverlapIntervals</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt;&amp; intervals)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(intervals.<span class=\"built_in\">size</span>() == <span class=\"number\">0</span> || intervals.<span class=\"built_in\">size</span>() == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//按照 end 升序排列</span></span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(intervals.<span class=\"built_in\">begin</span>(), intervals.<span class=\"built_in\">end</span>(), [](<span class=\"type\">const</span> vector&lt;<span class=\"type\">int</span>&gt;&amp; a, <span class=\"type\">const</span> vector&lt;<span class=\"type\">int</span>&gt;&amp; b)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> a[<span class=\"number\">1</span>] &lt; b[<span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"comment\">//至少有一个区间不相交</span></span><br><span class=\"line\">        <span class=\"type\">int</span> count = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">//排序后，第一个区间为 x</span></span><br><span class=\"line\">        <span class=\"type\">int</span> x_end = intervals[<span class=\"number\">0</span>][<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(vector&lt;<span class=\"type\">int</span>&gt; intv : intervals)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> start = intv[<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(start &gt;= x_end)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//找到下一个选择的区间</span></span><br><span class=\"line\">                count++;</span><br><span class=\"line\">                x_end = intv[<span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> intervals.<span class=\"built_in\">size</span>() - count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"用最少数量的箭引爆气球\"><a\nhref=\"https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/\">452.\n用最少数量的箭引爆气球</a></h1>\n<p>有一些球形气球贴在一堵用 XY\n平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] =\n[xstart, xend] 表示水平直径在 xstart 和\nxend之间的气球。你不知道气球的确切 y 坐标。</p>\n<p>一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x\n处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足\nxstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。\n弓箭一旦被射出之后，可以无限地前进。</p>\n<p>给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。</p>\n<h2 id=\"示例-1\">示例：</h2>\n<blockquote>\n<p>输入：points = [[10,16],[2,8],[1,6],[7,12]] 输出：2\n解释：气球可以用2支箭来爆破: -在x = 6处射出箭，击破气球[2,8]和[1,6]。\n-在x = 11处发射箭，击破气球[10,16]和[7,12]。</p>\n</blockquote>\n<h3 id=\"思路-1\">思路：</h3>\n<p>和前面差不多，也是按照<code>end</code>的升序来排列</p>\n<ul>\n<li>从points 中选择结束时间最早的一个区间<code>x_end</code></li>\n<li>我们可以发现只要start 小于\n<code>x_end</code>的都可以只需要一箭，所以当 start 大于\n<code>x_end</code>时，箭的数量加一，并且改变<code>x_end</code></li>\n<li>重复以上两个，知道points 为空</li>\n</ul>\n<p><img src=\"贪心算法/1.jpeg\" /></p>\n<p>代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">findMinArrowShots</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(points.<span class=\"built_in\">size</span>() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(points.<span class=\"built_in\">size</span>() == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//按照 end 升序排列</span></span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(points.<span class=\"built_in\">begin</span>(), points.<span class=\"built_in\">end</span>(), [](<span class=\"type\">const</span> vector&lt;<span class=\"type\">int</span>&gt;&amp; a, <span class=\"type\">const</span> vector&lt;<span class=\"type\">int</span>&gt;&amp; b)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> a[<span class=\"number\">1</span>] &lt; b[<span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"comment\">//至少需要一根箭</span></span><br><span class=\"line\">        <span class=\"type\">int</span> count = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> x_end = points[<span class=\"number\">0</span>][<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(vector&lt;<span class=\"type\">int</span>&gt; p : points)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> start = p[<span class=\"number\">0</span>];</span><br><span class=\"line\">          \t<span class=\"comment\">// 起点大于终点，箭的数量加一，更新新的终点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(start &gt; x_end)&#123;</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">                x_end = p[<span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"视频拼接\"><a\nhref=\"https://leetcode-cn.com/problems/video-stitching/\">1024.\n视频拼接</a></h1>\n<p>你将会获得一系列视频片段，这些片段来自于一项持续时长为 time\n秒的体育赛事。这些片段可能有所重叠，也可能长度不一。</p>\n<p>使用数组 clips 描述所有的视频片段，其中 clips[i] = [starti, endi]\n表示：某个视频片段开始于 starti 并于 endi 结束。</p>\n<p>甚至可以对这些片段自由地再剪辑：</p>\n<p>例如，片段 [0, 7] 可以剪切成 [0, 1] + [1, 3] + [3, 7] 三部分。\n我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（[0,\ntime]）。返回所需片段的最小数目，如果无法完成该任务，则返回 -1 。</p>\n<h2 id=\"示例-2\">示例：</h2>\n<blockquote>\n<p>输入：clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], time = 10\n输出：3 解释： 选中 [0,2], [8,10], [1,9] 这三个片段。\n然后，按下面的方案重制比赛片段： 将 [1,9] 再剪辑为 [1,2] + [2,8] + [8,9]\n。 现在手上的片段为 [0,2] + [2,8] + [8,10]，而这些覆盖了整场比赛 [0,\n10]。</p>\n</blockquote>\n<h3 id=\"思路-2\">思路：</h3>\n<p>我们先按照起点升序排列，如果起点相同的话按照终点降序排列。原因如下：</p>\n<ul>\n<li>视频肯定是<code>[0,time]</code>，如果没有从 0\n开始的肯定凑不齐。</li>\n<li>如果有几个短视频的起点相同，我们肯定选择最长的（终点最大）视频。</li>\n</ul>\n<p>排序之后我们可以得到：</p>\n<p><img src=\"贪心算法/2.jpg\" /></p>\n<p>这样我们就可以确定，如果<code>clips[0]</code>是的起点是\n0，那么<code>clips[0]</code>这个视频一定会被选择。</p>\n<p><img src=\"贪心算法/3.jpg\" /></p>\n<p>当我们确定<code>clips[0]</code>一定会被选择之后，就可以选出第二个会被选择的视频:</p>\n<p><img src=\"贪心算法/4.jpg\" /></p>\n<p><strong>我们会比较所有起点小于<code>clips[0][1]</code>的区间，根据贪心策略，它们中终点最大的那个区间就是第二个会被选中的视频</strong>。</p>\n<p>然后可以通过第二个视频区间贪心选择出第三个视频，以此类推，直到覆盖区间<code>[0, T]</code>，或者无法覆盖返回\n-1。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">videoStitching</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; clips, <span class=\"type\">int</span> time)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//按照起点升序排列，如果起点相同，按照终点降序排列</span></span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(clips.<span class=\"built_in\">begin</span>(), clips.<span class=\"built_in\">end</span>(), [](<span class=\"type\">const</span> vector&lt;<span class=\"type\">int</span>&gt;&amp; a, <span class=\"type\">const</span> vector&lt;<span class=\"type\">int</span>&gt;&amp; b)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(a[<span class=\"number\">0</span>] == b[<span class=\"number\">0</span>])&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> a[<span class=\"number\">1</span>] &gt; b[<span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> a[<span class=\"number\">0</span>] &lt; b[<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> curEnd = <span class=\"number\">0</span>, nextEnd = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> i = <span class=\"number\">0</span>, n = clips.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i &lt; n &amp;&amp; clips[i][<span class=\"number\">0</span>] &lt;= curEnd)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//在第 res 个视频的区间内贪心选择下一个视频</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(i &lt; n &amp;&amp; clips[i][<span class=\"number\">0</span>] &lt;= curEnd)&#123;</span><br><span class=\"line\">                nextEnd = <span class=\"built_in\">max</span>(nextEnd, clips[i][<span class=\"number\">1</span>]);</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//找到下一个视频，更新 curEnd</span></span><br><span class=\"line\">            res++;</span><br><span class=\"line\">            curEnd = nextEnd;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(curEnd &gt;= time)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//已经可以拼出区间 [0,time]</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["贪心","区间"],"tags":["leetcode","区间","排序","贪心"]},{"title":"背包问题","url":"/2022/03/03/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","content":"<p><img src=\"背包问题/1.png\" /></p>\n<span id=\"more\"></span>\n<p>#0-1背包</p>\n<p>给你一个可装载重量为 <code>W</code> 的背包和 <code>N</code>\n个物品，每个物品有重量和价值两个属性。其中第 <code>i</code>\n个物品的重量为 <code>wt[i]</code>，价值为\n<code>val[i]</code>，现在让你用这个背包装物品，最多能装的价值是多少？</p>\n<p>例如：</p>\n<blockquote>\n<p>N = 3, W = 4</p>\n<p>wt = [2,1,3]</p>\n<p>val = [4,2,3]</p>\n</blockquote>\n<p>算法返回 6，选择前两件物品装进背包，总重量 3 小于\n<code>W</code>，可以获得最大价值 6。</p>\n<p>题目就是这么简单，一个典型的动态规划问题。这个题目中的物品不可以分割，要么装进包里，要么不装，不能说切成两块装一半。这就是\n0-1 背包这个名词的来历。</p>\n<p>解决这个问题没有什么排序之类巧妙的方法，只能穷举所有可能，根据我们[动态规划详解中的套路，直接走流程就行了。</p>\n<p>###<strong>第一步要明确两点，「状态」和「选择」</strong></p>\n<p>对于0-1背包状态有两个，就是「背包容量」和「可选择的物品」；</p>\n<p>再说选择，对于每件物品，选择就是「装进背包」或者「不装进背包」</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> 状态<span class=\"number\">1</span> in 状态<span class=\"number\">1</span>的所有取值：</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> 状态<span class=\"number\">2</span> in 状态<span class=\"number\">2</span>的所有取值:</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> ...</span><br><span class=\"line\">\t\t\tdp[状态<span class=\"number\">1</span>][状态<span class=\"number\">2</span>][...] = 择优(选择<span class=\"number\">1</span>，选择<span class=\"number\">2.</span>..)</span><br></pre></td></tr></table></figure>\n<p>###<strong>第二步要明确<code>dp</code>数组的定义</strong></p>\n<p>首先看看刚才找到的「状态」，有两个，也就是说我们需要一个二维\n<code>dp</code> 数组。</p>\n<p><code>dp[i][w]</code> 的定义如下：对于前 <code>i</code>\n个物品，当前背包的容量为 <code>w</code>，这种情况下可以装的最大价值是\n<code>dp[i][w]</code>。</p>\n<p>比如说，如果\n<code>dp[3][5] = 6</code>，其含义为：对于给定的一系列物品中，若只对前 3\n个物品进行选择，当背包容量为 5 时，最多可以装下的价值为 6。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>[][] dp[N+<span class=\"number\">1</span>][W+<span class=\"number\">1</span>]</span><br><span class=\"line\">dp[<span class=\"number\">0</span>][..] = <span class=\"number\">0</span></span><br><span class=\"line\">dp[..][<span class=\"number\">0</span>] = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i in [<span class=\"number\">1.</span>.N]:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> w in [<span class=\"number\">1.</span>.W]:</span><br><span class=\"line\">        dp[i][w] = <span class=\"built_in\">max</span>(</span><br><span class=\"line\">            把物品 i 装进背包,</span><br><span class=\"line\">            不把物品 i 装进背包</span><br><span class=\"line\">        )</span><br><span class=\"line\"><span class=\"keyword\">return</span> dp[N][W]</span><br></pre></td></tr></table></figure>\n<p>###<strong>第三步，根据「选择」，思考状态转移的逻辑</strong></p>\n<p>先重申下<code>dp</code>数组的定义：</p>\n<p>对于前 <code>i</code> 个物品，当前背包的容量为\n<code>w</code>，这种情况下可以装的最大价值是 <code>dp[i][w]</code>。</p>\n<p><strong>如果你没有把这第<code>i</code>个物品装入背包，</strong>\n那么最大价值<code>dp[i][w]</code>应该等于<code>dp[i-1][w]</code>，继承之前的结果。</p>\n<p><strong>如果你把第<code>i</code>个物品装入了背包，</strong>\n那么<code>dp[i][w]</code>应该等于<code>dp[i-1][w-wt[i-1]]+val[i-1]</code></p>\n<p>首先，由于<code>i</code>是从1开始的，所以<code>val</code>和<code>wt</code>的索引是<code>i-1</code>时表示第<code>i</code>个物品的价值和重量。</p>\n<p>而 <code>dp[i-1][w - wt[i-1]]</code> 也很好理解：你如果装了第\n<code>i</code> 个物品，就要寻求剩余重量 <code>w - wt[i-1]</code>\n限制下的最大价值，加上第 <code>i</code> 个物品的价值\n<code>val[i-1]</code>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i in [<span class=\"number\">1.</span>.N]:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> w in [<span class=\"number\">1.</span>.W]:</span><br><span class=\"line\">        dp[i][w] = <span class=\"built_in\">max</span>(</span><br><span class=\"line\">            dp[i<span class=\"number\">-1</span>][w],</span><br><span class=\"line\">            dp[i<span class=\"number\">-1</span>][w - wt[i<span class=\"number\">-1</span>]] + val[i<span class=\"number\">-1</span>]</span><br><span class=\"line\">        )</span><br><span class=\"line\"><span class=\"keyword\">return</span> dp[N][W]</span><br></pre></td></tr></table></figure>\n<p>###<strong>最后一步，处理边界</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">knapsack</span><span class=\"params\">(<span class=\"type\">int</span> W, <span class=\"type\">int</span> N, <span class=\"type\">int</span>[] wt, <span class=\"type\">int</span>[] val)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// base case 已初始化</span></span><br><span class=\"line\">    <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"type\">int</span>[N + <span class=\"number\">1</span>][W + <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= N; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> w = <span class=\"number\">1</span>; w &lt;= W; w++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (w - wt[i - <span class=\"number\">1</span>] &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 这种情况下只能选择不装入背包</span></span><br><span class=\"line\">                dp[i][w] = dp[i - <span class=\"number\">1</span>][w];</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 装入或者不装入背包，择优</span></span><br><span class=\"line\">                dp[i][w] = Math.<span class=\"built_in\">max</span>(</span><br><span class=\"line\">                    dp[i - <span class=\"number\">1</span>][w - wt[i<span class=\"number\">-1</span>]] + val[i<span class=\"number\">-1</span>], </span><br><span class=\"line\">                    dp[i - <span class=\"number\">1</span>][w]</span><br><span class=\"line\">                );</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[N][W];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"分割等和子集\"><a\nhref=\"https://leetcode-cn.com/problems/partition-equal-subset-sum/\">416.\n分割等和子集</a></h2>\n<p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组\n<code>nums</code>\n。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>\n<h3 id=\"示例\">示例：</h3>\n<blockquote>\n<p>输入：nums = [1,5,11,5] 输出：true 解释：数组可以分割成 [1, 5, 5] 和\n[11] 。</p>\n</blockquote>\n<h3 id=\"思路\">思路：</h3>\n<p>那么对于这个问题，我们可以先对集合求和，得出\n<code>sum</code>，把问题转化为背包问题：</p>\n<p><strong>给一个可装载重量为 <code>sum / 2</code> 的背包和\n<code>N</code> 个物品，每个物品的重量为\n<code>nums[i]</code>。现在让你装物品，是否存在一种装法，能够恰好将背包装满</strong>？</p>\n<h4\nid=\"第一步要明确两点状态和选择\">第一步要明确两点，「状态」和「选择」</h4>\n<p>状态就是「背包的容量」和「可选择的物品」，选择就是「装进背包」或者「不装进背包」。</p>\n<h4\nid=\"第二步要明确dp数组的定义\">第二步要明确<code>dp</code>数组的定义</h4>\n<p><code>dp[i][j] = x</code>表示，对于前<code>i</code>个物品，当前背包容量为<code>j</code>时，若<code>x</code>为<code>true</code>，则说明可以恰好将背包装满，若为<code>false</code>，则说明不能恰好将背包装满。</p>\n<p>对于本题，我们相求的最终答案为<code>dp[N][sum/2]</code>，结束条件为<code>dp[..][0] = true</code>和<code>dp[0][..] = false</code>，因为背包没有空间的时候，就相当于装满了，而当没有物品可选择的时候，肯定没办法装满背包。</p>\n<h4\nid=\"第三步根据选择思考状态转移的逻辑\">第三步，根据「选择」，思考状态转移的逻辑</h4>\n<p>如果不把 <code>nums[i]</code> 算入子集，<strong>或者说你不把这第\n<code>i</code>\n个物品装入背包</strong>，那么是否能够恰好装满背包，取决于上一个状态\n<code>dp[i-1][j]</code>，继承之前的结果。</p>\n<p>如果把 <code>nums[i]</code> 算入子集，<strong>或者说你把这第\n<code>i</code>\n个物品装入了背包</strong>，那么是否能够恰好装满背包，取决于状态\n<code>dp[i-1][j-nums[i-1]]</code>。</p>\n<p>首先，由于 <code>i</code> 是从 1 开始的，而数组索引是从 0\n开始的，所以第 <code>i</code> 个物品的重量应该是\n<code>nums[i-1]</code>，这一点不要搞混。</p>\n<p><code>dp[i - 1][j-nums[i-1]]</code> 也很好理解：你如果装了第\n<code>i</code> 个物品，就要看背包的剩余重量 <code>j - nums[i-1]</code>\n限制下是否能够被恰好装满。</p>\n<p>换句话说，如果 <code>j - nums[i-1]</code>\n的重量可以被恰好装满，那么只要把第 <code>i</code>\n个物品装进去，也可恰好装满 <code>j</code>的重量；否则的话，重量\n<code>j</code> 肯定是装不满的。</p>\n<h4 id=\"最后一步处理一些边界问题\">最后一步，处理一些边界问题</h4>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">canPartition</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 计算和</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> num : nums) sum += num;</span><br><span class=\"line\">        <span class=\"comment\">//和为奇数，不可能划分</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sum % <span class=\"number\">2</span> != <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        sum = sum / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"comment\">//初始化 base case</span></span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">bool</span>&gt; &gt;<span class=\"built_in\">dp</span>(n+<span class=\"number\">1</span>,<span class=\"built_in\">vector</span>&lt;<span class=\"type\">bool</span>&gt;(sum+<span class=\"number\">1</span>,<span class=\"literal\">false</span>));</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= sum; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(j - nums[i<span class=\"number\">-1</span>] &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//容量不足，不能装入第 i 个物品</span></span><br><span class=\"line\">                    dp[i][j] = dp[i<span class=\"number\">-1</span>][j];</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//装入或者不装入</span></span><br><span class=\"line\">                    dp[i][j] = dp[i<span class=\"number\">-1</span>][j] || dp[i<span class=\"number\">-1</span>][j - nums[i - <span class=\"number\">1</span>]];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n][sum];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"进一步优化\">进一步优化</h4>\n<p>再进一步，是否可以优化这个代码呢？<strong>注意到\n<code>dp[i][j]</code> 都是通过上一行 <code>dp[i-1][..]</code>\n转移过来的</strong>，之前的数据都不会再使用了。</p>\n<p>将二维<code>dp</code>数组压缩为一维</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">canPartition</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 计算和</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> num : nums) sum += num;</span><br><span class=\"line\">        <span class=\"comment\">//和为奇数，不可能划分</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sum % <span class=\"number\">2</span> != <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        sum = sum / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"comment\">//base case</span></span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">bool</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(sum + <span class=\"number\">1</span>,<span class=\"literal\">false</span>)</span></span>;</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = sum; j &gt;= <span class=\"number\">0</span>; j--)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(j - nums[i] &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    dp[j] = dp[j] || dp[j - nums[i]];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[sum];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>其实这段代码和之前的解法思路完全相同，只在一行 <code>dp</code>\n数组上操作，<code>i</code> 每进行一轮迭代，<code>dp[j]</code>\n其实就相当于 <code>dp[i-1][j]</code>，所以只需要一维数组就够用了。</p>\n<p><strong>唯一需要注意的是 <code>j</code>\n应该从后往前反向遍历，因为每个物品（或者说数字）只能用一次，以免之前的结果影响其他的结果</strong>。</p>\n<h1 id=\"完全背包问题\">完全背包问题</h1>\n<h2 id=\"零钱兑换-ii\"><a\nhref=\"https://leetcode-cn.com/problems/coin-change-2/\">518. 零钱兑换\nII</a></h2>\n<p>给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount\n表示总金额。</p>\n<p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回\n0 。</p>\n<p>假设每一种面额的硬币有无限个。</p>\n<p>题目数据保证结果符合 32 位带符号整数。</p>\n<h3 id=\"示例-1\">示例：</h3>\n<blockquote>\n<p>输入：amount = 5, coins = [1, 2, 5] 输出：4\n解释：有四种方式可以凑成总金额： 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1</p>\n</blockquote>\n<h3 id=\"思路-1\">思路：</h3>\n<p><strong>我们可以把这个问题转化为背包问题的描述形式</strong>：</p>\n<p>有一个背包，最大容量为 <code>amount</code>，有一系列物品\n<code>coins</code>，每个物品的重量为\n<code>coins[i]</code>，<strong>每个物品的数量无限</strong>。请问有多少种方法，能够把背包恰好装满？</p>\n<p>这个问题和我们前面讲过的两个背包问题，有一个最大的区别就是，每个物品的数量是无限的，这也就是传说中的「<strong>完全背包问题</strong>」，没啥高大上的，无非就是状态转移方程有一点变化而已。</p>\n<h4\nid=\"第一步要明确两点状态和选择-1\"><strong>第一步要明确两点，「状态」和「选择」</strong></h4>\n<p>状态有两个，就是「背包的容量」和「可选择的物品」，选择就是「装进背包」或者「不装进背包」嘛，背包问题的套路都是这样。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> 状态<span class=\"number\">1</span> in 状态<span class=\"number\">1</span>的所有取值：</span><br><span class=\"line\">    <span class=\"keyword\">for</span> 状态<span class=\"number\">2</span> in 状态<span class=\"number\">2</span>的所有取值：</span><br><span class=\"line\">        <span class=\"keyword\">for</span> ...</span><br><span class=\"line\">            dp[状态<span class=\"number\">1</span>][状态<span class=\"number\">2</span>][...] = 计算(选择<span class=\"number\">1</span>，选择<span class=\"number\">2.</span>..)</span><br></pre></td></tr></table></figure>\n<h4 id=\"第二步要明确-dp-数组的定义\"><strong>第二步要明确 <code>dp</code>\n数组的定义</strong></h4>\n<p><code>dp[i][j]</code> 的定义如下：</p>\n<p>若只使用前 <code>i</code> 个物品（可以重复使用），当背包容量为\n<code>j</code> 时，有 <code>dp[i][j]</code> 种方法可以装满背包。</p>\n<p>换句话说，翻译回我们题目的意思就是：</p>\n<p><strong>若只使用 <code>coins</code> 中的前 <code>i</code>\n个硬币的面值，若想凑出金额 <code>j</code>，有 <code>dp[i][j]</code>\n种凑法</strong>。</p>\n<p>经过以上的定义，可以得到：</p>\n<p>base case 为\n<code>dp[0][..] = 0， dp[..][0] = 1</code>。因为如果不使用任何硬币面值，就无法凑出任何金额；如果凑出的目标金额为\n0，那么“无为而治”就是唯一的一种凑法。</p>\n<p>我们最终想得到的答案就是 <code>dp[N][amount]</code>，其中\n<code>N</code> 为 <code>coins</code> 数组的大小。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> dp[N+<span class=\"number\">1</span>][amount+<span class=\"number\">1</span>]</span><br><span class=\"line\">dp[<span class=\"number\">0</span>][..] = <span class=\"number\">0</span></span><br><span class=\"line\">dp[..][<span class=\"number\">0</span>] = <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i in [<span class=\"number\">1.</span>.N]:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j in [<span class=\"number\">1.</span>.amount]:</span><br><span class=\"line\">        把物品 i 装进背包,</span><br><span class=\"line\">        不把物品 i 装进背包</span><br><span class=\"line\"><span class=\"keyword\">return</span> dp[N][amount]</span><br></pre></td></tr></table></figure>\n<h4\nid=\"第三步根据选择思考状态转移的逻辑-1\"><strong>第三步，根据「选择」，思考状态转移的逻辑</strong></h4>\n<p><strong>如果你不把这第 <code>i</code>\n个物品装入背包</strong>，也就是说你不使用 <code>coins[i]</code>\n这个面值的硬币，那么凑出面额 <code>j</code> 的方法数\n<code>dp[i][j]</code> 应该等于\n<code>dp[i-1][j]</code>，继承之前的结果。</p>\n<p><strong>如果你把这第 <code>i</code>\n个物品装入了背包</strong>，也就是说你使用 <code>coins[i]</code>\n这个面值的硬币，那么 <code>dp[i][j]</code> 应该等于\n<code>dp[i][j-coins[i-1]]</code>。</p>\n<p>首先由于 <code>i</code> 是从 1 开始的，所以 <code>coins</code>\n的索引是 <code>i-1</code> 时表示第 <code>i</code> 个硬币的面值。</p>\n<p><code>dp[i][j-coins[i-1]]</code>\n也不难理解，如果你决定使用这个面值的硬币，那么就应该关注如何凑出金额\n<code>j - coins[i-1]</code>。</p>\n<p>比如说，你想用面值为 2 的硬币凑出金额 5，那么如果你知道了凑出金额 3\n的方法，再加上一枚面额为 2 的硬币，不就可以凑出 5 了嘛。</p>\n<p><strong>综上就是两种选择，而我们想求的 <code>dp[i][j]</code>\n是「共有多少种凑法」，所以 <code>dp[i][j]</code>\n的值应该是以上两种选择的结果之和</strong>：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= amount; j++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (j - coins[i<span class=\"number\">-1</span>] &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">            dp[i][j] = dp[i - <span class=\"number\">1</span>][j] </span><br><span class=\"line\">                     + dp[i][j-coins[i<span class=\"number\">-1</span>]];</span><br><span class=\"line\"><span class=\"keyword\">return</span> dp[N][W]</span><br></pre></td></tr></table></figure>\n<h4\nid=\"最后一步把伪码翻译成代码处理一些边界情况\"><strong>最后一步，把伪码翻译成代码，处理一些边界情况</strong></h4>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">change</span><span class=\"params\">(<span class=\"type\">int</span> amount, vector&lt;<span class=\"type\">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = coins.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"comment\">//base case</span></span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt;<span class=\"built_in\">dp</span>(n+<span class=\"number\">1</span>,<span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(amount+<span class=\"number\">1</span>,<span class=\"number\">0</span>));</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= amount; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(j-coins[i - <span class=\"number\">1</span>] &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                    dp[i][j] = dp[i - <span class=\"number\">1</span>][j] + dp[i][j - coins[i - <span class=\"number\">1</span>]];</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    dp[i][j] = dp[i - <span class=\"number\">1</span>][j];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n][amount];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>而且，我们通过观察可以发现，<code>dp</code> 数组的转移只和\n<code>dp[i][..]</code> 和 <code>dp[i-1][..]</code>\n有关，所以可以压缩状态，进一步降低算法的空间复杂度：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">change</span><span class=\"params\">(<span class=\"type\">int</span> amount, vector&lt;<span class=\"type\">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = coins.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"comment\">//base case</span></span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(amount + <span class=\"number\">1</span>,<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= amount; j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(j - coins[i] &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">                dp[j] = dp[j] + dp[j-coins[i]];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[amount];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["算法","背包问题","动态规划"],"tags":["动态规划","背包问题"]},{"title":"第二章_进程与线程","url":"/2022/08/06/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/","content":"<p>[[toc]]</p>\n<p><img\nsrc=\"https://sjchen404.oss-cn-shenzhen.aliyuncs.com/img/第二章_进程与线程.png\" /></p>\n<h1 id=\"进程与线程\">进程与线程</h1>\n<p><strong>进程与线程的比较</strong></p>\n<table>\n<colgroup>\n<col style=\"width: 6%\" />\n<col style=\"width: 41%\" />\n<col style=\"width: 51%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th></th>\n<th>进程</th>\n<th>线程</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>映像组成</td>\n<td>由程序段，相关数据段和<code>PCB</code>组成</td>\n<td>共享其隶属进程的进程映像，仅拥有线程ID，寄存器集合和堆栈等</td>\n</tr>\n<tr class=\"even\">\n<td>并发性</td>\n<td>在没有引入线程的操作系统中，进程是独立运行的基本单位</td>\n<td><strong>线程是独立运行的基本单位</strong>,一个进程可以拥有一个或多个线程</td>\n</tr>\n<tr class=\"odd\">\n<td>资源分配</td>\n<td>进程是资源分配和拥有的基本单位</td>\n<td>线程自己不拥有系统资源，但它可以访问所属进程所拥有的全部资源</td>\n</tr>\n<tr class=\"even\">\n<td><strong>调度</strong></td>\n<td>在没有引入线程的操作系统中，进程是独立调度和分配的基本单位</td>\n<td>在引入线程后的操作系统，线程是独立调度和分配的基本单位</td>\n</tr>\n<tr class=\"odd\">\n<td>通信</td>\n<td>PV操作；共享存储；消息传递；管道通信</td>\n<td>同一进程的各线程直接读写进程数据段，不同进程的线程之间通信属于进程剑通信</td>\n</tr>\n<tr class=\"even\">\n<td>目的</td>\n<td>更好的使多道程序并发执行，提高资源利用率和系统吞吐量</td>\n<td>减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能</td>\n</tr>\n<tr class=\"odd\">\n<td>地址空间</td>\n<td>进程的地址空间之间相互独立</td>\n<td>同一进程的各线程间共享进程的地址空间</td>\n</tr>\n</tbody>\n</table>\n<p><strong>进程映像是静态的，进程是动态的</strong></p>\n<span id=\"more\"></span>\n<h2 id=\"pcb\">PCB</h2>\n<p><code>PCB</code>是进程存在的唯一标记！！！</p>\n<p>组成： - 进程描述信息 - 进程控制和管理信息 - 资源分配清单 -\n处理机相关信息</p>\n<table>\n<colgroup>\n<col style=\"width: 27%\" />\n<col style=\"width: 28%\" />\n<col style=\"width: 20%\" />\n<col style=\"width: 23%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>进程描述信息</th>\n<th>进程控制和管理信息</th>\n<th>资源分配清单</th>\n<th>处理机相关信息</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>进程标识符（PID）</td>\n<td>进程当前状态</td>\n<td>代码段指针</td>\n<td>通用寄存器值</td>\n</tr>\n<tr class=\"even\">\n<td>用户标识符（UID）</td>\n<td>进程优先级</td>\n<td>数据段指针</td>\n<td>地址寄存器值</td>\n</tr>\n<tr class=\"odd\">\n<td></td>\n<td>代码运行入口地址</td>\n<td>堆栈段指针</td>\n<td>控制寄存器值</td>\n</tr>\n<tr class=\"even\">\n<td></td>\n<td>程序的外存地址</td>\n<td>文件描述符</td>\n<td>标记寄存器值</td>\n</tr>\n<tr class=\"odd\">\n<td></td>\n<td>进入内存时间</td>\n<td>键盘</td>\n<td>状态字</td>\n</tr>\n<tr class=\"even\">\n<td></td>\n<td>处理机占用时间</td>\n<td>鼠标</td>\n<td></td>\n</tr>\n<tr class=\"odd\">\n<td></td>\n<td>信号量的使用</td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"进程的状态\">进程的状态</h2>\n<p><img\nsrc=\"https://sjchen404.oss-cn-shenzhen.aliyuncs.com/img/进程状态.png\" /></p>\n<p><strong>从运行态变成阻塞态是主动的</strong></p>\n<h2 id=\"用户级线程和内核支持线程\">用户级线程和内核支持线程</h2>\n<table>\n<colgroup>\n<col style=\"width: 4%\" />\n<col style=\"width: 39%\" />\n<col style=\"width: 55%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>线程</th>\n<th>用户级线程</th>\n<th>内核级线程</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>优点</td>\n<td>线程切换不需要转换到内核空间，节省了开销</td>\n<td>一个线程被阻塞，内核可以调度该进程中的其他线程；能发挥多处理器优势</td>\n</tr>\n<tr class=\"even\">\n<td>缺点</td>\n<td>一个线程被阻塞，则同一进程内所有线程都会被阻塞</td>\n<td>同一进程中，线程切换时，需要从用户态转到内核态，系统开销大</td>\n</tr>\n</tbody>\n</table>\n<p>多线程模型： - 多对一 &gt; 一个线程阻塞，则整个进程阻塞 - 一对一 -\n多对多</p>\n<h2 id=\"进程控制\">进程控制</h2>\n<p><strong>进程创建</strong></p>\n<p><img\nsrc=\"https://sjchen404.oss-cn-shenzhen.aliyuncs.com/img/进程创建.png\" /></p>\n<p>在同一个进程中，线程切换不会引起进程的切换。</p>\n<p>当从一个进程中的线程切换到另一个进程中的线程时，才会引起进程的切换。</p>\n<h1 id=\"处理机调度\">处理机调度</h1>\n<p>在多道程序系统中，进程的数量往往多于处理机个数，因此进程争用处理机的情况在所难免。</p>\n<p>处理机调度是对处理机进行分配，即从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程并发地执行。</p>\n<h2 id=\"调度的层次\">调度的层次</h2>\n<ul>\n<li>高级调度（作业调度）</li>\n<li>中级调度（内存调度）</li>\n<li>低级调度（进程调度）</li>\n</ul>\n<p><img\nsrc=\"https://sjchen404.oss-cn-shenzhen.aliyuncs.com/img/调度层次.png\" /></p>\n<p>多道批处理器系统中大多配有作业调度，而其他系统中通常不需要配置作业调度。</p>\n<p><em>引入中级调度的目的是提高内存利用率和系统吞吐量。</em></p>\n<p>进程调度是最基本的，不可或缺。</p>\n<h2 id=\"调度的原则\">调度的原则</h2>\n<p><code>CPU</code>利用率：</p>\n<blockquote>\n<p>CPU的工作在整个系统工作时间所占的比例。</p>\n</blockquote>\n<p><span class=\"math display\">\\[\nCPU利用率 = \\frac{CPU有效工作时间}{CPU有效工作时间 + CPU空闲等待时间}\n\\]</span></p>\n<p>系统吞吐量： 表示单位时间内CPU完成作业的数量。</p>\n<p>周转时间：</p>\n<p><span class=\"math display\">\\[\n周转时间 = 作业完成时间 - 作业提交时间\n\\]</span></p>\n<p>平均周转时间：</p>\n<p><span class=\"math display\">\\[\n平均周转时间 = \\frac{作业1的周转时间 + ... + 作业n的周转时间}{n}\n\\]</span></p>\n<p>带权周转时间：</p>\n<p><span class=\"math display\">\\[\n带权周转时间 = \\frac{作业周转时间}{作业实际运行时间}\n\\]</span></p>\n<p>等待时间：</p>\n<p>进程处于等待处理器状态的时间之和。</p>\n<p>响应时间：</p>\n<p>从用户提交请求到系统首次产生响应所用的时间。</p>\n<h2 id=\"不能进行处理机调度的情况\">不能进行处理机调度的情况</h2>\n<ul>\n<li>在处理中断的过程中</li>\n<li>进程在操作系统内核临界区中</li>\n<li>其他需要完全屏蔽中断的原子操作过程中</li>\n</ul>\n<h2 id=\"常用的调度算法\">常用的调度算法</h2>\n<table>\n<colgroup>\n<col style=\"width: 11%\" />\n<col style=\"width: 20%\" />\n<col style=\"width: 68%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th>算法</th>\n<th>调度方法</th>\n<th>特点</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>先来先服务FCFS</td>\n<td>每次选择最先进入的作业或进程</td>\n<td>有利于长作业不利于短作业<br>有利于CPU繁忙型型作业不利于I/O繁忙型作业</td>\n</tr>\n<tr class=\"even\">\n<td>短作业优先SJF</td>\n<td>选择运行时间最短的</td>\n<td><em>平均等待时间，平均周转时间最少</em></td>\n</tr>\n<tr class=\"odd\">\n<td>时间片轮转</td>\n<td>所有进程按先来先服务排队</td>\n<td>主要适用于<strong>分时系统</strong></td>\n</tr>\n<tr class=\"even\">\n<td>优先级调度</td>\n<td>选择优先级最高的</td>\n<td>系统进程&gt; 用户进程<br>交互性进程&gt;\n非交互性进程<br>I/O型进程&gt;计算型进程</td>\n</tr>\n<tr class=\"odd\">\n<td>高响应比优先</td>\n<td>选择响应比最高的</td>\n<td>有利于短作业，长作业不会产出“饥饿”，等待时间越长，优先级越高</td>\n</tr>\n<tr class=\"even\">\n<td>多级反馈队列</td>\n<td>...</td>\n<td>终端型作业：短作业优先<br>短批处理作业用户：周转时间较短<br>长批处理作业用户：不会长期得不到处理</td>\n</tr>\n</tbody>\n</table>\n<p>响应比：</p>\n<p><span class=\"math display\">\\[\n响应比R_p = \\frac{等待时间 + 要求服务时间}{要求服务时间}\n\\]</span></p>\n<h1 id=\"同步与互斥\">同步与互斥</h1>\n<h2 id=\"基本概念\">基本概念</h2>\n<p>我们将一次仅允许一个进程使用的资源称为<em>临界资源</em></p>\n<p>临界区：进程中访问临界资源的那段代码。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    entry section;      <span class=\"comment\">//进入区</span></span><br><span class=\"line\">    critical section;   <span class=\"comment\">//临界区</span></span><br><span class=\"line\">    exit section;       <span class=\"comment\">//退出区</span></span><br><span class=\"line\">    remainder section;  <span class=\"comment\">//剩余区</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)</span><br></pre></td></tr></table></figure>\n<p><strong>同步：</strong>\n进程需要协调它们的工作次序而等待，传递信息所产生的制约关系。</p>\n<p><strong>互斥：</strong>\n当一个进程进入临界区使用临界资源时，另一个进程必须等待，当占用临界资源的进程退出临界区后，另一进程才允许去访问此临界资源</p>\n<p>同步需要遵循的准则： - 空闲让进 --\n临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。 -\n忙则等待 -- 当已有进程进入临界区时，其他试图进入临界区的进程必须等待。 -\n有限等待 -- 对已有进程进入临界区，应保证能在有限时间内进入临界区。 -\n让权等待 --\n当进程不能进入临界区时，应立即释放处理器，防止进程忙等待。</p>\n<h2 id=\"实现临界区互斥的基本方法\">实现临界区互斥的基本方法</h2>\n<h3 id=\"软件实现\">软件实现</h3>\n<ul>\n<li>单标记法</li>\n<li>双标记法先检查</li>\n<li>双标记法后检查</li>\n<li>皮特森算法（Peterson）</li>\n</ul>\n<h4 id=\"单标记法\">单标记法</h4>\n<p>设置一个公用模型变量<code>turn</code>,用于指示被允许进入临界区的进程编号，即若<code>turn = 0</code>,则允许<span\nclass=\"math inline\">\\(p_0\\)</span>进程进入临界区。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//p0进程</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(turn != <span class=\"number\">0</span>);   <span class=\"comment\">//进入区</span></span><br><span class=\"line\">critical section;   <span class=\"comment\">//临界区</span></span><br><span class=\"line\">turn = <span class=\"number\">1</span>;           <span class=\"comment\">//退出区</span></span><br><span class=\"line\">remainder section;  <span class=\"comment\">//剩余区</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//p1进程;</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(turn != <span class=\"number\">1</span>);</span><br><span class=\"line\">critical section;</span><br><span class=\"line\">turn = <span class=\"number\">0</span>;</span><br><span class=\"line\">remainder section;</span><br></pre></td></tr></table></figure>\n<p>该算法保证每次只允许一个进程进入临界区，但两个进程必须交替进入临界区，若某个进程不再进入临界区，则另一个进程也将无法进入临界区。\n违背了<em>空闲让进</em>，容易造成资源利用不充分。</p>\n<h4 id=\"双标记法先检查\">双标记法先检查</h4>\n<p>思想：</p>\n<p>在每个进程访问临界区资源之前，先检查临界资源是否正在被访问，若正在被访问，该进程等待；否则，进程才进入自己的临界区。</p>\n<p>设置一个数组<code>flag[2]</code>,表示进程是否进入临界区。<code>flag[i]</code>值为<code>FALSE</code>,表示<span\nclass=\"math inline\">\\(P_i\\)</span>进程未进入临界区，值为<code>TRUE</code>,表示<span\nclass=\"math inline\">\\(P_i\\)</span>进程进入临界区。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//P_i进程</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(flag[j]);     <span class=\"comment\">// 1 进入区</span></span><br><span class=\"line\">flag[i] = TRUE;     <span class=\"comment\">// 3 进入区</span></span><br><span class=\"line\">critical section;   <span class=\"comment\">// 临界区</span></span><br><span class=\"line\">flag[i] = FALSE;    <span class=\"comment\">//退出区</span></span><br><span class=\"line\">remainder section;  <span class=\"comment\">//剩余区</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// P_j进程</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(flag[i]);     <span class=\"comment\">// 2</span></span><br><span class=\"line\">flag[j] = TRUE;     <span class=\"comment\">// 4</span></span><br><span class=\"line\">critical section;</span><br><span class=\"line\">flag[j] = FALSE;</span><br><span class=\"line\">remainder section;</span><br></pre></td></tr></table></figure>\n<p>优点：不用交替进入，可连续使用；</p>\n<p>缺点：<span class=\"math inline\">\\(P_i\\)</span>和<span\nclass=\"math inline\">\\(P_j\\)</span>可能同时进入临界区；</p>\n<p>按系列1，2，3，4执行，会同时进入临界区（违背了<em>忙则等待</em>）。</p>\n<h4 id=\"双标记法后检查\">双标记法后检查</h4>\n<p>和双标记法先检查相比，先将自己的标记设置为<code>TRUE</code>,再检测对方的状态标记，若对方标记为<code>TRUE</code>,则进程等待；否则进入临界区。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//P_i进程</span></span><br><span class=\"line\">flag[i] = TRUE;     <span class=\"comment\">// 先设置自己的标记，进入区</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(flag[j]);     <span class=\"comment\">// 检查对方状态，进入区</span></span><br><span class=\"line\">critical section;   <span class=\"comment\">// 临界区</span></span><br><span class=\"line\">flag[i] = FALSE;    <span class=\"comment\">// 退出区</span></span><br><span class=\"line\">remainder section;  <span class=\"comment\">// 剩余区</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//P_j进程</span></span><br><span class=\"line\">flag[j] = TRUE;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(flag[i]);</span><br><span class=\"line\">critical section;</span><br><span class=\"line\">flag[j] = FALSE;</span><br><span class=\"line\">remainder section;</span><br></pre></td></tr></table></figure>\n<p>确保进程可以互斥访问临界区。</p>\n<p>但是存在两个进程都进不了临界区的“饥饿”现象。</p>\n<h4 id=\"皮特森算法peterson\">皮特森算法（Peterson）</h4>\n<p>为了防止两个进程为进入临界区而无限期等待，又设置了变量<code>turn</code>，每个进程在先设置自己的标记之后再设计<code>turn</code>标记。再同时检测另一个进程状态标记和\n允许进入标记，以便保证两个进程同时要求进入临界区，只允许一个进程进入临界区。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//P_i进程</span></span><br><span class=\"line\">flag[i] = TRUE, turn = j;  <span class=\"comment\">// falg[j] = TRUE表示它想要进入临界区，turn = j,表示进程P_j已在临界区</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(flag[j] &amp;&amp; turn == j);</span><br><span class=\"line\">critical sections;</span><br><span class=\"line\">flag[i] = FALSE;</span><br><span class=\"line\">remainder section;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// P_j进程</span></span><br><span class=\"line\">flag[j] = TRUE, turn = i;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(flag[i] &amp;&amp; turn == i);</span><br><span class=\"line\">critical section;</span><br><span class=\"line\">flag[j] = FALSE;</span><br><span class=\"line\">remainder section;</span><br></pre></td></tr></table></figure>\n<p><code>Peterson</code>算法利用<code>turn</code>解决了“饥饿”问题</p>\n<h3 id=\"硬件实现方法\">硬件实现方法</h3>\n<p>（低级方法）</p>\n<h4 id=\"中断屏蔽方法\">（1）中断屏蔽方法</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">关中断</span><br><span class=\"line\">临界区</span><br><span class=\"line\">开中断</span><br></pre></td></tr></table></figure>\n<p>效率低</p>\n<h4 id=\"硬件指令方法\">（2）硬件指令方法</h4>\n<p><em>由硬件逻辑直接实现，不会被中断</em></p>\n<p><code>TestAndSet</code>指令，<code>原子操作</code>,即这条指令执行时不允许被中断。</p>\n<p>功能：读出指定标志后把该指令设置为真。</p>\n<p><code>Swap</code>指令：</p>\n<p>功能：交换两个字（字节）的内容。</p>\n<p><strong>小结：</strong></p>\n<p>缺点：进程等待进入临界区要耗费处理机时间，<em>不能实现让权等待</em>，会导致“饥饿”现象。</p>\n<p>优点：适用于任意数目的进程，而不管是单处理机还是多处理机；简单，容易验证其正确性。</p>\n<h2 id=\"互斥锁\">互斥锁</h2>\n<p>解决临界区最简单的工具就是<em>互斥锁（mutex\nlock）</em>。一个进程在进入临界区时应获得锁，在退出临界区时释放锁。\n函数<code>acquire()</code>获得锁，而函数<code>release()</code>释放锁。</p>\n<p>每个锁有一个布尔变量<code>available</code>,表示锁是否可用。</p>\n<p><strong>互斥锁通常采用硬件机制实现</strong></p>\n<p><strong>缺点：忙等待</strong></p>\n<h2 id=\"信号量\">信号量</h2>\n<p>用来解决互斥与同步问题，它只能被两个标准的原语<code>wait(s)</code>和<code>signal(s)</code>访问，也可记为“P操作”或“V操作”。</p>\n<h3 id=\"整型信号量\">整型信号量</h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">wait</span>(S)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(S &lt;= <span class=\"number\">0</span>);</span><br><span class=\"line\">        S = S - <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">signal</span>(S)&#123;</span><br><span class=\"line\">        S = S + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不遵循“让权等待”的准则，而是使进程处于“忙等”的状态。</p>\n<h3 id=\"记录型信号量\">记录型信号量</h3>\n<p>除了需要一个用于代表资源数目的整型变量<code>value</code>外，再增加一个进程链表L，用于链接所有等待该资源的进程。\n<code>wait</code>操作请求一个该类资源时，如果<code>s.value &lt; 0</code>,表示该类资源已经分配完毕，因此进程应调用<code>block</code>原语，进行自我阻塞，放弃处理机。\n并插入该类资源的等待队列<code>S.L</code>。</p>\n<p>不存在“忙等”现象等进程同步机制。遵循了“让权等待”准则。</p>\n<h3 id=\"利用信号量实现同步\">利用信号量实现同步</h3>\n<p>同步就是根据什么次序配合互相完成。</p>\n<h3 id=\"利用信号量实现进程互斥\">利用信号量实现进程互斥</h3>\n<p>一般都把初始化信号量设为1.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">semaphore S = <span class=\"number\">1</span>;        <span class=\"comment\">// 初始化信号量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">P1</span>() &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"built_in\">P</span>(S);           <span class=\"comment\">// 准备开始访问临界资源，加锁</span></span><br><span class=\"line\">        进程P1的临界区；</span><br><span class=\"line\">        <span class=\"built_in\">V</span>(S);           <span class=\"comment\">// 访问结束，解锁</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">P2</span>() &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"built_in\">P</span>(S);</span><br><span class=\"line\">        进程P2的临界区</span><br><span class=\"line\">        <span class=\"built_in\">V</span>(S);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"利用信号量实现前驱关系\">利用信号量实现前驱关系</h3>\n<h2 id=\"管程\">管程</h2>\n<p>在信号量机制中，每个要访问临界资源的进程都必须自备同步的PV操作。大量分散的同步操作给系统管理带来了麻烦，\n且容易因操作不当而导致系统<em>死锁</em>。</p>\n<h3 id=\"定义\">定义</h3>\n<p>管程定义了一个数据结构和能为并发进程所执行（在该数据结构上）的一组操作，这组操作能同步进程和改变管程中的数据。</p>\n<p>组成： - 管程的名称 - 局部于管程内部的共享数据结构说明 -\n对该数据结构进行操作的一组过程 -\n对局部于管程内部的共享数据设置初始值的语句</p>\n<p>管程很像一个类（class）： - 管程把对共享资源的操作封装起来 -\n每次仅允许一个进程进入管程</p>\n<h3 id=\"条件变量\">条件变量</h3>\n<p>将阻塞原因定义为条件变量。</p>\n<p>对条件变量只能进行两种操作：\n<code>wait</code>和<code>signal</code></p>\n<h2 id=\"经典同步问题重点\">经典同步问题（重点！！！）</h2>\n<h3 id=\"生产者-消费者问题\">1. 生产者-消费者问题</h3>\n<p><strong>问题描述：</strong>\n一组生产者进程和一组消费者进程共享一个初始为空，大小为<code>n</code>的缓冲区，只有缓冲区没满时，生产者才能把消息放入缓冲区，\n否则必须等待；只有缓冲区不空时，消费者才能从中取出消息，否则必须等待。由于缓冲区是临界资源，它只允许一个生产者放入消息，或一个消费者从中\n取出消息。</p>\n<p><strong>问题分析：</strong></p>\n<ol type=\"1\">\n<li><p>关系分析。生产者和消费者对缓冲区互斥访问是<em>互斥关系</em>，同时生产者和消费者又是一个互相协作的关系，只有生产者生产之后，消费者才能消费，\n它们也是<em>同步关系</em>。</p></li>\n<li><p>思路。只有生产者和消费者两个进程，它们又是互斥和同步关系，那么需要解决的是互斥和同步PV操作的位置。</p></li>\n<li><p>信号量设置。信号量<code>mutex</code>作为互斥信号量，用于控制互斥访问访问缓冲区，互斥信号量初始值为1；信号量<code>full</code>用于记录当前缓冲池中的“满”缓冲区数，\n初值为0，信号量<code>empty</code>用于记录当前缓冲池中的“空”缓冲区数，初值为<code>n</code>。</p></li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">semaphore mutex = <span class=\"number\">1</span>;        <span class=\"comment\">// 临界区互斥信号量</span></span><br><span class=\"line\">semaphore empty = n;        <span class=\"comment\">// 空闲缓冲区</span></span><br><span class=\"line\">semaphore full = <span class=\"number\">0</span>;         <span class=\"comment\">// 缓冲区初始化为空</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">producer</span>() &#123;                <span class=\"comment\">// 生产者进程</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        produce an item in nextp;   <span class=\"comment\">// 生产数据</span></span><br><span class=\"line\">        <span class=\"built_in\">p</span>(empty);                   <span class=\"comment\">// 获取空缓冲区单元</span></span><br><span class=\"line\">        <span class=\"built_in\">p</span>(mutex);                   <span class=\"comment\">// 进入互斥区</span></span><br><span class=\"line\">        add nextp to buffer;        <span class=\"comment\">// 将数据放入缓冲区</span></span><br><span class=\"line\">        <span class=\"built_in\">v</span>(mutex);                   <span class=\"comment\">// 离开互斥区，释放互斥信号量</span></span><br><span class=\"line\">        <span class=\"built_in\">v</span>(full);                    <span class=\"comment\">// 满缓冲区数+1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">consumer</span>() &#123;                        <span class=\"comment\">// 消费者进程</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">p</span>(full);                    <span class=\"comment\">// 获取满缓冲区单元</span></span><br><span class=\"line\">        <span class=\"built_in\">p</span>(mutex);                   <span class=\"comment\">// 进入临界区</span></span><br><span class=\"line\">        remove an item from buffer; <span class=\"comment\">// 从缓冲区取数据</span></span><br><span class=\"line\">        <span class=\"built_in\">v</span>(mutex);                   <span class=\"comment\">// 离开临界区，释放互斥信号量</span></span><br><span class=\"line\">        <span class=\"built_in\">v</span>(empty);                   <span class=\"comment\">// 空缓冲区数+1</span></span><br><span class=\"line\">        consum the item;            <span class=\"comment\">// 消费数据</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"读者-写者问题\">2. 读者-写者问题</h3>\n<p><strong>问题描述：</strong>\n有读者和写者两组并发进程，共享一个文件，当两个或以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：</p>\n<ol type=\"1\">\n<li><p>允许多个读者可以同时对文件执行读操作；</p></li>\n<li><p>只允许一个写者往文件中写信息；</p></li>\n<li><p>任一写者在完成写操作之前不允许其他读者或写者工作；</p></li>\n<li><p>写者执行写操作之前，应让已有的读者和写者全部退出；</p></li>\n</ol>\n<p><strong>问题分析：</strong></p>\n<ol type=\"1\">\n<li><p>关系分析。读者和写者是互斥的，写者和写者也是互斥的，读者和读者不存在互斥问题。</p></li>\n<li><p>思路。两个进程，即读者和写者。写者和任何进程都互斥，因此只需要互斥信号量的PV操作即可。读者问题比较复杂，它必须在实现与写者互斥的同时，实现与其他\n读者的同步，因此简单的一对PV操作是无法解决问题，这里我们用到一个计数器，用来判断当前是否有读者读文件。当有读者时，写者是无法写文件的，此时读者会\n一直占用文件，当没有读者时，写者才可以写文件。同时，这里不同读者对计数器的访问应该也是互斥的。</p></li>\n<li><p>信号量设置。首先设置信号量<code>count</code>为计数器，用于记录当前读者的数量，初值为0；设置<code>mutex</code>为互斥信号量，用于保护更新<code>count</code>变量的互斥；设置互斥信号量\n<code>rw</code>，用于保证读者和写者的互斥访问。</p></li>\n</ol>\n<p><strong>读进程优先：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">int count = 0;              // 用于记录当前的读者数量</span><br><span class=\"line\">semaphore mutex = 1;        // 用于保护更新count变量时的互斥</span><br><span class=\"line\">semaphore rw = 1;           // 用于保证读者和写者互斥地访问文件</span><br><span class=\"line\"></span><br><span class=\"line\">writer() &#123;                  // 写者进程</span><br><span class=\"line\">    while(1) &#123;</span><br><span class=\"line\">        p(rw);              // 互斥访问共享文件</span><br><span class=\"line\">        writing;</span><br><span class=\"line\">        v(rw);              // 释放共享文件</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">reader() &#123;                  // 读者进程</span><br><span class=\"line\">    while(1) &#123;</span><br><span class=\"line\">        p(mutex);           // 互斥访问count</span><br><span class=\"line\">        if(count == 0)      // 当第一个读进程读共享文件时</span><br><span class=\"line\">          p(rw);            // 阻止写进程写</span><br><span class=\"line\">        count++;            // 读者计数器+1</span><br><span class=\"line\">        v(mutex);           // 释放互斥变量count</span><br><span class=\"line\">        reading;</span><br><span class=\"line\">        p(mutex);           // 互斥访问count</span><br><span class=\"line\">        count--;            // 读者计数器减1</span><br><span class=\"line\">        if(count == 0)      // 当最后一个读进程读完共享文件</span><br><span class=\"line\">            v(rw);          // 允许写进程写</span><br><span class=\"line\">        v(mutex);           // 释放互斥变量count</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当存在读进程时，写操作被延迟，且只要有一个读进程活跃，随后的读进程都被允许访问文件，这样会导致写进程可能长时间等待，且存在写进程“饿死”的情况。</p>\n<p><strong>写进程优先：</strong></p>\n<blockquote>\n<p>有写进程请求访问，这时应禁止后续读进程的请求，等到已在共享文件中的读进程执行完毕，立即让写进程执行，只有在无写进程执行的情况下，\n才允许读进程再次运行，因此，增加一个信号量并在上面的writer()和reader()函数中各增加一对PV操作。</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> count = <span class=\"number\">0</span>;              <span class=\"comment\">// 用于记录当前的读者数量</span></span><br><span class=\"line\">semaphore mutex = <span class=\"number\">1</span>;        <span class=\"comment\">// 用于保护更新count变量时的互斥</span></span><br><span class=\"line\">semaphore rw = <span class=\"number\">1</span>;           <span class=\"comment\">// 用于保证读者和写者互斥地访问文件</span></span><br><span class=\"line\">semaphore w = <span class=\"number\">1</span>;            <span class=\"comment\">// 用于实现“写优先”</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">writer</span>() &#123;                  <span class=\"comment\">// 写者进程</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">p</span>(w);               <span class=\"comment\">// 在无写进程请求时进入</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">p</span>(rw);              <span class=\"comment\">// 互斥访问共享文件</span></span><br><span class=\"line\">        writing;</span><br><span class=\"line\">        <span class=\"built_in\">v</span>(rw);              <span class=\"comment\">// 释放共享文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">v</span>(w);               <span class=\"comment\">// 恢复对共享文件的访问</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">reader</span>() &#123;                  <span class=\"comment\">// 读者进程</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">p</span>(w);               <span class=\"comment\">// 在无写进程请求时进入</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">p</span>(mutex);           <span class=\"comment\">// 互斥访问count</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(count == <span class=\"number\">0</span>)      <span class=\"comment\">// 当第一个读进程读共享文件时</span></span><br><span class=\"line\">          <span class=\"built_in\">p</span>(rw);            <span class=\"comment\">// 阻止写进程写</span></span><br><span class=\"line\">        count++;            <span class=\"comment\">// 读者计数器+1</span></span><br><span class=\"line\">        <span class=\"built_in\">v</span>(mutex);           <span class=\"comment\">// 释放互斥变量count</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">v</span>(w);               <span class=\"comment\">// 恢复对共享文件的访问</span></span><br><span class=\"line\"></span><br><span class=\"line\">        reading;</span><br><span class=\"line\">        <span class=\"built_in\">p</span>(mutex);           <span class=\"comment\">// 互斥访问count</span></span><br><span class=\"line\">        count--;            <span class=\"comment\">// 读者计数器减1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(count == <span class=\"number\">0</span>)      <span class=\"comment\">// 当最后一个读进程读完共享文件</span></span><br><span class=\"line\">            <span class=\"built_in\">v</span>(rw);          <span class=\"comment\">// 允许写进程写</span></span><br><span class=\"line\">        <span class=\"built_in\">v</span>(mutex);           <span class=\"comment\">// 释放互斥变量count</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>也叫做<strong>读写公平法</strong></p>\n<h3 id=\"哲学家进餐问题\">3. 哲学家进餐问题</h3>\n<p><strong>问题描述：</strong>\n一张圆桌边上坐着5名哲学家，每两名哲学家之间的桌子上摆着一根筷子，两根筷子中间是一碗米饭。\n只有当哲学家饥饿时，才试图拿起左，右两根筷子（一根一根拿起）。若筷子已在他人手上，则需要等待。饥饿的哲学家只有同时拿到两根\n筷子才可以开始进餐，进餐完毕后，放下筷子继续思考。</p>\n<p><strong>问题分析：</strong></p>\n<ol type=\"1\">\n<li>关系分析。5名哲学家与左右邻居对其中间的筷子的访问是互斥关系。</li>\n<li>整理思路。显然，这里有5个进程。关键是如何让一名哲学家拿到左右两根筷子而不造成死锁或即饿现象。\n解决方法有两个：一是让他们同时拿两根筷子；二是对每名哲学家的动作制定规则，避免饥饿或死锁现象的发生。</li>\n<li>信号量设置。定义互斥信号量数组<code>chopstick[5] = &#123;1,1,1,1,1&#125;</code>,用于对5个筷子的互斥访问。哲学家按顺序编号0～4，哲学家<code>i</code>左边的筷子编号为<code>i</code>，\n右边筷子编号为<code>(i+1)%5</code>。</li>\n</ol>\n<p><strong>同时拿筷子：</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">semaphore chopstick[<span class=\"number\">5</span>] = &#123;<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>&#125;;       <span class=\"comment\">// 定义信号量数组</span></span><br><span class=\"line\"><span class=\"built_in\">pi</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">p</span>(chopstick[i]);                    <span class=\"comment\">// 取左边筷子</span></span><br><span class=\"line\">        <span class=\"built_in\">p</span>(chocktick[(i+<span class=\"number\">1</span>)%<span class=\"number\">5</span>]);              <span class=\"comment\">// 取右边筷子</span></span><br><span class=\"line\">        eat;</span><br><span class=\"line\">        <span class=\"built_in\">v</span>(chopstick[i]);                    <span class=\"comment\">// 放回左边筷子</span></span><br><span class=\"line\">        <span class=\"built_in\">v</span>(chopstick[(i+<span class=\"number\">1</span>)%<span class=\"number\">5</span>]);              <span class=\"comment\">// 放回右边筷子</span></span><br><span class=\"line\">        think;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该算法存在以下问题：当5名哲学家都想要进餐并分别拿起左边的筷子时，筷子已被拿完，等他们再想拿右边筷子时，就被完全阻塞，\n因此出现了死锁。</p>\n<p>为防止死锁发生，可对哲学家进程施加一些限制条件。</p>\n<ul>\n<li>至多允许4名哲学家同时进餐</li>\n<li>仅当一名哲学家左右两边的筷子都可用时，才允许他抓起筷子。</li>\n<li>对哲学家顺序编号，要求奇数号哲学家先拿左边的筷子，然后拿右边筷子，偶数号哲学家相反。</li>\n</ul>\n<p>下面我们采用第二种方法：当一名哲学家左右两边筷子都可用时，才允许他抓起筷子。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">semaphore chopstick[<span class=\"number\">5</span>] = &#123;<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">semaphore mutex = <span class=\"number\">1</span>;                            <span class=\"comment\">// 设置取筷子信号量</span></span><br><span class=\"line\"><span class=\"built_in\">pi</span>() &#123;                                          <span class=\"comment\">// i 号哲学家进程</span></span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">p</span>(mutex);                                   <span class=\"comment\">// 在取筷子之前获得互斥量</span></span><br><span class=\"line\">        <span class=\"built_in\">p</span>(chopstick[i]);                            <span class=\"comment\">// 取左边筷子</span></span><br><span class=\"line\">        <span class=\"built_in\">p</span>(chopstick[(i+<span class=\"number\">1</span>)%<span class=\"number\">5</span>]);                      <span class=\"comment\">// 取右边筷子</span></span><br><span class=\"line\">        <span class=\"built_in\">v</span>(mutex);</span><br><span class=\"line\">        eat;</span><br><span class=\"line\">        <span class=\"built_in\">v</span>(chocktick[i]);</span><br><span class=\"line\">        <span class=\"built_in\">v</span>(chocktick[(i+<span class=\"number\">1</span>)%<span class=\"number\">5</span>]);</span><br><span class=\"line\">        think;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">while</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"吸烟者问题\">4. 吸烟者问题</h3>\n<p><strong>问题描述：</strong>\n假设一个系统有三个抽烟者进程和一个供应者进程。要卷起并抽掉一根烟，抽烟者需要三种材料：烟草，纸和胶水。\n三个抽烟者中，第一个拥有烟草，第二个拥有纸，第三个拥有胶水。供应者进程无限特供三种材料，供应者每次将两种材料放在桌子上，\n拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者一个信号告诉已完成，此时供应者就会将另外两种材料放在桌上，\n如此重复。</p>\n<p><strong>问题分析：</strong></p>\n<ol type=\"1\">\n<li>关系分析。供应者与三个抽烟者分别是同步关系。由于供应者无法同时满足两个或以上的抽烟者，三个抽烟者对抽烟这个动作互斥。</li>\n<li>整理思路。显然这里有4个进程，供应者作为生产者向三个抽烟者提供材料。</li>\n<li>信号量设置。信号量<code>offer1</code>,<code>offer2</code>,<code>offer3</code>分别表示烟草和纸的资源，烟草和胶水组合的资源，纸和胶水组合的资源。\n信号量<code>finish</code>用于互斥进行抽烟动作。</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> num = <span class=\"number\">0</span>;                    <span class=\"comment\">// 存储随机数</span></span><br><span class=\"line\">semaphore offer1 = <span class=\"number\">0</span>;           <span class=\"comment\">// 烟草和纸组合的资源</span></span><br><span class=\"line\">semaphore offer2 = <span class=\"number\">0</span>;           <span class=\"comment\">// 烟草和胶水组合的资源</span></span><br><span class=\"line\">semaphore offer3 = <span class=\"number\">0</span>;           <span class=\"comment\">// 纸和胶水组合的资源</span></span><br><span class=\"line\">semaphore finish = <span class=\"number\">0</span>;           <span class=\"comment\">// 表示抽烟动作是否完成</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">process <span class=\"title\">P1</span><span class=\"params\">()</span> </span>&#123;                  <span class=\"comment\">// 供应者</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        num++;</span><br><span class=\"line\">        num = num % <span class=\"number\">3</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(num == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"built_in\">v</span>(offer1);          <span class=\"comment\">// 提供烟草和纸</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(num == <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"built_in\">v</span>(offer2);          <span class=\"comment\">// 提供烟草和胶水</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"built_in\">v</span>(offer3);          <span class=\"comment\">// 提供纸和胶水</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 任意两种材料放在桌子上。</span></span><br><span class=\"line\">        <span class=\"built_in\">p</span>(finish);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">process <span class=\"title\">P2</span><span class=\"params\">()</span> </span>&#123;                  <span class=\"comment\">// 拥有烟草者</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">p</span>(offe3);</span><br><span class=\"line\">        拿纸和胶水，卷成烟，抽掉；</span><br><span class=\"line\">        <span class=\"built_in\">v</span>(finish);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">process <span class=\"title\">P3</span><span class=\"params\">()</span> </span>&#123;                  <span class=\"comment\">// 拥有纸者</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">p</span>(offe2);</span><br><span class=\"line\">        拿烟草和胶水，卷成烟，抽掉；</span><br><span class=\"line\">        <span class=\"built_in\">v</span>(finish);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">process <span class=\"title\">P4</span><span class=\"params\">()</span> </span>&#123;                  <span class=\"comment\">// 拥有胶水者</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">p</span>(offe1);</span><br><span class=\"line\">        拿纸和烟草，卷成烟，抽掉；</span><br><span class=\"line\">        <span class=\"built_in\">v</span>(finish);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"死锁\">死锁</h1>\n<h2 id=\"定义-1\">定义</h2>\n<p>指多个进程因竞争资源而造成的一种互相等待，若无外力作用，这些进程都无法向前推进。</p>\n<h2 id=\"死锁产生的原因\">死锁产生的原因</h2>\n<ul>\n<li>系统资源的竞争</li>\n<li>进程推进顺序不当</li>\n</ul>\n<h2 id=\"死锁产出的必要条件\">死锁产出的必要条件</h2>\n<ol type=\"1\">\n<li><strong>互斥条件：</strong>\n在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</li>\n<li><strong>不剥夺条件：</strong>\n进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放。</li>\n<li><strong>请求与保持条件：</strong>\n进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，\n但对自己获得的资源保持不放。</li>\n<li><strong>循环等待条件：</strong>\n存在一种进程资源的循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。</li>\n</ol>\n<h2 id=\"死锁的处理策略\">死锁的处理策略</h2>\n<ul>\n<li>n\n个进程，每个进程需要<code>m</code>个某类资源，则发生死锁的最大资源数为<code>n(m-1)</code>，不发生死锁的最小资源数为<code>n(m-1) + 1</code>。</li>\n</ul>\n<h3 id=\"死锁预防\">死锁预防</h3>\n<p>需要破坏死锁的4个必要条件中的一个或多个。</p>\n<h3 id=\"避免死锁\">避免死锁</h3>\n<p>在死锁的动态分布过程中，用某种方法防止系统进入<em>不安全状态</em>。</p>\n<p>并非所有的不安全状态都是死锁状态，但当系统进入不安全状态后，便可能进入死锁状态；\n只要系统处于安全状态，系统便可以避免进入死锁状态。</p>\n<p>死锁一定是不安全状态，不安全状态不一定是死锁状态。</p>\n<p>最主要的算法就是：<strong>银行家算法</strong></p>\n<p>银河家算法的主要数据结构为</p>\n<table>\n<thead>\n<tr class=\"header\">\n<th>数据结构</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td>可利用资源<code>Available</code></td>\n</tr>\n<tr class=\"even\">\n<td>最大需求矩阵<code>Max</code></td>\n</tr>\n<tr class=\"odd\">\n<td>分配矩阵<code>Allocation</code></td>\n</tr>\n<tr class=\"even\">\n<td>需求矩阵<code>Need</code></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"死锁检测和解除\">死锁检测和解除</h3>\n<p>允许产生死锁，采取某种措施解除死锁。</p>\n<h4 id=\"资源分配图\">资源分配图</h4>\n<p>用圆圈代表一个进程，用框代表一类资源。</p>\n<p>从进程到资源的有向边称为<em>请求边</em>，表示该进程申请一个单位的该类资源；</p>\n<p>从资源到进程的边称为<em>分配边</em>。表示该类资源已有一个资源分配给了该进程。</p>\n<p><img\nsrc=\"https://sjchen404.oss-cn-shenzhen.aliyuncs.com/img/资源分配图.png\" /></p>\n<blockquote>\n<p>p1,p2为进程，R1，R2表示资源</p>\n</blockquote>\n<h4 id=\"死锁定理\">死锁定理</h4>\n<p>当资源分配图不可完全简化，则为死锁。</p>\n<p>简化资源分配图可检测系统状态<code>S</code>是否处于死锁状态。简化方法如下：</p>\n<ol type=\"1\">\n<li><p>在资源分配图中，找出既不阻塞又不孤点的进程 <span\nclass=\"math inline\">\\(P_i\\)</span>\n（即找出一条有向边与它相邻，且该有向边对应的资源的申请数量小于等于系统中已有\n的空闲资源数量。）如上图，我们可以找到进程<code>p1</code>,（<code>R1</code>没有资源，<code>R2</code>有一个资源，进程<code>p1</code>也只有一条申请边），消去它所有的请求边和分配边，\n使之成为孤立的点。如图（b）</p></li>\n<li><p>进程 <span\nclass=\"math inline\">\\(P_i\\)</span>所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程，重复动作1。</p></li>\n</ol>\n<p><img\nsrc=\"https://sjchen404.oss-cn-shenzhen.aliyuncs.com/img/资源分配图化简.png\" /></p>\n<h4 id=\"死锁解除\">死锁解除</h4>\n<ol type=\"1\">\n<li>资源剥夺法</li>\n<li>撤销进程法</li>\n<li>进程回退法</li>\n</ol>\n","categories":["操作系统"],"tags":["操作系统"]},{"title":"转骰子","url":"/2022/04/04/%E8%BD%AC%E9%AA%B0%E5%AD%90/","content":"<p>#转骰子</p>\n<p>骰子是一个正方体，每个面有一个数字，初始为左1，右2，前3，后4，上5，下6，用123456表示这个状态，放置在平面上，可以向左翻转（用L表示向左翻转1次）；可以向右翻转（用R表示向右翻转1次）；可以向前翻转（用F表示向前翻转1次）；可以向后翻转（用B表示向后翻转1次）；可以逆时针翻转（用A表示向逆时针翻转1次）；可以向顺时针翻转（用C表示向顺时针翻转1次）</p>\n<p>输入一行指令，输出最后骰子的状态</p>\n<blockquote>\n<p>输入 RL 输出 123456\n解释：骰子向右转一下，再向左转一下，各面结果相当于不变</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"思路\">思路：</h2>\n<p><img src=\"转骰子/1.jpeg\" style=\"zoom:80%;\" /></p>\n<p><img src=\"转骰子/2.jpeg\" /></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    string op;</span><br><span class=\"line\">    cin &gt;&gt; op;</span><br><span class=\"line\">    <span class=\"comment\">//                  左 右 前 后  上 下</span></span><br><span class=\"line\">    <span class=\"type\">int</span> status[<span class=\"number\">7</span>] = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span> ,<span class=\"number\">4</span>, <span class=\"number\">5</span> ,<span class=\"number\">6</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; op.<span class=\"built_in\">size</span>(); i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(op[i])&#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;L&#x27;</span>: &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 前后不变，左上右下，左移一位</span></span><br><span class=\"line\">                <span class=\"type\">int</span> left = status[<span class=\"number\">1</span>];</span><br><span class=\"line\">                <span class=\"type\">int</span> up = status[<span class=\"number\">5</span>];</span><br><span class=\"line\">                <span class=\"type\">int</span> right = status[<span class=\"number\">2</span>];</span><br><span class=\"line\">                <span class=\"type\">int</span> down = status[<span class=\"number\">6</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">                status[<span class=\"number\">1</span>] = up;</span><br><span class=\"line\">                status[<span class=\"number\">5</span>] = right;</span><br><span class=\"line\">                status[<span class=\"number\">2</span>] = down;</span><br><span class=\"line\">                status[<span class=\"number\">6</span>] = left;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;R&#x27;</span>:&#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> left = status[<span class=\"number\">1</span>];</span><br><span class=\"line\">                <span class=\"type\">int</span> up = status[<span class=\"number\">5</span>];</span><br><span class=\"line\">                <span class=\"type\">int</span> right = status[<span class=\"number\">2</span>];</span><br><span class=\"line\">                <span class=\"type\">int</span> down = status[<span class=\"number\">6</span>];</span><br><span class=\"line\">                <span class=\"comment\">//前后不变,左上右下,右移一位</span></span><br><span class=\"line\">                status[<span class=\"number\">1</span>] = down;</span><br><span class=\"line\">                status[<span class=\"number\">5</span>] = left;</span><br><span class=\"line\">                status[<span class=\"number\">2</span>] = up;</span><br><span class=\"line\">                status[<span class=\"number\">6</span>] = right;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;F&#x27;</span>:&#123;</span><br><span class=\"line\">                <span class=\"comment\">//左右不变，前下后上，右移一位</span></span><br><span class=\"line\">                <span class=\"type\">int</span> front = status[<span class=\"number\">3</span>];</span><br><span class=\"line\">                <span class=\"type\">int</span> down = status[<span class=\"number\">6</span>];</span><br><span class=\"line\">                <span class=\"type\">int</span> rear = status[<span class=\"number\">4</span>];</span><br><span class=\"line\">                <span class=\"type\">int</span> up = status[<span class=\"number\">5</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">                status[<span class=\"number\">3</span>] = up;</span><br><span class=\"line\">                status[<span class=\"number\">6</span>] = front;</span><br><span class=\"line\">                status[<span class=\"number\">4</span>] = down;</span><br><span class=\"line\">                status[<span class=\"number\">5</span>] = rear;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;B&#x27;</span>:&#123;</span><br><span class=\"line\">                <span class=\"comment\">//左右不变，前下后上，左移一位</span></span><br><span class=\"line\">                <span class=\"type\">int</span> front = status[<span class=\"number\">3</span>];</span><br><span class=\"line\">                <span class=\"type\">int</span> down = status[<span class=\"number\">6</span>];</span><br><span class=\"line\">                <span class=\"type\">int</span> rear = status[<span class=\"number\">4</span>];</span><br><span class=\"line\">                <span class=\"type\">int</span> up = status[<span class=\"number\">5</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">                status[<span class=\"number\">3</span>] = down;</span><br><span class=\"line\">                status[<span class=\"number\">6</span>] = rear;</span><br><span class=\"line\">                status[<span class=\"number\">4</span>] = up;</span><br><span class=\"line\">                status[<span class=\"number\">5</span>] = front;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;A&#x27;</span>:&#123;</span><br><span class=\"line\">                <span class=\"comment\">//上下不变，左前右后，右移一位</span></span><br><span class=\"line\">                <span class=\"type\">int</span> left = status[<span class=\"number\">1</span>];</span><br><span class=\"line\">                <span class=\"type\">int</span> front = status[<span class=\"number\">3</span>];</span><br><span class=\"line\">                <span class=\"type\">int</span> right = status[<span class=\"number\">2</span>];</span><br><span class=\"line\">                <span class=\"type\">int</span> rear = status[<span class=\"number\">4</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">                status[<span class=\"number\">1</span>] = rear;</span><br><span class=\"line\">                status[<span class=\"number\">3</span>] = left;</span><br><span class=\"line\">                status[<span class=\"number\">2</span>] = front;</span><br><span class=\"line\">                status[<span class=\"number\">4</span>] = right;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;C&#x27;</span>:&#123;</span><br><span class=\"line\">                <span class=\"comment\">//上下不变，左前右后，左移一位</span></span><br><span class=\"line\">                <span class=\"type\">int</span> left = status[<span class=\"number\">1</span>];</span><br><span class=\"line\">                <span class=\"type\">int</span> front = status[<span class=\"number\">3</span>];</span><br><span class=\"line\">                <span class=\"type\">int</span> right = status[<span class=\"number\">2</span>];</span><br><span class=\"line\">                <span class=\"type\">int</span> rear = status[<span class=\"number\">4</span>];</span><br><span class=\"line\">                status[<span class=\"number\">1</span>] = front;</span><br><span class=\"line\">                status[<span class=\"number\">3</span>] = right;</span><br><span class=\"line\">                status[<span class=\"number\">2</span>] = rear;</span><br><span class=\"line\">                status[<span class=\"number\">4</span>] = left;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"number\">7</span>; i++)&#123;</span><br><span class=\"line\">        cout &lt;&lt; status[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["华为","模拟"],"tags":["模拟"]},{"title":"进阶词云","url":"/2019/06/09/%E8%BF%9B%E9%98%B6%E8%AF%8D%E4%BA%91/","content":"<p><code>python</code>实现词云</p>\n<span id=\"more\"></span>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">登陆微信获取好友个性签名生成词云</span><br><span class=\"line\"><span class=\"keyword\">import</span> itchat</span><br><span class=\"line\"><span class=\"keyword\">import</span> jieba</span><br><span class=\"line\"><span class=\"keyword\">import</span> imageio</span><br><span class=\"line\"><span class=\"keyword\">import</span> wordcloud</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 登陆微信</span></span><br><span class=\"line\">itchat.login()</span><br><span class=\"line\">tList=[]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取好友列表</span></span><br><span class=\"line\">friends=itchat.get_friends(update=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#构建所有好友个性签名组成的大列表tList</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> friends:</span><br><span class=\"line\">    signature=i[<span class=\"string\">&quot;Signature&quot;</span>]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"string\">&#x27;emoji&#x27;</span> <span class=\"keyword\">in</span> signature:</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        tList.append(signature)</span><br><span class=\"line\">text=<span class=\"string\">&quot; &quot;</span>.join(tList)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 对个性签名进行中文分词</span></span><br><span class=\"line\">wordlist_jieba=jieba.lcut(text,cut_all=<span class=\"literal\">True</span>)</span><br><span class=\"line\">wl_space_split=<span class=\"string\">&quot; &quot;</span>.join(wordlist_jieba)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 读取个性图片</span></span><br><span class=\"line\">mk=imageio.imread(<span class=\"string\">&quot;/Users/SJCHEN/Downloads/zihaowordcloud-master/code/chinamap.png&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 构建词云对象</span></span><br><span class=\"line\">my_wordcloud=wordcloud.WordCloud(background_color=<span class=\"string\">&#x27;white&#x27;</span>,</span><br><span class=\"line\">                                 width=<span class=\"number\">1000</span>,</span><br><span class=\"line\">                                 height=<span class=\"number\">700</span>,</span><br><span class=\"line\">                                 font_path=<span class=\"string\">&#x27;Songti.ttc&#x27;</span>,</span><br><span class=\"line\">                                 max_words=<span class=\"number\">2000</span>,</span><br><span class=\"line\">                                 mask=mk,</span><br><span class=\"line\">                                 scale=<span class=\"number\">20</span>)</span><br><span class=\"line\">my_wordcloud.generate(wl_space_split)</span><br><span class=\"line\"></span><br><span class=\"line\">nickname=friends[<span class=\"number\">0</span>][<span class=\"string\">&#x27;NickName&#x27;</span>]</span><br><span class=\"line\">filename=<span class=\"string\">&quot;example12-&#123;&#125;的微信好友个性签名词云图.png&quot;</span>.<span class=\"built_in\">format</span>(nickname)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示词云图</span></span><br><span class=\"line\">plt.imshow(my_wordcloud)</span><br><span class=\"line\">plt.axis(<span class=\"string\">&quot;off&quot;</span>)</span><br><span class=\"line\">plt.show()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;程序结束&#x27;</span>)</span><br></pre></td></tr></table></figure>\n","categories":["python","词云"],"tags":["python","词云"]},{"title":"迷宫","url":"/2019/04/11/%E8%BF%B7%E5%AE%AB/","content":"<p><a\nhref=\"https://www.luogu.org/problemnew/show/P1605\">题目链接</a></p>\n<h1 id=\"题目背景\">题目背景</h1>\n<p>迷宫 【问题描述】</p>\n<p>给定一个N*M方格的迷宫，迷宫里有T处障碍，障碍处不可通过。给定起点坐标和</p>\n<p>终点坐标，问:\n每个方格最多经过1次，有多少种从起点坐标到终点坐标的方案。在迷宫</p>\n<p>中移动有上下左右四种方式，每次只能移动一个方格。数据保证起点上没有障碍。</p>\n<p>输入样例 输出样例</p>\n<p>【数据规模】</p>\n<p>1≤N,M≤5</p>\n<span id=\"more\"></span>\n<h2 id=\"题目描述\">题目描述</h2>\n<h3 id=\"输入输出格式\">输入输出格式</h3>\n<p>输入格式：</p>\n<p>【输入】</p>\n<p>第一行N、M和T，N为行，M为列，T为障碍总数。第二行起点坐标SX,SY，终点</p>\n<p>坐标FX,FY。接下来T行，每行为障碍点的坐标。</p>\n<p>输出格式：</p>\n<p>【输出】</p>\n<p>给定起点坐标和终点坐标，问每个方格最多经过1次，从起点坐标到终点坐标的方</p>\n<p>案总数。</p>\n<h3 id=\"输入样例\">输入样例:</h3>\n<blockquote>\n<p>2 2 1</p>\n<p>1 1 2 2</p>\n<p>1 2</p>\n</blockquote>\n<h3 id=\"输出样例\">输出样例:</h3>\n<blockquote>\n<p>1</p>\n</blockquote>\n<h4 id=\"解题思路\">解题思路:</h4>\n<p>典型的dfs，我们只需要记录路径即可，这里我们用另一个数组来记录路径。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ll long long</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> n,m,t;</span><br><span class=\"line\"><span class=\"type\">int</span> sx,sy,fx,fy;</span><br><span class=\"line\"><span class=\"type\">int</span> vis[<span class=\"number\">10</span>][<span class=\"number\">10</span>];<span class=\"comment\">//记录路径</span></span><br><span class=\"line\"><span class=\"type\">int</span> temp[<span class=\"number\">10</span>][<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"type\">int</span> dir[][<span class=\"number\">2</span>]=&#123;&#123;<span class=\"number\">-1</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">1</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">0</span>,<span class=\"number\">-1</span>&#125;,&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>&#125;&#125;;<span class=\"comment\">//四个方向</span></span><br><span class=\"line\"><span class=\"type\">int</span> ans;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(x==fx&amp;&amp;y==fy)&#123;<span class=\"comment\">//找到终点</span></span><br><span class=\"line\">        ans++;<span class=\"comment\">//次数加1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">4</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> dx=x+dir[i][<span class=\"number\">0</span>];<span class=\"comment\">//寻找方向</span></span><br><span class=\"line\">            <span class=\"type\">int</span> dy=y+dir[i][<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dx&gt;=<span class=\"number\">1</span>&amp;&amp;dx&lt;=n&amp;&amp;dy&gt;=<span class=\"number\">1</span>&amp;&amp;dy&lt;=m&amp;&amp;vis[dx][dy]==<span class=\"number\">0</span>&amp;&amp;temp[dx][dy]==<span class=\"number\">0</span>)&#123;<span class=\"comment\">//在地图内且没有被走过</span></span><br><span class=\"line\">                temp[x][y]=<span class=\"number\">1</span>;<span class=\"comment\">//标志走过</span></span><br><span class=\"line\">                <span class=\"built_in\">dfs</span>(dx,dy);</span><br><span class=\"line\">                temp[x][y]=<span class=\"number\">0</span>;<span class=\"comment\">//回溯</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;t;</span><br><span class=\"line\">    cin&gt;&gt;sx&gt;&gt;sy&gt;&gt;fx&gt;&gt;fy;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(vis,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(vis));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(temp,<span class=\"number\">0</span>,<span class=\"built_in\">sizeof</span>(temp));</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> xz,yz;</span><br><span class=\"line\">        cin&gt;&gt;xz&gt;&gt;yz;</span><br><span class=\"line\">        vis[xz][yz]=<span class=\"number\">1</span>;<span class=\"comment\">//障碍</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">dfs</span>(sx,sy);<span class=\"comment\">//从起点开始dfs</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,ans);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","categories":["dfs"],"tags":["dfs"]},{"title":"高级词云：绘制指定形状","url":"/2019/06/09/%E9%AB%98%E7%BA%A7%E8%AF%8D%E4%BA%91%EF%BC%9A%E7%BB%98%E5%88%B6%E6%8C%87%E5%AE%9A%E5%BD%A2%E7%8A%B6/","content":"<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">first: 通过以下代码读入外部词云形状图片（需要先pip3 install imageio安装imageio）</span><br><span class=\"line\">import imageio</span><br><span class=\"line\">mk=imageio.imread(&quot;picture.png&quot;)</span><br><span class=\"line\">w=wordcloud.WordCloud(mask=mk)</span><br></pre></td></tr></table></figure>\n<span id=\"more\"></span>\n<h4 id=\"例子\">例子</h4>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> jieba</span><br><span class=\"line\"><span class=\"keyword\">import</span> wordcloud</span><br><span class=\"line\"><span class=\"keyword\">import</span> imageio</span><br><span class=\"line\"></span><br><span class=\"line\">mk=imageio.imread(<span class=\"string\">&quot;/Users/SJCHEN/Downloads/zihaowordcloud-master/code/wujiaoxing.png&quot;</span>)</span><br><span class=\"line\">w=wordcloud.WordCloud(mask=mk)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 构建并配置词云对象w，注意要加scale参数，提高清晰度</span></span><br><span class=\"line\">w=wordcloud.WordCloud(width=<span class=\"number\">1000</span>,</span><br><span class=\"line\">                      height=<span class=\"number\">700</span>,</span><br><span class=\"line\">                      background_color=<span class=\"string\">&#x27;white&#x27;</span>,</span><br><span class=\"line\">                      font_path=<span class=\"string\">&#x27;Songti.ttc&#x27;</span>,</span><br><span class=\"line\">                      mask=mk,</span><br><span class=\"line\">                      scale=<span class=\"number\">15</span>)</span><br><span class=\"line\">f=<span class=\"built_in\">open</span>(<span class=\"string\">&#x27;/Users/SJCHEN/Downloads/zihaowordcloud-master/code/关于实施乡村振兴战略的意见.txt&#x27;</span>,encoding=<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\">txt=f.read()</span><br><span class=\"line\">textlist=jieba.lcut(txt)</span><br><span class=\"line\">string=<span class=\"string\">&quot; &quot;</span>.join(textlist)</span><br><span class=\"line\"></span><br><span class=\"line\">w.generate(string)</span><br><span class=\"line\">w.to_file(<span class=\"string\">&#x27;example7.png&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<p><img src=\"高级词云：绘制指定形状/example7.png\" /></p>\n<h4\nid=\"去除指定词stopwords参数去除词\">去除指定词（stopwords参数去除词）</h4>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> jieba</span><br><span class=\"line\"><span class=\"keyword\">import</span> wordcloud</span><br><span class=\"line\"><span class=\"keyword\">import</span> imageio</span><br><span class=\"line\"></span><br><span class=\"line\">mk=imageio.imread(<span class=\"string\">&quot;/Users/SJCHEN/Downloads/zihaowordcloud-master/code/chinamap.png&quot;</span>)</span><br><span class=\"line\">w=wordcloud.WordCloud(mask=mk)</span><br><span class=\"line\"></span><br><span class=\"line\">w=wordcloud.WordCloud(width=<span class=\"number\">1000</span>,</span><br><span class=\"line\">                      height=<span class=\"number\">700</span>,</span><br><span class=\"line\">                      background_color=<span class=\"string\">&#x27;white&#x27;</span>,</span><br><span class=\"line\">                      font_path=<span class=\"string\">&#x27;Songti.ttc&#x27;</span>,</span><br><span class=\"line\">                      mask=mk,</span><br><span class=\"line\">                      scale=<span class=\"number\">15</span>,</span><br><span class=\"line\">                      stopwords=&#123;<span class=\"string\">&#x27;曹操&#x27;</span>,<span class=\"string\">&#x27;孔明&#x27;</span>&#125;)</span><br><span class=\"line\">f=<span class=\"built_in\">open</span>(<span class=\"string\">&#x27;/Users/SJCHEN/Downloads/zihaowordcloud-master/code/三国演义.txt&#x27;</span>,encoding=<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\">txt=f.read()</span><br><span class=\"line\">textlist=jieba.lcut(txt)</span><br><span class=\"line\">string=<span class=\"string\">&quot; &quot;</span>.join(textlist)</span><br><span class=\"line\"></span><br><span class=\"line\">w.generate(string)</span><br><span class=\"line\">w.to_file(<span class=\"string\">&#x27;example10.png&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<p>利用原来的方法我们得到</p>\n<p><img src=\"高级词云：绘制指定形状/example9.png\" /></p>\n<p>去掉指定的词后</p>\n<p><img src=\"高级词云：绘制指定形状/example10.png\" /></p>\n<h4 id=\"勾勒轮廓线\">勾勒轮廓线</h4>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> wordcloud</span><br><span class=\"line\"><span class=\"keyword\">import</span> imageio</span><br><span class=\"line\"></span><br><span class=\"line\">mk=imageio.imread(<span class=\"string\">&quot;/Users/SJCHEN/Downloads/zihaowordcloud-master/code/alice.png&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 构建词云对象w，注意增加参数contour_width和contour_color设置轮廓宽度和颜色</span></span><br><span class=\"line\">w=wordcloud.WordCloud(background_color=<span class=\"string\">&#x27;white&#x27;</span>,</span><br><span class=\"line\">                      mask=mk,</span><br><span class=\"line\">                      contour_width=<span class=\"number\">1</span>,</span><br><span class=\"line\">                      contour_color=<span class=\"string\">&#x27;steelblue&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 将外部文件包含的文本保存在string变量中</span></span><br><span class=\"line\">string =<span class=\"built_in\">open</span>(<span class=\"string\">&#x27;/Users/SJCHEN/Downloads/zihaowordcloud-master/code/hamlet.txt&#x27;</span>).read()</span><br><span class=\"line\">w.generate(string)</span><br><span class=\"line\">w.to_file(<span class=\"string\">&#x27;example11.png&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<p><img src=\"高级词云：绘制指定形状/example13.png\" /></p>\n<h4 id=\"按模版填色\">按模版填色</h4>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"keyword\">from</span> wordcloud <span class=\"keyword\">import</span> WordCloud,ImageColorGenerator</span><br><span class=\"line\"><span class=\"keyword\">import</span> imageio</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将外部文件包含的文本保存在text变量中</span></span><br><span class=\"line\">text = <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;/Users/SJCHEN/Downloads/zihaowordcloud-master/code/alice.txt&#x27;</span>,encoding=<span class=\"string\">&#x27;utf-8&#x27;</span>).read()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 导入imageio库中的imread函数，并用这个函数读取本地图片queen2.jfif，作为词云形状图片</span></span><br><span class=\"line\">mk = imageio.imread(<span class=\"string\">&quot;/Users/SJCHEN/Downloads/zihaowordcloud-master/code/alice_color.png&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 构建词云对象w</span></span><br><span class=\"line\">wc = WordCloud(background_color=<span class=\"string\">&quot;white&quot;</span>,</span><br><span class=\"line\">               mask=mk,)</span><br><span class=\"line\"><span class=\"comment\"># 将text字符串变量传入w的generate()方法，给词云输入文字</span></span><br><span class=\"line\">wc.generate(text)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 调用wordcloud库中的ImageColorGenerator()函数，提取模板图片各部分的颜色</span></span><br><span class=\"line\">image_colors = ImageColorGenerator(mk)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 显示原生词云图、按模板图片颜色的词云图和模板图片，按左、中、右显示</span></span><br><span class=\"line\">fig, axes = plt.subplots(<span class=\"number\">1</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"comment\"># 最左边的图片显示原生词云图</span></span><br><span class=\"line\">axes[<span class=\"number\">0</span>].imshow(wc)</span><br><span class=\"line\"><span class=\"comment\"># 中间的图片显示按模板图片颜色生成的词云图，采用双线性插值的方法显示颜色</span></span><br><span class=\"line\">axes[<span class=\"number\">1</span>].imshow(wc.recolor(color_func=image_colors), interpolation=<span class=\"string\">&quot;bilinear&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 右边的图片显示模板图片</span></span><br><span class=\"line\">axes[<span class=\"number\">2</span>].imshow(mk, cmap=plt.cm.gray)</span><br><span class=\"line\"><span class=\"keyword\">for</span> ax <span class=\"keyword\">in</span> axes:</span><br><span class=\"line\">    ax.set_axis_off()</span><br><span class=\"line\">plt.show()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 给词云对象按模板图片的颜色重新上色</span></span><br><span class=\"line\">wc_color = wc.recolor(color_func=image_colors)</span><br><span class=\"line\"><span class=\"comment\"># 将词云图片导出到当前文件夹</span></span><br><span class=\"line\">wc_color.to_file(<span class=\"string\">&#x27;example11.png&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<p><img src=\"高级词云：绘制指定形状/example11.png\" /></p>\n<p><img src=\"高级词云：绘制指定形状/Figure_1.png\" />\n如果只是简单的用的话</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> wordcloud <span class=\"keyword\">import</span> WordCloud,ImageColorGenerator</span><br><span class=\"line\"><span class=\"keyword\">import</span> imageio</span><br><span class=\"line\"></span><br><span class=\"line\">text = <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;/Users/SJCHEN/Downloads/zihaowordcloud-master/code/alice.txt&#x27;</span>,encoding=<span class=\"string\">&#x27;utf-8&#x27;</span>).read()</span><br><span class=\"line\">mk=imageio.imread(<span class=\"string\">&quot;/Users/SJCHEN/Downloads/zihaowordcloud-master/code/alice_color.png&quot;</span>)</span><br><span class=\"line\">w=WordCloud(background_color=<span class=\"string\">&#x27;white&#x27;</span>,</span><br><span class=\"line\">            mask=mk,)</span><br><span class=\"line\">w.generate(text)</span><br><span class=\"line\">image_colors=ImageColorGenerator(mk)</span><br><span class=\"line\">w_color=w.recolor(color_func=image_colors)</span><br><span class=\"line\">w_color.to_file(<span class=\"string\">&#x27;exam.png&#x27;</span>)</span><br></pre></td></tr></table></figure>\n","categories":["python","词云"],"tags":["python","词云","jieba","imageio"]},{"title":"验证外星语词典","url":"/2022/05/17/%E9%AA%8C%E8%AF%81%E5%A4%96%E6%98%9F%E8%AF%AD%E8%AF%8D%E5%85%B8/","content":"<h1 id=\"验证外星语词典\"><a\nhref=\"https://leetcode.cn/problems/verifying-an-alien-dictionary/\">953.\n验证外星语词典</a></h1>\n<p>某种外星语也使用英文小写字母，但可能顺序\n<code>order</code>不同。字母表的顺序（<code>order</code>）是一些小写字母的排列。</p>\n<p>给定一组用外星语书写的单词 <code>words</code>，以及其字母表的顺序\n<code>order</code>，只有当给定的单词在这种外星语中按字典序排列时，返回\n<code>true</code>；否则，返回 <code>false</code>。</p>\n<h2 id=\"示例\">示例：</h2>\n<blockquote>\n<p>输入：words = [\"hello\",\"leetcode\"], order =\n\"hlabcdefgijkmnopqrstuvwxyz\" 输出：true 解释：在该语言的字母表中，'h'\n位于 'l' 之前，所以单词序列是按字典序排列的。</p>\n</blockquote>\n<span id=\"more\"></span>\n<h3 id=\"思路\">思路</h3>\n<h4 id=\"方法一\">方法一</h4>\n<p>我们把外星语转化为正常的英语序，最后判断是否按照字典序排列</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isAlienSorted</span><span class=\"params\">(vector&lt;string&gt;&amp; words, string order)</span> </span>&#123;</span><br><span class=\"line\">        unordered_map&lt;<span class=\"type\">char</span>,<span class=\"type\">int</span>&gt; mp;</span><br><span class=\"line\">        <span class=\"comment\">//哈希表确定位置</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; order.<span class=\"built_in\">size</span>(); i++)&#123;</span><br><span class=\"line\">            mp[order[i]] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        vector&lt;string&gt; tmp;</span><br><span class=\"line\">        <span class=\"comment\">// 把外星语转化为正常英语序，最后判断是否有序</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(string&amp; word : words)&#123;</span><br><span class=\"line\">            string tmpWord;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">char</span> c : word)&#123;</span><br><span class=\"line\">                tmpWord += <span class=\"string\">&#x27;a&#x27;</span> + mp[c];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            tmp.<span class=\"built_in\">emplace_back</span>(tmpWord);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">is_sorted</span>(tmp.<span class=\"built_in\">begin</span>(), tmp.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><code>M</code>为\n<code>words</code>数组对长度，<code>N</code>为平均的单词长度\n时间复杂度为<code>O(M*N)</code> 空间复杂度为<code>O(N)</code></p>\n<h4 id=\"方法二\">方法二：</h4>\n<p>我们只需要相邻的两个字符串是否按照给定的序列排列即可，这样就可以压缩空间复杂度</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution1</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isAlienSorted</span><span class=\"params\">(vector&lt;string&gt;&amp; words, string order)</span> </span>&#123;</span><br><span class=\"line\">       unordered_map&lt;<span class=\"type\">char</span>, <span class=\"type\">int</span>&gt; mp;</span><br><span class=\"line\">       <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; order.<span class=\"built_in\">size</span>(); i++)&#123;</span><br><span class=\"line\">           mp[order[i]] = i;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; words.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; i++)&#123;</span><br><span class=\"line\">           string pre = words[i];</span><br><span class=\"line\">           string cur = words[i + <span class=\"number\">1</span>];</span><br><span class=\"line\">           <span class=\"type\">bool</span> res = <span class=\"literal\">false</span>;</span><br><span class=\"line\">           <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"built_in\">min</span>(pre.<span class=\"built_in\">size</span>(), cur.<span class=\"built_in\">size</span>()); j++)&#123;</span><br><span class=\"line\">               <span class=\"keyword\">if</span>(mp[pre[j]] &lt; mp[cur[j]])&#123;</span><br><span class=\"line\">                   res = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                   <span class=\"keyword\">break</span>;</span><br><span class=\"line\">               &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(mp[pre[j]] &gt; mp[cur[j]])&#123;</span><br><span class=\"line\">                   <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"comment\">// 如果前面都相等，则判断长度</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span>(!res &amp;&amp; pre.<span class=\"built_in\">size</span>() &gt; cur.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">               <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["字符串","哈希表"],"tags":["字符串","哈希表"]},{"title":"魔兽世界之一：备战","url":"/2019/04/26/%E9%AD%94%E5%85%BD%E4%B8%96%E7%95%8C%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%A4%87%E6%88%98/","content":"<p><a href=\"http://cxsjsxmooc.openjudge.cn/test/B/\">题目链接</a></p>\n<h3 id=\"描述\">描述</h3>\n<p>魔兽世界的西面是红魔军的司令部，东面是蓝魔军的司令部。两个司令部之间是依次排列的若干城市。红司令部，City\n1，City 2，……，City n，蓝司令部 两军的司令部都会制造武士。武士一共有\ndragon 、ninja、iceman、lion、wolf\n五种。每种武士都有编号、生命值、攻击力这三种属性。\n双方的武士编号都是从1开始计算。红方制造出来的第n个武士，编号就是n。同样，蓝方制造出来的第n个武士，编号也是n。\n武士在刚降生的时候有一个生命值。\n在每个整点，双方的司令部中各有一个武士降生。\n红方司令部按照iceman、lion、wolf、ninja、dragon的顺序循环制造武士。\n蓝方司令部按照lion、dragon、ninja、iceman、wolf的顺序循环制造武士。\n制造武士需要生命元。\n制造一个初始生命值为m的武士，司令部中的生命元就要减少m个。\n如果司令部中的生命元不足以制造某个按顺序应该制造的武士，那么司令部就试图制造下一个。如果所有武士都不能制造了，则司令部停止制造武士。\n给定一个时间，和双方司令部的初始生命元数目，要求你将从0点0分开始到双方司令部停止制造武士为止的所有事件按顺序输出。一共有两种事件，其对应的输出样例如下：</p>\n<span id=\"more\"></span>\n<ol type=\"1\">\n<li><code>武士降生输出样例： 004 blue lion 5 born with strength 5,2 lion in red headquarter表示在4点整，编号为5的蓝魔lion武士降生，它降生时生命值为5，降生后蓝魔司令部里共有2个lion武士。（为简单起见，不考虑单词的复数形式）注意，每制造出一个新的武士，都要输出此时司令部里共有多少个该种武士。</code></li>\n<li><code>司令部停止制造武士输出样例： 010 red headquarter stops making warriors表示在10点整，红方司令部停止制造武士</code></li>\n</ol>\n<p>输出事件时： 首先按时间顺序输出；\n同一时间发生的事件，先输出红司令部的，再输出蓝司令部的。</p>\n<h4 id=\"输入\">输入</h4>\n<p>第一行是一个整数，代表测试数据组数。 每组测试数据共两行。\n第一行：一个整数M。其含义为， 每个司令部一开始都有M个生命元( 1 &lt;= M\n&lt;= 10000)。 第二行：五个整数，依次是 dragon\n、ninja、iceman、lion、wolf 的初始生命值。它们都大于0小于等于10000。</p>\n<h4 id=\"输出\">输出</h4>\n<p>对每组测试数据，要求输出从0时0分开始，到双方司令部都停止制造武士为止的所有事件。对每组测试数据，首先输出\"Case:n\"\nn是测试数据的编号，从1开始\n。接下来按恰当的顺序和格式输出所有事件。每个事件都以事件发生的时间开头，时间以小时为单位，有三位。</p>\n<h4 id=\"样例输入\">样例输入</h4>\n<blockquote>\n<p>1</p>\n<p>20</p>\n<p>3 4 5 6 7</p>\n</blockquote>\n<h4 id=\"样例输出\">样例输出</h4>\n<blockquote>\n<p>Case:1 000 red iceman 1 born with strength 5,1 iceman in red\nheadquarter 000 blue lion 1 born with strength 6,1 lion in blue\nheadquarter 001 red lion 2 born with strength 6,1 lion in red\nheadquarter 001 blue dragon 2 born with strength 3,1 dragon in blue\nheadquarter 002 red wolf 3 born with strength 7,1 wolf in red\nheadquarter 002 blue ninja 3 born with strength 4,1 ninja in blue\nheadquarter 003 red headquarter stops making warriors 003 blue iceman 4\nborn with strength 5,1 iceman in blue headquarter 004 blue headquarter\nstops making warriors</p>\n</blockquote>\n<h3 id=\"思路\">思路:</h3>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> WARRIOR_NUM = <span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Headquarter</span>;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Warrior</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    Headquarter * pHeadquarter;</span><br><span class=\"line\">    <span class=\"type\">int</span> kindNo;<span class=\"comment\">//武士种类编号 d,n,i,l,w</span></span><br><span class=\"line\">    <span class=\"type\">int</span> no;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">static</span> string names[WARRIOR_NUM];<span class=\"comment\">//武士名</span></span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">int</span> initialLifeValue[WARRIOR_NUM];<span class=\"comment\">//武士生命值</span></span><br><span class=\"line\">    <span class=\"built_in\">Warrior</span>(Headquarter *p, <span class=\"type\">int</span> no_, <span class=\"type\">int</span> kindNo_);<span class=\"comment\">//初始化</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">PrintResult</span><span class=\"params\">(<span class=\"type\">int</span> nTime)</span></span>;<span class=\"comment\">//输出结果</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Headquarter</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> totalLifeValue;<span class=\"comment\">//总的生命值</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> stopped;</span><br><span class=\"line\">    <span class=\"type\">int</span> totalWarriorNum;<span class=\"comment\">//总的武士数目</span></span><br><span class=\"line\">    <span class=\"type\">int</span> color;<span class=\"comment\">//红还是蓝</span></span><br><span class=\"line\">    <span class=\"type\">int</span> curMakingSeqIdx;<span class=\"comment\">//当前要制造的武士是制造序列中的第几个</span></span><br><span class=\"line\">    <span class=\"type\">int</span> warriorNum[WARRIOR_NUM];</span><br><span class=\"line\">    Warrior *pWarrior[<span class=\"number\">1000</span>];</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">friend</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Warrior</span>;</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">int</span> makingSeq[<span class=\"number\">2</span>][WARRIOR_NUM];<span class=\"comment\">//武士的制造序列,0为红，1为蓝</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Init</span><span class=\"params\">(<span class=\"type\">int</span> color_,<span class=\"type\">int</span> Lv)</span></span>;<span class=\"comment\">//初始化</span></span><br><span class=\"line\">    ~<span class=\"built_in\">Headquarter</span>();<span class=\"comment\">//析构</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Produce</span><span class=\"params\">(<span class=\"type\">int</span> nTime)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">GetColor</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Warrior::<span class=\"built_in\">Warrior</span>(Headquarter *p, <span class=\"type\">int</span> no_, <span class=\"type\">int</span> kindNo_)<span class=\"comment\">//构造函数</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    no = no_;</span><br><span class=\"line\">    kindNo = kindNo_;</span><br><span class=\"line\">    pHeadquarter = p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Warrior::PrintResult</span><span class=\"params\">(<span class=\"type\">int</span> nTime)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    string color =  pHeadquarter-&gt;<span class=\"built_in\">GetColor</span>();</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%03d %s %s %d born with strength %d,%d %s in %s headquarter\\n&quot;</span>    ,</span><br><span class=\"line\">           nTime, color.<span class=\"built_in\">c_str</span>(), names[kindNo].<span class=\"built_in\">c_str</span>(), no, initialLifeValue[kindNo],</span><br><span class=\"line\">           pHeadquarter-&gt;warriorNum[kindNo],names[kindNo].<span class=\"built_in\">c_str</span>(),color.<span class=\"built_in\">c_str</span>());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Headquarter::Init</span><span class=\"params\">(<span class=\"type\">int</span> color_,<span class=\"type\">int</span> Lv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    color = color_;</span><br><span class=\"line\">    totalLifeValue = Lv;<span class=\"comment\">//初始化生命值</span></span><br><span class=\"line\">    totalWarriorNum = <span class=\"number\">0</span>;<span class=\"comment\">//刚开始时，武士数量为0</span></span><br><span class=\"line\">    stopped = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    curMakingSeqIdx = <span class=\"number\">0</span>;<span class=\"comment\">//还没开始制造</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;WARRIOR_NUM;i++)</span><br><span class=\"line\">        warriorNum[i]=<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Headquarter::~<span class=\"built_in\">Headquarter</span>()<span class=\"comment\">//析构</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;totalWarriorNum;i++)</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> pWarrior[i];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Headquarter::Produce</span><span class=\"params\">(<span class=\"type\">int</span> nTime)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(stopped) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> searchingTimes = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(Warrior::initialLifeValue[makingSeq[color][curMakingSeqIdx]] &gt; totalLifeValue</span><br><span class=\"line\">          &amp;&amp; searchingTimes &lt; WARRIOR_NUM) &#123;</span><br><span class=\"line\">        curMakingSeqIdx = (curMakingSeqIdx+<span class=\"number\">1</span>) % WARRIOR_NUM;<span class=\"comment\">//制造武士的序列，5个以后，返回到最开始</span></span><br><span class=\"line\">        searchingTimes++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> kindNo = makingSeq[color][curMakingSeqIdx];<span class=\"comment\">//武士制造序列</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Warrior::initialLifeValue[kindNo] &gt; totalLifeValue) &#123;<span class=\"comment\">//生命元不够制造武士</span></span><br><span class=\"line\">        stopped = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (color == <span class=\"number\">0</span>) <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%03d red headquarter stops making warriors\\n&quot;</span>,nTime);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%03d blue headquarter stops making warriors\\n&quot;</span>,nTime);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//制造士兵</span></span><br><span class=\"line\">    totalLifeValue -= Warrior::initialLifeValue[kindNo];<span class=\"comment\">//每制造一个武士，就减去制造该武士的生命元</span></span><br><span class=\"line\">    curMakingSeqIdx = (curMakingSeqIdx+<span class=\"number\">1</span>) % WARRIOR_NUM;</span><br><span class=\"line\">    pWarrior[totalWarriorNum] = <span class=\"keyword\">new</span> <span class=\"built_in\">Warrior</span>(<span class=\"keyword\">this</span>,totalWarriorNum+<span class=\"number\">1</span>,kindNo);<span class=\"comment\">//构造下一个武士</span></span><br><span class=\"line\">    warriorNum[kindNo]++;<span class=\"comment\">//该武士的数目加1</span></span><br><span class=\"line\">    pWarrior[totalWarriorNum]-&gt;<span class=\"built_in\">PrintResult</span>(nTime);<span class=\"comment\">//输出该次制造武士的结果</span></span><br><span class=\"line\">    totalWarriorNum++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">string <span class=\"title\">Headquarter::GetColor</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (color==<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;red&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"string\">&quot;blue&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">string Warrior::names[WARRIOR_NUM] = &#123;<span class=\"string\">&quot;dragon&quot;</span>,<span class=\"string\">&quot;ninja&quot;</span>,<span class=\"string\">&quot;iceman&quot;</span>,<span class=\"string\">&quot;lion&quot;</span>,<span class=\"string\">&quot;wolf&quot;</span>&#125;;<span class=\"comment\">//初始顺序</span></span><br><span class=\"line\"><span class=\"type\">int</span> Warrior::initialLifeValue[WARRIOR_NUM];</span><br><span class=\"line\"><span class=\"type\">int</span> Headquarter::makingSeq[<span class=\"number\">2</span>][WARRIOR_NUM] = &#123;&#123;<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">3</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>&#125;&#125;;<span class=\"comment\">//红蓝制作武士的顺序</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> t,m;</span><br><span class=\"line\">    Headquarter RedHead,BlueHead;</span><br><span class=\"line\">    cin &gt;&gt; t;</span><br><span class=\"line\">    <span class=\"type\">int</span> nCaseNo=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">        cout&lt;&lt;<span class=\"string\">&quot;Case:&quot;</span>&lt;&lt;nCaseNo++&lt;&lt;endl;</span><br><span class=\"line\">        cin &gt;&gt; m;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;WARRIOR_NUM;i++)</span><br><span class=\"line\">            cin&gt;&gt;Warrior::initialLifeValue[i];<span class=\"comment\">//初始化生命值</span></span><br><span class=\"line\">        RedHead.<span class=\"built_in\">Init</span>(<span class=\"number\">0</span>,m);<span class=\"comment\">//0为红</span></span><br><span class=\"line\">        BlueHead.<span class=\"built_in\">Init</span>(<span class=\"number\">1</span>,m);</span><br><span class=\"line\">        <span class=\"type\">int</span> nTime=<span class=\"number\">0</span>;<span class=\"comment\">//时间</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> temp1 = RedHead.<span class=\"built_in\">Produce</span>(nTime);</span><br><span class=\"line\">            <span class=\"type\">int</span> temp2 = BlueHead.<span class=\"built_in\">Produce</span>(nTime);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(temp1 == <span class=\"number\">0</span> &amp;&amp; temp2 == <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            nTime++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["c++"]},{"title":"自动售票机","url":"/2019/04/24/%E8%87%AA%E5%8A%A8%E5%94%AE%E7%A5%A8%E6%9C%BA/","content":"<p>我们做一个类似地铁自动售票机的小程序</p>\n<span id=\"more\"></span>\n<p><img src=\"自动售票机/a.png\" /></p>\n<h4 id=\"main.cpp\">main.cpp</h4>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;TicketMachine.hpp&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    TicketMachine tm;</span><br><span class=\"line\">    tm.<span class=\"built_in\">insertMoney</span>(<span class=\"number\">100</span>);</span><br><span class=\"line\">    tm.<span class=\"built_in\">showBalance</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"ticketmachine.hpp\">TicketMachine.hpp</h4>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> TicketMachine_hpp<span class=\"comment\">//如果没有定义这个宏</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> TicketMachine_hpp<span class=\"comment\">//那就定义这个宏</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TicketMachine</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">TicketMachine</span>();</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">TicketMachine</span>();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">showPrompt</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insertMoney</span><span class=\"params\">(<span class=\"type\">int</span> money)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">showBalance</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">printTicket</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">showTotal</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> PRICE;</span><br><span class=\"line\">    <span class=\"type\">int</span> balance;</span><br><span class=\"line\">    <span class=\"type\">int</span> total;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">/* TicketMachine_hpp */</span></span></span><br></pre></td></tr></table></figure>\n<h4 id=\"ticketmachine.cpp\">TicketMachine.cpp</h4>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;TicketMachine.hpp&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//构造函数</span></span><br><span class=\"line\">TicketMachine::<span class=\"built_in\">TicketMachine</span>() : <span class=\"built_in\">PRICE</span>(<span class=\"number\">0</span>)&#123;<span class=\"comment\">//初始化</span></span><br><span class=\"line\">    <span class=\"comment\">//<span class=\"doctag\">TODO:</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">TicketMachine::~<span class=\"built_in\">TicketMachine</span>()&#123;<span class=\"comment\">//析构函数</span></span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TicketMachine::showPrompt</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;something&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TicketMachine::insertMoney</span><span class=\"params\">(<span class=\"type\">int</span> money)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    balance +=money;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">TicketMachine::showBalance</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cout&lt;&lt;balance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"resolver\"><strong>::resolver</strong></h3>\n<p>也就是 <strong>解析符</strong></p>\n<p><strong><Class Name>::<function name></strong>\n这表示这个函数不是自由的，而是羁绊于 Class Name这个类的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">S::f</span><span class=\"params\">()</span> </span>&#123;<span class=\"comment\">//代表f()这个函数属于s</span></span><br><span class=\"line\">    ::<span class=\"built_in\">f</span>();<span class=\"comment\">//递归调用自己</span></span><br><span class=\"line\">    ::a++;<span class=\"comment\">//代表全局变量</span></span><br><span class=\"line\">    a--;<span class=\"comment\">//代表这个函数里的变量</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"定义类definition-of-a-class\">定义类(Definition of a class)</h3>\n<ul>\n<li>在c++中，.h和.cpp文件被用来定义一个类</li>\n<li>类的定义和函数原型放在.h中(declarations)</li>\n<li>累的bodies放在.cpp中(definitions)</li>\n</ul>\n<h3 id=\"declarations-vs.definitions\">Declarations vs.Definitions</h3>\n<ul>\n<li>一个.cpp文件就是一个编译单元</li>\n<li>只有声明(declarations)被允许在.h文件中\n<ul>\n<li>exterm variables</li>\n<li>function prototypes(函数原型）</li>\n<li>class/struct declaration</li>\n</ul></li>\n</ul>\n","categories":["c++"]},{"title":"鸡蛋掉落","url":"/2022/03/20/%E9%B8%A1%E8%9B%8B%E6%8E%89%E8%90%BD/","content":"<h1 id=\"鸡蛋掉落\"><a\nhref=\"https://leetcode-cn.com/problems/super-egg-drop/\">887.\n鸡蛋掉落</a></h1>\n<p>给你<code>k</code>枚相同的鸡蛋，并可以使用一栋从第 1 层到第 n 层共有\nn 层楼的建筑。</p>\n<p>已知存在楼层 f ，满足<code>0 &lt;= f &lt;= n</code> ，任何从 高于 f\n的楼层落下的鸡蛋都会碎，从 f 楼层或比它低的楼层落下的鸡蛋都不会破。</p>\n<p>每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 x 扔下（满足 1\n&lt;= x &lt;=\nn）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中\n<strong>重复使用</strong> 这枚鸡蛋。</p>\n<p>请你计算并返回要确定<code>f</code>确切的值\n的<strong>最小操作次数</strong> 是多少？</p>\n<h2 id=\"示例\">示例：</h2>\n<blockquote>\n<p>输入：k = 1, n = 2 输出：2 解释： 鸡蛋从 1\n楼掉落。如果它碎了，肯定能得出 f = 0 。 否则，鸡蛋从 2\n楼掉落。如果它碎了，肯定能得出 f = 1 。 如果它没碎，那么肯定能得出 f = 2\n。 因此，在最坏的情况下我们需要移动 2 次以确定 f 是多少。</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"思路\">思路：</h2>\n<p>###题目分析：</p>\n<p>读完题目之后，也就是让我们找到<strong>摔不碎鸡蛋的最高楼层<code>f</code></strong></p>\n<p>假如我们<strong>现在不管鸡蛋个数的限制</strong>，有<code>7</code>层楼，怎么去找鸡蛋恰好摔碎的那层楼？</p>\n<p>最直接的就是<strong>线性扫描</strong>：先在<code>1</code>楼扔一下，没碎，再去<code>2</code>楼扔一下，没碎，再去<code>3</code>楼......</p>\n<p>根据这种策略，最坏情况应该就是找到第<code>7</code>层楼(<code>F = 7</code>)。</p>\n<p>既然是至少需要扔几次，那么我们能不能使用<strong>二分查找思想</strong></p>\n<ul>\n<li>先去<code>(1 + 7) / 2 = 4</code>楼扔一下，如果碎了，说明<code>f &lt; 4</code>，我就去第<code>(1 + 3) / 2 = 2</code>层</li>\n<li>如果没碎，说明<code>f &gt; 4</code>，我就去第<code>(5 + 7) / 2 = 6</code>层去试......</li>\n</ul>\n<p>这种情况下，最坏情况应该是试到第 7\n层鸡蛋还没碎(<code>f = 7</code>)，或者一直碎到第 1\n层(<code>f = 1</code>)。然而无论哪种最坏情况，只需要试<code>log7</code>，向上取整，也就是\n3 次，比之前尝试 7 次要少。</p>\n<p>实际上，如果不限制鸡蛋个数的话，二分思想显然可以得到最少尝试次数，但<strong>现在给了鸡蛋个数的限制<code>k</code>，直接使用二分思想就不可以了</strong>。</p>\n<blockquote>\n<p>ps: 后面会给出二分思路</p>\n</blockquote>\n<h3 id=\"思路分析\">思路分析：</h3>\n<p>对于动态规划问题，我们只需要明白框架：即这个问题有什么「状态」，有什么「选择」，然后穷举。</p>\n<p><strong>「状态」很明显，就是当前拥有的鸡蛋数<code>k</code>和需要测试的楼层数<code>n</code></strong>。</p>\n<p><strong>「选择」其实就是去选择哪层楼扔鸡蛋</strong>。</p>\n<p>那么<strong>动态规划的基本思想就形成了：</strong>肯定是个二维的<code>dp</code>数组或者带有两个状态的<code>dp</code>函数来表示状态转移；外加一个<code>for</code>循环来遍历所有选择，选择最优的选择更新状态：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//当前状态为 k 个鸡蛋，面对 n 层楼</span></span><br><span class=\"line\"><span class=\"comment\">//返回这个状态下的最优结果</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dp</span><span class=\"params\">(k, n)</span>:</span></span><br><span class=\"line\"><span class=\"function\">\tint res;</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"number\">1</span> &lt;= i &lt;= n)</span><br><span class=\"line\">\t\tres = <span class=\"built_in\">min</span>(res, 这次在第 i 层楼扔鸡蛋)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br></pre></td></tr></table></figure>\n<p>我们选择在第<code>i</code>层楼扔了鸡蛋之后，可能出现两种情况：鸡蛋碎了，鸡蛋没碎。<strong>这就是状态转移</strong>。</p>\n<p><strong>如果鸡蛋碎了</strong>，那么鸡蛋的个数<code>k</code>应该减一，搜索的楼层区间从<code>[1...n]</code>变为<code>[1...i - 1]</code>，共<code>i-1</code>层楼；</p>\n<p><strong>如果鸡蛋没碎</strong>，那么鸡蛋个数<code>k</code>不变，搜索的楼层区间应该从<code>[1...n]</code>变为<code>[i+1...n]</code>共<code>n-i</code>层楼；</p>\n<p><img src=\"鸡蛋掉落/1.jpg\" style=\"zoom:67%;\" /></p>\n<p>递归的<code>base case</code>也很容易理解：当楼层数<code>n ==0</code>时，显然不需要扔鸡蛋；当鸡蛋数<code>k</code>为\n1 时，显然只能线性扫描所有楼层：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">superEggDrop</span><span class=\"params\">(<span class=\"type\">int</span> k, <span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">dp</span>(k, n);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dp</span><span class=\"params\">(<span class=\"type\">int</span> k, <span class=\"type\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//base case</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n == <span class=\"number\">0</span> || n == <span class=\"number\">1</span> || k == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> n;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> res = n;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//最坏情况下的最少扔鸡蛋个数 碎了  没碎</span></span><br><span class=\"line\">            res = <span class=\"built_in\">min</span>(res, <span class=\"built_in\">max</span>(<span class=\"built_in\">dp</span>(k, n - i), <span class=\"built_in\">dp</span>(k - <span class=\"number\">1</span>, i - <span class=\"number\">1</span>)) + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>很明显存在重复子问题，使用备忘录优化：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; memo;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">superEggDrop</span><span class=\"params\">(<span class=\"type\">int</span> k, <span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        memo.<span class=\"built_in\">resize</span>(k + <span class=\"number\">1</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(n + <span class=\"number\">1</span>, <span class=\"number\">-1</span>));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">dp</span>(k, n);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dp</span><span class=\"params\">(<span class=\"type\">int</span> k, <span class=\"type\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// base case</span></span><br><span class=\"line\">        <span class=\"comment\">//如果只剩一个鸡蛋，线性遍历</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(k == <span class=\"number\">1</span> || n == <span class=\"number\">0</span> || n == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> n;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//避免重复计算</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(memo[k][n] != <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> memo[k][n];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> res = n;</span><br><span class=\"line\">        <span class=\"comment\">//穷举所有可能的选择</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//最坏情况下的最少扔鸡蛋个数</span></span><br><span class=\"line\">            res = <span class=\"built_in\">min</span>(res, <span class=\"built_in\">max</span>(<span class=\"built_in\">dp</span>(k, n - i), <span class=\"built_in\">dp</span>(k - <span class=\"number\">1</span>, i - <span class=\"number\">1</span>)) + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//记入备忘录</span></span><br><span class=\"line\">        memo[k][n] = res;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>动态规划算法时间复杂度就是子问题个数 X\n函数本身的复杂度。</strong></p>\n<p><code>for</code>循环复杂度为<code>O(N)</code>,子问题个数就是不同状态组合的总数，显然是两个状态的乘积，也就是<code>O(KN)</code>。</p>\n<p>所以总的时间复杂度为<code>O(KN^2)</code>，空间复杂度为<code>O(KN)</code>。</p>\n<h4 id=\"二分搜索优化\">二分搜索优化</h4>\n<p>我们先回忆下前面算法的思路：</p>\n<p>1、暴力穷举尝试在所有楼层 1 &lt;= i &lt;= N\n扔鸡蛋，每次选择尝试次数最少的那一层；</p>\n<p>2、每次扔鸡蛋有两种可能，要么碎，要么没碎；</p>\n<p>3、如果鸡蛋碎了，F 应该在第 i 层下面，否则，F 应该在第 i 层上面；</p>\n<p>4、鸡蛋是碎了还是没碎，取决于哪种情况下尝试次数更多，因为我们想求的是最坏情况下的结果。</p>\n<p><strong>状态转移方程为：</strong></p>\n<p>​ <span class=\"math inline\">\\(dp(k,n) = min(max(dp(k - 1, i - 1),\ndp(k, n - i)) + 1)\\)</span></p>\n<p>我们二分查找优化的思路思路就是根据这个状态转移方程来的，所以需要我们理解这个状态转移。</p>\n<p>首先我们根据<code>dp(k,n)</code>数组的定义：<strong>有 k 个鸡蛋面对 n\n层楼，最少需要扔几次</strong>，很容易知道 k 固定时，这个函数会随着 n\n的增加一定是单增的。因为随着楼层的增加，测试次数也一定会增加。</p>\n<p>那么注意<code>dp(k-1, i-1)</code>和<code>dp(k, n-i)</code>这两个函数，其中\ni 是从 1 到 N 单增的，如果我们固定 K 和 N，把这两个函数看做关于 i\n的函数，前者随着 i 的增加应该也是单调递增的，而后者随着 i\n的增加应该是单调递减的：</p>\n<p><img src=\"鸡蛋掉落/2.jpg\" style=\"zoom:67%;\" /></p>\n<p>这时候求二者的较大值，再求这些最大值之中的最小值，其实就是求这两条直线交点，也就是红色折线的最低点嘛。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; memo;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">superEggDrop</span><span class=\"params\">(<span class=\"type\">int</span> k, <span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        memo.<span class=\"built_in\">resize</span>(k + <span class=\"number\">1</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(n + <span class=\"number\">1</span>, <span class=\"number\">-1</span>));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">dp</span>(k, n);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dp</span><span class=\"params\">(<span class=\"type\">int</span> k, <span class=\"type\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//base case</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(k == <span class=\"number\">1</span> || n == <span class=\"number\">0</span> || n == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> n;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//避免重复计算</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(memo[k][n] != <span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> memo[k][n];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> res = n * n;</span><br><span class=\"line\">        <span class=\"comment\">//用二分搜索替代线性搜索</span></span><br><span class=\"line\">        <span class=\"type\">int</span> lo = <span class=\"number\">1</span>, hi = n;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(lo &lt;= hi)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> mid = (lo + hi) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"comment\">//碎了</span></span><br><span class=\"line\">            <span class=\"type\">int</span> broken = <span class=\"built_in\">dp</span>(k - <span class=\"number\">1</span>, mid - <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"comment\">//没碎</span></span><br><span class=\"line\">            <span class=\"type\">int</span> no_broken = <span class=\"built_in\">dp</span>(k, n - mid);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//res = min(max(碎，没碎) + 1)</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(broken &gt; no_broken)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//碎了</span></span><br><span class=\"line\">                hi = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">                res = <span class=\"built_in\">min</span>(res, broken + <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">//没碎</span></span><br><span class=\"line\">                lo = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">                res = <span class=\"built_in\">min</span>(res, no_broken + <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        memo[k][n] = res;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>因为用了二分搜索，所以复杂度为<code>O(logn)</code>，子问题个数为<code>O(kn)</code></p>\n<p>所以总的时间复杂度为<code>O(knlogn)</code>。</p>\n<p>####重新定义状态转移</p>\n<p><code>dp[k][m] = n</code> <em>表示当前有 k 个鸡蛋， 可以尝试扔 m\n次鸡蛋，在这个状态下，最坏情况下最多能确定一栋 n 层的</em></p>\n<p><strong>1、无论你在哪层楼扔鸡蛋，鸡蛋只可能摔碎或者没摔碎，碎了的话就测楼下，没碎的话就测楼上。</strong></p>\n<p><strong>2、无论你上楼还是下楼，总的楼层数 = 楼上的楼层数 +\n楼下的楼层数 + 1（当前这层楼）。</strong></p>\n<p><strong>转移方程：</strong></p>\n<p><code>dp[k][m] = dp[k][m-1] + dp[k - 1][m - 1] + 1;</code></p>\n<p>时间复杂度为O(kn)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">superEggDrop</span><span class=\"params\">(<span class=\"type\">int</span> k, <span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; <span class=\"built_in\">dp</span>(k + <span class=\"number\">1</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(n + <span class=\"number\">1</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> m = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(dp[k][m] &lt; n)&#123;</span><br><span class=\"line\">            m++;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= k; i++)&#123;</span><br><span class=\"line\">                dp[i][m] = dp[i][m - <span class=\"number\">1</span>] + dp[i - <span class=\"number\">1</span>][m - <span class=\"number\">1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["动态规划","leetcode"],"tags":["动态规划"]}]