<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css" integrity="sha256-xejo6yLi6vGtAjcMIsY8BHdKsLg7QynVlFMzdQgUuy8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"sjchen404.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.12.3","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="[[toc]]  进程与线程 进程与线程的比较          进程 线程     映像组成 由程序段，相关数据段和PCB组成 共享其隶属进程的进程映像，仅拥有线程ID，寄存器集合和堆栈等   并发性 在没有引入线程的操作系统中，进程是独立运行的基本单位 线程是独立运行的基本单位,一个进程可以拥有一个或多个线程   资源分配 进程是资源分配和拥有的基本单位 线程自己不拥有系统资源，但它可以访问所">
<meta property="og:type" content="article">
<meta property="og:title" content="第二章_进程与线程">
<meta property="og:url" content="https://sjchen404.github.io/2022/08/16/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="SJCHEN">
<meta property="og:description" content="[[toc]]  进程与线程 进程与线程的比较          进程 线程     映像组成 由程序段，相关数据段和PCB组成 共享其隶属进程的进程映像，仅拥有线程ID，寄存器集合和堆栈等   并发性 在没有引入线程的操作系统中，进程是独立运行的基本单位 线程是独立运行的基本单位,一个进程可以拥有一个或多个线程   资源分配 进程是资源分配和拥有的基本单位 线程自己不拥有系统资源，但它可以访问所">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-08-16T03:22:20.289Z">
<meta property="article:modified_time" content="2022-08-16T03:22:20.289Z">
<meta property="article:author" content="SJCHEN">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://sjchen404.github.io/2022/08/16/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://sjchen404.github.io/2022/08/16/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/","path":"2022/08/16/第二章_进程与线程/","title":"第二章_进程与线程"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>第二章_进程与线程 | SJCHEN</title>
  




<link rel="dns-prefetch" href="waline-blog-ij33-fskc7zdtq-1261476297-qqcom.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">SJCHEN</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">时光，不会辜负每一个平静努力的人</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-schedule"><a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">进程与线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#pcb"><span class="nav-number">1.1.</span> <span class="nav-text">PCB</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">1.2.</span> <span class="nav-text">进程的状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E6%A0%B8%E6%94%AF%E6%8C%81%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.3.</span> <span class="nav-text">用户级线程和内核支持线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-number">1.4.</span> <span class="nav-text">进程控制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6"><span class="nav-number">2.</span> <span class="nav-text">处理机调度</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%9A%84%E5%B1%82%E6%AC%A1"><span class="nav-number">2.1.</span> <span class="nav-text">调度的层次</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%9A%84%E5%8E%9F%E5%88%99"><span class="nav-number">2.2.</span> <span class="nav-text">调度的原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E8%83%BD%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">2.3.</span> <span class="nav-text">不能进行处理机调度的情况</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">2.4.</span> <span class="nav-text">常用的调度算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5"><span class="nav-number">3.</span> <span class="nav-text">同步与互斥</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">3.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%B4%E7%95%8C%E5%8C%BA%E4%BA%92%E6%96%A5%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.</span> <span class="nav-text">实现临界区互斥的基本方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.2.1.</span> <span class="nav-text">软件实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E6%A0%87%E8%AE%B0%E6%B3%95"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">单标记法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E6%A0%87%E8%AE%B0%E6%B3%95%E5%85%88%E6%A3%80%E6%9F%A5"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">双标记法先检查</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E6%A0%87%E8%AE%B0%E6%B3%95%E5%90%8E%E6%A3%80%E6%9F%A5"><span class="nav-number">3.2.1.3.</span> <span class="nav-text">双标记法后检查</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9A%AE%E7%89%B9%E6%A3%AE%E7%AE%97%E6%B3%95peterson"><span class="nav-number">3.2.1.4.</span> <span class="nav-text">皮特森算法（Peterson）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.2.</span> <span class="nav-text">硬件实现方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%B1%8F%E8%94%BD%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">（1）中断屏蔽方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E6%8C%87%E4%BB%A4%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">（2）硬件指令方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-number">3.3.</span> <span class="nav-text">互斥锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">3.4.</span> <span class="nav-text">信号量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">3.4.1.</span> <span class="nav-text">整型信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">3.4.2.</span> <span class="nav-text">记录型信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5"><span class="nav-number">3.4.3.</span> <span class="nav-text">利用信号量实现同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="nav-number">3.4.4.</span> <span class="nav-text">利用信号量实现进程互斥</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E5%89%8D%E9%A9%B1%E5%85%B3%E7%B3%BB"><span class="nav-number">3.4.5.</span> <span class="nav-text">利用信号量实现前驱关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%A1%E7%A8%8B"><span class="nav-number">3.5.</span> <span class="nav-text">管程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">3.5.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-number">3.5.2.</span> <span class="nav-text">条件变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98%E9%87%8D%E7%82%B9"><span class="nav-number">3.6.</span> <span class="nav-text">经典同步问题（重点！！！）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-number">3.6.1.</span> <span class="nav-text">1. 生产者-消费者问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-number">3.6.2.</span> <span class="nav-text">2. 读者-写者问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98"><span class="nav-number">3.6.3.</span> <span class="nav-text">3. 哲学家进餐问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%B8%E7%83%9F%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-number">3.6.4.</span> <span class="nav-text">4. 吸烟者问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">4.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="nav-number">4.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">4.2.</span> <span class="nav-text">死锁产生的原因</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E5%87%BA%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="nav-number">4.3.</span> <span class="nav-text">死锁产出的必要条件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"><span class="nav-number">4.4.</span> <span class="nav-text">死锁的处理策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2"><span class="nav-number">4.4.1.</span> <span class="nav-text">死锁预防</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="nav-number">4.4.2.</span> <span class="nav-text">避免死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E5%92%8C%E8%A7%A3%E9%99%A4"><span class="nav-number">4.4.3.</span> <span class="nav-text">死锁检测和解除</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE"><span class="nav-number">4.4.3.1.</span> <span class="nav-text">资源分配图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E5%AE%9A%E7%90%86"><span class="nav-number">4.4.3.2.</span> <span class="nav-text">死锁定理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E8%A7%A3%E9%99%A4"><span class="nav-number">4.4.3.3.</span> <span class="nav-text">死锁解除</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="SJCHEN"
      src="/images/new%E5%A4%B4%E5%83%8F.jpg">
  <p class="site-author-name" itemprop="name">SJCHEN</p>
  <div class="site-description" itemprop="description">start from zero</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">150</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">63</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">76</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/SJCHEN404" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;SJCHEN404" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:chenshengjiao1912@163.com" title="E-Mail → mailto:chenshengjiao1912@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/5702603638" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;5702603638" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



  <div class="links-of-recent-posts motion-element">
    <div class="links-of-recent-posts-title">
      <i class="fa fa-history fa-fw"></i>
      最近文章
    </div>
    <ul class="links-of-recent-posts-list">
        <li class="links-of-recent-posts-item">
          <a href="/2022/08/17/%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/" title="2022&#x2F;08&#x2F;17&#x2F;继承与多态&#x2F;">继承与多态</a>
        </li>
        <li class="links-of-recent-posts-item">
          <a href="/2022/08/17/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/" title="2022&#x2F;08&#x2F;17&#x2F;回溯算法&#x2F;">回溯算法</a>
        </li>
        <li class="links-of-recent-posts-item">
          <a href="/2022/08/17/%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/" title="2022&#x2F;08&#x2F;17&#x2F;柱状图中最大的矩形&#x2F;">柱状图中最大的矩形</a>
        </li>
        <li class="links-of-recent-posts-item">
          <a href="/2022/08/17/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91_%E5%90%8E%E7%BB%A7%E8%80%85/" title="2022&#x2F;08&#x2F;17&#x2F;二叉搜索树_后继者&#x2F;">二叉搜索树__后继者</a>
        </li>
        <li class="links-of-recent-posts-item">
          <a href="/2022/08/17/CSAPP%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%AE%B6%E5%BA%AD%E4%BD%9C%E4%B8%9A/" title="2022&#x2F;08&#x2F;17&#x2F;CSAPP第二章家庭作业&#x2F;">CSAPP第二章家庭作业</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sjchen404.github.io/2022/08/16/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/new%E5%A4%B4%E5%83%8F.jpg">
      <meta itemprop="name" content="SJCHEN">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SJCHEN">
      <meta itemprop="description" content="start from zero">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="第二章_进程与线程 | SJCHEN">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          第二章_进程与线程
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-16 11:22:20" itemprop="dateCreated datePublished" datetime="2022-08-16T11:22:20+08:00">2022-08-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2022/08/16/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2022/08/16/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>13k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>[[toc]]</p>
<p><img
src="https://sjchen404.oss-cn-shenzhen.aliyuncs.com/img/第二章_进程与线程.png" /></p>
<h1 id="进程与线程">进程与线程</h1>
<p><strong>进程与线程的比较</strong></p>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 41%" />
<col style="width: 51%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>进程</th>
<th>线程</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>映像组成</td>
<td>由程序段，相关数据段和<code>PCB</code>组成</td>
<td>共享其隶属进程的进程映像，仅拥有线程ID，寄存器集合和堆栈等</td>
</tr>
<tr class="even">
<td>并发性</td>
<td>在没有引入线程的操作系统中，进程是独立运行的基本单位</td>
<td><strong>线程是独立运行的基本单位</strong>,一个进程可以拥有一个或多个线程</td>
</tr>
<tr class="odd">
<td>资源分配</td>
<td>进程是资源分配和拥有的基本单位</td>
<td>线程自己不拥有系统资源，但它可以访问所属进程所拥有的全部资源</td>
</tr>
<tr class="even">
<td><strong>调度</strong></td>
<td>在没有引入线程的操作系统中，进程是独立调度和分配的基本单位</td>
<td>在引入线程后的操作系统，线程是独立调度和分配的基本单位</td>
</tr>
<tr class="odd">
<td>通信</td>
<td>PV操作；共享存储；消息传递；管道通信</td>
<td>同一进程的各线程直接读写进程数据段，不同进程的线程之间通信属于进程剑通信</td>
</tr>
<tr class="even">
<td>目的</td>
<td>更好的使多道程序并发执行，提高资源利用率和系统吞吐量</td>
<td>减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能</td>
</tr>
<tr class="odd">
<td>地址空间</td>
<td>进程的地址空间之间相互独立</td>
<td>同一进程的各线程间共享进程的地址空间</td>
</tr>
</tbody>
</table>
<p><strong>进程映像是静态的，进程是动态的</strong></p>
<span id="more"></span>
<h2 id="pcb">PCB</h2>
<p><code>PCB</code>是进程存在的唯一标记！！！</p>
<p>组成：</p>
<ul>
<li>进程描述信息</li>
<li>进程控制和管理信息</li>
<li>资源分配清单</li>
<li>处理机相关信息</li>
</ul>
<table>
<colgroup>
<col style="width: 27%" />
<col style="width: 28%" />
<col style="width: 20%" />
<col style="width: 23%" />
</colgroup>
<thead>
<tr class="header">
<th>进程描述信息</th>
<th>进程控制和管理信息</th>
<th>资源分配清单</th>
<th>处理机相关信息</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>进程标识符（PID）</td>
<td>进程当前状态</td>
<td>代码段指针</td>
<td>通用寄存器值</td>
</tr>
<tr class="even">
<td>用户标识符（UID）</td>
<td>进程优先级</td>
<td>数据段指针</td>
<td>地址寄存器值</td>
</tr>
<tr class="odd">
<td></td>
<td>代码运行入口地址</td>
<td>堆栈段指针</td>
<td>控制寄存器值</td>
</tr>
<tr class="even">
<td></td>
<td>程序的外存地址</td>
<td>文件描述符</td>
<td>标记寄存器值</td>
</tr>
<tr class="odd">
<td></td>
<td>进入内存时间</td>
<td>键盘</td>
<td>状态字</td>
</tr>
<tr class="even">
<td></td>
<td>处理机占用时间</td>
<td>鼠标</td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td>信号量的使用</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="进程的状态">进程的状态</h2>
<p><img
src="https://sjchen404.oss-cn-shenzhen.aliyuncs.com/img/进程状态.png" /></p>
<p><strong>从运行态变成阻塞态是主动的</strong></p>
<h2 id="用户级线程和内核支持线程">用户级线程和内核支持线程</h2>
<table>
<colgroup>
<col style="width: 4%" />
<col style="width: 39%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="header">
<th>线程</th>
<th>用户级线程</th>
<th>内核级线程</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>优点</td>
<td>线程切换不需要转换到内核空间，节省了开销</td>
<td>一个线程被阻塞，内核可以调度该进程中的其他线程；能发挥多处理器优势</td>
</tr>
<tr class="even">
<td>缺点</td>
<td>一个线程被阻塞，则同一进程内所有线程都会被阻塞</td>
<td>同一进程中，线程切换时，需要从用户态转到内核态，系统开销大</td>
</tr>
</tbody>
</table>
<p>多线程模型：</p>
<ul>
<li>多对一 &gt; 一个线程阻塞，则整个进程阻塞</li>
<li>一对一</li>
<li>多对多</li>
</ul>
<h2 id="进程控制">进程控制</h2>
<p><strong>进程创建</strong></p>
<p><img
src="https://sjchen404.oss-cn-shenzhen.aliyuncs.com/img/进程创建.png" /></p>
<p>在同一个进程中，线程切换不会引起进程的切换。</p>
<p>当从一个进程中的线程切换到另一个进程中的线程时，才会引起进程的切换。</p>
<h1 id="处理机调度">处理机调度</h1>
<p>在多道程序系统中，进程的数量往往多于处理机个数，因此进程争用处理机的情况在所难免。</p>
<p>处理机调度是对处理机进行分配，即从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程并发地执行。</p>
<h2 id="调度的层次">调度的层次</h2>
<ul>
<li>高级调度（作业调度）</li>
<li>中级调度（内存调度）</li>
<li>低级调度（进程调度）</li>
</ul>
<p><img
src="https://sjchen404.oss-cn-shenzhen.aliyuncs.com/img/调度层次.png" /></p>
<p>多道批处理器系统中大多配有作业调度，而其他系统中通常不需要配置作业调度。</p>
<p><em>引入中级调度的目的是提高内存利用率和系统吞吐量。</em></p>
<p>进程调度是最基本的，不可或缺。</p>
<h2 id="调度的原则">调度的原则</h2>
<p><code>CPU</code>利用率：</p>
<blockquote>
<p>CPU的工作在整个系统工作时间所占的比例。</p>
</blockquote>
<p><span class="math display">\[
CPU利用率 = \frac{CPU有效工作时间}{CPU有效工作时间 + CPU空闲等待时间}
\]</span></p>
<p>系统吞吐量： 表示单位时间内CPU完成作业的数量。</p>
<p>周转时间：</p>
<p><span class="math display">\[
周转时间 = 作业完成时间 - 作业提交时间
\]</span></p>
<p>平均周转时间：</p>
<p><span class="math display">\[
平均周转时间 = \frac{作业1的周转时间 + ... + 作业n的周转时间}{n}
\]</span></p>
<p>带权周转时间：</p>
<p><span class="math display">\[
带权周转时间 = \frac{作业周转时间}{作业实际运行时间}
\]</span></p>
<p>等待时间：</p>
<p>进程处于等待处理器状态的时间之和。</p>
<p>响应时间：</p>
<p>从用户提交请求到系统首次产生响应所用的时间。</p>
<h2 id="不能进行处理机调度的情况">不能进行处理机调度的情况</h2>
<ul>
<li>在处理中断的过程中</li>
<li>进程在操作系统内核临界区中</li>
<li>其他需要完全屏蔽中断的原子操作过程中</li>
</ul>
<h2 id="常用的调度算法">常用的调度算法</h2>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 20%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr class="header">
<th>算法</th>
<th>调度方法</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>先来先服务FCFS</td>
<td>每次选择最先进入的作业或进程</td>
<td>有利于长作业不利于短作业<br>有利于CPU繁忙型型作业不利于I/O繁忙型作业</td>
</tr>
<tr class="even">
<td>短作业优先SJF</td>
<td>选择运行时间最短的</td>
<td><em>平均等待时间，平均周转时间最少</em></td>
</tr>
<tr class="odd">
<td>时间片轮转</td>
<td>所有进程按先来先服务排队</td>
<td>主要适用于<strong>分时系统</strong></td>
</tr>
<tr class="even">
<td>优先级调度</td>
<td>选择优先级最高的</td>
<td>系统进程&gt; 用户进程<br>交互性进程&gt;
非交互性进程<br>I/O型进程&gt;计算型进程</td>
</tr>
<tr class="odd">
<td>高响应比优先</td>
<td>选择响应比最高的</td>
<td>有利于短作业，长作业不会产出“饥饿”，等待时间越长，优先级越高</td>
</tr>
<tr class="even">
<td>多级反馈队列</td>
<td>...</td>
<td>终端型作业：短作业优先<br>短批处理作业用户：周转时间较短<br>长批处理作业用户：不会长期得不到处理</td>
</tr>
</tbody>
</table>
<p>响应比：</p>
<p><span class="math display">\[
响应比R_p = \frac{等待时间 + 要求服务时间}{要求服务时间}
\]</span></p>
<h1 id="同步与互斥">同步与互斥</h1>
<h2 id="基本概念">基本概念</h2>
<p>我们将一次仅允许一个进程使用的资源称为<em>临界资源</em></p>
<p>临界区：进程中访问临界资源的那段代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    entry section;      <span class="comment">//进入区</span></span><br><span class="line">    critical section;   <span class="comment">//临界区</span></span><br><span class="line">    exit section;       <span class="comment">//退出区</span></span><br><span class="line">    remainder section;  <span class="comment">//剩余区</span></span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<p><strong>同步：</strong>
进程需要协调它们的工作次序而等待，传递信息所产生的制约关系。</p>
<p><strong>互斥：</strong>
当一个进程进入临界区使用临界资源时，另一个进程必须等待，当占用临界资源的进程退出临界区后，另一进程才允许去访问此临界资源</p>
<p>同步需要遵循的准则： - 空闲让进 --
临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。 -
忙则等待 -- 当已有进程进入临界区时，其他试图进入临界区的进程必须等待。 -
有限等待 -- 对已有进程进入临界区，应保证能在有限时间内进入临界区。 -
让权等待 --
当进程不能进入临界区时，应立即释放处理器，防止进程忙等待。</p>
<h2 id="实现临界区互斥的基本方法">实现临界区互斥的基本方法</h2>
<h3 id="软件实现">软件实现</h3>
<ul>
<li>单标记法</li>
<li>双标记法先检查</li>
<li>双标记法后检查</li>
<li>皮特森算法（Peterson）</li>
</ul>
<h4 id="单标记法">单标记法</h4>
<p>设置一个公用模型变量<code>turn</code>,用于指示被允许进入临界区的进程编号，即若<code>turn = 0</code>,则允许<span
class="math inline">\(p_0\)</span>进程进入临界区。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p0进程</span></span><br><span class="line"><span class="keyword">while</span>(turn != <span class="number">0</span>);   <span class="comment">//进入区</span></span><br><span class="line">critical section;   <span class="comment">//临界区</span></span><br><span class="line">turn = <span class="number">1</span>;           <span class="comment">//退出区</span></span><br><span class="line">remainder section;  <span class="comment">//剩余区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//p1进程;</span></span><br><span class="line"><span class="keyword">while</span>(turn != <span class="number">1</span>);</span><br><span class="line">critical section;</span><br><span class="line">turn = <span class="number">0</span>;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure>
<p>该算法保证每次只允许一个进程进入临界区，但两个进程必须交替进入临界区，若某个进程不再进入临界区，则另一个进程也将无法进入临界区。
违背了<em>空闲让进</em>，容易造成资源利用不充分。</p>
<h4 id="双标记法先检查">双标记法先检查</h4>
<p>思想：</p>
<p>在每个进程访问临界区资源之前，先检查临界资源是否正在被访问，若正在被访问，该进程等待；否则，进程才进入自己的临界区。</p>
<p>设置一个数组<code>flag[2]</code>,表示进程是否进入临界区。<code>flag[i]</code>值为<code>FALSE</code>,表示<span
class="math inline">\(P_i\)</span>进程未进入临界区，值为<code>TRUE</code>,表示<span
class="math inline">\(P_i\)</span>进程进入临界区。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//P_i进程</span></span><br><span class="line"><span class="keyword">while</span>(flag[j]);     <span class="comment">// 1 进入区</span></span><br><span class="line">flag[i] = TRUE;     <span class="comment">// 3 进入区</span></span><br><span class="line">critical section;   <span class="comment">// 临界区</span></span><br><span class="line">flag[i] = FALSE;    <span class="comment">//退出区</span></span><br><span class="line">remainder section;  <span class="comment">//剩余区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// P_j进程</span></span><br><span class="line"><span class="keyword">while</span>(flag[i]);     <span class="comment">// 2</span></span><br><span class="line">flag[j] = TRUE;     <span class="comment">// 4</span></span><br><span class="line">critical section;</span><br><span class="line">flag[j] = FALSE;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure>
<p>优点：不用交替进入，可连续使用；</p>
<p>缺点：<span class="math inline">\(P_i\)</span>和<span
class="math inline">\(P_j\)</span>可能同时进入临界区；</p>
<p>按系列1，2，3，4执行，会同时进入临界区（违背了<em>忙则等待</em>）。</p>
<h4 id="双标记法后检查">双标记法后检查</h4>
<p>和双标记法先检查相比，先将自己的标记设置为<code>TRUE</code>,再检测对方的状态标记，若对方标记为<code>TRUE</code>,则进程等待；否则进入临界区。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//P_i进程</span></span><br><span class="line">flag[i] = TRUE;     <span class="comment">// 先设置自己的标记，进入区</span></span><br><span class="line"><span class="keyword">while</span>(flag[j]);     <span class="comment">// 检查对方状态，进入区</span></span><br><span class="line">critical section;   <span class="comment">// 临界区</span></span><br><span class="line">flag[i] = FALSE;    <span class="comment">// 退出区</span></span><br><span class="line">remainder section;  <span class="comment">// 剩余区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//P_j进程</span></span><br><span class="line">flag[j] = TRUE;</span><br><span class="line"><span class="keyword">while</span>(flag[i]);</span><br><span class="line">critical section;</span><br><span class="line">flag[j] = FALSE;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure>
<p>确保进程可以互斥访问临界区。</p>
<p>但是存在两个进程都进不了临界区的“饥饿”现象。</p>
<h4 id="皮特森算法peterson">皮特森算法（Peterson）</h4>
<p>为了防止两个进程为进入临界区而无限期等待，又设置了变量<code>turn</code>，每个进程在先设置自己的标记之后再设计<code>turn</code>标记。再同时检测另一个进程状态标记和
允许进入标记，以便保证两个进程同时要求进入临界区，只允许一个进程进入临界区。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//P_i进程</span></span><br><span class="line">flag[i] = TRUE, turn = j;  <span class="comment">// falg[j] = TRUE表示它想要进入临界区，turn = j,表示进程P_j已在临界区</span></span><br><span class="line"><span class="keyword">while</span>(flag[j] &amp;&amp; turn == j);</span><br><span class="line">critical sections;</span><br><span class="line">flag[i] = FALSE;</span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P_j进程</span></span><br><span class="line">flag[j] = TRUE, turn = i;</span><br><span class="line"><span class="keyword">while</span>(flag[i] &amp;&amp; turn == i);</span><br><span class="line">critical section;</span><br><span class="line">flag[j] = FALSE;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure>
<p><code>Peterson</code>算法利用<code>turn</code>解决了“饥饿”问题</p>
<h3 id="硬件实现方法">硬件实现方法</h3>
<p>（低级方法）</p>
<h4 id="中断屏蔽方法">（1）中断屏蔽方法</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">关中断</span><br><span class="line">临界区</span><br><span class="line">开中断</span><br></pre></td></tr></table></figure>
<p>效率低</p>
<h4 id="硬件指令方法">（2）硬件指令方法</h4>
<p><em>由硬件逻辑直接实现，不会被中断</em></p>
<p><code>TestAndSet</code>指令，<code>原子操作</code>,即这条指令执行时不允许被中断。</p>
<p>功能：读出指定标志后把该指令设置为真。</p>
<p><code>Swap</code>指令：</p>
<p>功能：交换两个字（字节）的内容。</p>
<p><strong>小结：</strong></p>
<p>缺点：进程等待进入临界区要耗费处理机时间，<em>不能实现让权等待</em>，会导致“饥饿”现象。</p>
<p>优点：适用于任意数目的进程，而不管是单处理机还是多处理机；简单，容易验证其正确性。</p>
<h2 id="互斥锁">互斥锁</h2>
<p>解决临界区最简单的工具就是<em>互斥锁（mutex
lock）</em>。一个进程在进入临界区时应获得锁，在退出临界区时释放锁。
函数<code>acquire()</code>获得锁，而函数<code>release()</code>释放锁。</p>
<p>每个锁有一个布尔变量<code>available</code>,表示锁是否可用。</p>
<p><strong>互斥锁通常采用硬件机制实现</strong></p>
<p><strong>缺点：忙等待</strong></p>
<h2 id="信号量">信号量</h2>
<p>用来解决互斥与同步问题，它只能被两个标准的原语<code>wait(s)</code>和<code>signal(s)</code>访问，也可记为“P操作”或“V操作”。</p>
<h3 id="整型信号量">整型信号量</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">wait</span>(S)&#123;</span><br><span class="line">        <span class="keyword">while</span>(S &lt;= <span class="number">0</span>);</span><br><span class="line">        S = S - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">signal</span>(S)&#123;</span><br><span class="line">        S = S + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不遵循“让权等待”的准则，而是使进程处于“忙等”的状态。</p>
<h3 id="记录型信号量">记录型信号量</h3>
<p>除了需要一个用于代表资源数目的整型变量<code>value</code>外，再增加一个进程链表L，用于链接所有等待该资源的进程。
<code>wait</code>操作请求一个该类资源时，如果<code>s.value &lt; 0</code>,表示该类资源已经分配完毕，因此进程应调用<code>block</code>原语，进行自我阻塞，放弃处理机。
并插入该类资源的等待队列<code>S.L</code>。</p>
<p>不存在“忙等”现象等进程同步机制。遵循了“让权等待”准则。</p>
<h3 id="利用信号量实现同步">利用信号量实现同步</h3>
<p>同步就是根据什么次序配合互相完成。</p>
<h3 id="利用信号量实现进程互斥">利用信号量实现进程互斥</h3>
<p>一般都把初始化信号量设为1.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">semaphore S = <span class="number">1</span>;        <span class="comment">// 初始化信号量</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">P1</span>() &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">P</span>(S);           <span class="comment">// 准备开始访问临界资源，加锁</span></span><br><span class="line">        进程P1的临界区；</span><br><span class="line">        <span class="built_in">V</span>(S);           <span class="comment">// 访问结束，解锁</span></span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">P2</span>() &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">P</span>(S);</span><br><span class="line">        进程P2的临界区</span><br><span class="line">        <span class="built_in">V</span>(S);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="利用信号量实现前驱关系">利用信号量实现前驱关系</h3>
<h2 id="管程">管程</h2>
<p>在信号量机制中，每个要访问临界资源的进程都必须自备同步的PV操作。大量分散的同步操作给系统管理带来了麻烦，
且容易因操作不当而导致系统<em>死锁</em>。</p>
<h3 id="定义">定义</h3>
<p>管程定义了一个数据结构和能为并发进程所执行（在该数据结构上）的一组操作，这组操作能同步进程和改变管程中的数据。</p>
<p>组成： - 管程的名称 - 局部于管程内部的共享数据结构说明 -
对该数据结构进行操作的一组过程 -
对局部于管程内部的共享数据设置初始值的语句</p>
<p>管程很像一个类（class）： - 管程把对共享资源的操作封装起来 -
每次仅允许一个进程进入管程</p>
<h3 id="条件变量">条件变量</h3>
<p>将阻塞原因定义为条件变量。</p>
<p>对条件变量只能进行两种操作：
<code>wait</code>和<code>signal</code></p>
<h2 id="经典同步问题重点">经典同步问题（重点！！！）</h2>
<h3 id="生产者-消费者问题">1. 生产者-消费者问题</h3>
<p><strong>问题描述：</strong>
一组生产者进程和一组消费者进程共享一个初始为空，大小为<code>n</code>的缓冲区，只有缓冲区没满时，生产者才能把消息放入缓冲区，
否则必须等待；只有缓冲区不空时，消费者才能从中取出消息，否则必须等待。由于缓冲区是临界资源，它只允许一个生产者放入消息，或一个消费者从中
取出消息。</p>
<p><strong>问题分析：</strong></p>
<ol type="1">
<li><p>关系分析。生产者和消费者对缓冲区互斥访问是<em>互斥关系</em>，同时生产者和消费者又是一个互相协作的关系，只有生产者生产之后，消费者才能消费，
它们也是<em>同步关系</em>。</p></li>
<li><p>思路。只有生产者和消费者两个进程，它们又是互斥和同步关系，那么需要解决的是互斥和同步PV操作的位置。</p></li>
<li><p>信号量设置。信号量<code>mutex</code>作为互斥信号量，用于控制互斥访问访问缓冲区，互斥信号量初始值为1；信号量<code>full</code>用于记录当前缓冲池中的“满”缓冲区数，
初值为0，信号量<code>empty</code>用于记录当前缓冲池中的“空”缓冲区数，初值为<code>n</code>。</p></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;        <span class="comment">// 临界区互斥信号量</span></span><br><span class="line">semaphore empty = n;        <span class="comment">// 空闲缓冲区</span></span><br><span class="line">semaphore full = <span class="number">0</span>;         <span class="comment">// 缓冲区初始化为空</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">producer</span>() &#123;                <span class="comment">// 生产者进程</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        produce an item in nextp;   <span class="comment">// 生产数据</span></span><br><span class="line">        <span class="built_in">p</span>(empty);                   <span class="comment">// 获取空缓冲区单元</span></span><br><span class="line">        <span class="built_in">p</span>(mutex);                   <span class="comment">// 进入互斥区</span></span><br><span class="line">        add nextp to buffer;        <span class="comment">// 将数据放入缓冲区</span></span><br><span class="line">        <span class="built_in">v</span>(mutex);                   <span class="comment">// 离开互斥区，释放互斥信号量</span></span><br><span class="line">        <span class="built_in">v</span>(full);                    <span class="comment">// 满缓冲区数+1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">consumer</span>() &#123;                        <span class="comment">// 消费者进程</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">p</span>(full);                    <span class="comment">// 获取满缓冲区单元</span></span><br><span class="line">        <span class="built_in">p</span>(mutex);                   <span class="comment">// 进入临界区</span></span><br><span class="line">        remove an item from buffer; <span class="comment">// 从缓冲区取数据</span></span><br><span class="line">        <span class="built_in">v</span>(mutex);                   <span class="comment">// 离开临界区，释放互斥信号量</span></span><br><span class="line">        <span class="built_in">v</span>(empty);                   <span class="comment">// 空缓冲区数+1</span></span><br><span class="line">        consum the item;            <span class="comment">// 消费数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读者-写者问题">2. 读者-写者问题</h3>
<p><strong>问题描述：</strong>
有读者和写者两组并发进程，共享一个文件，当两个或以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：</p>
<ol type="1">
<li><p>允许多个读者可以同时对文件执行读操作；</p></li>
<li><p>只允许一个写者往文件中写信息；</p></li>
<li><p>任一写者在完成写操作之前不允许其他读者或写者工作；</p></li>
<li><p>写者执行写操作之前，应让已有的读者和写者全部退出；</p></li>
</ol>
<p><strong>问题分析：</strong></p>
<ol type="1">
<li><p>关系分析。读者和写者是互斥的，写者和写者也是互斥的，读者和读者不存在互斥问题。</p></li>
<li><p>思路。两个进程，即读者和写者。写者和任何进程都互斥，因此只需要互斥信号量的PV操作即可。读者问题比较复杂，它必须在实现与写者互斥的同时，实现与其他
读者的同步，因此简单的一对PV操作是无法解决问题，这里我们用到一个计数器，用来判断当前是否有读者读文件。当有读者时，写者是无法写文件的，此时读者会
一直占用文件，当没有读者时，写者才可以写文件。同时，这里不同读者对计数器的访问应该也是互斥的。</p></li>
<li><p>信号量设置。首先设置信号量<code>count</code>为计数器，用于记录当前读者的数量，初值为0；设置<code>mutex</code>为互斥信号量，用于保护更新<code>count</code>变量的互斥；设置互斥信号量
<code>rw</code>，用于保证读者和写者的互斥访问。</p></li>
</ol>
<p><strong>读进程优先：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int count = 0;              // 用于记录当前的读者数量</span><br><span class="line">semaphore mutex = 1;        // 用于保护更新count变量时的互斥</span><br><span class="line">semaphore rw = 1;           // 用于保证读者和写者互斥地访问文件</span><br><span class="line"></span><br><span class="line">writer() &#123;                  // 写者进程</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        p(rw);              // 互斥访问共享文件</span><br><span class="line">        writing;</span><br><span class="line">        v(rw);              // 释放共享文件</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader() &#123;                  // 读者进程</span><br><span class="line">    while(1) &#123;</span><br><span class="line">        p(mutex);           // 互斥访问count</span><br><span class="line">        if(count == 0)      // 当第一个读进程读共享文件时</span><br><span class="line">          p(rw);            // 阻止写进程写</span><br><span class="line">        count++;            // 读者计数器+1</span><br><span class="line">        v(mutex);           // 释放互斥变量count</span><br><span class="line">        reading;</span><br><span class="line">        p(mutex);           // 互斥访问count</span><br><span class="line">        count--;            // 读者计数器减1</span><br><span class="line">        if(count == 0)      // 当最后一个读进程读完共享文件</span><br><span class="line">            v(rw);          // 允许写进程写</span><br><span class="line">        v(mutex);           // 释放互斥变量count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当存在读进程时，写操作被延迟，且只要有一个读进程活跃，随后的读进程都被允许访问文件，这样会导致写进程可能长时间等待，且存在写进程“饿死”的情况。</p>
<p><strong>写进程优先：</strong></p>
<blockquote>
<p>有写进程请求访问，这时应禁止后续读进程的请求，等到已在共享文件中的读进程执行完毕，立即让写进程执行，只有在无写进程执行的情况下，
才允许读进程再次运行，因此，增加一个信号量并在上面的writer()和reader()函数中各增加一对PV操作。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count = <span class="number">0</span>;              <span class="comment">// 用于记录当前的读者数量</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;        <span class="comment">// 用于保护更新count变量时的互斥</span></span><br><span class="line">semaphore rw = <span class="number">1</span>;           <span class="comment">// 用于保证读者和写者互斥地访问文件</span></span><br><span class="line">semaphore w = <span class="number">1</span>;            <span class="comment">// 用于实现“写优先”</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">writer</span>() &#123;                  <span class="comment">// 写者进程</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">p</span>(w);               <span class="comment">// 在无写进程请求时进入</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">p</span>(rw);              <span class="comment">// 互斥访问共享文件</span></span><br><span class="line">        writing;</span><br><span class="line">        <span class="built_in">v</span>(rw);              <span class="comment">// 释放共享文件</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">v</span>(w);               <span class="comment">// 恢复对共享文件的访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">reader</span>() &#123;                  <span class="comment">// 读者进程</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">p</span>(w);               <span class="comment">// 在无写进程请求时进入</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">p</span>(mutex);           <span class="comment">// 互斥访问count</span></span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)      <span class="comment">// 当第一个读进程读共享文件时</span></span><br><span class="line">          <span class="built_in">p</span>(rw);            <span class="comment">// 阻止写进程写</span></span><br><span class="line">        count++;            <span class="comment">// 读者计数器+1</span></span><br><span class="line">        <span class="built_in">v</span>(mutex);           <span class="comment">// 释放互斥变量count</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">v</span>(w);               <span class="comment">// 恢复对共享文件的访问</span></span><br><span class="line"></span><br><span class="line">        reading;</span><br><span class="line">        <span class="built_in">p</span>(mutex);           <span class="comment">// 互斥访问count</span></span><br><span class="line">        count--;            <span class="comment">// 读者计数器减1</span></span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)      <span class="comment">// 当最后一个读进程读完共享文件</span></span><br><span class="line">            <span class="built_in">v</span>(rw);          <span class="comment">// 允许写进程写</span></span><br><span class="line">        <span class="built_in">v</span>(mutex);           <span class="comment">// 释放互斥变量count</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也叫做<strong>读写公平法</strong></p>
<h3 id="哲学家进餐问题">3. 哲学家进餐问题</h3>
<p><strong>问题描述：</strong>
一张圆桌边上坐着5名哲学家，每两名哲学家之间的桌子上摆着一根筷子，两根筷子中间是一碗米饭。
只有当哲学家饥饿时，才试图拿起左，右两根筷子（一根一根拿起）。若筷子已在他人手上，则需要等待。饥饿的哲学家只有同时拿到两根
筷子才可以开始进餐，进餐完毕后，放下筷子继续思考。</p>
<p><strong>问题分析：</strong></p>
<ol type="1">
<li>关系分析。5名哲学家与左右邻居对其中间的筷子的访问是互斥关系。</li>
<li>整理思路。显然，这里有5个进程。关键是如何让一名哲学家拿到左右两根筷子而不造成死锁或即饿现象。
解决方法有两个：一是让他们同时拿两根筷子；二是对每名哲学家的动作制定规则，避免饥饿或死锁现象的发生。</li>
<li>信号量设置。定义互斥信号量数组<code>chopstick[5] = &#123;1,1,1,1,1&#125;</code>,用于对5个筷子的互斥访问。哲学家按顺序编号0～4，哲学家<code>i</code>左边的筷子编号为<code>i</code>，
右边筷子编号为<code>(i+1)%5</code>。</li>
</ol>
<p><strong>同时拿筷子：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;       <span class="comment">// 定义信号量数组</span></span><br><span class="line"><span class="built_in">pi</span>() &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">p</span>(chopstick[i]);                    <span class="comment">// 取左边筷子</span></span><br><span class="line">        <span class="built_in">p</span>(chocktick[(i+<span class="number">1</span>)%<span class="number">5</span>]);              <span class="comment">// 取右边筷子</span></span><br><span class="line">        eat;</span><br><span class="line">        <span class="built_in">v</span>(chopstick[i]);                    <span class="comment">// 放回左边筷子</span></span><br><span class="line">        <span class="built_in">v</span>(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);              <span class="comment">// 放回右边筷子</span></span><br><span class="line">        think;</span><br><span class="line">    &#125; <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该算法存在以下问题：当5名哲学家都想要进餐并分别拿起左边的筷子时，筷子已被拿完，等他们再想拿右边筷子时，就被完全阻塞，
因此出现了死锁。</p>
<p>为防止死锁发生，可对哲学家进程施加一些限制条件。</p>
<ul>
<li>至多允许4名哲学家同时进餐</li>
<li>仅当一名哲学家左右两边的筷子都可用时，才允许他抓起筷子。</li>
<li>对哲学家顺序编号，要求奇数号哲学家先拿左边的筷子，然后拿右边筷子，偶数号哲学家相反。</li>
</ul>
<p>下面我们采用第二种方法：当一名哲学家左右两边筷子都可用时，才允许他抓起筷子。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;                            <span class="comment">// 设置取筷子信号量</span></span><br><span class="line"><span class="built_in">pi</span>() &#123;                                          <span class="comment">// i 号哲学家进程</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">p</span>(mutex);                                   <span class="comment">// 在取筷子之前获得互斥量</span></span><br><span class="line">        <span class="built_in">p</span>(chopstick[i]);                            <span class="comment">// 取左边筷子</span></span><br><span class="line">        <span class="built_in">p</span>(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);                      <span class="comment">// 取右边筷子</span></span><br><span class="line">        <span class="built_in">v</span>(mutex);</span><br><span class="line">        eat;</span><br><span class="line">        <span class="built_in">v</span>(chocktick[i]);</span><br><span class="line">        <span class="built_in">v</span>(chocktick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">        think;</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="吸烟者问题">4. 吸烟者问题</h3>
<p><strong>问题描述：</strong>
假设一个系统有三个抽烟者进程和一个供应者进程。要卷起并抽掉一根烟，抽烟者需要三种材料：烟草，纸和胶水。
三个抽烟者中，第一个拥有烟草，第二个拥有纸，第三个拥有胶水。供应者进程无限特供三种材料，供应者每次将两种材料放在桌子上，
拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者一个信号告诉已完成，此时供应者就会将另外两种材料放在桌上，
如此重复。</p>
<p><strong>问题分析：</strong></p>
<ol type="1">
<li>关系分析。供应者与三个抽烟者分别是同步关系。由于供应者无法同时满足两个或以上的抽烟者，三个抽烟者对抽烟这个动作互斥。</li>
<li>整理思路。显然这里有4个进程，供应者作为生产者向三个抽烟者提供材料。</li>
<li>信号量设置。信号量<code>offer1</code>,<code>offer2</code>,<code>offer3</code>分别表示烟草和纸的资源，烟草和胶水组合的资源，纸和胶水组合的资源。
信号量<code>finish</code>用于互斥进行抽烟动作。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">0</span>;                    <span class="comment">// 存储随机数</span></span><br><span class="line">semaphore offer1 = <span class="number">0</span>;           <span class="comment">// 烟草和纸组合的资源</span></span><br><span class="line">semaphore offer2 = <span class="number">0</span>;           <span class="comment">// 烟草和胶水组合的资源</span></span><br><span class="line">semaphore offer3 = <span class="number">0</span>;           <span class="comment">// 纸和胶水组合的资源</span></span><br><span class="line">semaphore finish = <span class="number">0</span>;           <span class="comment">// 表示抽烟动作是否完成</span></span><br><span class="line"></span><br><span class="line"><span class="function">process <span class="title">P1</span><span class="params">()</span> </span>&#123;                  <span class="comment">// 供应者</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        num++;</span><br><span class="line">        num = num % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">v</span>(offer1);          <span class="comment">// 提供烟草和纸</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">v</span>(offer2);          <span class="comment">// 提供烟草和胶水</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">v</span>(offer3);          <span class="comment">// 提供纸和胶水</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 任意两种材料放在桌子上。</span></span><br><span class="line">        <span class="built_in">p</span>(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">process <span class="title">P2</span><span class="params">()</span> </span>&#123;                  <span class="comment">// 拥有烟草者</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">p</span>(offe3);</span><br><span class="line">        拿纸和胶水，卷成烟，抽掉；</span><br><span class="line">        <span class="built_in">v</span>(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">process <span class="title">P3</span><span class="params">()</span> </span>&#123;                  <span class="comment">// 拥有纸者</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">p</span>(offe2);</span><br><span class="line">        拿烟草和胶水，卷成烟，抽掉；</span><br><span class="line">        <span class="built_in">v</span>(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">process <span class="title">P4</span><span class="params">()</span> </span>&#123;                  <span class="comment">// 拥有胶水者</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">p</span>(offe1);</span><br><span class="line">        拿纸和烟草，卷成烟，抽掉；</span><br><span class="line">        <span class="built_in">v</span>(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="死锁">死锁</h1>
<h2 id="定义-1">定义</h2>
<p>指多个进程因竞争资源而造成的一种互相等待，若无外力作用，这些进程都无法向前推进。</p>
<h2 id="死锁产生的原因">死锁产生的原因</h2>
<ul>
<li>系统资源的竞争</li>
<li>进程推进顺序不当</li>
</ul>
<h2 id="死锁产出的必要条件">死锁产出的必要条件</h2>
<ol type="1">
<li><strong>互斥条件：</strong>
在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</li>
<li><strong>不剥夺条件：</strong>
进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放。</li>
<li><strong>请求与保持条件：</strong>
进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，
但对自己获得的资源保持不放。</li>
<li><strong>循环等待条件：</strong>
存在一种进程资源的循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。</li>
</ol>
<h2 id="死锁的处理策略">死锁的处理策略</h2>
<ul>
<li>n
个进程，每个进程需要<code>m</code>个某类资源，则发生死锁的最大资源数为<code>n(m-1)</code>，不发生死锁的最小资源数为<code>n(m-1) + 1</code>。</li>
</ul>
<h3 id="死锁预防">死锁预防</h3>
<p>需要破坏死锁的4个必要条件中的一个或多个。</p>
<h3 id="避免死锁">避免死锁</h3>
<p>在死锁的动态分布过程中，用某种方法防止系统进入<em>不安全状态</em>。</p>
<p>并非所有的不安全状态都是死锁状态，但当系统进入不安全状态后，便可能进入死锁状态；
只要系统处于安全状态，系统便可以避免进入死锁状态。</p>
<p>死锁一定是不安全状态，不安全状态不一定是死锁状态。</p>
<p>最主要的算法就是：<strong>银行家算法</strong></p>
<p>银河家算法的主要数据结构为</p>
<table>
<thead>
<tr class="header">
<th>数据结构</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>可利用资源<code>Available</code></td>
</tr>
<tr class="even">
<td>最大需求矩阵<code>Max</code></td>
</tr>
<tr class="odd">
<td>分配矩阵<code>Allocation</code></td>
</tr>
<tr class="even">
<td>需求矩阵<code>Need</code></td>
</tr>
</tbody>
</table>
<h3 id="死锁检测和解除">死锁检测和解除</h3>
<p>允许产生死锁，采取某种措施解除死锁。</p>
<h4 id="资源分配图">资源分配图</h4>
<p>用圆圈代表一个进程，用框代表一类资源。</p>
<p>从进程到资源的有向边称为<em>请求边</em>，表示该进程申请一个单位的该类资源；</p>
<p>从资源到进程的边称为<em>分配边</em>。表示该类资源已有一个资源分配给了该进程。</p>
<p><img
src="https://sjchen404.oss-cn-shenzhen.aliyuncs.com/img/资源分配图.png" /></p>
<blockquote>
<p>p1,p2为进程，R1，R2表示资源</p>
</blockquote>
<h4 id="死锁定理">死锁定理</h4>
<p>当资源分配图不可完全简化，则为死锁。</p>
<p>简化资源分配图可检测系统状态<code>S</code>是否处于死锁状态。简化方法如下：</p>
<ol type="1">
<li><p>在资源分配图中，找出既不阻塞又不孤点的进程 <span
class="math inline">\(P_i\)</span>
（即找出一条有向边与它相邻，且该有向边对应的资源的申请数量小于等于系统中已有
的空闲资源数量。）如上图，我们可以找到进程<code>p1</code>,（<code>R1</code>没有资源，<code>R2</code>有一个资源，进程<code>p1</code>也只有一条申请边），消去它所有的请求边和分配边，
使之成为孤立的点。如图（b）</p></li>
<li><p>进程 <span
class="math inline">\(P_i\)</span>所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程，重复动作1。</p></li>
</ol>
<p><img
src="https://sjchen404.oss-cn-shenzhen.aliyuncs.com/img/资源分配图化简.png" /></p>
<h4 id="死锁解除">死锁解除</h4>
<ol type="1">
<li>资源剥夺法</li>
<li>撤销进程法</li>
<li>进程回退法</li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>Buy me a coffee</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.png" alt="SJCHEN 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.png" alt="SJCHEN 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>SJCHEN
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://sjchen404.github.io/2022/08/16/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/" title="第二章_进程与线程">https://sjchen404.github.io/2022/08/16/第二章_进程与线程/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"># 操作系统</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/08/16/Hexo8.x%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E5%8F%AF%E5%88%87%E6%8D%A2%E7%9A%84%E9%BB%91%E6%9A%97%E6%A8%A1%E5%BC%8F/" rel="prev" title="Hexo8.x主题添加可切换的黑暗模式">
                  <i class="fa fa-chevron-left"></i> Hexo8.x主题添加可切换的黑暗模式
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/08/16/%E5%BF%AB%E9%80%9F%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E5%88%B0github/" rel="next" title="上传项目到github">
                  上传项目到github <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="waline"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">null </a>
  </div>

<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SJCHEN</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">559k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">8:28</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/pace.js"></script>

  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","cdn":"//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"waline-blog-ij33-fskc7zdtq-1261476297-qqcom.vercel.app","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"请文明评论呀","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":false,"comment_count":true,"requiredFields":["nick"],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/2022/08/16/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>
<script src="https://unpkg.com/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: false,
  label: '🌓',
  autoMatchOsTheme: false
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
if (window.darkmode && !window.darkmode.isActivated()) {
  window.darkmode.toggle();
  var toggleButtons = document.getElementsByClassName("darkmode-toggle");
  if (toggleButtons && toggleButtons.length > 0) {
    for (i = 0; i < toggleButtons.length; i++) {
      toggleButtons[i].classList.add("darkmode-toggle--white");
    }
  }
}
</script>

</body>
</html>
